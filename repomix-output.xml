This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
.gitignore
auto_trimm.py
BACKEND_QUICKSTART.md
BUSINESS_IDEATION.md
cog.yaml
colab_analysis.ipynb
components.json
config/events.json
content.json
create_kaggle_zip.py
crop_config.json
cropper.py
deploy_to_vast.ps1
DEPLOYMENT_GUIDE.md
detect_bbox.py
diagnose_pdf.py
env.production
eslint.config.js
extract_pdf_content.py
extract_reference.py
index.html
iptv/app/api/proxy/stream/route.ts
iptv/app/api/xtream/route.ts
iptv/app/globals.css
iptv/app/layout.tsx
iptv/app/page.tsx
iptv/app/robots.ts
iptv/components/AuthWrapper.tsx
iptv/components/CascaderMenu.tsx
iptv/components/CategoriesSidebar.tsx
iptv/components/ChannelBrowser.tsx
iptv/components/ChannelListItem.tsx
iptv/components/ChannelListPanel.tsx
iptv/components/LoginForm.tsx
iptv/components/MobileControls.tsx
iptv/components/PWAProvider.tsx
iptv/components/VideoPlayer.tsx
iptv/components/VideoPlayerArea.tsx
iptv/contexts/AuthContext.tsx
iptv/hooks/useFavorites.ts
iptv/lib/xtream.ts
iptv/types/xtream.ts
package.json
postcss.config.js
predict.py
prepare_colab_package.py
public/favicon.ico
public/heatmaps/positions_test.json
public/heatmaps/positions.json
public/international-teams.json
public/lfp-clubs-players-data-2025-11-20T13-57-58.json
public/SoccerWiki_2025-11-15 - Alg√©rie_1763171594.json
python/advanced_engines.py
python/analytics/tactical_analytics.py
python/analyze_image_fixed.py
python/analyze_match.py
python/annotators/__init__.py
python/annotators/annotators.py
python/api_server.py
python/api.py
python/camera_movement_estimator/__init__.py
python/camera_movement_estimator/camera_movement_estimator.py
python/cleanup_db.py
python/clip_generator.py
python/colab_notebook.py
python/constants.py
python/development_and_analysis/color_assignement.ipynb
python/extract_positions.py
python/generate_clips.py
python/generate_heatmap.py
python/kaggle_notebook.py
python/keypoint_detection/__init__.py
python/keypoint_detection/homography.py
python/keypoint_detection/keypoint_constants.py
python/main.py
python/migrate_db.py
python/migrate_filename.py
python/migrate_pretag.py
python/migrate_qc.py
python/pipelines.py
python/player_ball_assigner/__init__.py
python/player_ball_assigner/player_ball_assigner.py
python/player_clustering.py
python/README (2).md
python/README.md
python/remote_server.py
python/soccer_analysis_core.py
python/soccer_analysis_processor.py
python/speed_and_distance_estimator/__init__.py
python/speed_and_distance_estimator/speed_and_distance_estimator.py
python/start_runpod.sh
python/tactabot.db
python/tactabot.py
python/team_assigner/__init__.py
python/team_assigner/team_assigner.py
python/test_pass_detection.py
python/test_roboflow.py
python/trackers/__init__.py
python/trackers/hybrid_tracker.py
python/trackers/tracker_manager.py
python/trackers/tracker.py
python/training/football_training_yolo_v5.ipynb
python/utils/__init__.py
python/utils/bbox_utils.py
python/utils/field_calibration.py
python/utils/model_downloader.py
python/utils/optical_flow.py
python/utils/roboflow_utils.py
python/utils/scene_analyzer.py
python/utils/video_utils.py
python/verify_db_fixes.py
python/view_transformer/__init__.py
python/view_transformer/view_transformer.py
python/yolo_inference.py
QUICK_START_GPU.md
read_MS_docx.py
README.md
REPLICATE_DEPLOY.md
replicate-analyzer.js
RUNPOD_GUIDE.md
scripts/forward.js
scripts/generate-pdf.js
SERVER_FIX_NEEDED.md
server.js
server.js.backup
src/App.css
src/App.tsx
src/components/Admin/EventConfigTable.tsx
src/components/Admin/GamepadRecorder.tsx
src/components/Admin/VisualGamepadConfig.tsx
src/components/AdminWaitingRoom.tsx
src/components/AnalysisDashboard.tsx
src/components/AnalysisModeSelector.tsx
src/components/AnalysisResultsViewer.tsx
src/components/analytics/LiveDashboard.tsx
src/components/analytics/MomentumChart.tsx
src/components/analytics/PostMatchDashboard.tsx
src/components/analytics/SemanticAnalytics.tsx
src/components/analytics/TacticalReview.tsx
src/components/AppSidebar.tsx
src/components/ButtonMappingConfig.tsx
src/components/common/DashboardWidget.tsx
src/components/common/SafetyBoundary.tsx
src/components/CommunityHub.tsx
src/components/ControllerGrid.tsx
src/components/ControllerMappingsGrid.tsx
src/components/CrowdReviewPanel.tsx
src/components/Dashboard.tsx
src/components/dashboard/DashboardHeader.tsx
src/components/dashboard/DashboardLeftPanel.tsx
src/components/dashboard/DashboardRightPanel.tsx
src/components/dashboard/views/AnalyticsView.tsx
src/components/dashboard/views/DashboardView.tsx
src/components/dashboard/views/QAView.tsx
src/components/dashboard/views/SettingsView.tsx
src/components/dashboard/views/TacticsView.tsx
src/components/dashboard/VisualGuide.tsx
src/components/ErrorBoundary.tsx
src/components/EventLog.tsx
src/components/EventMappingReference.tsx
src/components/FIFAPlus/FIFAPlusBrowser.tsx
src/components/Index/Header.tsx
src/components/Index/LiveEventToast.tsx
src/components/Index/MatchFeedPopover.tsx
src/components/Index/VideoBackground.tsx
src/components/IPTV/index.ts
src/components/IPTV/IPTVCategoriesSidebar.tsx
src/components/IPTV/IPTVChannelBrowser.tsx
src/components/IPTV/IPTVChannelListItem.tsx
src/components/IPTV/IPTVChannelListPanel.tsx
src/components/IPTV/IPTVLoginForm.tsx
src/components/IPTV/IPTVMobileControls.tsx
src/components/IPTV/IPTVVideoPlayer.tsx
src/components/IPTV/IPTVVideoPlayerArea.tsx
src/components/KeyboardShortcutsGrid.tsx
src/components/kpi/dialogs/CompetitorDetailDialog.tsx
src/components/kpi/dialogs/FunnelDrilldownDialog.tsx
src/components/kpi/dialogs/RiskSimulationDialog.tsx
src/components/kpi/dialogs/SegmentSimulationDialog.tsx
src/components/kpi/EditableCell.tsx
src/components/kpi/KPISidebar.tsx
src/components/kpi/tabs/BusinessModelTab.tsx
src/components/kpi/tabs/DashboardTab.tsx
src/components/kpi/tabs/DataSourcesTab.tsx
src/components/kpi/tabs/FinancialsTab.tsx
src/components/kpi/tabs/MarketTab.tsx
src/components/kpi/tabs/UnitEconomicsTab.tsx
src/components/LiveStreamPlayer.tsx
src/components/LoggerAuditPanel.tsx
src/components/MappingOverlay.tsx
src/components/MatchStateIndicator.tsx
src/components/NavLink.tsx
src/components/PassingNetworkViz.tsx
src/components/PendingEventsQueue.tsx
src/components/PitchMap.tsx
src/components/PlayerCard.tsx
src/components/PlayerGrid.tsx
src/components/PlayerHeatmap.tsx
src/components/PlayerSelectionSidebar.tsx
src/components/PlayerUpload.tsx
src/components/PossessionTimeline.tsx
src/components/PostMatchAnalysisPanel.tsx
src/components/ProtectedRoute.tsx
src/components/QuickPlayerSelector.tsx
src/components/SequenceAssistant.tsx
src/components/SessionModeModal.tsx
src/components/SmartPlayerSelector.tsx
src/components/SpotterPingPanel.tsx
src/components/StartingLineup.tsx
src/components/StatisticsDashboard.tsx
src/components/TacticalAnalysisDashboard.tsx
src/components/TeamGrid.tsx
src/components/TrackingModeSelector.tsx
src/components/ui/accordion.tsx
src/components/ui/alert-dialog.tsx
src/components/ui/alert.tsx
src/components/ui/aspect-ratio.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/breadcrumb.tsx
src/components/ui/button.tsx
src/components/ui/calendar.tsx
src/components/ui/card.tsx
src/components/ui/carousel.tsx
src/components/ui/chart.tsx
src/components/ui/checkbox.tsx
src/components/ui/collapsible.tsx
src/components/ui/command.tsx
src/components/ui/context-menu.tsx
src/components/ui/dialog.tsx
src/components/ui/drawer.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/form.tsx
src/components/ui/hover-card.tsx
src/components/ui/input-otp.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/menubar.tsx
src/components/ui/navigation-menu.tsx
src/components/ui/pagination.tsx
src/components/ui/popover.tsx
src/components/ui/progress.tsx
src/components/ui/radio-group.tsx
src/components/ui/resizable.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/sheet.tsx
src/components/ui/sidebar.tsx
src/components/ui/skeleton.tsx
src/components/ui/slider.tsx
src/components/ui/sonner.tsx
src/components/ui/switch.tsx
src/components/ui/table.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/components/ui/TipbarButton.tsx
src/components/ui/TipbarGroup.tsx
src/components/ui/toast.tsx
src/components/ui/toaster.tsx
src/components/ui/toggle-group.tsx
src/components/ui/toggle.tsx
src/components/ui/tooltip.tsx
src/components/ui/use-toast.ts
src/components/ValidationSuite.tsx
src/components/VideoEditor/VideoEditorSidebar.tsx
src/components/VideoManager.tsx
src/components/VideoPlayer_backup.tsx
src/components/VideoPlayer/AnalysisVideoPlayer.tsx
src/components/VideoPlayer/AnnotatedVideoPlayer.tsx
src/components/VideoPlayer/AnnotationCanvas.tsx
src/components/VideoPlayer/AnnotationInteractionLayer.tsx
src/components/VideoPlayer/AnnotationToolbar.tsx
src/components/VideoPlayer/CalibrationInterface.tsx
src/components/VideoPlayer/index.tsx
src/components/VideoPlayer/index.tsx.backup
src/components/VideoPlayer/PlayerTracker.tsx
src/components/VideoPlayer/TacticalAnnotationSidebar.tsx
src/components/VideoPlayer/TacticalPitchView.tsx
src/components/VideoPlayer/Timeline.tsx
src/components/VideoPlayer/VideoControls.tsx
src/components/VideoPlayer/VideoOverlay.tsx
src/components/VideoUpload.tsx
src/components/ZoneGrid.tsx
src/components/ZoneIndicator.tsx
src/components/ZoneSelectorOverlay.tsx
src/config/eventRegistry.ts
src/config/multer.js
src/config/state.js
src/contexts/AuthContext.tsx
src/contexts/EventConfigContext.tsx
src/contexts/IPTVAuthContext.tsx
src/contexts/KPIContext.tsx
src/contexts/MatchContext.tsx
src/contexts/SocketContext.tsx
src/data/algerian_teams.json
src/data/eventDefinitions.ts
src/hooks/index/useIndexEffects.ts
src/hooks/index/useIndexHandlers.ts
src/hooks/index/useIndexState.ts
src/hooks/use-mobile.tsx
src/hooks/use-toast.ts
src/hooks/useAnnotations.ts
src/hooks/useAudioBroadcast.ts
src/hooks/useAutoZoom.ts
src/hooks/useDashboardLayout.ts
src/hooks/useGamepad.ts
src/hooks/useIPTVFavorites.ts
src/hooks/useMatchTimer.ts
src/hooks/useMediaCoords.ts
src/hooks/usePictureInPicture.ts
src/hooks/useSocketEvents.ts
src/hooks/useVideoControls.ts
src/hooks/useVoiceRecognition.ts
src/hooks/useVoiceRoom.ts
src/hooks/useWebRTC.ts
src/index.css
src/layouts/MainLayout.tsx
src/lib/utils.ts
src/main.tsx
src/middleware/authMiddleware.js
src/pages/AdminPortal.tsx
src/pages/AnalystAudit.tsx
src/pages/Analytics.tsx
src/pages/Index.tsx
src/pages/Index.tsx.backup
src/pages/IndexContent.tsx
src/pages/KPIEngine.tsx
src/pages/Login.tsx
src/pages/Monitoring.tsx
src/pages/NotFound.tsx
src/PITCH.PY
src/routes/analysis.routes.js
src/routes/auth.routes.js
src/routes/export.routes.js
src/routes/heatmap.routes.js
src/routes/lfp.routes.js
src/routes/proxy.routes.js
src/routes/roboflow.routes.js
src/routes/stream-info.routes.js
src/routes/upload.routes.js
src/routes/user.routes.js
src/services/analysis.service.js
src/services/auth.service.js
src/socket/handlers.js
src/types/gamepad.ts
src/types/player.ts
src/types/xtream.ts
src/utils/analysisEngine.ts
src/utils/apiConfig.js
src/utils/coords.ts
src/utils/csvExport.ts
src/utils/eventNaming.ts
src/utils/heatmapApi.ts
src/utils/homography.ts
src/utils/kpiEngine.ts
src/utils/MatchStateMachine.ts
src/utils/passingNetwork.ts
src/utils/passPredictor.ts
src/utils/PossessionChain.ts
src/utils/roboflowApi.ts
src/utils/SequencePredictor.ts
src/utils/voiceUtils.ts
src/vite-env.d.ts
start-api-server.bat
tailwind.config.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vercel.json
verify_analytics.ts
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
# =====================================================
# Logs
# =====================================================
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# =====================================================
# Node / Frontend
# =====================================================
node_modules/
dist-ssr/
*.local
tsconfig.app.tsbuildinfo
tsconfig.node.tsbuildinfo

# =====================================================
# Editor / OS
# =====================================================
.vscode/*
!.vscode/extensions.json
.idea/
.DS_Store
Thumbs.db
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# =====================================================
# Environment & Secrets (CRITICAL)
# =====================================================
.env
.env.*
**/.ssh/
**/.ssh/*
vast_ai_key*
*vast_ai_key*

# =====================================================
# Pytho n
# =====================================================
python_env_new/
.venv/
venv/
**/__pycache__/
*.pyc
*.pyo
*.pyd

# Python artifacts / zips
python.zip
python_deploy.zip
python_kaggle.zip

# =====================================================
# Media & Large Assets (ZIP / GitHub friendly)
# ====== ===============================================
*.mp4
*.avi
*.mkv
*.mov
*.webm
*.wav

*.png
*.jpg
*.jpeg
*.svg
*.gif
*.webp

*.pdf
*.zip
*.rar 
*.7z

# Model / ML weights
*.pt
*.pth
*.pkl
*.onnx

# =====================================================
# Project-Specific Heavy Folders
# =====================================================

pro_highlights/
MATCH_DATE/

extracted_assets/
recreated_assets/
reference_slides/

public/extracted/
public/uploads/

python/public/
python/models/
python/models/weights/

# =====================================================
# Documents & Temporary Files
# =====================================================
*.doc
*.docx
*.xls
*.xlsx
*.ppt
*.pptx

*.html
!index.html
*.txt
~$*

the ask.html

# =====================================================
# Analysis & Generated Data
# =====================================================
analysis_results.json
public/analysis/*.json

# =====================================================
# Archives & Backups
# =====================================================
*.bak
*.tmp
*.old
</file>

<file path="auto_trimm.py">
import tkinter as tk
from tkinter import messagebox, simpledialog
import cv2
import numpy as np
from PIL import Image, ImageTk, ImageGrab
from ultralytics import YOLO
from collections import deque
import torch
import sys

# ================= AI ENGINE (YOLOv8) =================
class AI_Tracker:
    def __init__(self, model_size="yolov8n.pt"):
        self.model_path = model_size
        self.model = None
        self.ball_trace = deque(maxlen=30) # Remembers last 30 frames (The "Tail")
        
    def load_model(self):
        """Safely loads YOLOv8 with PyTorch 2.6 fix"""
        if self.model is not None: return

        print("üß† Loading AI Model...")
        # --- PYTORCH 2.6 SECURITY PATCH ---
        _original_load = torch.load
        def patched_load(*args, **kwargs):
            if 'weights_only' not in kwargs: kwargs['weights_only'] = False
            return _original_load(*args, **kwargs)
            
        try:
            torch.load = patched_load
            self.model = YOLO(self.model_path)
        finally:
            torch.load = _original_load
        print("‚úÖ AI Ready.")

    def run_tracking(self, video_path, start_seconds=0):
        self.load_model()
        
        cap = cv2.VideoCapture(video_path)
        fps = cap.get(cv2.CAP_PROP_FPS)
        
        # Seek to start time
        cap.set(cv2.CAP_PROP_POS_MSEC, start_seconds * 1000)
        
        print(f"‚ö° Starting Video at {start_seconds}s...")

        while cap.isOpened():
            ret, frame = cap.read()
            if not ret: break
            
            # 1. AI PREDICTION
            # conf=0.25 is a good balance for balls
            results = self.model.track(frame, persist=True, verbose=False, conf=0.25)
            
            # 2. FIND BALL
            ball_center = None
            
            if results[0].boxes.id is not None:
                boxes = results[0].boxes.xyxy.cpu().numpy()
                classes = results[0].boxes.cls.cpu().numpy()
                
                for box, cls in zip(boxes, classes):
                    # Class 32 = Sports Ball (COCO Dataset)
                    if int(cls) == 32:
                        x1, y1, x2, y2 = map(int, box)
                        ball_center = (int((x1+x2)/2), int((y1+y2)/2))
                        
                        # Draw Box around ball
                        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 255), 2)
                        break # Only track one ball

            # 3. UPDATE TRACE (The "Comet Tail")
            if ball_center:
                self.ball_trace.append(ball_center)
            else:
                # If ball is lost briefly, we don't clear the trace immediately
                # but if lost for long, we might want to break the line.
                pass 

            # 4. DRAW TRACE
            for i in range(1, len(self.ball_trace)):
                if self.ball_trace[i-1] is None or self.ball_trace[i] is None:
                    continue
                
                # Thickness fades out (Oldest points are thin, newest are thick)
                thickness = int(np.sqrt(64 / float(len(self.ball_trace) - i + 1)) * 2)
                cv2.line(frame, self.ball_trace[i-1], self.ball_trace[i], (0, 0, 255), thickness)

            # 5. DISPLAY
            # Add timecode
            current_time = cap.get(cv2.CAP_PROP_POS_MSEC) / 1000.0
            cv2.putText(frame, f"Time: {current_time:.1f}s", (20, 40), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
            
            cv2.putText(frame, "PRESS 'Q' TO STOP", (20, 80), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (100, 100, 100), 1)

            cv2.imshow("AI Ball Tracker (Max Level)", frame)
            
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
        
        cap.release()
        cv2.destroyAllWindows()

# ================= GUI STUDIO =================
class FootballStudio:
    def __init__(self, root):
        self.root = root
        self.root.title("‚öΩ Max Level AI Studio")
        self.root.geometry("1280x800")
        
        self.video_path = "match.mp4" # DEFAULT VIDEO
        self.ai_tracker = AI_Tracker()
        
        self._setup_ui()

    def _setup_ui(self):
        # --- TOP TOOLBAR ---
        toolbar = tk.Frame(self.root, bd=1, relief=tk.RAISED, bg="#222")
        toolbar.pack(side=tk.TOP, fill=tk.X)
        
        style_lbl = {"bg": "#222", "fg": "white", "font": ("Arial", 10)}
        style_btn = {"bg": "#444", "fg": "white", "relief": tk.FLAT, "padx": 10}
        style_accent = {"bg": "#007acc", "fg": "white", "relief": tk.FLAT, "padx": 15, "font": ("Arial", 10, "bold")}

        # Input: Start Time
        tk.Label(toolbar, text="Start Time (sec):", **style_lbl).pack(side=tk.LEFT, padx=5)
        self.entry_time = tk.Entry(toolbar, width=6)
        self.entry_time.insert(0, "0") # Default 0 seconds
        self.entry_time.pack(side=tk.LEFT, padx=5)

        # Button: RUN AI
        btn_run = tk.Button(toolbar, text="‚ñ∂ START PROCESSING", command=self.start_processing, **style_accent)
        btn_run.pack(side=tk.LEFT, padx=20, pady=10)
        
        # Button: Paste Frame (Legacy feature)
        tk.Button(toolbar, text="üì∏ Snapshot", command=self.snapshot, **style_btn).pack(side=tk.LEFT, padx=5)

        # --- CANVAS ---
        self.canvas_frame = tk.Frame(self.root, bg="#111")
        self.canvas_frame.pack(fill=tk.BOTH, expand=True)
        
        self.canvas = tk.Canvas(self.canvas_frame, bg="#111", highlightthickness=0)
        self.canvas.pack(fill=tk.BOTH, expand=True)
        
        # Placeholder Text
        self.canvas.create_text(640, 400, text="Ready to Process.\nEnter Start Time and Click START.", 
                               fill="#555", font=("Arial", 20))

    def start_processing(self):
        # 1. Get Time
        try:
            time_str = self.entry_time.get()
            if ":" in time_str:
                # Handle "10:30" format
                m, s = map(int, time_str.split(":"))
                start_sec = m * 60 + s
            else:
                # Handle "630" format
                start_sec = int(time_str)
        except ValueError:
            messagebox.showerror("Error", "Invalid Time Format. Use seconds (e.g. '10') or mm:ss")
            return

        # 2. Run AI (This opens a CV2 window)
        self.root.minimize() # Hide GUI temporarily
        try:
            self.ai_tracker.run_tracking(self.video_path, start_seconds=start_sec)
        except Exception as e:
            messagebox.showerror("AI Error", str(e))
        finally:
            self.root.deiconify() # Bring GUI back

    def snapshot(self):
        # Just grab the first frame for the canvas background
        cap = cv2.VideoCapture(self.video_path)
        ret, frame = cap.read()
        cap.release()
        if ret:
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            self.pil_image = Image.fromarray(frame)
            self.tk_image = ImageTk.PhotoImage(self.pil_image)
            self.canvas.create_image(0, 0, image=self.tk_image, anchor=tk.NW)

def main():
    # Fix for high-DPI displays (Windows)
    try:
        from ctypes import windll
        windll.shcore.SetProcessDpiAwareness(1)
    except:
        pass
        
    root = tk.Tk()
    app = FootballStudio(root)
    root.mainloop()

if __name__ == "__main__":
    main()
</file>

<file path="BACKEND_QUICKSTART.md">
# Python Backend API - Quick Start Guide

## üöÄ D√©marrage

### Windows
```bash
# Double-cliquez sur:
start-api-server.bat
```

### Manuel
```bash
python -m venv venv
venv\Scripts\activate  # Windows
pip install -r python/requirements.txt
cd python
python api_server.py
```

## üì° API Endpoints

- `GET /api/health` - Health check
- `POST /api/analyze-video` - Upload & analyze video
- `GET /api/analysis-status/:jobId` - Get analysis progress
- `POST /api/calculate-metrics` - Calculate advanced metrics
- `GET /api/results/:jobId` - Get full results
- `GET /api/jobs` - List all jobs

## üîß Configuration

- **Port**: 5000
- **Max file size**: 2GB
- **Formats**: MP4, AVI, MOV, MKV
- **Models**: YOLOv10, RT-DETR, DeepSORT

## üìä Workflow

1. Frontend uploads video ‚Üí `/api/analyze-video`
2. Backend returns `job_id`
3. Frontend polls `/api/analysis-status/:jobId`
4. Backend processes (detect, track, calibrate, metrics)
5. Frontend receives results

Serveur disponible sur: **http://localhost:5000**
</file>

<file path="BUSINESS_IDEATION.md">
# Tacta - Business Ideation & Strategy

## üöÄ Executive Summary
Tacta is a crowd-sourced sports analytics platform that gamifies data collection. By leveraging a community of users via a Telegram bot, we convert raw match footage into professional-grade statistical data. We solve the problem of expensive analytics for amateur/semi-pro leagues while providing an engaging, competitive experience for football fans.

---

## üßê The Problem
1.  **Data Gap**: 99% of football matches (amateur, youth, lower leagues) go unanalyzed because professional tools (Opta, Wyscout) are too expensive.
2.  **Passive Fandom**: Fans consume content passively but crave deeper engagement and recognition for their tactical knowledge.
3.  **Scouting Blindspots**: Talented players in lower leagues are missed due to lack of performance data.

## üí° The Solution: TactaBot
A "Human-in-the-Loop" AI system where users act as data labelers in exchange for status and rewards.

### Core Loop
1.  **Upload**: Leagues/Clubs upload full match videos.
2.  **Slice**: System cuts video into 5-10 second clips.
3.  **Tag**: Users watch clips on Telegram and identify events (Goal, Pass, Press, etc.).
4.  **Verify**: Our "Consensus Engine" validates data using user Trust Scores.
5.  **Publish**: Verified stats are generated for the teams.

---

## ‚öôÔ∏è Key Features (Implemented)
*   **Telegram Mini-App Interface**: Low barrier to entry, no app download needed.
*   **Trust Score System**:
    *   Users start at 50 Trust.
    *   Correct tags (matching consensus) increase trust.
    *   Spamming or wrong tags decrease trust.
    *   *Business Value*: Ensures high data quality without paid employees.
*   **Gamification**:
    *   **XP & Leveling**: Instant gratification for work done.
    *   **Streaks**: Retention mechanic to encourage daily use.
    *   **Badges**: Bronze/Silver/Gold milestones for long-term engagement.
    *   **Leaderboards**: Weekly competitions to drive "super-user" behavior.
*   **Quality Control Pipeline**:
    *   *Stage 1*: Rule Validation (Spam checks).
    *   *Stage 2*: Crowd Consensus (3 matching votes).
    *   *Stage 3*: Elite Review (Ambiguous clips sent to high-trust users).

---

## üí∞ Monetization Strategy

### 1. B2B: "Tacta for Leagues" (Primary)
*   **Target**: Amateur leagues, Youth academies, Semi-pro clubs.
*   **Model**: Subscription (SaaS).
*   **Offering**: They upload video -> We return comprehensive match reports, player ratings, and heatmaps.

### 2. B2C: "Tacta Pro" (Secondary)
*   **Target**: Hardcore users/fans.
*   **Model**: Monthly micro-subscription ($2-$5/mo).
*   **Perks**:
    *   2x XP & Trust gain.
    *   Exclusive "Scout" badges.
    *   Access to advanced data for their own analysis.

### 3. Data Licensing (Long-term)
*   **Target**: Betting companies, Scouting agencies, Football Manager games.
*   **Model**: API Access fees.
*   **Asset**: A unique, granular dataset of lower-league football that no one else has.

---

## üó∫Ô∏è Roadmap

### Phase 1: Foundation (Current)
- [x] Functional Telegram Bot.
- [x] Basic User Reputation System.
- [x] Clip Slicing & Distribution.
- [x] SQLite Database Implementation.

### Phase 2: Growth & Scale
- [ ] **Web Dashboard**: A react-based portal for clubs to view their stats (Visualizations).
- [ ] **AI Pre-labeling**: Use CV models to suggest tags, users just "Confirm/Reject" (10x speed).
- [ ] **Social Sharing**: Auto-generate "Highlight Reels" for players to share on Instagram/TikTok.

### Phase 3: Ecosystem
- [ ] **Tacta Token**: Crypto-incentives for taggers (Optional/Web3 angle).
- [ ] **Scouting Marketplace**: Connect top-rated players directly with scouts via the platform.
</file>

<file path="cog.yaml">
build:
  gpu: true
  python_version: "3.11"
  system_packages:
    - "libgl1-mesa-glx"
    - "libglib2.0-0"
  python_packages:
    - "opencv-python==4.8.1.78"
    - "ultralytics==8.0.200"
    - "numpy==1.24.3"
    - "scipy==1.11.3"
    - "scikit-learn==1.3.2"
    - "matplotlib==3.7.2"
    - "Pillow==10.0.1"

predict: "predict.py:Predictor"
</file>

<file path="colab_analysis.ipynb">
{
    "cells": [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# Soccer Match Analysis on Google Colab\n",
                "\n",
                "Use this notebook to run the analysis on a GPU.\n",
                "\n",
                "### Instructions:\n",
                "1.  Upload `colab_package.zip` (created by `prepare_colab_package.py`).\n",
                "2.  Upload your video file (e.g., `video.mp4`).\n",
                "3.  Run the cells below."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# 1. Install Dependencies\n",
                "!pip install ultralytics opencv-python numpy scipy scikit-learn"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# 2. Unzip Code\n",
                "!unzip -o colab_package.zip"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# 3. Run Analysis\n",
                "# Replace 'video.mp4' with your uploaded video filename\n",
                "video_path = \"video.mp4\"\n",
                "output_path = \"analysis_results.json\"\n",
                "\n",
                "!python python/analyze_match.py --video {video_path} --output {output_path} --generate-video"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# 4. Download Results\n",
                "from google.colab import files\n",
                "files.download(output_path)\n",
                "# If video was generated\n",
                "# files.download('output_video.mp4') # Adjust filename if needed"
            ]
        }
    ],
    "metadata": {
        "kernelspec": {
            "display_name": "Python 3",
            "language": "python",
            "name": "python3"
        },
        "language_info": {
            "codemirror_mode": {
                "name": "ipython",
                "version": 3
            },
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.8.5"
        }
    },
    "nbformat": 4,
    "nbformat_minor": 4
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="config/events.json">
[
  {
    "id": 1001,
    "category": "Core",
    "eventName": "ui_confirm",
    "label": "Confirm / A",
    "defaultDuration": [
      0,
      0
    ],
    "trigger": "Bouton A",
    "endCondition": "Instantan√©",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/",
    "filenameConvention": "UI.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 0,
        "mode": "BOTH"
      }
    ]
  },
  {
    "id": 1002,
    "category": "Core",
    "eventName": "ui_cancel",
    "label": "Cancel / B",
    "defaultDuration": [
      0,
      0
    ],
    "trigger": "Bouton B",
    "endCondition": "Instantan√©",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/",
    "filenameConvention": "UI.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 1,
        "mode": "BOTH"
      }
    ]
  },
  {
    "id": 1003,
    "category": "Core",
    "eventName": "pass_start",
    "label": "Pass Start / X",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Bouton X",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Pass/",
    "filenameConvention": "PASS_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 2,
        "mode": "BOTH"
      }
    ]
  },
  {
    "id": 1004,
    "category": "Core",
    "eventName": "shot_start",
    "label": "Shot Start / Y",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Bouton Y",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Shot/",
    "filenameConvention": "SHOT_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 3,
        "mode": "BOTH"
      }
    ]
  },
  {
    "id": 1005,
    "category": "Core",
    "eventName": "turnover",
    "label": "Perte / Turnover",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Bouton LB",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Turnover/",
    "filenameConvention": "TURNOVER_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 4,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1006,
    "category": "Core",
    "eventName": "carry_start",
    "label": "Carry / Hold RB",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Hold RB",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Carry/",
    "filenameConvention": "CARRY_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 5,
        "isHold": true,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1007,
    "category": "Core",
    "eventName": "clearance",
    "label": "D√©gagement / LB+Y",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "LB+Y",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Clearance/",
    "filenameConvention": "CLEARANCE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 3,
        "modifier": "LB",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1008,
    "category": "Core",
    "eventName": "dribble_attempt",
    "label": "Dribble / RB+X",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "RB+X",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Dribble/",
    "filenameConvention": "DRIBBLE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 2,
        "modifier": "RB",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1009,
    "category": "Core",
    "eventName": "tag_start",
    "label": "Generic Tag / Menu",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Bouton Menu",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Tags/",
    "filenameConvention": "TAG_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 9,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1010,
    "category": "Core",
    "eventName": "press_trap",
    "label": "Press Trap / L3",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Bouton L3",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Tactical/",
    "filenameConvention": "PRESS_TRAP_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 10,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1011,
    "category": "Core",
    "eventName": "dangerous_attack",
    "label": "Dangerous / R3",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Bouton R3",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Tactical/",
    "filenameConvention": "DANGER_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 11,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1012,
    "category": "Core",
    "eventName": "pressing_trigger",
    "label": "Press Trigger / D-Up",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D-Pad Up",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Tactical/",
    "filenameConvention": "PRESS_TRIGGER_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 12,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1013,
    "category": "Core",
    "eventName": "phase_lowblock",
    "label": "Low Block / D-Down",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D-Pad Down",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/Core/Tactical/",
    "filenameConvention": "LOWBLOCK_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 13,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1014,
    "category": "Core",
    "eventName": "switch_of_play",
    "label": "Switch / D-Left",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D-Pad Left",
    "isRealTime": true,
    "isPostMatch": true,
    "gamepadMappings": [
      {
        "buttonIndex": 14,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1015,
    "category": "Core",
    "eventName": "final_third_entry",
    "label": "Final Third / RB+A",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D-Pad Right / RB+A",
    "isRealTime": true,
    "isPostMatch": true,
    "gamepadMappings": [
      {
        "buttonIndex": 15,
        "mode": "LIVE"
      },
      {
        "buttonIndex": 0,
        "modifier": "RB",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1016,
    "category": "Core",
    "eventName": "cross_start",
    "label": "Cross / RT+B",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "RT+B",
    "isRealTime": true,
    "isPostMatch": true,
    "gamepadMappings": [
      {
        "buttonIndex": 1,
        "modifier": "RT",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1017,
    "category": "Core",
    "eventName": "duel_ground",
    "label": "Duel Ground / RT+X",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "RT+X",
    "isRealTime": true,
    "isPostMatch": true,
    "gamepadMappings": [
      {
        "buttonIndex": 2,
        "modifier": "RT",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1018,
    "category": "Core",
    "eventName": "big_chance",
    "label": "Big Chance / RT+R3",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "RT+R3",
    "isRealTime": true,
    "isPostMatch": true,
    "gamepadMappings": [
      {
        "buttonIndex": 11,
        "modifier": "RT",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1019,
    "category": "Core",
    "eventName": "obs_toggle_record",
    "label": "OBS Record / RT+Menu",
    "defaultDuration": [
      0,
      0
    ],
    "trigger": "RT+Menu",
    "isRealTime": true,
    "gamepadMappings": [
      {
        "buttonIndex": 9,
        "modifier": "RT",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1020,
    "category": "Core",
    "eventName": "ball_out_of_play",
    "label": "Ball Out / LT+Menu",
    "defaultDuration": [
      0,
      0
    ],
    "trigger": "LT+Menu",
    "isRealTime": true,
    "gamepadMappings": [
      {
        "buttonIndex": 9,
        "modifier": "LT",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1021,
    "category": "Core",
    "eventName": "analyst_note",
    "label": "Note / View+LB",
    "defaultDuration": [
      0,
      0
    ],
    "trigger": "View+LB",
    "isRealTime": true,
    "gamepadMappings": [
      {
        "buttonIndex": 4,
        "modifier": "View",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1022,
    "category": "Core",
    "eventName": "phase_highpress",
    "label": "High Press / Hold D-Up",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Hold D-Pad Up",
    "isRealTime": true,
    "gamepadMappings": [
      {
        "buttonIndex": 12,
        "isHold": true,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1023,
    "category": "Core",
    "eventName": "free_kick",
    "label": "Free Kick / RT+View",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "RT+View",
    "isRealTime": true,
    "gamepadMappings": [
      {
        "buttonIndex": 8,
        "modifier": "RT",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1024,
    "category": "Core",
    "eventName": "offside",
    "label": "Offside / View+A",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "View+A",
    "isRealTime": true,
    "gamepadMappings": [
      {
        "buttonIndex": 0,
        "modifier": "View",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1025,
    "category": "Core",
    "eventName": "throw_in_tactical",
    "label": "Throw-In / Menu+LB",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Menu+LB",
    "isRealTime": true,
    "gamepadMappings": [
      {
        "buttonIndex": 5,
        "modifier": "View",
        "mode": "LIVE"
      },
      {
        "buttonIndex": 4,
        "modifier": "Menu",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 1,
    "category": "Build-Up",
    "eventName": "sortie_de_balle_courte",
    "label": "Sortie de balle courte",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Sortie_de_balle_courte/",
    "filenameConvention": "SORTIE_DE_BALLE_COURTE_MIN_SEC.mp4"
  },
  {
    "id": 2,
    "category": "Build-Up",
    "eventName": "sortie_de_balle_longue",
    "label": "Sortie de balle longue",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Sortie_de_balle_longue/",
    "filenameConvention": "SORTIE_DE_BALLE_LONGUE_MIN_SEC.mp4"
  },
  {
    "id": 3,
    "category": "Build-Up",
    "eventName": "progression_axe",
    "label": "Progression axe",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Progression_axe/",
    "filenameConvention": "PROGRESSION_AXE_MIN_SEC.mp4"
  },
  {
    "id": 4,
    "category": "Build-Up",
    "eventName": "progression_cote",
    "label": "Progression c√¥t√©",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Progression_c√¥t√©/",
    "filenameConvention": "PROGRESSION_C√îT√â_MIN_SEC.mp4"
  },
  {
    "id": 5,
    "category": "Build-Up",
    "eventName": "circulation_lente",
    "label": "Circulation lente",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Circulation_lente/",
    "filenameConvention": "CIRCULATION_LENTE_MIN_SEC.mp4"
  },
  {
    "id": 6,
    "category": "Build-Up",
    "eventName": "circulation_rapide",
    "label": "Circulation rapide",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Circulation_rapide/",
    "filenameConvention": "CIRCULATION_RAPIDE_MIN_SEC.mp4"
  },
  {
    "id": 7,
    "category": "Build-Up",
    "eventName": "fixation_bloc",
    "label": "Fixation bloc",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Fixation_bloc/",
    "filenameConvention": "FIXATION_BLOC_MIN_SEC.mp4"
  },
  {
    "id": 8,
    "category": "Build-Up",
    "eventName": "renversement",
    "label": "Renversement / D-Left",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Renversement/",
    "filenameConvention": "RENVERSEMENT_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 14,
        "mode": "BOTH"
      }
    ]
  },
  {
    "id": 9,
    "category": "Build-Up",
    "eventName": "troisieme_homme",
    "label": "Troisi√®me homme",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Troisi√®me_homme/",
    "filenameConvention": "TROISI√àME_HOMME_MIN_SEC.mp4"
  },
  {
    "id": 10,
    "category": "Build-Up",
    "eventName": "break_line_pass",
    "label": "Break line pass",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Break_line_pass/",
    "filenameConvention": "BREAK_LINE_PASS_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 15,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 11,
    "category": "Build-Up",
    "eventName": "appel_decroche",
    "label": "Appel d√©croch√©",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Appel_d√©croch√©/",
    "filenameConvention": "APPEL_D√âCROCH√â_MIN_SEC.mp4"
  },
  {
    "id": 12,
    "category": "Build-Up",
    "eventName": "appel_profondeur",
    "label": "Appel profondeur",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/01_BuildUp/Appel_profondeur/",
    "filenameConvention": "APPEL_PROFONDEUR_MIN_SEC.mp4"
  },
  {
    "id": 13,
    "category": "Offensive",
    "eventName": "tir_cadre",
    "label": "Tir cadr√©",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Tir_cadr√©/",
    "filenameConvention": "TIR_CADR√â_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 1,
        "modifier": "RB",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 14,
    "category": "Offensive",
    "eventName": "tir_non_cadre",
    "label": "Tir non cadr√©",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Tir_non_cadr√©/",
    "filenameConvention": "TIR_NON_CADR√â_MIN_SEC.mp4"
  },
  {
    "id": 15,
    "category": "Offensive",
    "eventName": "occasion_creee",
    "label": "Occasion cr√©√©e",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Occasion_cr√©√©e/",
    "filenameConvention": "OCCASION_CR√â√âE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 3,
        "modifier": "RB",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 16,
    "category": "Offensive",
    "eventName": "xg_eleve",
    "label": "xG √©lev√©",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/xG_√©lev√©/",
    "filenameConvention": "XG_√âLEV√â_MIN_SEC.mp4"
  },
  {
    "id": 17,
    "category": "Offensive",
    "eventName": "centre_dangereux",
    "label": "Centre dangereux",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Centre_dangereux/",
    "filenameConvention": "CENTRE_DANGEREUX_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 2,
        "modifier": "RB",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 18,
    "category": "Offensive",
    "eventName": "centre_rate",
    "label": "Centre rat√©",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Centre_rat√©/",
    "filenameConvention": "CENTRE_RAT√â_MIN_SEC.mp4"
  },
  {
    "id": 19,
    "category": "Offensive",
    "eventName": "dribble_reussi",
    "label": "Dribble r√©ussi",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Dribble_r√©ussi/",
    "filenameConvention": "DRIBBLE_R√âUSSI_MIN_SEC.mp4"
  },
  {
    "id": 20,
    "category": "Offensive",
    "eventName": "dribble_rate",
    "label": "Dribble rat√©",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Dribble_rat√©/",
    "filenameConvention": "DRIBBLE_RAT√â_MIN_SEC.mp4"
  },
  {
    "id": 21,
    "category": "Offensive",
    "eventName": "une_deux",
    "label": "Une-deux",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Une-deux/",
    "filenameConvention": "UNE-DEUX_MIN_SEC.mp4"
  },
  {
    "id": 22,
    "category": "Offensive",
    "eventName": "passe_cle",
    "label": "Passe cl√©",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Passe_cl√©/",
    "filenameConvention": "PASSE_CL√â_MIN_SEC.mp4"
  },
  {
    "id": 23,
    "category": "Offensive",
    "eventName": "counter_attack",
    "label": "Contre-attaque",
    "requiresZone": true,
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Contre-attaque/",
    "filenameConvention": "CONTRE-ATTAQUE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 3,
        "modifier": "RB",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 24,
    "category": "Offensive",
    "eventName": "projection_milieu",
    "label": "Projection milieu",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/02_Offensive/Projection_milieu/",
    "filenameConvention": "PROJECTION_MILIEU_MIN_SEC.mp4"
  },
  {
    "id": 25,
    "category": "D√©fensive",
    "eventName": "duel_gagne",
    "label": "Duel gagn√© / LB+B",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Duel_gagn√©/",
    "filenameConvention": "DUEL_GAGN√â_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 1,
        "modifier": "LB",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 26,
    "category": "D√©fensive",
    "eventName": "duel_perdu",
    "label": "Duel perdu",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Duel_perdu/",
    "filenameConvention": "DUEL_PERDU_MIN_SEC.mp4"
  },
  {
    "id": 27,
    "category": "D√©fensive",
    "eventName": "interception",
    "label": "Interception / LB+X",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Interception/",
    "filenameConvention": "INTERCEPTION_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 5,
        "mode": "BOTH"
      },
      {
        "buttonIndex": 2,
        "modifier": "LB",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 28,
    "category": "D√©fensive",
    "eventName": "tacle_reussi",
    "label": "Tacle r√©ussi / LB+A",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Tacle_r√©ussi/",
    "filenameConvention": "TACLE_R√âUSSI_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 0,
        "modifier": "LB",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 29,
    "category": "D√©fensive",
    "eventName": "tacle_rate",
    "label": "Tacle rat√©",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Tacle_rat√©/",
    "filenameConvention": "TACLE_RAT√â_MIN_SEC.mp4"
  },
  {
    "id": 30,
    "category": "D√©fensive",
    "eventName": "bloc_bas",
    "label": "Bloc bas / D-Down",
    "requiresZone": true,
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Bloc_bas/",
    "filenameConvention": "BLOC_BAS_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 13,
        "mode": "BOTH"
      }
    ]
  },
  {
    "id": 31,
    "category": "D√©fensive",
    "eventName": "bloc_median",
    "label": "Bloc m√©dian",
    "requiresZone": true,
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Bloc_m√©dian/",
    "filenameConvention": "BLOC_M√âDIAN_MIN_SEC.mp4"
  },
  {
    "id": 32,
    "category": "D√©fensive",
    "eventName": "pressing_haut",
    "label": "Pressing haut / D-Up",
    "requiresZone": true,
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Pressing_haut/",
    "filenameConvention": "PRESSING_HAUT_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 12,
        "mode": "BOTH"
      }
    ]
  },
  {
    "id": 33,
    "category": "D√©fensive",
    "eventName": "pressing_coordonne",
    "label": "Pressing coordonn√©",
    "requiresZone": true,
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Pressing_coordonn√©/",
    "filenameConvention": "PRESSING_COORDONN√â_MIN_SEC.mp4"
  },
  {
    "id": 34,
    "category": "D√©fensive",
    "eventName": "sortie_defenseur",
    "label": "Sortie d√©fenseur",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Sortie_d√©fenseur/",
    "filenameConvention": "SORTIE_D√âFENSEUR_MIN_SEC.mp4"
  },
  {
    "id": 35,
    "category": "D√©fensive",
    "eventName": "couverture",
    "label": "Couverture",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Couverture/",
    "filenameConvention": "COUVERTURE_MIN_SEC.mp4"
  },
  {
    "id": 36,
    "category": "D√©fensive",
    "eventName": "faute_tactique",
    "label": "Faute tactique / Menu+RB",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Menu+RB",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/03_Defensive/Faute_tactique/",
    "filenameConvention": "FAUTE_TACTIQUE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 5,
        "modifier": "Menu",
        "mode": "BOTH"
      }
    ]
  },
  {
    "id": 37,
    "category": "Transition",
    "eventName": "recuperation_haute",
    "label": "R√©cup√©ration haute",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/04_Transition/R√©cup√©ration_haute/",
    "filenameConvention": "R√âCUP√âRATION_HAUTE_MIN_SEC.mp4"
  },
  {
    "id": 38,
    "category": "Transition",
    "eventName": "recuperation_mediane",
    "label": "R√©cup√©ration m√©diane",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/04_Transition/R√©cup√©ration_m√©diane/",
    "filenameConvention": "R√âCUP√âRATION_M√âDIANE_MIN_SEC.mp4"
  },
  {
    "id": 39,
    "category": "Transition",
    "eventName": "recuperation_basse",
    "label": "R√©cup√©ration basse",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/04_Transition/R√©cup√©ration_basse/",
    "filenameConvention": "R√âCUP√âRATION_BASSE_MIN_SEC.mp4"
  },
  {
    "id": 40,
    "category": "Transition",
    "eventName": "transition_off_start",
    "label": "Transition offensive",
    "requiresZone": true,
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/04_Transition/Transition_offensive/",
    "filenameConvention": "TRANSITION_OFFENSIVE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 7,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 41,
    "category": "Transition",
    "eventName": "transition_def_start",
    "label": "Transition d√©fensive",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/04_Transition/Transition_d√©fensive/",
    "filenameConvention": "TRANSITION_D√âFENSIVE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 6,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 42,
    "category": "Transition",
    "eventName": "projection_rapide",
    "label": "Projection rapide",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/04_Transition/Projection_rapide/",
    "filenameConvention": "PROJECTION_RAPIDE_MIN_SEC.mp4"
  },
  {
    "id": 43,
    "category": "Transition",
    "eventName": "retard_defensif",
    "label": "Retard d√©fensif",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/04_Transition/Retard_d√©fensif/",
    "filenameConvention": "RETARD_D√âFENSIF_MIN_SEC.mp4"
  },
  {
    "id": 44,
    "category": "Transition",
    "eventName": "contre_pressing",
    "label": "Contre pressing",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/04_Transition/Contre_pressing/",
    "filenameConvention": "CONTRE_PRESSING_MIN_SEC.mp4"
  },
  {
    "id": 45,
    "category": "Transition",
    "eventName": "perte_dangereuse",
    "label": "Perte dangereuse",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/04_Transition/Perte_dangereuse/",
    "filenameConvention": "PERTE_DANGEREUSE_MIN_SEC.mp4"
  },
  {
    "id": 46,
    "category": "Transition",
    "eventName": "perte_anodine",
    "label": "Perte anodine",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/04_Transition/Perte_anodine/",
    "filenameConvention": "PERTE_ANODINE_MIN_SEC.mp4"
  },
  {
    "id": 47,
    "category": "Moments Cl√©s",
    "eventName": "goal",
    "label": "But / Menu+Y",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Menu+Y",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/05_MomentsCles/But/",
    "filenameConvention": "BUT_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 3,
        "modifier": "Menu",
        "mode": "BOTH"
      },
      {
        "buttonIndex": 5,
        "mode": "POST"
      }
    ]
  },
  {
    "id": 48,
    "category": "Moments Cl√©s",
    "eventName": "but_refuse",
    "label": "But refus√©",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/05_MomentsCles/But_refus√©/",
    "filenameConvention": "BUT_REFUS√â_MIN_SEC.mp4"
  },
  {
    "id": 49,
    "category": "Moments Cl√©s",
    "eventName": "passe_decisive",
    "label": "Passe d√©cisive / Menu+X",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "Menu+X",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/05_MomentsCles/Passe_d√©cisive/",
    "filenameConvention": "PASSE_D√âCISIVE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 2,
        "modifier": "Menu",
        "mode": "BOTH"
      }
    ]
  },
  {
    "id": 50,
    "category": "Moments Cl√©s",
    "eventName": "penalty",
    "label": "Penalty obtenu",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/05_MomentsCles/Penalty_obtenu/",
    "filenameConvention": "PENALTY_OBTENU_MIN_SEC.mp4",
    "gamepadMappings": []
  },
  {
    "id": 51,
    "category": "Moments Cl√©s",
    "eventName": "penalty_concede",
    "label": "Penalty conc√©d√©",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/05_MomentsCles/Penalty_conc√©d√©/",
    "filenameConvention": "PENALTY_CONC√âD√â_MIN_SEC.mp4"
  },
  {
    "id": 52,
    "category": "Moments Cl√©s",
    "eventName": "occasion_ratee",
    "label": "Occasion rat√©e",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/05_MomentsCles/Occasion_rat√©e/",
    "filenameConvention": "OCCASION_RAT√âE_MIN_SEC.mp4"
  },
  {
    "id": 53,
    "category": "Moments Cl√©s",
    "eventName": "sauvetage_ligne",
    "label": "Sauvetage ligne",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/05_MomentsCles/Sauvetage_ligne/",
    "filenameConvention": "SAUVETAGE_LIGNE_MIN_SEC.mp4"
  },
  {
    "id": 54,
    "category": "Moments Cl√©s",
    "eventName": "erreur_menant_au_tir",
    "label": "Erreur menant au tir",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/05_MomentsCles/Erreur_menant_au_tir/",
    "filenameConvention": "ERREUR_MENANT_AU_TIR_MIN_SEC.mp4"
  },
  {
    "id": 55,
    "category": "Moments Cl√©s",
    "eventName": "erreur_menant_au_but",
    "label": "Erreur menant au but",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/05_MomentsCles/Erreur_menant_au_but/",
    "filenameConvention": "ERREUR_MENANT_AU_BUT_MIN_SEC.mp4"
  },
  {
    "id": 56,
    "category": "Moments Cl√©s",
    "eventName": "action_decisive",
    "label": "Action d√©cisive",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/05_MomentsCles/Action_d√©cisive/",
    "filenameConvention": "ACTION_D√âCISIVE_MIN_SEC.mp4"
  },
  {
    "id": 57,
    "category": "Phases Arr√™t√©es",
    "eventName": "corner_offensif",
    "label": "Corner offensif",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/06_SetPieces/Corner_offensif/",
    "filenameConvention": "CORNER_OFFENSIF_MIN_SEC.mp4"
  },
  {
    "id": 58,
    "category": "Phases Arr√™t√©es",
    "eventName": "corner_defensif",
    "label": "Corner d√©fensif",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/06_SetPieces/Corner_d√©fensif/",
    "filenameConvention": "CORNER_D√âFENSIF_MIN_SEC.mp4"
  },
  {
    "id": 59,
    "category": "Phases Arr√™t√©es",
    "eventName": "coup_franc_direct",
    "label": "Coup franc direct",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/06_SetPieces/Coup_franc_direct/",
    "filenameConvention": "COUP_FRANC_DIRECT_MIN_SEC.mp4"
  },
  {
    "id": 60,
    "category": "Phases Arr√™t√©es",
    "eventName": "coup_franc_indirect",
    "label": "Coup franc indirect",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/06_SetPieces/Coup_franc_indirect/",
    "filenameConvention": "COUP_FRANC_INDIRECT_MIN_SEC.mp4"
  },
  {
    "id": 61,
    "category": "Phases Arr√™t√©es",
    "eventName": "penalty_tire",
    "label": "Penalty tir√©",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/06_SetPieces/Penalty_tir√©/",
    "filenameConvention": "PENALTY_TIR√â_MIN_SEC.mp4"
  },
  {
    "id": 62,
    "category": "Phases Arr√™t√©es",
    "eventName": "penalty_arrete",
    "label": "Penalty arr√™t√©",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/06_SetPieces/Penalty_arr√™t√©/",
    "filenameConvention": "PENALTY_ARR√äT√â_MIN_SEC.mp4"
  },
  {
    "id": 63,
    "category": "Phases Arr√™t√©es",
    "eventName": "second_ballon_cpa",
    "label": "Second ballon CPA",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/06_SetPieces/Second_ballon_CPA/",
    "filenameConvention": "SECOND_BALLON_CPA_MIN_SEC.mp4"
  },
  {
    "id": 64,
    "category": "Phases Arr√™t√©es",
    "eventName": "organisation_cpa",
    "label": "Organisation CPA",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/06_SetPieces/Organisation_CPA/",
    "filenameConvention": "ORGANISATION_CPA_MIN_SEC.mp4"
  },
  {
    "id": 65,
    "category": "Gardien",
    "eventName": "arret_simple",
    "label": "Arr√™t simple",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/07_Gardien/Arr√™t_simple/",
    "filenameConvention": "ARR√äT_SIMPLE_MIN_SEC.mp4"
  },
  {
    "id": 66,
    "category": "Gardien",
    "eventName": "arret_reflexe",
    "label": "Arr√™t r√©flexe",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/07_Gardien/Arr√™t_r√©flexe/",
    "filenameConvention": "ARR√äT_R√âFLEXE_MIN_SEC.mp4"
  },
  {
    "id": 67,
    "category": "Gardien",
    "eventName": "sortie_aerienne",
    "label": "Sortie a√©rienne",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/07_Gardien/Sortie_a√©rienne/",
    "filenameConvention": "SORTIE_A√âRIENNE_MIN_SEC.mp4"
  },
  {
    "id": 68,
    "category": "Gardien",
    "eventName": "sortie_au_sol",
    "label": "Sortie au sol",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/07_Gardien/Sortie_au_sol/",
    "filenameConvention": "SORTIE_AU_SOL_MIN_SEC.mp4"
  },
  {
    "id": 69,
    "category": "Gardien",
    "eventName": "relance_courte",
    "label": "Relance courte",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/07_Gardien/Relance_courte/",
    "filenameConvention": "RELANCE_COURTE_MIN_SEC.mp4"
  },
  {
    "id": 70,
    "category": "Gardien",
    "eventName": "relance_longue",
    "label": "Relance longue",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/07_Gardien/Relance_longue/",
    "filenameConvention": "RELANCE_LONGUE_MIN_SEC.mp4"
  },
  {
    "id": 71,
    "category": "Gardien",
    "eventName": "erreur_relance",
    "label": "Erreur relance",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/07_Gardien/Erreur_relance/",
    "filenameConvention": "ERREUR_RELANCE_MIN_SEC.mp4"
  },
  {
    "id": 72,
    "category": "Gardien",
    "eventName": "1v1_gagne",
    "label": "1v1 gagn√©",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/07_Gardien/1v1_gagn√©/",
    "filenameConvention": "1V1_GAGN√â_MIN_SEC.mp4"
  },
  {
    "id": 73,
    "category": "Gardien",
    "eventName": "1v1_perdu",
    "label": "1v1 perdu",
    "requiresZone": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/07_Gardien/1v1_perdu/",
    "filenameConvention": "1V1_PERDU_MIN_SEC.mp4"
  },
  {
    "id": 74,
    "category": "Discipline",
    "eventName": "foul",
    "label": "Faute simple",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/08_Discipline/Faute_simple/",
    "filenameConvention": "FAUTE_SIMPLE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 8,
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 75,
    "category": "Discipline",
    "eventName": "faute_dangereuse",
    "label": "Faute dangereuse",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/08_Discipline/Faute_dangereuse/",
    "filenameConvention": "FAUTE_DANGEREUSE_MIN_SEC.mp4"
  },
  {
    "id": 76,
    "category": "Discipline",
    "eventName": "card_yellow",
    "label": "Carton jaune",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/08_Discipline/Carton_jaune/",
    "filenameConvention": "CARTON_JAUNE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 3,
        "modifier": "View",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 77,
    "category": "Discipline",
    "eventName": "card_red",
    "label": "Carton rouge",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/08_Discipline/Carton_rouge/",
    "filenameConvention": "CARTON_ROUGE_MIN_SEC.mp4",
    "gamepadMappings": [
      {
        "buttonIndex": 1,
        "modifier": "View",
        "mode": "LIVE"
      }
    ]
  },
  {
    "id": 78,
    "category": "Discipline",
    "eventName": "avertissement_verbal",
    "label": "Avertissement verbal",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/08_Discipline/Avertissement_verbal/",
    "filenameConvention": "AVERTISSEMENT_VERBAL_MIN_SEC.mp4"
  },
  {
    "id": 79,
    "category": "Physique",
    "eventName": "sprint",
    "label": "Sprint",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/09_Physique/Sprint/",
    "filenameConvention": "SPRINT_MIN_SEC.mp4"
  },
  {
    "id": 80,
    "category": "Physique",
    "eventName": "haute_intensite",
    "label": "Haute intensit√©",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/09_Physique/Haute_intensit√©/",
    "filenameConvention": "HAUTE_INTENSIT√â_MIN_SEC.mp4"
  },
  {
    "id": 81,
    "category": "Physique",
    "eventName": "baisse_de_rythme",
    "label": "Baisse de rythme",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/09_Physique/Baisse_de_rythme/",
    "filenameConvention": "BAISSE_DE_RYTHME_MIN_SEC.mp4"
  },
  {
    "id": 82,
    "category": "Physique",
    "eventName": "retour_defensif_long",
    "label": "Retour d√©fensif long",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/09_Physique/Retour_d√©fensif_long/",
    "filenameConvention": "RETOUR_D√âFENSIF_LONG_MIN_SEC.mp4"
  },
  {
    "id": 83,
    "category": "Physique",
    "eventName": "fatigue_visible",
    "label": "Fatigue visible",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/09_Physique/Fatigue_visible/",
    "filenameConvention": "FATIGUE_VISIBLE_MIN_SEC.mp4"
  },
  {
    "id": 84,
    "category": "Tactique",
    "eventName": "changement_systeme",
    "label": "Changement syst√®me",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/10_Tactique/Changement_syst√®me/",
    "filenameConvention": "CHANGEMENT_SYST√àME_MIN_SEC.mp4"
  },
  {
    "id": 85,
    "category": "Tactique",
    "eventName": "ajustement_pressing",
    "label": "Ajustement pressing",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/10_Tactique/Ajustement_pressing/",
    "filenameConvention": "AJUSTEMENT_PRESSING_MIN_SEC.mp4"
  },
  {
    "id": 86,
    "category": "Tactique",
    "eventName": "bloc_plus_haut",
    "label": "Bloc plus haut",
    "requiresZone": true,
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/10_Tactique/Bloc_plus_haut/",
    "filenameConvention": "BLOC_PLUS_HAUT_MIN_SEC.mp4"
  },
  {
    "id": 87,
    "category": "Tactique",
    "eventName": "bloc_plus_bas",
    "label": "Bloc plus bas",
    "requiresZone": true,
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/10_Tactique/Bloc_plus_bas/",
    "filenameConvention": "BLOC_PLUS_BAS_MIN_SEC.mp4"
  },
  {
    "id": 88,
    "category": "Tactique",
    "eventName": "desequilibre_cote",
    "label": "D√©s√©quilibre c√¥t√©",
    "requiresZone": true,
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/10_Tactique/D√©s√©quilibre_c√¥t√©/",
    "filenameConvention": "D√âS√âQUILIBRE_C√îT√â_MIN_SEC.mp4"
  },
  {
    "id": 89,
    "category": "Tactique",
    "eventName": "surnombre_cree",
    "label": "Surnombre cr√©√©",
    "requiresZone": true,
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/10_Tactique/Surnombre_cr√©√©/",
    "filenameConvention": "SURNOMBRE_CR√â√â_MIN_SEC.mp4"
  },
  {
    "id": 90,
    "category": "Psychologique",
    "eventName": "leadership",
    "label": "Leadership",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/11_Psychologique/Leadership/",
    "filenameConvention": "LEADERSHIP_MIN_SEC.mp4"
  },
  {
    "id": 91,
    "category": "Psychologique",
    "eventName": "reaction_apres_but",
    "label": "R√©action apr√®s but",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/11_Psychologique/R√©action_apr√®s_but/",
    "filenameConvention": "R√âACTION_APR√àS_BUT_MIN_SEC.mp4"
  },
  {
    "id": 92,
    "category": "Psychologique",
    "eventName": "perte_de_concentration",
    "label": "Perte de concentration",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/11_Psychologique/Perte_de_concentration/",
    "filenameConvention": "PERTE_DE_CONCENTRATION_MIN_SEC.mp4"
  },
  {
    "id": 93,
    "category": "Psychologique",
    "eventName": "motivation_collective",
    "label": "Motivation collective",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/11_Psychologique/Motivation_collective/",
    "filenameConvention": "MOTIVATION_COLLECTIVE_MIN_SEC.mp4"
  },
  {
    "id": 94,
    "category": "Match",
    "eventName": "coup_denvoi",
    "label": "Coup d‚Äôenvoi",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/12_Match/Coup_d‚Äôenvoi/",
    "filenameConvention": "COUP_D‚ÄôENVOI_MIN_SEC.mp4"
  },
  {
    "id": 95,
    "category": "Match",
    "eventName": "mi_temps",
    "label": "Mi-temps",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/12_Match/Mi-temps/",
    "filenameConvention": "MI-TEMPS_MIN_SEC.mp4"
  },
  {
    "id": 96,
    "category": "Match",
    "eventName": "fin_de_match",
    "label": "Fin de match",
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": false,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/12_Match/Fin_de_match/",
    "filenameConvention": "FIN_DE_MATCH_MIN_SEC.mp4"
  },
  {
    "id": 97,
    "category": "Match",
    "eventName": "temps_fort",
    "label": "Temps fort",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/12_Match/Temps_fort/",
    "filenameConvention": "TEMPS_FORT_MIN_SEC.mp4"
  },
  {
    "id": 98,
    "category": "Match",
    "eventName": "temps_faible",
    "label": "Temps faible",
    "requiresDuration": true,
    "defaultDuration": [
      5,
      12
    ],
    "trigger": "D√©clencheur terrain",
    "endCondition": "Action termin√©e",
    "isRealTime": true,
    "isPostMatch": true,
    "folderPath": "/Match_DATE/12_Match/Temps_faible/",
    "filenameConvention": "TEMPS_FAIBLE_MIN_SEC.mp4"
  }
]
</file>

<file path="content.json">
{
  "slides": [
    {
      "page_number": 1,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_1_img_1.png",
          "path": "extracted_assets\\slide_1_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 2,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_2_img_1.png",
          "path": "extracted_assets\\slide_2_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 3,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_3_img_1.png",
          "path": "extracted_assets\\slide_3_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 4,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_4_img_1.png",
          "path": "extracted_assets\\slide_4_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 5,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_5_img_1.png",
          "path": "extracted_assets\\slide_5_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 6,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_6_img_1.png",
          "path": "extracted_assets\\slide_6_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 7,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_7_img_1.png",
          "path": "extracted_assets\\slide_7_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 8,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_8_img_1.png",
          "path": "extracted_assets\\slide_8_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 9,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_9_img_1.png",
          "path": "extracted_assets\\slide_9_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 10,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_10_img_1.png",
          "path": "extracted_assets\\slide_10_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 11,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_11_img_1.png",
          "path": "extracted_assets\\slide_11_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 12,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_12_img_1.png",
          "path": "extracted_assets\\slide_12_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 13,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_13_img_1.png",
          "path": "extracted_assets\\slide_13_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 14,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_14_img_1.png",
          "path": "extracted_assets\\slide_14_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 15,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_15_img_1.png",
          "path": "extracted_assets\\slide_15_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 16,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_16_img_1.png",
          "path": "extracted_assets\\slide_16_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    },
    {
      "page_number": 17,
      "text_blocks": [],
      "images": [
        {
          "filename": "slide_17_img_1.png",
          "path": "extracted_assets\\slide_17_img_1.png",
          "bboxes": [
            [
              0.0,
              0.0,
              1376.0,
              768.0
            ]
          ]
        }
      ]
    }
  ]
}
</file>

<file path="create_kaggle_zip.py">
import zipfile
import os

def zip_folder(folder_path, output_path):
    print(f"Zipping '{folder_path}' to '{output_path}'...")
    try:
        with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(folder_path):
                for file in files:
                    # Get the full file path
                    file_path = os.path.join(root, file)
                    
                    # Create a relative path for the archive (e.g., python/api.py)
                    # We want the 'python' folder to be the root inside the zip
                    arcname = os.path.relpath(file_path, os.path.dirname(os.path.abspath(folder_path)))
                    
                    # CRITICAL: Force forward slashes for Linux/Kaggle compatibility
                    arcname = arcname.replace(os.sep, '/')
                    
                    print(f"Adding: {arcname}")
                    zipf.write(file_path, arcname)
        print(f"‚úÖ Successfully created {output_path}")
    except Exception as e:
        print(f"‚ùå Error creating zip: {e}")

if __name__ == "__main__":
    # Run from the project root
    zip_folder('python', 'python_kaggle.zip')
</file>

<file path="crop_config.json">
{
    "slides": [
        {
            "page": 1,
            "crops": [
                {
                    "name": "illustration",
                    "bbox": [688, 113, 1364, 720]
                }
            ]
        },
        {
            "page": 2,
            "crops": [
                {
                    "name": "illustration",
                    "bbox": [688, 124, 1375, 720]
                }
            ]
        },
        {
            "page": 3,
            "crops": [
                {
                    "name": "text",
                    "bbox": [55, 57, 680, 757]
                },
                {
                    "name": "illustration",
                    "bbox": [688, 57, 1364, 720]
                }
            ]
        }
    ]
}
</file>

<file path="cropper.py">
import json
import os
from PIL import Image

CONFIG_FILE = "crop_config.json"
ASSETS_DIR = "extracted_assets"
OUTPUT_DIR = "recreated_assets"

def crop_images():
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    with open(CONFIG_FILE, "r") as f:
        config = json.load(f)

    for slide in config["slides"]:
        page_num = slide["page"]
        src_image_name = f"slide_{page_num}_img_1.png"
        src_path = os.path.join(ASSETS_DIR, src_image_name)
        
        if not os.path.exists(src_path):
            print(f"Source image not found: {src_path}")
            continue

        img = Image.open(src_path)

        for crop in slide["crops"]:
            bbox = tuple(crop["bbox"])
            crop_name = crop["name"]
            
            cropped_img = img.crop(bbox)
            
            output_filename = f"slide_{page_num}_{crop_name}.png"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            cropped_img.save(output_path)
            print(f"Saved {output_path}")

if __name__ == "__main__":
    crop_images()
</file>

<file path="deploy_to_vast.ps1">
param(
    [Parameter(Mandatory=$true)]
    [string]$KeyPath
)

# Configuration pour le proxy SSH Vast.ai

# Configuration (Mode Direct Connection)
$User = "root"
$HostIP = "86.127.244.250"   # L'adresse IP directe (plus de probl√®me DNS)
$Port = "21521"              # ATTENTION : Le port a chang√© (c'est celui du Direct Connect)
Write-Host "=== Deploying to Vast.ai Instance via Proxy SSH (${HostIP}:${Port}) ==="

# 1. Upload Python scripts
Write-Host "[1/3] Uploading Python scripts..."
scp -P $Port -i "$KeyPath" -o StrictHostKeyChecking=no -r ./python "$User@${HostIP}:/root/"

if ($LASTEXITCODE -ne 0) {
    Write-Error "Upload failed. Check your key path and connection."
    exit
}

# 2. Install Dependencies
Write-Host "[2/3] Installing dependencies on remote server..."
# On essaie d'abord d'installer pip si n√©cessaire, puis les librairies
ssh -p $Port -i "$KeyPath" -o StrictHostKeyChecking=no "$User@${HostIP}" "apt-get update && apt-get install -y python3-pip && pip3 install fastapi uvicorn ultralytics opencv-python-headless python-multipart"

if ($LASTEXITCODE -ne 0) {
    Write-Error "Dependency installation failed."
    exit
}

# 3. Instructions
Write-Host "[3/3] Setup Complete!"
Write-Host "---------------------------------------------------"
Write-Host "To start the server and connect, run the following command in a NEW terminal window:"
Write-Host ""
Write-Host "ssh -p $Port -i `"$KeyPath`" -L 8080:localhost:8080 $User@${HostIP} 'python3 /root/python/remote_server.py'"
Write-Host ""
Write-Host "---------------------------------------------------"
</file>

<file path="DEPLOYMENT_GUIDE.md">
# Complete Replicate Deployment Guide

## Current Status
‚úÖ Replicate integration module created (`replicate-analyzer.js`)  
‚úÖ Environment template created (`.env.example`)  
‚úÖ Replicate npm package installed  
‚ö†Ô∏è `server.js` needs manual fix (see `SERVER_FIX_NEEDED.md`)

## Step-by-Step Deployment

### Step 1: Fix server.js (5 minutes)
The file got corrupted during editing. You have two options:

**Option A: Quick Fix**
1. Open `server.js`
2. Add the imports from `SERVER_FIX_NEEDED.md` at the very top
3. Save

**Option B: Let me recreate it**
- Reply "recreate server.js" and I'll generate a fresh one with Replicate integration

### Step 2: Install Cog (One-time setup)
```bash
# Windows (PowerShell as Administrator)
iwr -useb https://cog.run/install.ps1 | iex

# Or download from: https://github.com/replicate/cog/releases
```

### Step 3: Sign Up for Replicate
1. Go to https://replicate.com/
2. Sign up (free tier available)
3. Get API token from https://replicate.com/account/api-tokens

### Step 4: Deploy Your Model
```bash
# From project root
cog login
cog push r8.im/YOUR_USERNAME/soccer-analysis
```

This will take 10-15 minutes the first time (uploads Python environment).

### Step 5: Configure Environment
Create `.env` file:
```
REPLICATE_API_TOKEN=r8_your_token_here
REPLICATE_MODEL=YOUR_USERNAME/soccer-analysis
PORT=3003
```

### Step 6: Test
```bash
npm run server
```

Upload a video and click "Analyze Match". It should now use Replicate GPU!

## How It Works

1. User uploads video in web app
2. Server checks if `REPLICATE_API_TOKEN` is set
3. **If yes**: Sends video to Replicate GPU ‚Üí Fast analysis (~2 min)
4. **If no**: Uses local Python ‚Üí Slow analysis (~10+ min)

## Cost
- First 100 predictions/month: FREE
- After that: ~$0.02 per analysis (2-3 minutes of GPU time)

## Next Steps
1. Fix `server.js` (choose Option A or B above)
2. Follow steps 2-6 to deploy

Let me know which option you'd like for fixing server.js!
</file>

<file path="detect_bbox.py">
from PIL import Image
import sys

def find_content_bbox(image_path, threshold=240):
    """
    Finds the bounding box of non-white content in an image.
    Assumes white background (pixel value > threshold).
    """
    try:
        img = Image.open(image_path).convert("RGB")
        width, height = img.size
        print(f"Analyzing {image_path} ({width}x{height})")

        left, top, right, bottom = width, height, 0, 0
        found = False

        # Load pixels
        pixels = img.load()

        # Simplify: Scan rows and columns to find limits
        # Top
        for y in range(height):
            for x in range(width):
                r, g, b = pixels[x, y]
                if r < threshold or g < threshold or b < threshold:
                    top = y
                    found = True
                    break
            if found: break
        
        if not found:
            print("No content found (image is all white/light).")
            return

        # Bottom
        found = False
        for y in range(height - 1, -1, -1):
            for x in range(width):
                r, g, b = pixels[x, y]
                if r < threshold or g < threshold or b < threshold:
                    bottom = y
                    found = True
                    break
            if found: break

        # Left
        found = False
        for x in range(width):
            for y in range(top, bottom + 1):
                r, g, b = pixels[x, y]
                if r < threshold or g < threshold or b < threshold:
                    left = x
                    found = True
                    break
            if found: break

        # Right
        found = False
        for x in range(width - 1, -1, -1):
            for y in range(top, bottom + 1):
                r, g, b = pixels[x, y]
                if r < threshold or g < threshold or b < threshold:
                    right = x
                    found = True
                    break
            if found: break

        print(f"Content BBox: ({left}, {top}, {right}, {bottom})")
        print(f"Width: {right - left}, Height: {bottom - top}")

        # Also, let's try to detect if there's a distinct "right side" image
        # Assuming the image is on the right half
        mid_x = width // 2
        print(f"\nScanning right half (x > {mid_x})...")
        
        r_left, r_top, r_right, r_bottom = width, height, mid_x, 0
        r_found = False

        # Scan right half
        for y in range(height):
            for x in range(mid_x, width):
                r, g, b = pixels[x, y]
                if r < threshold or g < threshold or b < threshold:
                    if x < r_left: r_left = x
                    if x > r_right: r_right = x
                    if y < r_top: r_top = y
                    if y > r_bottom: r_bottom = y
                    r_found = True
        
        if r_found:
            print(f"Right Side Blob BBox: ({r_left}, {r_top}, {r_right}, {r_bottom})")

    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        find_content_bbox(sys.argv[1])
    else:
        print("Usage: python detect_bbox.py <image_path>")
</file>

<file path="diagnose_pdf.py">
import fitz

PDF_PATH = "Analyst_Crisis_TACTA_Solution.pdf"

def diagnose_pdf():
    doc = fitz.open(PDF_PATH)
    page = doc[0] # Check first page
    
    # Check text again
    text = page.get_text()
    print(f"--- Text on Page 1 ---\n{text if text.strip() else 'NO TEXT FOUND'}\n----------------------")
    
    # Check drawings (vector graphics)
    drawings = page.get_drawings()
    print(f"Number of drawings on Page 1: {len(drawings)}")
    if drawings:
        print("Sample drawing:", drawings[0])

    # Check for other objects
    print(f"Page content: {page.read_contents()}")

if __name__ == "__main__":
    diagnose_pdf()
</file>

<file path="env.production">
# Production Environment Variables
NODE_ENV=production
PORT=10000

# Frontend API Configuration - Empty because we're serving from same domain
VITE_API_BASE_URL=
VITE_API_URL=
VITE_ANALYSIS_API_URL=/analysis-api
VITE_SOCKET_URL=

# Server Configuration
CORS_ORIGIN=https://tactasports.onrender.com
FRONTEND_URL=https://tactasports.onrender.com

# Telegram (if needed in production)
TELEGRAM_BOT_TOKEN=8546700045:AAG-hd__jgaladIkt_m3B4WOGrfAWolMAFY
ADMIN_IDS=1719899525

# Roboflow
ROBOFLOW_API_KEY=opvo93bUk9eGbWWUaaEY

# Replicate (replace with your actual token)
REPLICATE_API_TOKEN=r8_your_actual_token_here
REPLICATE_MODEL=yolov8-soccer
</file>

<file path="eslint.config.js">
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": ["warn", { allowConstantExport: true }],
      "@typescript-eslint/no-unused-vars": "off",
    },
  },
);
</file>

<file path="extract_pdf_content.py">
import fitz  # PyMuPDF
import json
import os

# Configuration
PDF_PATH = "Analyst_Crisis_TACTA_Solution.pdf"
OUTPUT_DIR = "extracted_assets"
JSON_OUTPUT = "content.json"

def extract_content():
    if not os.path.exists(PDF_PATH):
        print(f"Error: PDF not found at {PDF_PATH}")
        return

    # Create output directory for images
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    doc = fitz.open(PDF_PATH)
    presentation_data = {"slides": []}

    for page_num, page in enumerate(doc):
        slide = {
            "page_number": page_num + 1,
            "text_blocks": [],
            "images": []
        }

        # Extract text blocks
        # "dict" returns a dictionary with detailed information
        blocks = page.get_text("dict")["blocks"]
        
        for b in blocks:
            if b["type"] == 0:  # Text block
                for line in b["lines"]:
                    for span in line["spans"]:
                        text_item = {
                            "text": span["text"],
                            "size": span["size"],
                            "font": span["font"],
                            "color": span["color"],
                            "bbox": span["bbox"],  # (x0, y0, x1, y1)
                            "origin": span["origin"]
                        }
                        slide["text_blocks"].append(text_item)

        # Extract images
        image_list = page.get_images(full=True)
        
        for img_index, img in enumerate(image_list):
            xref = img[0]
            base_image = doc.extract_image(xref)
            image_bytes = base_image["image"]
            image_ext = base_image["ext"]
            
            image_filename = f"slide_{page_num + 1}_img_{img_index + 1}.{image_ext}"
            image_path = os.path.join(OUTPUT_DIR, image_filename)
            
            with open(image_path, "wb") as f:
                f.write(image_bytes)
            
            # Get image bbox on page (this can be tricky, simplified here)
            # PyMuPDF doesn't give bbox in get_images directly, we need to search for it
            # or just list it as an asset belonging to the slide.
            # For accurate positioning, we would need to search for the image on the page
            # using page.get_image_rects(xref)
            
            rects = page.get_image_rects(xref)
            bboxes = [list(r) for r in rects]

            slide["images"].append({
                "filename": image_filename,
                "path": image_path,
                "bboxes": bboxes
            })

        presentation_data["slides"].append(slide)
        print(f"Processed slide {page_num + 1}")

    # Save structured data to JSON
    with open(JSON_OUTPUT, "w", encoding="utf-8") as f:
        json.dump(presentation_data, f, indent=2, ensure_ascii=False)
    
    print(f"Extraction complete. JSON saved to {JSON_OUTPUT}")

if __name__ == "__main__":
    extract_content()
</file>

<file path="extract_reference.py">
import fitz
import os

PDF_PATH = "Analyst_Crisis_TACTA_Solution.pdf"
OUTPUT_DIR = "reference_slides"

def extract_reference():
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    doc = fitz.open(PDF_PATH)
    
    for page_num, page in enumerate(doc):
        # Render the page to an image (pixmap) instead of extracting embedded images
        # This ensures we get exactly what the slide looks like (text included)
        pix = page.get_pixmap(matrix=fitz.Matrix(1, 1)) # Standard resolution is fine for reading text
        
        output_filename = f"slide_{page_num + 1}_ref.png"
        output_path = os.path.join(OUTPUT_DIR, output_filename)
        
        pix.save(output_path)
        print(f"Saved reference {output_path}")

if __name__ == "__main__":
    extract_reference()
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Soccer Controller</title>
  <meta name="description" content="Lovable Generated Project" />
  <meta name="author" content="Lovable" />
  <meta property="og:image" content="/og-image.png" />
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>
</file>

<file path="iptv/app/api/proxy/stream/route.ts">
import { NextRequest, NextResponse } from "next/server";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";
export const fetchCache = "force-no-store";

const DEFAULT_USER_AGENT =
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36 Edg/140.0.0.0";
const PASS_THROUGH_HEADERS = new Set([
  "range",
  "if-none-match",
  "if-modified-since",
  "accept",
  "accept-encoding",
  "accept-language",
  "sec-fetch-mode",
  "sec-fetch-site",
  "sec-fetch-dest",
]);
const PLAYLIST_CONTENT_TYPES = [
  "application/vnd.apple.mpegurl",
  "application/x-mpegurl",
  "application/mpegurl",
  "audio/mpegurl",
];
const SKIPPED_PROXY_HEADERS = new Set([
  "content-security-policy",
  "content-length",
  "transfer-encoding",
]);
const PROXY_PATH = "/api/proxy/stream";
const SESSION_COOKIE = process.env.XTREAM_SESSION_COOKIE ?? null;

const isPlaylistContentType = (contentType?: string | null) =>
  contentType
    ? PLAYLIST_CONTENT_TYPES.some((type) =>
        contentType.toLowerCase().includes(type)
      )
    : false;

const buildProxiedUrl = (
  resource: string,
  baseUrl: URL,
  requestOrigin: string,
  debug: boolean = false
): string | null => {
  if (!resource) return null;

  try {
    let absolute: URL;

    // √ñnce absolute URL olarak parse etmeyi dene
    try {
      absolute = new URL(resource);
      // Eƒüer absolute URL ise ve zaten proxy URL'i ise, olduƒüu gibi d√∂nd√ºr
      if (absolute.pathname.startsWith(PROXY_PATH)) {
        if (debug) {
          console.log("[Proxy] Already proxied URL:", resource);
        }
        return resource;
      }
    } catch {
      // Absolute URL deƒüilse, relative URL olarak base URL ile birle≈ütir
      try {
        absolute = new URL(resource, baseUrl);
      } catch (error) {
        if (debug) {
          console.error("[Proxy] Failed to parse URL:", {
            resource,
            baseUrl: baseUrl.toString(),
            error: error instanceof Error ? error.message : String(error),
          });
        }
        return null;
      }
    }

    // Eƒüer zaten proxy URL'i ise, olduƒüu gibi d√∂nd√ºr
    if (absolute.pathname.startsWith(PROXY_PATH)) {
      if (debug) {
        console.log(
          "[Proxy] Already proxied URL (after parse):",
          absolute.toString()
        );
      }
      return resource;
    }

    // Segment URL'leri i√ßin referer olarak playlist URL'ini kullan
    // √á√ºnk√º segment URL'leri playlist'ten geliyor ve upstream server playlist URL'ini referer olarak bekliyor
    // Playlist URL'leri i√ßin de playlist URL'ini kullan
    const refererForProxy = baseUrl.toString();

    // URL'leri encode et (URLSearchParams √ßift encode yapmamasƒ± i√ßin manuel encode)
    const encodedUrl = encodeURIComponent(absolute.toString());
    const encodedReferer = encodeURIComponent(refererForProxy);

    // Absolute proxy URL olu≈ütur
    const proxyPath = `${PROXY_PATH}?url=${encodedUrl}&referer=${encodedReferer}`;
    const proxyUrl = `${requestOrigin}${proxyPath}`;

    if (debug) {
      console.log("[Proxy] Rewriting URL:", {
        original: resource,
        absolute: absolute.toString(),
        proxied: proxyUrl,
        baseUrl: baseUrl.toString(),
        isAbsolute:
          resource.startsWith("http://") || resource.startsWith("https://"),
      });
    }

    return proxyUrl;
  } catch (error) {
    if (debug) {
      console.error("[Proxy] Failed to build proxied URL:", {
        resource,
        baseUrl: baseUrl.toString(),
        error: error instanceof Error ? error.message : String(error),
      });
    }
    return null;
  }
};

const rewritePlaylist = (
  body: string,
  baseUrl: URL,
  requestOrigin: string,
  debug: boolean = false
) => {
  const newline = body.includes("\r\n") ? "\r\n" : "\n";
  return body
    .split(/\r?\n/)
    .map((line) => {
      if (!line) return line;

      // URI= parametrelerini yakala (EXT-X-KEY, EXT-X-MAP gibi)
      let rewrittenLine = line.replace(
        /URI=(['"])(.+?)\1/gi,
        (match, quote, value) => {
          const proxied = buildProxiedUrl(value, baseUrl, requestOrigin, debug);
          return proxied ? `URI=${quote}${proxied}${quote}` : match;
        }
      );

      const trimmed = line.trim();

      // Yorum satƒ±rlarƒ± ve bo≈ü satƒ±rlarƒ± atla
      if (!trimmed || trimmed.startsWith("#")) {
        return rewrittenLine;
      }

      // Segment URL'lerini proxy'le (yorum satƒ±rƒ± olmayan, URI= i√ßermeyen satƒ±rlar)
      // Bu genellikle direkt segment URL'leridir
      const proxied = buildProxiedUrl(trimmed, baseUrl, requestOrigin, debug);
      if (proxied && proxied !== trimmed) {
        return proxied;
      }

      return rewrittenLine;
    })
    .join(newline);
};

const applyCors = <T extends Response | NextResponse>(response: T): T => {
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
    "Access-Control-Allow-Headers":
      "Content-Type, Range, Accept, Origin, Referer, User-Agent, Cache-Control, Pragma, X-Requested-With",
    "Access-Control-Expose-Headers":
      "Accept-Ranges, Content-Length, Content-Range, X-Proxy-Debug, X-Proxy-Environment",
    "Access-Control-Allow-Credentials": "false",
    "Access-Control-Max-Age": "86400",
  };
  Object.entries(corsHeaders).forEach(([key, value]) =>
    response.headers.set(key, value)
  );
  return response;
};

export async function GET(request: NextRequest) {
  const { searchParams } = request.nextUrl;
  const streamUrl = searchParams.get("url");
  const refererParam = searchParams.get("referer");
  const debugEnabled =
    searchParams.get("debug") === "1" ||
    searchParams.get("debug") === "true" ||
    searchParams.has("debug");
  const shouldLog = debugEnabled || process.env.NODE_ENV === "production";

  // Request origin'ini al (localhost i√ßin doƒüru √ßalƒ±≈ümasƒ± i√ßin)
  const requestOrigin = request.nextUrl.origin;

  if (!streamUrl) {
    return applyCors(
      NextResponse.json({ error: "Stream URL is required" }, { status: 400 })
    );
  }

  try {
    // URL'i decode et - encodeURIComponent ile encode edilmi≈ü URL'leri decode et
    // √áift encode edilmi≈ü URL'leri de handle et
    let decodedUrl: string = streamUrl;
    try {
      // √ñnce bir kez decode et
      decodedUrl = decodeURIComponent(streamUrl);
      // Eƒüer hala encode edilmi≈ü g√∂r√ºn√ºyorsa (√∂rneƒüin %25 gibi), tekrar decode et
      if (decodedUrl.includes("%25")) {
        decodedUrl = decodeURIComponent(decodedUrl);
      }
    } catch {
      // Eƒüer decode edilemezse, zaten decode edilmi≈ü demektir
      decodedUrl = streamUrl;
    }

    const targetUrl = new URL(decodedUrl);

    // Referer belirleme - localhost'tan gelen referer'ƒ± kullanma
    // Segment URL'leri i√ßin referer olarak segment URL'in kendi path'ini kullan
    // Playlist URL'leri i√ßin refererParam'dan veya target URL'in origin'inden referer al
    let refererHeader: string | null = null;

    const isSegmentUrl = targetUrl.pathname.endsWith(".ts");

    if (isSegmentUrl) {
      // Segment URL'leri i√ßin referer olarak segment URL'in kendi path'ini kullan
      // Ama √∂nce refererParam'dan playlist URL'ini kontrol et
      if (refererParam?.trim()) {
        try {
          const decodedReferer = decodeURIComponent(refererParam.trim());
          const refererUrl = new URL(decodedReferer);
          // Localhost referer'larƒ± kabul etme
          if (
            !refererUrl.hostname.includes("localhost") &&
            !refererUrl.hostname.includes("127.0.0.1")
          ) {
            refererHeader = refererUrl.toString();
          }
        } catch {
          // Ge√ßersiz referer, kullanma
        }
      }

      // Eƒüer referer yoksa, segment URL'in kendi path'ini kullan
      if (!refererHeader) {
        refererHeader = `${targetUrl.origin}${targetUrl.pathname}`;
      }
    } else {
      // Playlist URL'leri i√ßin refererParam'dan veya target URL'in origin'inden referer al
      if (refererParam?.trim()) {
        try {
          const decodedReferer = decodeURIComponent(refererParam.trim());
          const refererUrl = new URL(decodedReferer);
          // Localhost referer'larƒ± kabul etme
          if (
            !refererUrl.hostname.includes("localhost") &&
            !refererUrl.hostname.includes("127.0.0.1")
          ) {
            refererHeader = refererUrl.toString();
          }
        } catch {
          // Ge√ßersiz referer, kullanma
        }
      }

      // Eƒüer referer yoksa veya localhost ise, target URL'in origin'ini kullan
      if (!refererHeader) {
        refererHeader = `${targetUrl.origin}/`;
      }
    }

    const upstreamHeaders = new Headers({
      "User-Agent": process.env.XTREAM_USER_AGENT ?? DEFAULT_USER_AGENT,
      Accept: request.headers.get("accept") ?? "*/*",
      "Accept-Language":
        request.headers.get("accept-language") ?? "tr,en-US;q=0.9,en;q=0.8",
      "Cache-Control": "no-cache",
      Pragma: "no-cache",
      Referer: refererHeader,
      Origin: targetUrl.origin,
      "sec-fetch-mode": "cors",
      "sec-fetch-site": "cross-site",
      "sec-fetch-dest": "video",
    });

    // Pass-through headers
    PASS_THROUGH_HEADERS.forEach((header) => {
      const value = request.headers.get(header);
      if (value && !upstreamHeaders.has(header))
        upstreamHeaders.set(header, value);
    });

    // Forward headers
    [
      "x-forwarded-for",
      "x-real-ip",
      "true-client-ip",
      "cf-connecting-ip",
      "forwarded",
    ].forEach((header) => {
      const value = request.headers.get(header);
      if (value)
        upstreamHeaders.set(
          header
            .replace("x-", "X-")
            .replace("cf-", "CF-")
            .replace("true-", "True-"),
          value
        );
    });

    if (SESSION_COOKIE && !upstreamHeaders.has("cookie")) {
      upstreamHeaders.set("Cookie", SESSION_COOKIE);
    }

    const fetchOptions: RequestInit = {
      method: "GET",
      headers: upstreamHeaders,
      redirect: "follow",
      signal: request.signal,
      cache: "no-store",
    };

    if (debugEnabled) {
      console.log("[Proxy] Fetching upstream:", {
        url: targetUrl.toString(),
        referer: refererHeader || `${targetUrl.origin}/`,
        headers: Object.fromEntries(upstreamHeaders.entries()),
      });
    }

    let retryStage = "initial";
    let upstreamResponse = await fetch(targetUrl, fetchOptions);

    if (debugEnabled) {
      console.log("[Proxy] Upstream response:", {
        status: upstreamResponse.status,
        statusText: upstreamResponse.statusText,
        headers: Object.fromEntries(upstreamResponse.headers.entries()),
        url: targetUrl.toString(),
      });
    }

    // Retry logic
    if (upstreamResponse.status === 403) {
      upstreamHeaders.delete("Referer");
      retryStage = "no-referer";
      if (debugEnabled) {
        console.log("[Proxy] Retrying without Referer header");
      }
      upstreamResponse = await fetch(targetUrl, fetchOptions);
    } else if (upstreamResponse.status === 404) {
      // 404 i√ßin farklƒ± referer stratejileri dene
      const originalReferer = upstreamHeaders.get("Referer");

      if (isSegmentUrl && refererParam?.trim()) {
        // Segment URL'leri i√ßin √∂nce playlist URL'ini referer olarak dene
        try {
          const decodedReferer = decodeURIComponent(refererParam.trim());
          const refererUrl = new URL(decodedReferer);
          if (
            !refererUrl.hostname.includes("localhost") &&
            !refererUrl.hostname.includes("127.0.0.1")
          ) {
            upstreamHeaders.set("Referer", refererUrl.toString());
            retryStage = "playlist-referer";
            if (debugEnabled) {
              console.log("[Proxy] Retrying with playlist referer:", {
                originalReferer,
                newReferer: refererUrl.toString(),
              });
            }
            upstreamResponse = await fetch(targetUrl, fetchOptions);
          }
        } catch {
          // Ge√ßersiz referer, devam et
        }
      }

      // Hala 404 ise, origin referer ile dene
      if (upstreamResponse.status === 404) {
        upstreamHeaders.set("Referer", `${targetUrl.origin}/`);
        retryStage = "origin-referer";
        if (debugEnabled) {
          console.log("[Proxy] Retrying with origin referer:", {
            originalReferer,
            newReferer: `${targetUrl.origin}/`,
          });
        }
        upstreamResponse = await fetch(targetUrl, fetchOptions);
      }

      // Hala 404 ise, referer'ƒ± tamamen kaldƒ±r
      if (upstreamResponse.status === 404) {
        upstreamHeaders.delete("Referer");
        retryStage = "no-referer-after-404";
        if (debugEnabled) {
          console.log("[Proxy] Retrying without Referer after 404");
        }
        upstreamResponse = await fetch(targetUrl, fetchOptions);
      }
    }

    if (!upstreamResponse.ok || !upstreamResponse.body) {
      const detail = await upstreamResponse.text().catch(() => undefined);
      const errorResponse = NextResponse.json(
        {
          error: "Stream not available",
          status: upstreamResponse.status,
          message: `Upstream server returned ${upstreamResponse.status}: ${upstreamResponse.statusText}`,
          ...(shouldLog && {
            debug: {
              url: targetUrl.toString(),
              status: upstreamResponse.status,
              retryStage,
              detail: detail?.slice(0, 200),
            },
          }),
        },
        { status: upstreamResponse.status || 502 }
      );

      if (shouldLog) {
        const debugHeaders = {
          "X-Proxy-Debug": "1",
          "X-Proxy-Referer": refererHeader ?? `${targetUrl.origin}/`,
          "X-Proxy-Origin": targetUrl.origin,
          "X-Proxy-Sent-Cookie": upstreamHeaders.has("Cookie") ? "yes" : "no",
          "X-Proxy-Retry": retryStage,
          "X-Proxy-Upstream-Status": String(upstreamResponse.status),
          "X-Proxy-Target-Host": targetUrl.host,
          "X-Proxy-Environment": process.env.NODE_ENV || "unknown",
        };
        Object.entries(debugHeaders).forEach(([key, value]) =>
          errorResponse.headers.set(key, value)
        );
      }

      return applyCors(errorResponse);
    }

    const contentType = upstreamResponse.headers.get("content-type");
    const responseHeaders = new Headers();

    // Copy headers
    upstreamResponse.headers.forEach((value, key) => {
      if (!SKIPPED_PROXY_HEADERS.has(key.toLowerCase()))
        responseHeaders.set(key, value);
    });

    // Set response headers
    Object.entries({
      "Content-Type": contentType ?? "application/octet-stream",
      "Cache-Control": "no-cache, no-store, must-revalidate",
      Pragma: "no-cache",
      Expires: "0",
    }).forEach(([key, value]) => responseHeaders.set(key, value));

    const isPlaylistByExt = targetUrl.pathname.toLowerCase().endsWith(".m3u8");

    // Debug headers
    if (debugEnabled) {
      const debugHeaders = {
        "X-Proxy-Debug": "1",
        "X-Proxy-Referer": refererHeader ?? `${targetUrl.origin}/`,
        "X-Proxy-Origin": targetUrl.origin,
        "X-Proxy-Sent-Cookie": upstreamHeaders.has("Cookie") ? "yes" : "no",
        "X-Proxy-Retry": retryStage,
        "X-Proxy-Upstream-Status": String(upstreamResponse.status),
        "X-Proxy-Is-Playlist":
          isPlaylistContentType(contentType) || isPlaylistByExt ? "1" : "0",
        "X-Proxy-Target-Host": targetUrl.host,
      };
      Object.entries(debugHeaders).forEach(([key, value]) =>
        responseHeaders.set(key, value)
      );
    }

    // Handle playlist content
    if (isPlaylistContentType(contentType) || isPlaylistByExt) {
      const text = await upstreamResponse.text();

      // Debug i√ßin: ƒ∞lk birka√ß satƒ±rƒ± logla
      if (debugEnabled) {
        const lines = text.split(/\r?\n/).slice(0, 20);
        console.log("[Proxy] Playlist preview:", lines.join("\n"));
      }

      const rewritten = rewritePlaylist(
        text,
        targetUrl,
        requestOrigin,
        debugEnabled
      );

      // Debug i√ßin: Rewrite edilmi≈ü ilk birka√ß satƒ±rƒ± logla
      if (debugEnabled) {
        const rewrittenLines = rewritten.split(/\r?\n/).slice(0, 20);
        console.log(
          "[Proxy] Rewritten playlist preview:",
          rewrittenLines.join("\n")
        );
      }

      responseHeaders.delete("content-length");
      return applyCors(
        new NextResponse(rewritten, {
          status: upstreamResponse.status,
          headers: responseHeaders,
        })
      );
    }

    return applyCors(
      new NextResponse(upstreamResponse.body, {
        status: upstreamResponse.status,
        headers: responseHeaders,
      })
    );
  } catch (error) {
    const errorResponse = NextResponse.json(
      {
        error: "Failed to fetch stream",
        message: error instanceof Error ? error.message : "Unknown error",
        ...(shouldLog && {
          debug: {
            error: error instanceof Error ? error.message : String(error),
            streamUrl: streamUrl?.substring(0, 100) + "...",
          },
        }),
      },
      { status: 500 }
    );

    if (shouldLog) {
      errorResponse.headers.set("X-Proxy-Debug", "1");
      errorResponse.headers.set(
        "X-Proxy-Environment",
        process.env.NODE_ENV || "unknown"
      );
    }

    return applyCors(errorResponse);
  }
}

export async function OPTIONS() {
  return applyCors(new NextResponse(null, { status: 200 }));
}
</file>

<file path="iptv/app/api/xtream/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getCategoriesWithStreams, XtreamApiError } from "@/lib/xtream";

export const revalidate = 60;

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
};

export async function OPTIONS() {
  return new NextResponse(null, { status: 200, headers: corsHeaders });
}

export async function GET(request: NextRequest) {
  try {
    const credentialsParam = request.nextUrl.searchParams.get("credentials");
    const credentials = credentialsParam
      ? JSON.parse(decodeURIComponent(credentialsParam))
      : undefined;

    const categories = await getCategoriesWithStreams(credentials);
    return NextResponse.json(
      { categories },
      { headers: { "Cache-Control": "s-maxage=60, stale-while-revalidate=60" } }
    );
  } catch (error) {
    if (error instanceof XtreamApiError) {
      return NextResponse.json(
        {
          message: "Xtream API verilerine ulasilamadi",
          error: error.message,
          status: error.status,
        },
        { status: error.status }
      );
    }
    return NextResponse.json(
      {
        message: "Xtream API verilerine ulasilamadi",
        error:
          error instanceof Error
            ? error.message
            : "Beklenmedik bir hata olustu",
      },
      { status: 500 }
    );
  }
}
</file>

<file path="iptv/app/globals.css">
@import "tailwindcss";

:root {
  color-scheme: dark;
}

body {
  background-color: rgb(2 6 23);
  color: rgb(241 245 249);
  min-height: 100vh;
  background-image: radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.08) 1px, transparent 0);
  background-size: 24px 24px;
}

.scrollbar-thin::-webkit-scrollbar {
  height: 10px;
  width: 10px;
}

.scrollbar-thin::-webkit-scrollbar-track {
  background: rgba(30, 41, 59, 0.5);
  border-radius: 5px;
  margin: 2px;
}

.scrollbar-thin::-webkit-scrollbar-thumb {
  background-color: rgba(148, 163, 184, 0.8);
  border-radius: 5px;
  border: 1px solid rgba(30, 41, 59, 0.5);
}

.scrollbar-thin::-webkit-scrollbar-thumb:hover {
  background-color: rgba(148, 163, 184, 1);
}

.scrollbar-thin::-webkit-scrollbar-corner {
  background: rgba(30, 41, 59, 0.5);
}

.card-glass {
  background-color: rgba(15, 23, 42, 0.6);
  -webkit-backdrop-filter: blur(24px);
  backdrop-filter: blur(24px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 20px 45px -12px rgba(37, 99, 235, 0.35);
}
</file>

<file path="iptv/app/layout.tsx">
import type { Metadata } from "next";
import type { ReactNode } from "react";
import { Inter, Space_Grotesk } from "next/font/google";
import "./globals.css";
import { AuthProvider } from "@/contexts/AuthContext";
import { PWAProvider } from "@/components/PWAProvider";

const inter = Inter({ subsets: ["latin"], variable: "--font-inter" });
const grotesk = Space_Grotesk({
  subsets: ["latin"],
  variable: "--font-grotesk",
});

export const metadata: Metadata = {
  title: "React IPTV Client",
  description: "Xtream Codes destekli modern IPTV arayuzu",
  icons: {
    icon: [
      {
        url: "/icons/icon-192x192.svg",
        sizes: "192x192",
        type: "image/svg+xml",
      },
      {
        url: "/icons/icon-512x512.svg",
        sizes: "512x512",
        type: "image/svg+xml",
      },
    ],
    apple: [
      {
        url: "/icons/icon-152x152.svg",
        sizes: "152x152",
        type: "image/svg+xml",
      },
    ],
  },
  manifest: "/manifest.json",
  robots: {
    index: false,
    follow: false,
    googleBot: {
      index: false,
      follow: false,
    },
  },
  viewport: {
    width: "device-width",
    initialScale: 1,
    maximumScale: 1,
    userScalable: false,
    viewportFit: "cover",
  },
  themeColor: [
    { media: "(prefers-color-scheme: light)", color: "#2563eb" },
    { media: "(prefers-color-scheme: dark)", color: "#2563eb" },
  ],
  appleWebApp: {
    capable: true,
    statusBarStyle: "black-translucent",
    title: "React IPTV Client",
  },
  other: {
    "mobile-web-app-capable": "yes",
    "apple-mobile-web-app-capable": "yes",
    "apple-mobile-web-app-status-bar-style": "black-translucent",
    "msapplication-TileColor": "#2563eb",
    "msapplication-config": "/browserconfig.xml",
  },
};

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="tr">
      <body className={`${inter.variable} ${grotesk.variable} font-sans`}>
        <PWAProvider />
        <AuthProvider>{children}</AuthProvider>
      </body>
    </html>
  );
}
</file>

<file path="iptv/app/page.tsx">
import { ChannelBrowser } from "@/components/ChannelBrowser";
import { AuthWrapper } from "@/components/AuthWrapper";

export const dynamic = "force-dynamic";

export default function HomePage() {
  return (
    <main className="h-screen w-screen overflow-hidden">
      <AuthWrapper>
        <ChannelBrowser />
      </AuthWrapper>
    </main>
  );
}
</file>

<file path="iptv/app/robots.ts">
import type { MetadataRoute } from "next";

export default function robots(): MetadataRoute.Robots {
  return {
    rules: [
      {
        userAgent: "*",
        disallow: "/",
      },
    ],
    sitemap: undefined,
    host: undefined,
  };
}
</file>

<file path="iptv/components/AuthWrapper.tsx">
"use client";

import type { ReactNode } from "react";
import { Settings, LogOut } from "lucide-react";
import { useAuth } from "@/contexts/AuthContext";
import { LoginForm } from "./LoginForm";

interface AuthWrapperProps {
  children: ReactNode;
}

export function AuthWrapper({ children }: AuthWrapperProps) {
  const { isConfigured, clearConfiguration, isLoading } = useAuth();

  if (isLoading) {
    return (
      <div className="h-screen w-screen bg-slate-950 flex items-center justify-center">
        <div className="text-center">
          <div className="w-8 h-8 border-2 border-primary/30 border-t-primary rounded-full animate-spin mx-auto mb-4" />
          <p className="text-slate-400">Y√ºkleniyor...</p>
        </div>
      </div>
    );
  }

  if (!isConfigured) {
    return <LoginForm />;
  }

  return (
    <div className="relative">
      <div className="fixed top-4 right-4 z-50 flex items-center gap-2">
        <button
          onClick={clearConfiguration}
          className="flex items-center gap-2 rounded-lg bg-blue-500/20 hover:bg-blue-500/30 text-blue-400 hover:text-blue-300 px-3 py-2 text-sm font-medium transition-colors backdrop-blur-sm border border-blue-500/20"
          title="IPTV ayarlarƒ±nƒ± deƒüi≈ütir"
        >
          <Settings className="h-4 w-4" />
          Ayarlar
        </button>

        <button
          onClick={clearConfiguration}
          className="flex items-center gap-2 rounded-lg bg-red-500/20 hover:bg-red-500/30 text-red-400 hover:text-red-300 px-3 py-2 text-sm font-medium transition-colors backdrop-blur-sm border border-red-500/20"
          title="IPTV yapƒ±landƒ±rmasƒ±nƒ± temizle"
        >
          <LogOut className="h-4 w-4" />
          Temizle
        </button>
      </div>

      {children}
    </div>
  );
}
</file>

<file path="iptv/components/CascaderMenu.tsx">
"use client";

import { useState, useMemo } from "react";
import { clsx } from "clsx";
import { Heart, HeartOff, Star, StarOff } from "lucide-react";
import type { ChannelCategory } from "@/types/xtream";
import { useFavorites } from "@/hooks/useFavorites";

interface CascaderMenuProps {
  categories: ChannelCategory[];
  selectedCategoryId: string | null;
  onCategorySelect: (categoryId: string) => void;
}

export function CascaderMenu({
  categories,
  selectedCategoryId,
  onCategorySelect,
}: CascaderMenuProps) {
  const [showFavorites, setShowFavorites] = useState(false);
  const { isCategoryFavorite, toggleCategoryFavorite, getFavoriteCategories } =
    useFavorites();

  const orderedCategories = useMemo(
    () =>
      [...categories].sort((a, b) =>
        a.name.localeCompare(b.name, "tr", { sensitivity: "base" })
      ),
    [categories]
  );

  const favoriteCategories = useMemo(
    () => getFavoriteCategories(orderedCategories),
    [orderedCategories, getFavoriteCategories]
  );

  const displayCategories = useMemo(() => {
    if (showFavorites) {
      return favoriteCategories;
    }

    const favorites = favoriteCategories;
    const others = orderedCategories.filter(
      (cat) => !favorites.some((fav) => fav.id === cat.id)
    );

    return [...favorites, ...others];
  }, [showFavorites, favoriteCategories, orderedCategories]);

  return (
    <div className="flex h-full flex-col min-h-0">
      {/* Header */}
      <div className="flex-shrink-0 mb-3 sm:mb-4">
        <div className="flex items-center justify-between mb-2 sm:mb-3">
          <h2 className="text-base sm:text-lg font-semibold text-white">
            Kategoriler
          </h2>
          <button
            onClick={() => setShowFavorites(!showFavorites)}
            className={clsx(
              "rounded-md p-1 sm:p-1.5 transition-colors",
              showFavorites
                ? "bg-yellow-500/20 text-yellow-400"
                : "bg-white/5 text-slate-400 hover:text-white"
            )}
            title={
              showFavorites
                ? "T√ºm kategorileri g√∂ster"
                : "Sadece favorileri g√∂ster"
            }
          >
            {showFavorites ? (
              <Star className="h-3 w-3 sm:h-4 sm:w-4" />
            ) : (
              <StarOff className="h-3 w-3 sm:h-4 sm:w-4" />
            )}
          </button>
        </div>
      </div>

      {/* Categories List */}
      <div className="flex-1 min-h-0 overflow-y-auto space-y-1 pr-2 scrollbar-thin">
        {displayCategories.length === 0 ? (
          <div className="rounded-lg border border-dashed border-white/10 bg-white/5 p-4 text-center text-slate-400">
            <p className="text-xs">
              {showFavorites
                ? "Hen√ºz favori kategori yok"
                : "Kategori bulunamadƒ±"}
            </p>
          </div>
        ) : (
          displayCategories.map((category) => {
            const isSelected = selectedCategoryId === category.id;
            const isFavorite = isCategoryFavorite(category.id);

            return (
              <div
                key={category.id}
                className="flex items-center gap-1 min-w-0"
              >
                <button
                  onClick={() => onCategorySelect(category.id)}
                  className={clsx(
                    "flex-1 flex items-center gap-1 sm:gap-2 rounded-md border px-1.5 sm:px-2 py-1 sm:py-1.5 text-left text-xs font-medium transition-all min-w-0 overflow-hidden",
                    isSelected
                      ? "border-primary bg-primary/15 text-primary"
                      : "border-white/10 bg-white/5 text-slate-300 hover:border-primary/60 hover:text-primary"
                  )}
                >
                  <span
                    className="truncate flex-1 min-w-0"
                    title={category.name}
                  >
                    {category.name}
                  </span>
                  <span className="text-xs text-slate-500 ml-auto flex-shrink-0">
                    ({category.streams.length})
                  </span>
                </button>

                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    toggleCategoryFavorite(category.id);
                  }}
                  className={clsx(
                    "rounded-md p-0.5 sm:p-1 transition-colors",
                    isFavorite
                      ? "text-red-400 hover:text-red-300"
                      : "text-slate-500 hover:text-slate-300"
                  )}
                  title={isFavorite ? "Favorilerden √ßƒ±kar" : "Favorilere ekle"}
                >
                  {isFavorite ? (
                    <Heart className="h-2.5 w-2.5 sm:h-3 sm:w-3" />
                  ) : (
                    <HeartOff className="h-2.5 w-2.5 sm:h-3 sm:w-3" />
                  )}
                </button>
              </div>
            );
          })
        )}
      </div>
    </div>
  );
}
</file>

<file path="iptv/components/CategoriesSidebar.tsx">
"use client";

import { Tv, ChevronLeft, ChevronRight } from "lucide-react";
import { clsx } from "clsx";
import { CascaderMenu } from "./CascaderMenu";
import type { ChannelCategory } from "@/types/xtream";

interface CategoriesSidebarProps {
  categories: ChannelCategory[];
  selectedCategoryId: string;
  onCategorySelect: (categoryId: string) => void;
  isSidebarOpen: boolean;
  isMenuCollapsed: boolean;
  onToggleMenuCollapsed: () => void;
  totals: { totalStreams: number; totalCategories: number };
}

export const CategoriesSidebar = ({
  categories,
  selectedCategoryId,
  onCategorySelect,
  isSidebarOpen,
  isMenuCollapsed,
  onToggleMenuCollapsed,
  totals,
}: CategoriesSidebarProps) => {
  return (
    <aside
      className={clsx(
        "fixed lg:static inset-y-0 left-0 z-50 bg-slate-900/95 backdrop-blur-md border-r border-white/10 transition-transform duration-300 ease-in-out shadow-2xl shadow-black/40 lg:shadow-none",
        isSidebarOpen ? "translate-x-0" : "-translate-x-full lg:translate-x-0",
        isMenuCollapsed ? "w-12" : "w-[85vw] max-w-sm sm:w-80 lg:w-72"
      )}
    >
      <div className="flex h-full flex-col">
        {/* Collapse Toggle */}
        <div className="flex items-center justify-between p-2 sm:p-3 border-b border-white/10">
          {!isMenuCollapsed && (
            <div className="flex gap-1 text-xs text-slate-300">
              <div className="flex items-center gap-1 rounded-full bg-white/5 px-1.5 sm:px-2 py-0.5 sm:py-1">
                <Tv className="h-2.5 w-2.5 sm:h-3 sm:w-3 text-primary" />
                <span className="font-medium text-white text-xs">
                  {totals.totalStreams}
                </span>
              </div>
              <div className="flex items-center gap-1 rounded-full bg-white/5 px-1.5 sm:px-2 py-0.5 sm:py-1">
                <span className="h-1 w-1 sm:h-1.5 sm:w-1.5 rounded-full bg-emerald-400" />
                <span className="font-medium text-white text-xs">
                  {totals.totalCategories}
                </span>
              </div>
            </div>
          )}
          <button
            onClick={onToggleMenuCollapsed}
            className="rounded-md p-1 sm:p-1.5 text-slate-400 hover:text-white transition-colors"
            title={isMenuCollapsed ? "Men√ºy√º geni≈ület" : "Men√ºy√º daralt"}
          >
            {isMenuCollapsed ? (
              <ChevronRight className="h-3 w-3 sm:h-4 sm:w-4" />
            ) : (
              <ChevronLeft className="h-3 w-3 sm:h-4 sm:w-4" />
            )}
          </button>
        </div>

        {/* Menu Content */}
        {!isMenuCollapsed && (
          <div className="flex-1 min-h-0 p-2 sm:p-3">
            <CascaderMenu
              categories={categories}
              selectedCategoryId={selectedCategoryId}
              onCategorySelect={onCategorySelect}
            />
          </div>
        )}

        {/* Collapsed Menu Icons */}
        {isMenuCollapsed && (
          <div className="flex-1 flex flex-col items-center py-4 space-y-2">
            <div className="rounded-md p-2 bg-white/5 text-slate-400">
              <Tv className="h-4 w-4" />
            </div>
            <div className="rounded-md p-2 bg-white/5 text-slate-400">
              <Tv className="h-4 w-4" />
            </div>
          </div>
        )}
      </div>
    </aside>
  );
};
</file>

<file path="iptv/components/ChannelBrowser.tsx">
"use client";

import { useMemo, useState, useCallback, useEffect } from "react";
import { AlertCircle, RefreshCw, Tv } from "lucide-react";
import { VideoPlayerArea } from "./VideoPlayerArea";
import { CategoriesSidebar } from "./CategoriesSidebar";
import { ChannelListPanel } from "./ChannelListPanel";
import { MobileControls } from "./MobileControls";
import { useAuth } from "@/contexts/AuthContext";
import type { ChannelCategory, ChannelStream } from "@/types/xtream";

const CACHE_KEY = "react-iptv-categories-cache";
const CACHE_DURATION = 5 * 60 * 1000;

interface CacheData {
  categories: ChannelCategory[];
  timestamp: number;
  credentialsHash: string;
}

export function ChannelBrowser() {
  const { credentials } = useAuth();
  const [categories, setCategories] = useState<ChannelCategory[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const orderedCategories = useMemo(
    () =>
      [...categories].sort((a, b) =>
        a.name.localeCompare(b.name, "tr", { sensitivity: "base" })
      ),
    [categories]
  );

  const [selectedCategoryId, setSelectedCategoryId] = useState<string>(
    orderedCategories[0]?.id ?? ""
  );
  const [searchTerm, setSearchTerm] = useState("");
  const [showChannelFavorites, setShowChannelFavorites] = useState(false);
  const [selectedStream, setSelectedStream] = useState<ChannelStream | null>(
    null
  );
  const [isPlayerOpen, setIsPlayerOpen] = useState(false);
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const [isChannelListOpen, setIsChannelListOpen] = useState(false);
  const [isMenuCollapsed, setIsMenuCollapsed] = useState(false);
  const [isChannelPanelCollapsed, setIsChannelPanelCollapsed] = useState(false);

  const credentialsHash = useMemo(() => {
    if (!credentials) return "";
    return btoa(JSON.stringify(credentials)).slice(0, 16);
  }, [credentials]);

  const loadCategories = useCallback(
    async (forceRefresh = false) => {
      if (!credentials) return;

      setIsLoading(true);
      setError(null);

      try {
        if (!forceRefresh) {
          const cached = localStorage.getItem(CACHE_KEY);
          if (cached) {
            const cacheData: CacheData = JSON.parse(cached);
            const isExpired = Date.now() - cacheData.timestamp > CACHE_DURATION;
            const isSameCredentials =
              cacheData.credentialsHash === credentialsHash;

            if (
              !isExpired &&
              isSameCredentials &&
              cacheData.categories.length > 0
            ) {
              setCategories(cacheData.categories);
              if (cacheData.categories.length > 0 && !selectedCategoryId) {
                setSelectedCategoryId(cacheData.categories[0].id);
              }
              setIsLoading(false);
              return;
            }
          }
        }

        const response = await fetch(
          `/api/xtream?credentials=${encodeURIComponent(
            JSON.stringify(credentials)
          )}`
        );

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.message || "API isteƒüi ba≈üarƒ±sƒ±z");
        }

        const data = await response.json();
        const newCategories = data.categories || [];

        const cacheData: CacheData = {
          categories: newCategories,
          timestamp: Date.now(),
          credentialsHash,
        };
        localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
        setCategories(newCategories);

        if (newCategories.length > 0 && !selectedCategoryId) {
          setSelectedCategoryId(newCategories[0].id);
        }
      } catch (err) {
        setError(
          err instanceof Error
            ? err.message
            : "Kategoriler y√ºklenirken hata olu≈ütu"
        );
      } finally {
        setIsLoading(false);
      }
    },
    [credentials, selectedCategoryId, credentialsHash]
  );

  useEffect(() => {
    loadCategories();
  }, [loadCategories]);

  useEffect(() => {
    if (credentials) {
      localStorage.removeItem(CACHE_KEY);
    }
  }, [credentials]);

  const toggleSidebar = useCallback(() => {
    setIsSidebarOpen((prev) => {
      const next = !prev;
      if (next) setIsChannelListOpen(false);
      return next;
    });
  }, []);

  const toggleChannelList = useCallback(() => {
    setIsChannelListOpen((prev) => {
      const next = !prev;
      if (next) setIsSidebarOpen(false);
      return next;
    });
  }, []);

  const selectedCategory = useMemo(() => {
    if (!selectedCategoryId) return orderedCategories[0];
    return (
      orderedCategories.find(
        (category) => category.id === selectedCategoryId
      ) ?? orderedCategories[0]
    );
  }, [orderedCategories, selectedCategoryId]);

  const activeStreamId = selectedStream?.id ?? null;
  const totals = useMemo(
    () => ({
      totalStreams: categories.reduce(
        (acc, category) => acc + category.streams.length,
        0
      ),
      totalCategories: categories.length,
    }),
    [categories]
  );

  const handlePlayStream = useCallback((stream: ChannelStream) => {
    setSelectedStream(stream);
    setIsPlayerOpen(true);
    setIsChannelListOpen(false);
  }, []);

  const handleClosePlayer = useCallback(() => {
    setIsPlayerOpen(false);
    setSelectedStream(null);
  }, []);

  if (isLoading) {
    return (
      <div className="flex h-screen w-screen items-center justify-center bg-slate-950">
        <div className="text-center">
          <div className="w-12 h-12 border-4 border-primary/30 border-t-primary rounded-full animate-spin mx-auto mb-4" />
          <p className="text-slate-400">IPTV verileri y√ºkleniyor...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex h-screen w-screen items-center justify-center bg-slate-950">
        <div className="text-center max-w-md mx-4">
          <div className="rounded-full bg-red-500/20 p-6 mb-6 mx-auto w-fit">
            <AlertCircle className="h-12 w-12 text-red-400" />
          </div>
          <h2 className="text-xl font-semibold text-white mb-4">
            IPTV Verileri Y√ºklenemedi
          </h2>
          <p className="text-slate-300 mb-6 leading-relaxed">{error}</p>
          <button
            onClick={() => loadCategories(true)}
            className="flex items-center gap-2 rounded-xl bg-primary px-6 py-3 text-sm font-medium text-white hover:bg-primary/80 transition-colors mx-auto"
          >
            <RefreshCw className="h-4 w-4" />
            Tekrar Dene
          </button>
        </div>
      </div>
    );
  }

  if (categories.length === 0) {
    return (
      <div className="flex h-screen w-screen items-center justify-center bg-slate-950">
        <div className="text-center max-w-md mx-4">
          <div className="rounded-full bg-slate-500/20 p-6 mb-6 mx-auto w-fit">
            <Tv className="h-12 w-12 text-slate-400" />
          </div>
          <h2 className="text-xl font-semibold text-white mb-4">
            Kategori Bulunamadƒ±
          </h2>
          <p className="text-slate-300 mb-6 leading-relaxed">
            IPTV servisinizde hen√ºz kategori bulunmuyor veya eri≈üim izniniz yok.
          </p>
          <button
            onClick={() => loadCategories(true)}
            className="flex items-center gap-2 rounded-xl bg-primary px-6 py-3 text-sm font-medium text-white hover:bg-primary/80 transition-colors mx-auto"
          >
            <RefreshCw className="h-4 w-4" />
            Yenile
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex h-screen w-screen flex-col bg-slate-950 lg:flex-row">
      <MobileControls
        isSidebarOpen={isSidebarOpen}
        onToggleSidebar={toggleSidebar}
        onToggleChannelList={toggleChannelList}
      />

      {/* Sidebar Overlay (Mobile) */}
      {(isSidebarOpen || isChannelListOpen) && (
        <div
          className="fixed inset-0 z-40 bg-black/50 backdrop-blur-sm lg:hidden"
          onClick={() => {
            setIsSidebarOpen(false);
            setIsChannelListOpen(false);
          }}
        />
      )}

      <CategoriesSidebar
        categories={orderedCategories}
        selectedCategoryId={selectedCategoryId}
        onCategorySelect={(categoryId) => {
          setSelectedCategoryId(categoryId);
          setSearchTerm("");
          setIsSidebarOpen(false);
        }}
        isSidebarOpen={isSidebarOpen}
        isMenuCollapsed={isMenuCollapsed}
        onToggleMenuCollapsed={() => setIsMenuCollapsed(!isMenuCollapsed)}
        totals={totals}
      />

      <ChannelListPanel
        selectedCategory={selectedCategory}
        searchTerm={searchTerm}
        onSearchChange={setSearchTerm}
        showChannelFavorites={showChannelFavorites}
        onToggleChannelFavorites={() =>
          setShowChannelFavorites(!showChannelFavorites)
        }
        isChannelPanelCollapsed={isChannelPanelCollapsed}
        onToggleChannelPanelCollapsed={() =>
          setIsChannelPanelCollapsed(!isChannelPanelCollapsed)
        }
        onPlayStream={handlePlayStream}
        activeStreamId={activeStreamId}
      />

      <VideoPlayerArea
        selectedStream={selectedStream}
        isPlayerOpen={isPlayerOpen}
        onClosePlayer={handleClosePlayer}
      />
    </div>
  );
}
</file>

<file path="iptv/components/ChannelListItem.tsx">
"use client";

import { useCallback, useState } from "react";
import Image from "next/image";
import { clsx } from "clsx";
import { Play, ExternalLink, Heart, HeartOff } from "lucide-react";
import type { ChannelStream } from "@/types/xtream";

interface ChannelListItemProps {
  stream: ChannelStream;
  onPlay: (stream: ChannelStream) => void;
  isFavorite: boolean;
  onToggleFavorite: () => void;
  isActive: boolean;
}

export const ChannelListItem = ({
  stream,
  onPlay,
  isFavorite,
  onToggleFavorite,
  isActive,
}: ChannelListItemProps) => {
  const [imageError, setImageError] = useState(false);
  const handlePlayClick = useCallback(() => onPlay(stream), [onPlay, stream]);

  const handleExternalClick = useCallback(
    (e: React.MouseEvent) => {
      e.stopPropagation();
      window.open(stream.streamUrl, "_blank", "noopener,noreferrer");
    },
    [stream.streamUrl]
  );

  const containerClasses = clsx(
    "group flex items-center gap-2 rounded-md p-2 transition-all hover:border-primary/50 hover:bg-white/10",
    isActive
      ? "border-primary bg-primary/20 shadow-lg shadow-primary/20"
      : "border-white/10 bg-white/5"
  );

  const titleClasses = clsx(
    "truncate text-xs font-semibold transition-colors",
    isActive ? "text-white" : "text-white group-hover:text-primary"
  );

  const subtitleClasses = clsx(
    "text-xs",
    isActive ? "text-white/80" : "text-slate-400"
  );
  const initialClasses = clsx(
    "text-xs font-semibold uppercase",
    isActive ? "text-white/80" : "text-white/60"
  );

  return (
    <div className={containerClasses}>
      {/* Channel Logo */}
      <div className="relative h-8 w-8 shrink-0 overflow-hidden rounded-md bg-gradient-to-tr from-slate-800 to-slate-700">
        {stream.streamIcon && !imageError ? (
          <Image
            src={stream.streamIcon}
            alt={stream.name}
            fill
            sizes="32px"
            className="object-contain object-center p-0.5"
            unoptimized
            onError={() => setImageError(true)}
          />
        ) : (
          <div className="flex h-full w-full items-center justify-center">
            <span className={initialClasses}>{stream.name.charAt(0)}</span>
          </div>
        )}
      </div>

      {/* Channel Info */}
      <div className="flex-1 min-w-0">
        <h3 className={titleClasses}>{stream.name}</h3>
        <p className={subtitleClasses}>
          {stream.streamType === "live" ? "Canlƒ±" : stream.streamType}
        </p>
      </div>

      {/* Action Buttons */}
      <div className="flex items-center gap-1">
        <button
          type="button"
          onClick={(e) => {
            e.stopPropagation();
            onToggleFavorite();
          }}
          className={clsx(
            "group/btn inline-flex items-center gap-1 rounded-md px-1.5 py-1 text-xs font-medium transition",
            isFavorite
              ? "text-red-400 hover:text-red-300"
              : "text-slate-500 hover:text-slate-300"
          )}
          title={isFavorite ? "Favorilerden √ßƒ±kar" : "Favorilere ekle"}
        >
          {isFavorite ? (
            <Heart className="h-3 w-3" />
          ) : (
            <HeartOff className="h-3 w-3" />
          )}
        </button>
        <button
          type="button"
          onClick={handlePlayClick}
          className={clsx(
            "group/btn inline-flex items-center gap-1 rounded-md bg-primary px-2 py-1 text-xs font-medium text-white transition hover:bg-primary/80",
            isActive &&
              "ring-2 ring-primary/60 ring-offset-1 ring-offset-slate-900"
          )}
          title="Kanalƒ± oynat"
        >
          <Play className="h-3 w-3 transition-transform group-hover/btn:scale-110" />
        </button>
        <button
          type="button"
          onClick={handleExternalClick}
          className="group/btn inline-flex items-center gap-1 rounded-md border border-white/20 bg-white/5 px-1.5 py-1 text-xs font-medium text-white transition hover:bg-white/10"
          title="Yeni sekmede a√ß"
        >
          <ExternalLink className="h-3 w-3 transition-transform group-hover/btn:scale-110" />
        </button>
      </div>
    </div>
  );
};
</file>

<file path="iptv/components/ChannelListPanel.tsx">
"use client";

import { useMemo } from "react";
import { Search, Star, StarOff, ChevronLeft, ChevronRight } from "lucide-react";
import { clsx } from "clsx";
import { ChannelListItem } from "./ChannelListItem";
import { useFavorites } from "@/hooks/useFavorites";
import type { ChannelCategory, ChannelStream } from "@/types/xtream";

interface ChannelListPanelProps {
  selectedCategory: ChannelCategory | undefined;
  searchTerm: string;
  onSearchChange: (term: string) => void;
  showChannelFavorites: boolean;
  onToggleChannelFavorites: () => void;
  isChannelPanelCollapsed: boolean;
  onToggleChannelPanelCollapsed: () => void;
  onPlayStream: (stream: ChannelStream) => void;
  activeStreamId: number | null;
}

export const ChannelListPanel = ({
  selectedCategory,
  searchTerm,
  onSearchChange,
  showChannelFavorites,
  onToggleChannelFavorites,
  isChannelPanelCollapsed,
  onToggleChannelPanelCollapsed,
  onPlayStream,
  activeStreamId,
}: ChannelListPanelProps) => {
  const { isChannelFavorite, toggleChannelFavorite, getFavoriteChannels } =
    useFavorites();

  const filteredStreams = useMemo(() => {
    if (!selectedCategory) return [] as ChannelStream[];

    let streams = selectedCategory.streams;
    const term = searchTerm.trim().toLowerCase();

    if (term) {
      streams = streams.filter((stream) =>
        stream.name.toLowerCase().includes(term)
      );
    }

    const trStreams = streams.filter((stream) =>
      stream.name.toLowerCase().startsWith("tr")
    );
    const otherStreams = streams.filter(
      (stream) => !stream.name.toLowerCase().startsWith("tr")
    );

    const favoriteTrStreams = getFavoriteChannels(trStreams);
    const favoriteOtherStreams = getFavoriteChannels(otherStreams);
    const nonFavoriteTrStreams = trStreams.filter(
      (stream) => !favoriteTrStreams.some((fav) => fav.id === stream.id)
    );
    const nonFavoriteOtherStreams = otherStreams.filter(
      (stream) => !favoriteOtherStreams.some((fav) => fav.id === stream.id)
    );

    if (showChannelFavorites) {
      return [...favoriteTrStreams, ...favoriteOtherStreams];
    }

    return [
      ...favoriteTrStreams,
      ...nonFavoriteTrStreams,
      ...favoriteOtherStreams,
      ...nonFavoriteOtherStreams,
    ];
  }, [selectedCategory, searchTerm, showChannelFavorites, getFavoriteChannels]);

  return (
    <aside
      className={clsx(
        "fixed lg:static inset-y-0 right-0 z-50 bg-slate-900/95 backdrop-blur-md border-l border-white/10 transition-transform duration-300 ease-in-out shadow-2xl shadow-black/40 lg:shadow-none",
        isChannelPanelCollapsed
          ? "translate-x-full lg:translate-x-0"
          : "translate-x-0",
        isChannelPanelCollapsed ? "w-12" : "w-[85vw] max-w-sm sm:w-80 lg:w-72"
      )}
    >
      <div className="flex h-full flex-col">
        {/* Channel Panel Header */}
        <div className="flex items-center justify-between p-2 sm:p-3 border-b border-white/10">
          {!isChannelPanelCollapsed && (
            <div className="flex-1">
              <div className="flex items-center justify-between mb-2">
                <h2 className="text-base sm:text-lg font-semibold text-white">
                  {selectedCategory?.name || "Kanallar"}
                </h2>
                <button
                  onClick={onToggleChannelFavorites}
                  className={clsx(
                    "rounded-md p-1 sm:p-1.5 transition-colors",
                    showChannelFavorites
                      ? "bg-yellow-500/20 text-yellow-400"
                      : "bg-white/5 text-slate-400 hover:text-white"
                  )}
                  title={
                    showChannelFavorites
                      ? "T√ºm kanallarƒ± g√∂ster"
                      : "Sadece favorileri g√∂ster"
                  }
                >
                  {showChannelFavorites ? (
                    <Star className="h-3 w-3 sm:h-4 sm:w-4" />
                  ) : (
                    <StarOff className="h-3 w-3 sm:h-4 sm:w-4" />
                  )}
                </button>
              </div>

              {/* Channel Search */}
              <div className="relative">
                <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-3 w-3 text-slate-500" />
                <input
                  value={searchTerm}
                  onChange={(e) => onSearchChange(e.target.value)}
                  placeholder="Kanal ara..."
                  className="w-full rounded-md border border-white/10 bg-slate-950/60 py-1.5 sm:py-2 pl-7 pr-2 text-xs text-white shadow-inner placeholder:text-slate-500 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/30"
                />
              </div>

              <p className="text-xs text-slate-300 mt-1">
                {filteredStreams.length} kanal bulundu
              </p>
            </div>
          )}
          <button
            onClick={onToggleChannelPanelCollapsed}
            className="rounded-md p-1 sm:p-1.5 text-slate-400 hover:text-white transition-colors"
            title={isChannelPanelCollapsed ? "Panel geni≈ület" : "Panel daralt"}
          >
            {isChannelPanelCollapsed ? (
              <ChevronRight className="h-3 w-3 sm:h-4 sm:w-4" />
            ) : (
              <ChevronLeft className="h-3 w-3 sm:h-4 sm:w-4" />
            )}
          </button>
        </div>

        {/* Channel List Content */}
        {!isChannelPanelCollapsed && (
          <div className="flex-1 min-h-0 p-2 sm:p-3">
            <div className="h-full overflow-y-auto space-y-1 pr-2 scrollbar-thin">
              {filteredStreams.length === 0 ? (
                <div className="rounded-lg border border-dashed border-white/10 bg-white/5 p-4 text-center text-slate-400">
                  <p className="text-xs">
                    Se√ßili kategori i√ßin kanal bulunamadƒ±.
                  </p>
                </div>
              ) : (
                filteredStreams.map((stream) => (
                  <ChannelListItem
                    key={stream.id}
                    stream={stream}
                    onPlay={onPlayStream}
                    isFavorite={isChannelFavorite(stream.id)}
                    onToggleFavorite={() => toggleChannelFavorite(stream.id)}
                    isActive={activeStreamId === stream.id}
                  />
                ))
              )}
            </div>
          </div>
        )}

        {/* Collapsed Panel Icons */}
        {isChannelPanelCollapsed && (
          <div className="flex-1 flex flex-col items-center py-4 space-y-2">
            <div className="rounded-md p-2 bg-white/5 text-slate-400">
              <Search className="h-4 w-4" />
            </div>
            <div className="text-xs text-slate-500 text-center">
              {filteredStreams.length}
            </div>
          </div>
        )}
      </div>
    </aside>
  );
};
</file>

<file path="iptv/components/LoginForm.tsx">
"use client";

import { useState, type FormEvent } from "react";
import {
  Eye,
  EyeOff,
  Lock,
  User,
  AlertCircle,
  Server,
  Globe,
  Settings,
} from "lucide-react";
import { useAuth, type IPTVCredentials } from "@/contexts/AuthContext";

export function LoginForm() {
  const [apiBase, setApiBase] = useState("");
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [sessionCookie, setSessionCookie] = useState("");
  const [userAgent, setUserAgent] = useState("");
  const [streamReferer, setStreamReferer] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const { configureIPTV } = useAuth();

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError("");
    setIsLoading(true);

    try {
      if (!apiBase.trim() || !username.trim() || !password.trim()) {
        setError("API Base URL, kullanƒ±cƒ± adƒ± ve ≈üifre gereklidir");
        return;
      }

      try {
        new URL(apiBase);
      } catch {
        setError("Ge√ßerli bir API Base URL giriniz");
        return;
      }

      await new Promise((resolve) => setTimeout(resolve, 300));

      const credentials: IPTVCredentials = {
        apiBase: apiBase.trim(),
        username: username.trim(),
        password: password.trim(),
        sessionCookie: sessionCookie.trim() || undefined,
        userAgent: userAgent.trim() || undefined,
        streamReferer: streamReferer.trim() || undefined,
      };

      configureIPTV(credentials);
    } catch (err) {
      setError("Konfig√ºrasyon kaydedilirken bir hata olu≈ütu");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center p-4">
      <div className="w-full max-w-2xl">
        {/* Logo/Header */}
        <div className="text-center mb-8">
          <div className="inline-flex items-center justify-center w-16 h-16 bg-primary/20 rounded-full mb-4">
            <Settings className="h-8 w-8 text-primary" />
          </div>
          <h1 className="text-2xl font-bold text-white mb-2">
            React IPTV Client
          </h1>
          <p className="text-slate-400">
            IPTV servis bilgilerinizi yapƒ±landƒ±rƒ±n
          </p>
        </div>

        {/* Configuration Form */}
        <div className="bg-slate-800/50 backdrop-blur-md rounded-xl border border-white/10 p-6 shadow-2xl">
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* API Base URL Field */}
            <div>
              <label
                htmlFor="apiBase"
                className="block text-sm font-medium text-slate-300 mb-2"
              >
                API Base URL *
              </label>
              <div className="relative">
                <Server className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-500" />
                <input
                  id="apiBase"
                  type="url"
                  value={apiBase}
                  onChange={(e) => setApiBase(e.target.value)}
                  className="w-full pl-10 pr-4 py-3 bg-slate-900/50 border border-white/10 rounded-lg text-white placeholder-slate-500 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/30 transition-colors"
                  placeholder="http://server.com:8080/player_api.php"
                  required
                  disabled={isLoading}
                />
              </div>
              <p className="text-xs text-slate-500 mt-1">
                Xtream Codes API endpoint URL&apos;i
              </p>
            </div>

            {/* Username Field */}
            <div>
              <label
                htmlFor="username"
                className="block text-sm font-medium text-slate-300 mb-2"
              >
                Kullanƒ±cƒ± Adƒ± *
              </label>
              <div className="relative">
                <User className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-500" />
                <input
                  id="username"
                  type="text"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  className="w-full pl-10 pr-4 py-3 bg-slate-900/50 border border-white/10 rounded-lg text-white placeholder-slate-500 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/30 transition-colors"
                  placeholder="IPTV kullanƒ±cƒ± adƒ±nƒ±z"
                  required
                  disabled={isLoading}
                />
              </div>
            </div>

            {/* Password Field */}
            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-slate-300 mb-2"
              >
                ≈ûifre *
              </label>
              <div className="relative">
                <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-500" />
                <input
                  id="password"
                  type={showPassword ? "text" : "password"}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="w-full pl-10 pr-12 py-3 bg-slate-900/50 border border-white/10 rounded-lg text-white placeholder-slate-500 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/30 transition-colors"
                  placeholder="IPTV ≈üifreniz"
                  required
                  disabled={isLoading}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute right-3 top-1/2 transform -translate-y-1/2 text-slate-500 hover:text-slate-300 transition-colors"
                  disabled={isLoading}
                >
                  {showPassword ? (
                    <EyeOff className="h-4 w-4" />
                  ) : (
                    <Eye className="h-4 w-4" />
                  )}
                </button>
              </div>
            </div>

            {/* Session Cookie Field */}
            <div>
              <label
                htmlFor="sessionCookie"
                className="block text-sm font-medium text-slate-300 mb-2"
              >
                Session Cookie (Opsiyonel)
              </label>
              <div className="relative">
                <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-500" />
                <input
                  id="sessionCookie"
                  type="text"
                  value={sessionCookie}
                  onChange={(e) => setSessionCookie(e.target.value)}
                  className="w-full pl-10 pr-4 py-3 bg-slate-900/50 border border-white/10 rounded-lg text-white placeholder-slate-500 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/30 transition-colors"
                  placeholder="capp_name_session=..."
                  disabled={isLoading}
                />
              </div>
              <p className="text-xs text-slate-500 mt-1">
                Eri≈üim kƒ±sƒ±tlamasƒ± varsa tarayƒ±cƒ±dan alƒ±nan session cookie
              </p>
            </div>

            {/* User Agent Field */}
            <div>
              <label
                htmlFor="userAgent"
                className="block text-sm font-medium text-slate-300 mb-2"
              >
                User Agent (Opsiyonel)
              </label>
              <div className="relative">
                <Globe className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-500" />
                <input
                  id="userAgent"
                  type="text"
                  value={userAgent}
                  onChange={(e) => setUserAgent(e.target.value)}
                  className="w-full pl-10 pr-4 py-3 bg-slate-900/50 border border-white/10 rounded-lg text-white placeholder-slate-500 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/30 transition-colors"
                  placeholder="Mozilla/5.0 (Windows NT 10.0; Win64; x64)..."
                  disabled={isLoading}
                />
              </div>
              <p className="text-xs text-slate-500 mt-1">
                √ñzel User-Agent string (bo≈ü bƒ±rakƒ±lƒ±rsa varsayƒ±lan kullanƒ±lƒ±r)
              </p>
            </div>

            {/* Stream Referer Field */}
            <div>
              <label
                htmlFor="streamReferer"
                className="block text-sm font-medium text-slate-300 mb-2"
              >
                Stream Referer (Opsiyonel)
              </label>
              <div className="relative">
                <Globe className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-500" />
                <input
                  id="streamReferer"
                  type="url"
                  value={streamReferer}
                  onChange={(e) => setStreamReferer(e.target.value)}
                  className="w-full pl-10 pr-4 py-3 bg-slate-900/50 border border-white/10 rounded-lg text-white placeholder-slate-500 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/30 transition-colors"
                  placeholder="http://server.com/"
                  disabled={isLoading}
                />
              </div>
              <p className="text-xs text-slate-500 mt-1">
                Stream istekleri i√ßin referer URL&apos;i
              </p>
            </div>

            {/* Error Message */}
            {error && (
              <div className="flex items-center gap-2 p-3 bg-red-500/10 border border-red-500/20 rounded-lg text-red-400 text-sm">
                <AlertCircle className="h-4 w-4 flex-shrink-0" />
                <span>{error}</span>
              </div>
            )}

            {/* Submit Button */}
            <button
              type="submit"
              disabled={isLoading || !apiBase || !username || !password}
              className="w-full py-3 bg-primary hover:bg-primary/80 disabled:bg-slate-600 disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors flex items-center justify-center gap-2"
            >
              {isLoading ? (
                <>
                  <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                  Yapƒ±landƒ±rƒ±lƒ±yor...
                </>
              ) : (
                "IPTV'yi Yapƒ±landƒ±r"
              )}
            </button>
          </form>

          {/* Footer */}
          <div className="mt-6 text-center">
            <p className="text-xs text-slate-500">
              Bilgileriniz g√ºvenli bir ≈üekilde tarayƒ±cƒ±nƒ±zda saklanƒ±r
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="iptv/components/MobileControls.tsx">
"use client";

import { Menu, X, Tv } from "lucide-react";

interface MobileControlsProps {
  isSidebarOpen: boolean;
  onToggleSidebar: () => void;
  onToggleChannelList: () => void;
}

export const MobileControls = ({
  isSidebarOpen,
  onToggleSidebar,
  onToggleChannelList,
}: MobileControlsProps) => {
  return (
    <div className="fixed top-4 left-4 z-50 lg:hidden flex gap-2">
      <button
        onClick={onToggleSidebar}
        className="rounded-lg bg-black/60 p-2.5 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
      >
        {isSidebarOpen ? (
          <X className="h-5 w-5" />
        ) : (
          <Menu className="h-5 w-5" />
        )}
      </button>

      <button
        onClick={onToggleChannelList}
        className="rounded-lg bg-black/60 p-2.5 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
        title="Kanal listesini a√ß/kapat"
      >
        <Tv className="h-5 w-5" />
      </button>
    </div>
  );
};
</file>

<file path="iptv/components/PWAProvider.tsx">
"use client";

import { useEffect } from "react";

export function PWAProvider() {
  useEffect(() => {
    if (typeof window === "undefined" || !("serviceWorker" in navigator))
      return;

    const registerSW = async () => {
      try {
        const registration = await navigator.serviceWorker.register("/sw.js", {
          scope: "/",
        });

        console.log("Service Worker registered successfully:", registration);

        registration.addEventListener("updatefound", () => {
          const newWorker = registration.installing;
          if (newWorker) {
            newWorker.addEventListener("statechange", () => {
              if (
                newWorker.state === "installed" &&
                navigator.serviceWorker.controller
              ) {
                console.log("New service worker version available");
              }
            });
          }
        });

        navigator.serviceWorker.addEventListener("message", (event) => {
          console.log("Message from service worker:", event.data);
        });
      } catch (error) {
        console.error("Service Worker registration failed:", error);
      }
    };

    registerSW();

    let deferredPrompt: any = null;

    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault();
      deferredPrompt = e;
      console.log("PWA install prompt available");
    };

    const handleAppInstalled = () => {
      console.log("PWA was installed");
      deferredPrompt = null;
    };

    window.addEventListener("beforeinstallprompt", handleBeforeInstallPrompt);
    window.addEventListener("appinstalled", handleAppInstalled);

    return () => {
      window.removeEventListener(
        "beforeinstallprompt",
        handleBeforeInstallPrompt
      );
      window.removeEventListener("appinstalled", handleAppInstalled);
    };
  }, []);

  return null;
}

export const installPWA = async () => {
  if (typeof window === "undefined" || !("serviceWorker" in navigator)) return;

  try {
    const registration = await navigator.serviceWorker.getRegistration();
    if (registration?.waiting) {
      registration.waiting.postMessage({ type: "SKIP_WAITING" });
      window.location.reload();
    }
  } catch (error) {
    console.error("Failed to update PWA:", error);
  }
};

export const getPWAStatus = () => {
  if (typeof window === "undefined") return null;

  return {
    isInstalled:
      window.matchMedia("(display-mode: standalone)").matches ||
      (window.navigator as any).standalone === true,
    isOnline: navigator.onLine,
    hasServiceWorker: "serviceWorker" in navigator,
    isSecure:
      location.protocol === "https:" || location.hostname === "localhost",
  };
};
</file>

<file path="iptv/components/VideoPlayer.tsx">
"use client";

/* eslint-disable react/forbid-dom-props, react/no-unknown-property */
import { useState, useRef, useEffect, useCallback } from "react";
import { createPortal } from "react-dom";
import {
  X,
  Volume2,
  VolumeX,
  Maximize,
  Minimize,
  Play,
  Pause,
  RotateCcw,
} from "lucide-react";
import { clsx } from "clsx";

interface VideoPlayerProps {
  streamUrl: string;
  channelName: string;
  isOpen: boolean;
  onClose: () => void;
  isEmbedded?: boolean;
}

export function VideoPlayer({
  streamUrl,
  channelName,
  isOpen,
  onClose,
  isEmbedded = false,
}: VideoPlayerProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [volume, setVolume] = useState(0.8);
  const [isMuted, setIsMuted] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);
  const [showControls, setShowControls] = useState(true);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);

  const videoRef = useRef<HTMLVideoElement>(null);
  const playerContainerRef = useRef<HTMLDivElement>(null);
  const hlsRef = useRef<any>(null);
  const controlsTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const loadStream = useCallback(async () => {
    setIsLoading(true);
    setHasError(false);
    setIsPlaying(false);

    try {
      // Stream URL'ini direkt kullan (artƒ±k proxy yok)
      const normalizedStreamUrl = streamUrl;

      // Stream URL'inden origin'i al (header'lar i√ßin)
      let streamOrigin = "";
      try {
        const streamUrlObj = new URL(streamUrl);
        streamOrigin = streamUrlObj.origin;
      } catch {
        // URL parse edilemezse, varsayƒ±lan deƒüer kullan
        streamOrigin = "http://tgrpro25.xyz:8080";
      }

      const Hls = (await import("hls.js")).default;
      const video = videoRef.current;
      if (!video) return;

      try {
        video.pause();
        video.currentTime = 0;
      } catch {}

      if (Hls.isSupported()) {
        if (hlsRef.current) hlsRef.current.destroy();

        const hls = new Hls({
          enableWorker: true,
          lowLatencyMode: true,
          backBufferLength: 90,
          maxBufferLength: 30,
          maxMaxBufferLength: 60,
          liveSyncDurationCount: 3,
          liveMaxLatencyDurationCount: 5,
          debug: process.env.NODE_ENV === "development",
          // Upstream server'a gerekli header'larƒ± ekle
          xhrSetup: (xhr, url) => {
            // Proxy URL'lerini tespit et ve direkt URL'e √ßevir
            if (url && url.includes("/api/proxy/stream")) {
              try {
                const urlObj = new URL(url);
                const originalUrl = urlObj.searchParams.get("url");
                if (originalUrl) {
                  const decodedUrl = decodeURIComponent(originalUrl);
                  // XHR'in a√ßƒ±lacaƒüƒ± URL'i deƒüi≈ütir
                  Object.defineProperty(xhr, "open", {
                    value: function (
                      method: string,
                      url: string | URL,
                      async: boolean = true,
                      username?: string | null,
                      password?: string | null
                    ) {
                      return XMLHttpRequest.prototype.open.call(
                        this,
                        method,
                        decodedUrl,
                        async,
                        username,
                        password
                      );
                    },
                    writable: false,
                  });
                }
              } catch (e) {
                console.error("[HLS] Failed to extract direct URL:", e);
              }
            }

            // Upstream server'a gerekli header'larƒ± ekle
            xhr.setRequestHeader(
              "User-Agent",
              "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36 Edg/140.0.0.0"
            );
            xhr.setRequestHeader("Accept", "*/*");
            xhr.setRequestHeader("Accept-Language", "tr,en-US;q=0.9,en;q=0.8");
            xhr.setRequestHeader("Referer", `${streamOrigin}/`);
            xhr.setRequestHeader("Origin", streamOrigin);
          },
        });

        hlsRef.current = hls;

        hls.on(Hls.Events.MANIFEST_PARSED, async () => {
          setIsLoading(false);
          setHasError(false);
          try {
            if (videoRef.current && !videoRef.current.paused)
              await videoRef.current.play();
          } catch {}
        });

        hls.on(Hls.Events.ERROR, (event: any, data: any) => {
          if (data.fatal) {
            setIsLoading(false);
            setHasError(true);
            setIsPlaying(false);
            if (videoRef.current) {
              videoRef.current.pause();
              videoRef.current.currentTime = 0;
            }
            if (hlsRef.current) {
              hlsRef.current.destroy();
              hlsRef.current = null;
            }
          }
        });

        hls.attachMedia(video);
        hls.loadSource(normalizedStreamUrl);
      } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
        video.src = normalizedStreamUrl;
        setIsLoading(false);
        try {
          await video.play();
        } catch {}
      } else {
        throw new Error("HLS desteklenmiyor");
      }
    } catch (error) {
      setIsLoading(false);
      setHasError(true);
      setIsPlaying(false);
      if (videoRef.current) {
        videoRef.current.pause();
        videoRef.current.currentTime = 0;
      }
      if (hlsRef.current) {
        hlsRef.current.destroy();
        hlsRef.current = null;
      }
    }
  }, [streamUrl]);

  const resetControlsTimeout = useCallback(() => {
    if (controlsTimeoutRef.current) clearTimeout(controlsTimeoutRef.current);

    setShowControls(true);
    controlsTimeoutRef.current = setTimeout(() => {
      if (isPlaying) {
        setShowControls(false);
      }
    }, 3000);
  }, [isPlaying]);

  const handleMouseMove = useCallback(() => {
    resetControlsTimeout();
  }, [resetControlsTimeout]);

  const handlePlayPause = useCallback(async () => {
    const video = videoRef.current;
    if (!video) return;

    try {
      if (video.paused) {
        if (isLoading || hasError) return;
        await video.play();
      } else {
        video.pause();
      }
    } catch {}

    resetControlsTimeout();
  }, [hasError, isLoading, resetControlsTimeout]);

  const handleVolumeChange = useCallback(
    (newVolume: number) => {
      const video = videoRef.current;
      if (!video) return;

      setVolume(newVolume);
      video.volume = newVolume;
      setIsMuted(newVolume === 0);
      resetControlsTimeout();
    },
    [resetControlsTimeout]
  );

  const handleMuteToggle = useCallback(() => {
    const video = videoRef.current;
    if (!video) return;

    if (isMuted) {
      video.volume = 0.8;
      setVolume(0.8);
      setIsMuted(false);
    } else {
      video.volume = 0;
      setIsMuted(true);
    }
    resetControlsTimeout();
  }, [isMuted, resetControlsTimeout]);

  const handleFullscreen = useCallback(() => {
    const container = playerContainerRef.current;
    if (!container) return;

    const fullscreenElement =
      document.fullscreenElement ||
      (document as any).webkitFullscreenElement ||
      (document as any).msFullscreenElement;

    if (!fullscreenElement) {
      const requestFullscreen =
        container.requestFullscreen ||
        (container as any).webkitRequestFullscreen ||
        (container as any).msRequestFullscreen;

      if (requestFullscreen) {
        requestFullscreen.call(container);
      }
    } else {
      const exitFullscreen =
        document.exitFullscreen ||
        (document as any).webkitExitFullscreen ||
        (document as any).msExitFullscreen;

      if (exitFullscreen) {
        exitFullscreen.call(document);
      }
    }

    resetControlsTimeout();
  }, [resetControlsTimeout]);

  useEffect(() => {
    const handleFullscreenChange = () => {
      const fullscreenElement =
        document.fullscreenElement ||
        (document as any).webkitFullscreenElement ||
        (document as any).msFullscreenElement;

      setIsFullscreen(Boolean(fullscreenElement));

      if (!fullscreenElement) {
        setShowControls(true);
      }
    };

    document.addEventListener("fullscreenchange", handleFullscreenChange);
    document.addEventListener("webkitfullscreenchange", handleFullscreenChange);
    document.addEventListener("MSFullscreenChange", handleFullscreenChange);

    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
      document.removeEventListener(
        "webkitfullscreenchange",
        handleFullscreenChange
      );
      document.removeEventListener(
        "MSFullscreenChange",
        handleFullscreenChange
      );
    };
  }, []);
  const handleRestart = async () => {
    const video = videoRef.current;
    if (!video) return;

    if (hasError) {
      setHasError(false);
      setIsLoading(true);
      setIsPlaying(false);

      if (hlsRef.current) {
        hlsRef.current.destroy();
        hlsRef.current = null;
      }

      try {
        video.pause();
        video.currentTime = 0;
        video.src = "";
      } catch {}

      setTimeout(() => loadStream(), 100);
    } else {
      try {
        video.currentTime = 0;
        if (!video.paused) await video.play();
      } catch {}
    }
    resetControlsTimeout();
  };

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === "Escape" && isOpen && !isEmbedded) {
        onClose();
      } else if (event.key === " " && isOpen) {
        event.preventDefault();
        handlePlayPause();
      } else if (event.key === "f" && isOpen) {
        event.preventDefault();
        handleFullscreen();
      }
    };

    if (isOpen) {
      document.addEventListener("keydown", handleKeyDown);
      if (!isEmbedded) {
        document.body.style.overflow = "hidden";
      }
    }

    return () => {
      document.removeEventListener("keydown", handleKeyDown);
      if (!isEmbedded) {
        document.body.style.overflow = "unset";
      }
    };
  }, [handleFullscreen, handlePlayPause, isEmbedded, isOpen, onClose]);

  useEffect(() => {
    if (!isOpen || !videoRef.current) return;

    loadStream();

    return () => {
      if (hlsRef.current) {
        hlsRef.current.destroy();
        hlsRef.current = null;
      }
    };
  }, [isOpen, loadStream]);

  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleLoadedMetadata = () => {
      setDuration(video.duration);
    };

    const handleTimeUpdate = () => {
      setCurrentTime(video.currentTime);
    };

    const handlePlay = () => {
      setIsPlaying(true);
    };

    const handlePause = () => {
      setIsPlaying(false);
    };

    const handleError = () => {
      setIsLoading(false);
      setHasError(true);
      setIsPlaying(false);
      if (videoRef.current) {
        videoRef.current.pause();
        videoRef.current.currentTime = 0;
      }
      if (hlsRef.current) {
        hlsRef.current.destroy();
        hlsRef.current = null;
      }
    };

    video.addEventListener("loadedmetadata", handleLoadedMetadata);
    video.addEventListener("timeupdate", handleTimeUpdate);
    video.addEventListener("play", handlePlay);
    video.addEventListener("pause", handlePause);
    video.addEventListener("error", handleError);

    return () => {
      video.removeEventListener("loadedmetadata", handleLoadedMetadata);
      video.removeEventListener("timeupdate", handleTimeUpdate);
      video.removeEventListener("play", handlePlay);
      video.removeEventListener("pause", handlePause);
      video.removeEventListener("error", handleError);
    };
  }, [isOpen]);

  const handleSeek = (e: React.MouseEvent<HTMLDivElement>) => {
    const video = videoRef.current;
    if (!video || duration === 0) return;

    const rect = e.currentTarget.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const newTime = (clickX / rect.width) * duration;
    video.currentTime = newTime;
  };

  if (!isOpen) return null;

  const videoContent = isEmbedded ? (
    <div
      ref={playerContainerRef}
      className={clsx(
        "flex h-full w-full items-center justify-center overflow-hidden bg-black",
        isFullscreen ? "" : "rounded-lg"
      )}
    >
      {/* Video Container */}
      <div
        className={clsx(
          "relative flex w-full items-center justify-center bg-black",
          !isFullscreen && "aspect-video"
        )}
        onMouseMove={handleMouseMove}
        onMouseLeave={() => {
          if (isPlaying) {
            setShowControls(false);
          }
        }}
      >
        <video
          ref={videoRef}
          className="h-full w-full object-contain bg-black"
          autoPlay
          muted={isMuted}
          playsInline
          crossOrigin="anonymous"
        />

        {/* Loading Overlay */}
        {isLoading && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/80 backdrop-blur-sm">
            <div className="flex flex-col items-center gap-6">
              <div className="relative">
                <div className="h-16 w-16 animate-spin rounded-full border-4 border-primary/30 border-t-primary" />
                <div className="absolute inset-0 h-16 w-16 animate-ping rounded-full border-4 border-primary/20" />
              </div>
              <div className="text-center">
                <p className="text-lg font-semibold text-white">
                  Yayƒ±n Y√ºkleniyor
                </p>
                <p className="text-sm text-slate-300 mt-1">
                  L√ºtfen bekleyin...
                </p>
              </div>
            </div>
          </div>
        )}

        {/* Error Overlay */}
        {hasError && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/90 backdrop-blur-sm">
            <div className="flex flex-col items-center gap-6 text-center max-w-md mx-4">
              <div className="relative">
                <div className="rounded-full bg-red-500/20 p-6">
                  <X className="h-12 w-12 text-red-400" />
                </div>
                <div className="absolute -top-2 -right-2 h-6 w-6 rounded-full bg-red-500 animate-pulse" />
              </div>
              <div>
                <h3 className="text-xl font-semibold text-white mb-2">
                  Yayƒ±n Y√ºklenemedi
                </h3>
                <p className="text-sm text-slate-300 leading-relaxed">
                  Bu kanal ≈üu anda eri≈üilebilir deƒüil veya ge√ßici bir sorun var.
                  L√ºtfen daha sonra tekrar deneyin.
                </p>
              </div>
              <button
                onClick={handleRestart}
                className="flex items-center gap-2 rounded-xl bg-primary px-6 py-3 text-sm font-medium text-white hover:bg-primary/80 transition-colors"
              >
                <RotateCcw className="h-4 w-4" />
                Tekrar Dene
              </button>
            </div>
          </div>
        )}

        {/* Controls Overlay */}
        <div
          className={clsx(
            "absolute inset-0 flex flex-col justify-between bg-gradient-to-t from-black/80 via-transparent to-black/40 transition-opacity duration-300",
            showControls ? "opacity-100" : "opacity-0"
          )}
        >
          {/* Top Controls */}
          <div className="flex items-center justify-between p-4">
            <div className="flex items-center gap-3">
              <div className="flex items-center gap-2">
                <div className="h-2 w-2 rounded-full bg-red-500 animate-pulse" />
                <span className="text-xs font-medium text-white bg-red-500/20 px-2 py-1 rounded-full border border-red-500/30">
                  CANLI
                </span>
              </div>
              <h2 className="text-sm font-semibold text-white truncate max-w-xs">
                {channelName}
              </h2>
            </div>

            {/* Audio Control */}
            <button
              onClick={handleMuteToggle}
              className="rounded-lg bg-black/60 p-2 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
              title={isMuted ? "Sesi a√ß" : "Sesi kapat"}
            >
              {isMuted ? (
                <VolumeX className="h-4 w-4" />
              ) : (
                <Volume2 className="h-4 w-4" />
              )}
            </button>
          </div>

          {/* Bottom Controls */}
          <div className="p-4">
            {/* Control Buttons */}
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <button
                  onClick={handlePlayPause}
                  className="rounded-lg bg-black/60 p-2 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                >
                  {isPlaying ? (
                    <Pause className="h-4 w-4" />
                  ) : (
                    <Play className="h-4 w-4" />
                  )}
                </button>

                <button
                  onClick={handleRestart}
                  className="rounded-lg bg-black/60 p-2 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                  title="Yeniden ba≈ülat"
                >
                  <RotateCcw className="h-4 w-4" />
                </button>
              </div>

              <div className="flex items-center gap-2">
                <button
                  onClick={handleFullscreen}
                  className="rounded-lg bg-black/60 p-2 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                  title="Tam ekran (F)"
                >
                  {isFullscreen ? (
                    <Minimize className="h-4 w-4" />
                  ) : (
                    <Maximize className="h-4 w-4" />
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  ) : (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/95 backdrop-blur-md">
      <div className="w-full px-4">
        <div
          ref={playerContainerRef}
          className={clsx(
            "relative mx-auto w-full",
            isFullscreen ? "h-full" : "max-w-5xl aspect-video"
          )}
        >
          {/* Video Container */}
          <div
            className={clsx(
              "absolute inset-0 flex items-center justify-center overflow-hidden bg-black",
              isFullscreen ? "" : "rounded-2xl"
            )}
            onMouseMove={handleMouseMove}
            onMouseLeave={() => {
              if (isPlaying) {
                setShowControls(false);
              }
            }}
          >
            <video
              ref={videoRef}
              className="h-full w-full object-contain bg-black"
              autoPlay
              muted={isMuted}
              playsInline
              crossOrigin="anonymous"
            />

            {/* Loading Overlay */}
            {isLoading && (
              <div className="absolute inset-0 flex items-center justify-center bg-black/80 backdrop-blur-sm">
                <div className="flex flex-col items-center gap-6">
                  <div className="relative">
                    <div className="h-16 w-16 animate-spin rounded-full border-4 border-primary/30 border-t-primary" />
                    <div className="absolute inset-0 h-16 w-16 animate-ping rounded-full border-4 border-primary/20" />
                  </div>
                  <div className="text-center">
                    <p className="text-lg font-semibold text-white">
                      Yayƒ±n Y√ºkleniyor
                    </p>
                    <p className="text-sm text-slate-300 mt-1">
                      L√ºtfen bekleyin...
                    </p>
                  </div>
                </div>
              </div>
            )}

            {/* Error Overlay */}
            {hasError && (
              <div className="absolute inset-0 flex items-center justify-center bg-black/90 backdrop-blur-sm">
                <div className="flex flex-col items-center gap-6 text-center max-w-md mx-4">
                  <div className="relative">
                    <div className="rounded-full bg-red-500/20 p-6">
                      <X className="h-12 w-12 text-red-400" />
                    </div>
                    <div className="absolute -top-2 -right-2 h-6 w-6 rounded-full bg-red-500 animate-pulse" />
                  </div>
                  <div>
                    <h3 className="text-xl font-semibold text-white mb-2">
                      Yayƒ±n Y√ºklenemedi
                    </h3>
                    <p className="text-sm text-slate-300 leading-relaxed">
                      Bu kanal ≈üu anda eri≈üilebilir deƒüil veya ge√ßici bir sorun
                      var. L√ºtfen daha sonra tekrar deneyin.
                    </p>
                  </div>
                  <button
                    onClick={handleRestart}
                    className="flex items-center gap-2 rounded-xl bg-primary px-6 py-3 text-sm font-medium text-white hover:bg-primary/80 transition-colors"
                  >
                    <RotateCcw className="h-4 w-4" />
                    Tekrar Dene
                  </button>
                </div>
              </div>
            )}

            {/* Controls Overlay */}
            <div
              className={clsx(
                "absolute inset-0 flex flex-col justify-between bg-gradient-to-t from-black/80 via-transparent to-black/40 transition-opacity duration-300",
                showControls ? "opacity-100" : "opacity-0"
              )}
            >
              {/* Top Controls */}
              <div className="flex items-center justify-between p-6">
                <div className="flex items-center gap-4">
                  <div className="flex items-center gap-3">
                    <div className="h-3 w-3 rounded-full bg-red-500 animate-pulse shadow-lg shadow-red-500/50" />
                    <span className="text-sm font-medium text-white bg-red-500/20 px-3 py-1 rounded-full border border-red-500/30">
                      CANLI
                    </span>
                  </div>
                  <h2 className="text-xl font-semibold text-white truncate max-w-md">
                    {channelName}
                  </h2>
                </div>
                <button
                  onClick={onClose}
                  className="rounded-xl bg-black/60 p-3 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                  title="Kapat (ESC)"
                >
                  <X className="h-6 w-6" />
                </button>
              </div>

              {/* Bottom Controls */}
              <div className="p-6">
                {/* Progress Bar */}
                <div
                  className="mb-6 h-2 w-full cursor-pointer rounded-full bg-white/20 hover:bg-white/30 transition-colors"
                  onClick={handleSeek}
                >
                  <div
                    className="h-full rounded-full bg-primary transition-all shadow-lg shadow-primary/50"
                    style={{
                      width: `${
                        duration > 0 ? (currentTime / duration) * 100 : 0
                      }%`,
                    }}
                  />
                </div>

                {/* Control Buttons */}
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-4">
                    <button
                      onClick={handlePlayPause}
                      className="rounded-xl bg-black/60 p-4 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                    >
                      {isPlaying ? (
                        <Pause className="h-7 w-7" />
                      ) : (
                        <Play className="h-7 w-7" />
                      )}
                    </button>

                    <button
                      onClick={handleRestart}
                      className="rounded-xl bg-black/60 p-3 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                      title="Yeniden ba≈ülat"
                    >
                      <RotateCcw className="h-5 w-5" />
                    </button>

                    <div className="flex items-center gap-3">
                      <button
                        onClick={handleMuteToggle}
                        className="rounded-xl bg-black/60 p-3 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                      >
                        {isMuted ? (
                          <VolumeX className="h-5 w-5" />
                        ) : (
                          <Volume2 className="h-5 w-5" />
                        )}
                      </button>
                      <input
                        type="range"
                        min="0"
                        max="1"
                        step="0.1"
                        value={isMuted ? 0 : volume}
                        onChange={(e) =>
                          handleVolumeChange(parseFloat(e.target.value))
                        }
                        className="w-24 h-2 bg-white/20 rounded-lg appearance-none cursor-pointer accent-primary"
                        title={`Ses seviyesi: ${Math.round(
                          (isMuted ? 0 : volume) * 100
                        )}%`}
                        aria-label="Ses seviyesi ayarƒ±"
                      />
                    </div>
                  </div>

                  <div className="flex items-center gap-2">
                    <button
                      onClick={handleFullscreen}
                      className="rounded-xl bg-black/60 p-3 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                      title="Tam ekran (F)"
                    >
                      {isFullscreen ? (
                        <Minimize className="h-5 w-5" />
                      ) : (
                        <Maximize className="h-5 w-5" />
                      )}
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );

  if (isEmbedded) {
    return videoContent;
  }

  if (typeof window === "undefined") return null;
  return createPortal(videoContent, document.body);
}
</file>

<file path="iptv/components/VideoPlayerArea.tsx">
"use client";

import { Tv } from "lucide-react";
import { VideoPlayer } from "./VideoPlayer";
import type { ChannelStream } from "@/types/xtream";

interface VideoPlayerAreaProps {
  selectedStream: ChannelStream | null;
  isPlayerOpen: boolean;
  onClosePlayer: () => void;
}

export const VideoPlayerArea = ({
  selectedStream,
  isPlayerOpen,
  onClosePlayer,
}: VideoPlayerAreaProps) => {
  return (
    <div className="flex-1 flex flex-col min-w-0">
      {selectedStream && isPlayerOpen ? (
        <div className="h-full w-full bg-black">
          <VideoPlayer
            streamUrl={selectedStream.streamUrl}
            channelName={selectedStream.name}
            isOpen={true}
            onClose={onClosePlayer}
            isEmbedded={true}
          />
        </div>
      ) : (
        <div className="flex-1 flex items-center justify-center bg-slate-900/50">
          <div className="text-center text-slate-400">
            <Tv className="h-16 w-16 mx-auto mb-4 text-slate-500" />
            <h3 className="text-lg font-semibold mb-2">Video Oynatƒ±cƒ±</h3>
            <p className="text-sm">Bir kanal se√ßin ve oynatƒ±n</p>
          </div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="iptv/contexts/AuthContext.tsx">
"use client";

import { createContext, useContext, useState, useEffect } from "react";
import type { ReactNode } from "react";

interface IPTVCredentials {
  apiBase: string;
  username: string;
  password: string;
  sessionCookie?: string;
  userAgent?: string;
  streamReferer?: string;
}

interface AuthContextType {
  isConfigured: boolean;
  credentials: IPTVCredentials | null;
  configureIPTV: (credentials: IPTVCredentials) => void;
  clearConfiguration: () => void;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);
const IPTV_STORAGE_KEY = "react-iptv-credentials";

export function AuthProvider({ children }: { children: ReactNode }) {
  const [isConfigured, setIsConfigured] = useState(false);
  const [credentials, setCredentials] = useState<IPTVCredentials | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (typeof window === "undefined") {
      setIsLoading(false);
      return;
    }

    try {
      const storedCredentials = localStorage.getItem(IPTV_STORAGE_KEY);
      if (storedCredentials) {
        const parsedCredentials = JSON.parse(storedCredentials);
        setCredentials(parsedCredentials);
        setIsConfigured(true);
      }
    } catch {
    } finally {
      setIsLoading(false);
    }
  }, []);

  const configureIPTV = (newCredentials: IPTVCredentials) => {
    setCredentials(newCredentials);
    setIsConfigured(true);
    if (typeof window !== "undefined") {
      try {
        localStorage.setItem(IPTV_STORAGE_KEY, JSON.stringify(newCredentials));
      } catch {}
    }
  };

  const clearConfiguration = () => {
    setCredentials(null);
    setIsConfigured(false);
    if (typeof window !== "undefined") {
      try {
        localStorage.removeItem(IPTV_STORAGE_KEY);
        localStorage.removeItem("react-iptv-categories-cache");
      } catch {}
    }
  };

  return (
    <AuthContext.Provider
      value={{
        isConfigured,
        credentials,
        configureIPTV,
        clearConfiguration,
        isLoading,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}

export type { IPTVCredentials };
</file>

<file path="iptv/hooks/useFavorites.ts">
"use client";

import { useState, useEffect } from "react";
import type { ChannelCategory, ChannelStream } from "@/types/xtream";

interface FavoritesData {
  categories: string[];
  channels: number[];
}

const FAVORITES_KEY = "react-iptv-favorites";

export function useFavorites() {
  const [favorites, setFavorites] = useState<FavoritesData>({
    categories: [],
    channels: [],
  });
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    if (typeof window === "undefined") {
      setIsLoaded(true);
      return;
    }

    try {
      const stored = localStorage.getItem(FAVORITES_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        setFavorites(parsed);
      }
    } catch (error) {
      console.error("Error loading favorites:", error);
    } finally {
      setIsLoaded(true);
    }
  }, []);

  useEffect(() => {
    if (!isLoaded || typeof window === "undefined") return;

    try {
      localStorage.setItem(FAVORITES_KEY, JSON.stringify(favorites));
    } catch (error) {
      console.error("Error saving favorites:", error);
    }
  }, [favorites, isLoaded]);

  const toggleCategoryFavorite = (categoryId: string) => {
    setFavorites((prev) => ({
      ...prev,
      categories: prev.categories.includes(categoryId)
        ? prev.categories.filter((id) => id !== categoryId)
        : [...prev.categories, categoryId],
    }));
  };

  const toggleChannelFavorite = (channelId: number) => {
    setFavorites((prev) => ({
      ...prev,
      channels: prev.channels.includes(channelId)
        ? prev.channels.filter((id) => id !== channelId)
        : [...prev.channels, channelId],
    }));
  };

  const isCategoryFavorite = (categoryId: string) => {
    return favorites.categories.includes(categoryId);
  };

  const isChannelFavorite = (channelId: number) => {
    return favorites.channels.includes(channelId);
  };

  const getFavoriteCategories = (categories: ChannelCategory[]) => {
    return categories.filter((cat) => favorites.categories.includes(cat.id));
  };

  const getFavoriteChannels = (channels: ChannelStream[]) => {
    return channels.filter((channel) =>
      favorites.channels.includes(channel.id)
    );
  };

  const clearFavorites = () => {
    setFavorites({ categories: [], channels: [] });
  };

  return {
    favorites,
    toggleCategoryFavorite,
    toggleChannelFavorite,
    isCategoryFavorite,
    isChannelFavorite,
    getFavoriteCategories,
    getFavoriteChannels,
    clearFavorites,
  };
}
</file>

<file path="iptv/lib/xtream.ts">
import "server-only";
import type {
  ChannelCategory,
  ChannelStream,
  XtreamCategory,
  XtreamStream,
} from "@/types/xtream";

export class XtreamApiError extends Error {
  status: number;
  body?: string;

  constructor(message: string, status: number, body?: string) {
    super(message);
    this.name = "XtreamApiError";
    this.status = status;
    this.body = body;
    Object.setPrototypeOf(this, XtreamApiError.prototype);
  }
}

const DEFAULT_API_BASE = "http://tgrpro25.xyz:8080/player_api.php";
const DEFAULT_USER_AGENT =
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36 Edg/140.0.0.0";
const API_BASE = process.env.XTREAM_API_BASE ?? DEFAULT_API_BASE;
const USERNAME = process.env.XTREAM_USERNAME;
const PASSWORD = process.env.XTREAM_PASSWORD;
const SESSION_COOKIE = process.env.XTREAM_SESSION_COOKIE;

const XTREAM_HEADERS = {
  Accept:
    "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
  "Accept-Language": "tr,en-US;q=0.9,en;q=0.8",
  "Cache-Control": "max-age=0",
  Connection: "keep-alive",
  DNT: "1",
  "Upgrade-Insecure-Requests": "1",
  "User-Agent": DEFAULT_USER_AGENT,
} as const;

interface IPTVCredentials {
  apiBase: string;
  username: string;
  password: string;
  sessionCookie?: string;
  userAgent?: string;
  streamReferer?: string;
}

const ensureCredentials = (credentials?: IPTVCredentials) => {
  if (credentials) {
    if (
      !credentials.username ||
      !credentials.password ||
      !credentials.apiBase
    ) {
      throw new Error(
        "IPTV servis bilgileri eksik. API Base URL, kullanƒ±cƒ± adƒ± ve ≈üifre gereklidir."
      );
    }
    return credentials;
  }

  if (!USERNAME || !PASSWORD) {
    throw new Error(
      "Xtream servis bilgileri eksik. Lutfen IPTV yapƒ±landƒ±rmasƒ±nƒ± tamamlayƒ±n veya XTREAM_USERNAME ve XTREAM_PASSWORD environment degiskenlerini tanimlayin."
    );
  }

  return {
    apiBase: API_BASE,
    username: USERNAME,
    password: PASSWORD,
    sessionCookie: SESSION_COOKIE,
  };
};

const buildXtreamUrl = (
  searchParams: Record<string, string | number>,
  credentials?: IPTVCredentials
) => {
  const creds = ensureCredentials(credentials);
  const url = new URL(creds.apiBase);
  const params = new URLSearchParams({
    username: creds.username,
    password: creds.password,
    ...Object.fromEntries(
      Object.entries(searchParams).map(([key, value]) => [key, String(value)])
    ),
  });
  url.search = params.toString();
  return url;
};

const xtreamRequest = async <T>(
  params: Record<string, string | number>,
  credentials?: IPTVCredentials
): Promise<T> => {
  const url = buildXtreamUrl(params, credentials);
  const creds = ensureCredentials(credentials);

  try {
    const headers = {
      ...XTREAM_HEADERS,
      ...(creds.userAgent ? { "User-Agent": creds.userAgent } : {}),
      ...(creds.sessionCookie ? { Cookie: creds.sessionCookie } : {}),
    };

    const response = await fetch(url, {
      method: "GET",
      cache: "no-store",
      headers,
    });
    const rawBody = await response.text();

    if (!response.ok) {
      throw new XtreamApiError(
        `Xtream API istegi basarisiz oldu (${response.status})`,
        response.status,
        rawBody.slice(0, 500)
      );
    }

    try {
      return JSON.parse(rawBody) as T;
    } catch {
      throw new XtreamApiError(
        "Xtream API beklenmedik bir yanit dondurdu.",
        502,
        rawBody.slice(0, 500)
      );
    }
  } catch (error) {
    if (error instanceof XtreamApiError) throw error;
    const message =
      error instanceof Error
        ? `Xtream API cagrisinda baglanti kurulamadi: ${error.message}`
        : "Xtream API cagrisinda baglanti kurulamadi.";
    throw new XtreamApiError(message, 503);
  }
};

const normaliseStreams = (
  streams: XtreamStream[],
  credentials?: IPTVCredentials
): ChannelStream[] => {
  const creds = ensureCredentials(credentials);
  const baseUrl = new URL(creds.apiBase);
  const origin = `${baseUrl.protocol}//${baseUrl.host}`;

  return streams
    .map((stream) => {
      const streamType = stream.stream_type?.toLowerCase() ?? "live";
      const extension = streamType === "live" ? "m3u8" : "mp4";
      const folder = streamType === "live" ? "live" : "movie";
      const streamUrl = `${origin}/${folder}/${creds.username}/${creds.password}/${stream.stream_id}.${extension}`;

      return {
        id: stream.stream_id,
        name: stream.name,
        streamType,
        streamIcon: stream.stream_icon ?? null,
        added: stream.added,
        streamUrl,
      };
    })
    .sort((a, b) =>
      a.name.localeCompare(b.name, "tr", { sensitivity: "base" })
    );
};

const getLiveCategories = (
  credentials?: IPTVCredentials
): Promise<XtreamCategory[]> =>
  xtreamRequest<XtreamCategory[]>(
    { action: "get_live_categories" },
    credentials
  );

const getLiveStreamsByCategory = (
  categoryId: string,
  credentials?: IPTVCredentials
): Promise<XtreamStream[]> =>
  xtreamRequest<XtreamStream[]>(
    { action: "get_live_streams", category_id: categoryId },
    credentials
  );

export async function getCategoriesWithStreams(
  credentials?: IPTVCredentials
): Promise<ChannelCategory[]> {
  ensureCredentials(credentials);
  const categories = await getLiveCategories(credentials);
  const categoriesWithStreams: ChannelCategory[] = [];

  for (let index = 0; index < categories.length; index += 1) {
    const category = categories[index];
    try {
      const streams = await getLiveStreamsByCategory(
        category.category_id,
        credentials
      );
      const normalisedCategory: ChannelCategory = {
        id: category.category_id,
        name: category.category_name,
        parentId: category.parent_id,
        order: Number.parseInt(category.category_id, 10) || index,
        streams: normaliseStreams(streams, credentials),
      };

      if (normalisedCategory.streams.length > 0) {
        categoriesWithStreams.push(normalisedCategory);
      }
    } catch {}
  }

  return categoriesWithStreams.sort((a, b) =>
    a.name.localeCompare(b.name, "tr", { sensitivity: "base" })
  );
}

export type { ChannelCategory, ChannelStream };
</file>

<file path="iptv/types/xtream.ts">
export interface XtreamCategory {
  category_id: string;
  category_name: string;
  parent_id: string;
  direct_source?: string;
}

export interface XtreamStream {
  num: number;
  name: string;
  stream_type: string;
  stream_id: number;
  stream_icon?: string;
  epg_channel_id?: string;
  category_id: string;
  custom_sid?: string;
  tv_archive_duration?: number;
  added?: string;
}

export interface ChannelStream {
  id: number;
  name: string;
  streamType: string;
  streamIcon: string | null;
  streamUrl: string;
  added?: string;
}

export interface ChannelCategory {
  id: string;
  name: string;
  order: number;
  parentId: string;
  streams: ChannelStream[];
}
</file>

<file path="package.json">
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:full": "tsc -b && vite build",
    "start": "node server.js",
    "lint": "eslint .",
    "preview": "vite preview",
    "server": "node server.js",
    "forward": "node scripts/forward.js",
    "tunnel": "lt --port 8080",
    "zip": "tar -a -c -f \"E:\\Nouveau nom (E).zip\" src config scripts dist package.json tsconfig.json"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@radix-ui/react-accordion": "^1.2.11",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-aspect-ratio": "^1.1.7",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.2",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-context-menu": "^2.2.15",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-hover-card": "^1.1.14",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-menubar": "^1.1.15",
    "@radix-ui/react-navigation-menu": "^1.2.13",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.3.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slider": "^1.3.5",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-toast": "^1.2.14",
    "@radix-ui/react-toggle": "^1.1.9",
    "@radix-ui/react-toggle-group": "^1.1.10",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@react-three/drei": "^9.88.17",
    "@react-three/fiber": "^8.15.19",
    "@react-three/postprocessing": "^2.16.2",
    "@tanstack/react-query": "^5.83.0",
    "@types/bcryptjs": "^2.4.6",
    "@types/d3": "^7.4.3",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^22.16.5",
    "@types/react": "^18.3.23",
    "@types/react-dom": "^18.3.7",
    "@types/three": "^0.181.0",
    "@vitejs/plugin-react-swc": "^3.11.0",
    "autoprefixer": "^10.4.21",
    "bcryptjs": "^3.0.3",
    "body-parser": "^2.2.0",
    "chart.js": "^4.5.1",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "cors": "^2.8.5",
    "d3": "^7.9.0",
    "date-fns": "^3.6.0",
    "dotenv": "^17.2.3",
    "embla-carousel-react": "^8.6.0",
    "express": "^5.1.0",
    "form-data": "^4.0.5",
    "hls.js": "^1.6.15",
    "i18next": "^25.7.1",
    "i18next-browser-languagedetector": "^8.2.0",
    "i18next-http-backend": "^3.0.2",
    "input-otp": "^1.4.2",
    "jsonwebtoken": "^9.0.3",
    "lovable-tagger": "^1.1.11",
    "lucide-react": "^0.462.0",
    "multer": "^2.0.2",
    "next-themes": "^0.3.0",
    "ngrok": "^5.0.0-beta.2",
    "node-fetch": "^3.3.2",
    "obs-websocket-js": "^5.0.7",
    "postcss": "^8.5.6",
    "puppeteer": "^24.32.0",
    "react": "^18.3.1",
    "react-chartjs-2": "^5.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.61.1",
    "react-i18next": "^16.3.5",
    "react-joyride": "^2.9.3",
    "react-resizable-panels": "^2.1.9",
    "react-router-dom": "^6.30.1",
    "recharts": "^2.15.4",
    "replicate": "^1.4.0",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "sonner": "^1.7.4",
    "tailwind-merge": "^2.6.0",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "three": "^0.154.0",
    "typescript": "^5.8.3",
    "vaul": "^0.9.9",
    "vite": "^5.4.19",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/js": "^9.32.0",
    "@tailwindcss/typography": "^0.5.16",
    "eslint": "^9.32.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^15.15.0",
    "localtunnel": "^2.0.2",
    "tsx": "^4.21.0",
    "typescript-eslint": "^8.38.0"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="predict.py">
import os
import json
import tempfile
from pathlib import Path
from cog import BasePredictor, Input, Path as CogPath

# Import your analysis modules
import sys
sys.path.insert(0, './python')

from soccer_analysis_processor import SoccerMatchAnalyzer, AnalysisConfig
from soccer_analysis_core import logger
import numpy as np


class NumpyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.integer):
            return int(obj)
        if isinstance(obj, np.floating):
            return float(obj)
        if isinstance(obj, np.ndarray):
            return obj.tolist()
        return super(NumpyEncoder, self).default(obj)


class Predictor(BasePredictor):
    def setup(self):
        """Load the model into memory to make running multiple predictions efficient"""
        # Model will be loaded on first prediction
        pass

    def predict(
        self,
        video: CogPath = Input(description="Input video file"),
        confidence_threshold: float = Input(
            description="Detection confidence threshold", 
            default=0.3, 
            ge=0.1, 
            le=0.9
        ),
        generate_video: bool = Input(
            description="Generate annotated output video", 
            default=False
        ),
    ) -> dict:
        """Run soccer match analysis"""
        
        # Create config
        config = AnalysisConfig(confidence_threshold=confidence_threshold)
        
        # Create analyzer
        analyzer = SoccerMatchAnalyzer(config)
        
        # Run analysis
        results = analyzer.analyze(
            video_path=str(video),
            clips=None,
            homography_matrix=None,
            generate_annotated_video=generate_video
        )
        
        # Convert numpy types for JSON serialization
        results_json = json.loads(json.dumps(results, cls=NumpyEncoder))
        
        return results_json
</file>

<file path="prepare_colab_package.py">
import zipfile
import os
from pathlib import Path

def create_colab_package():
    output_filename = "colab_package.zip"
    source_dir = Path("python")
    
    with zipfile.ZipFile(output_filename, "w", zipfile.ZIP_DEFLATED) as zipf:
        # Add python directory
        for root, dirs, files in os.walk(source_dir):
            for file in files:
                if file == "__pycache__" or file.endswith(".pyc"):
                    continue
                file_path = os.path.join(root, file)
                zipf.write(file_path, file_path)
        
        # Add requirements.txt if it exists outside
        if os.path.exists("requirements.txt"):
             zipf.write("requirements.txt", "requirements.txt")
             
        # Add models if they exist (optional, usually downloaded)
        # But here we assume models are downloaded by the script or in the repo
        # If 'models' dir exists, add it
        if os.path.exists("models"):
             for root, dirs, files in os.walk("models"):
                for file in files:
                    file_path = os.path.join(root, file)
                    zipf.write(file_path, file_path)

    print(f"Created {output_filename}. Upload this file to Google Colab.")

if __name__ == "__main__":
    create_colab_package()
</file>

<file path="public/heatmaps/positions_test.json">
{
  "video_info": {
    "total_frames": 96611,
    "fps": 30.0,
    "width": 1920,
    "height": 1080,
    "duration": 3220.366666666667,
    "analysis_start": 0.0,
    "analysis_end": 10.0
  },
  "positions": [
    {
      "frame": 0,
      "timestamp": 0.0,
      "x": 63.2,
      "y": 54.04,
      "team": "B",
      "confidence": 0.96
    },
    {
      "frame": 0,
      "timestamp": 0.0,
      "x": 36.19,
      "y": 49.3,
      "team": "A",
      "confidence": 0.93
    },
    {
      "frame": 5,
      "timestamp": 0.17,
      "x": 62.09,
      "y": 54.55,
      "team": "B",
      "confidence": 0.95
    },
    {
      "frame": 5,
      "timestamp": 0.17,
      "x": 35.64,
      "y": 49.52,
      "team": "A",
      "confidence": 0.94
    },
    {
      "frame": 10,
      "timestamp": 0.33,
      "x": 42.78,
      "y": 53.87,
      "team": "A",
      "confidence": 0.95
    },
    {
      "frame": 10,
      "timestamp": 0.33,
      "x": 65.58,
      "y": 64.79,
      "team": "B",
      "confidence": 0.75
    },
    {
      "frame": 15,
      "timestamp": 0.5,
      "x": 39.63,
      "y": 52.69,
      "team": "A",
      "confidence": 0.94
    },
    {
      "frame": 15,
      "timestamp": 0.5,
      "x": 65.15,
      "y": 65.07,
      "team": "B",
      "confidence": 0.86
    },
    {
      "frame": 20,
      "timestamp": 0.67,
      "x": 39.71,
      "y": 53.06,
      "team": "A",
      "confidence": 0.91
    },
    {
      "frame": 20,
      "timestamp": 0.67,
      "x": 61.47,
      "y": 64.99,
      "team": "B",
      "confidence": 0.74
    },
    {
      "frame": 25,
      "timestamp": 0.83,
      "x": 43.16,
      "y": 54.86,
      "team": "A",
      "confidence": 0.95
    },
    {
      "frame": 30,
      "timestamp": 1.0,
      "x": 48.22,
      "y": 54.83,
      "team": "A",
      "confidence": 0.93
    },
    {
      "frame": 35,
      "timestamp": 1.17,
      "x": 51.69,
      "y": 53.73,
      "team": "B",
      "confidence": 0.96
    },
    {
      "frame": 35,
      "timestamp": 1.17,
      "x": 20.52,
      "y": 64.68,
      "team": "A",
      "confidence": 0.87
    },
    {
      "frame": 40,
      "timestamp": 1.33,
      "x": 49.52,
      "y": 53.46,
      "team": "A",
      "confidence": 0.96
    },
    {
      "frame": 40,
      "timestamp": 1.33,
      "x": 14.8,
      "y": 64.8,
      "team": "A",
      "confidence": 0.91
    },
    {
      "frame": 45,
      "timestamp": 1.5,
      "x": 47.05,
      "y": 53.36,
      "team": "A",
      "confidence": 0.96
    },
    {
      "frame": 45,
      "timestamp": 1.5,
      "x": 13.64,
      "y": 65.2,
      "team": "A",
      "confidence": 0.9
    },
    {
      "frame": 50,
      "timestamp": 1.67,
      "x": 45.91,
      "y": 53.81,
      "team": "A",
      "confidence": 0.94
    },
    {
      "frame": 50,
      "timestamp": 1.67,
      "x": 11.43,
      "y": 64.49,
      "team": "A",
      "confidence": 0.89
    },
    {
      "frame": 55,
      "timestamp": 1.83,
      "x": 44.53,
      "y": 53.32,
      "team": "A",
      "confidence": 0.94
    },
    {
      "frame": 60,
      "timestamp": 2.0,
      "x": 42.6,
      "y": 52.9,
      "team": "A",
      "confidence": 0.95
    },
    {
      "frame": 65,
      "timestamp": 2.17,
      "x": 39.87,
      "y": 51.71,
      "team": "A",
      "confidence": 0.94
    },
    {
      "frame": 70,
      "timestamp": 2.33,
      "x": 37.89,
      "y": 51.02,
      "team": "A",
      "confidence": 0.95
    },
    {
      "frame": 75,
      "timestamp": 2.5,
      "x": 37.3,
      "y": 51.68,
      "team": "A",
      "confidence": 0.94
    },
    {
      "frame": 80,
      "timestamp": 2.67,
      "x": 36.09,
      "y": 49.93,
      "team": "A",
      "confidence": 0.94
    },
    {
      "frame": 85,
      "timestamp": 2.83,
      "x": 35.54,
      "y": 49.8,
      "team": "A",
      "confidence": 0.93
    },
    {
      "frame": 90,
      "timestamp": 3.0,
      "x": 35.59,
      "y": 49.78,
      "team": "A",
      "confidence": 0.92
    },
    {
      "frame": 95,
      "timestamp": 3.17,
      "x": 35.49,
      "y": 49.75,
      "team": "A",
      "confidence": 0.92
    },
    {
      "frame": 100,
      "timestamp": 3.33,
      "x": 35.55,
      "y": 49.76,
      "team": "A",
      "confidence": 0.93
    },
    {
      "frame": 105,
      "timestamp": 3.5,
      "x": 36.13,
      "y": 49.98,
      "team": "A",
      "confidence": 0.92
    },
    {
      "frame": 110,
      "timestamp": 3.67,
      "x": 37.19,
      "y": 50.07,
      "team": "A",
      "confidence": 0.91
    },
    {
      "frame": 115,
      "timestamp": 3.83,
      "x": 37.52,
      "y": 50.0,
      "team": "A",
      "confidence": 0.9
    },
    {
      "frame": 120,
      "timestamp": 4.0,
      "x": 37.27,
      "y": 50.02,
      "team": "A",
      "confidence": 0.92
    },
    {
      "frame": 125,
      "timestamp": 4.17,
      "x": 36.84,
      "y": 49.94,
      "team": "A",
      "confidence": 0.93
    },
    {
      "frame": 130,
      "timestamp": 4.33,
      "x": 36.62,
      "y": 49.65,
      "team": "A",
      "confidence": 0.9
    },
    {
      "frame": 135,
      "timestamp": 4.5,
      "x": 36.44,
      "y": 49.72,
      "team": "A",
      "confidence": 0.9
    },
    {
      "frame": 140,
      "timestamp": 4.67,
      "x": 36.2,
      "y": 49.72,
      "team": "A",
      "confidence": 0.91
    },
    {
      "frame": 145,
      "timestamp": 4.83,
      "x": 35.94,
      "y": 49.82,
      "team": "A",
      "confidence": 0.91
    },
    {
      "frame": 150,
      "timestamp": 5.0,
      "x": 35.66,
      "y": 49.66,
      "team": "A",
      "confidence": 0.9
    },
    {
      "frame": 155,
      "timestamp": 5.17,
      "x": 35.75,
      "y": 49.72,
      "team": "A",
      "confidence": 0.91
    },
    {
      "frame": 160,
      "timestamp": 5.33,
      "x": 58.56,
      "y": 49.66,
      "team": "B",
      "confidence": 0.84
    },
    {
      "frame": 165,
      "timestamp": 5.5,
      "x": 57.28,
      "y": 49.61,
      "team": "B",
      "confidence": 0.79
    },
    {
      "frame": 170,
      "timestamp": 5.67,
      "x": 56.39,
      "y": 49.34,
      "team": "B",
      "confidence": 0.8
    },
    {
      "frame": 175,
      "timestamp": 5.83,
      "x": 58.69,
      "y": 49.99,
      "team": "B",
      "confidence": 0.82
    },
    {
      "frame": 180,
      "timestamp": 6.0,
      "x": 47.93,
      "y": 49.69,
      "team": "A",
      "confidence": 0.89
    },
    {
      "frame": 185,
      "timestamp": 6.17,
      "x": 53.74,
      "y": 50.37,
      "team": "B",
      "confidence": 0.89
    },
    {
      "frame": 190,
      "timestamp": 6.33,
      "x": 55.97,
      "y": 50.15,
      "team": "B",
      "confidence": 0.86
    },
    {
      "frame": 195,
      "timestamp": 6.5,
      "x": 53.92,
      "y": 49.63,
      "team": "B",
      "confidence": 0.81
    },
    {
      "frame": 200,
      "timestamp": 6.67,
      "x": 45.51,
      "y": 49.49,
      "team": "A",
      "confidence": 0.79
    },
    {
      "frame": 205,
      "timestamp": 6.83,
      "x": 42.93,
      "y": 50.13,
      "team": "A",
      "confidence": 0.78
    },
    {
      "frame": 210,
      "timestamp": 7.0,
      "x": 54.48,
      "y": 49.46,
      "team": "B",
      "confidence": 0.75
    },
    {
      "frame": 215,
      "timestamp": 7.17,
      "x": 54.34,
      "y": 50.07,
      "team": "B",
      "confidence": 0.85
    },
    {
      "frame": 220,
      "timestamp": 7.33,
      "x": 59.08,
      "y": 50.05,
      "team": "B",
      "confidence": 0.87
    },
    {
      "frame": 225,
      "timestamp": 7.5,
      "x": 62.16,
      "y": 49.57,
      "team": "B",
      "confidence": 0.87
    },
    {
      "frame": 230,
      "timestamp": 7.67,
      "x": 60.3,
      "y": 49.67,
      "team": "B",
      "confidence": 0.72
    },
    {
      "frame": 235,
      "timestamp": 7.83,
      "x": 52.95,
      "y": 56.61,
      "team": "B",
      "confidence": 0.94
    },
    {
      "frame": 235,
      "timestamp": 7.83,
      "x": 89.5,
      "y": 49.77,
      "team": "B",
      "confidence": 0.86
    },
    {
      "frame": 240,
      "timestamp": 8.0,
      "x": 53.11,
      "y": 56.62,
      "team": "B",
      "confidence": 0.94
    },
    {
      "frame": 245,
      "timestamp": 8.17,
      "x": 53.65,
      "y": 56.8,
      "team": "B",
      "confidence": 0.95
    },
    {
      "frame": 250,
      "timestamp": 8.33,
      "x": 53.12,
      "y": 55.51,
      "team": "B",
      "confidence": 0.95
    },
    {
      "frame": 255,
      "timestamp": 8.5,
      "x": 56.54,
      "y": 53.69,
      "team": "B",
      "confidence": 0.94
    },
    {
      "frame": 260,
      "timestamp": 8.67,
      "x": 65.34,
      "y": 53.53,
      "team": "B",
      "confidence": 0.93
    },
    {
      "frame": 265,
      "timestamp": 8.83,
      "x": 67.11,
      "y": 54.32,
      "team": "B",
      "confidence": 0.95
    },
    {
      "frame": 270,
      "timestamp": 9.0,
      "x": 74.34,
      "y": 54.93,
      "team": "B",
      "confidence": 0.95
    },
    {
      "frame": 275,
      "timestamp": 9.17,
      "x": 73.76,
      "y": 54.03,
      "team": "B",
      "confidence": 0.95
    },
    {
      "frame": 280,
      "timestamp": 9.33,
      "x": 65.18,
      "y": 53.7,
      "team": "B",
      "confidence": 0.94
    },
    {
      "frame": 285,
      "timestamp": 9.5,
      "x": 55.13,
      "y": 54.31,
      "team": "B",
      "confidence": 0.93
    },
    {
      "frame": 290,
      "timestamp": 9.67,
      "x": 48.45,
      "y": 55.15,
      "team": "A",
      "confidence": 0.94
    },
    {
      "frame": 295,
      "timestamp": 9.83,
      "x": 47.68,
      "y": 54.77,
      "team": "A",
      "confidence": 0.95
    }
  ]
}
</file>

<file path="public/heatmaps/positions.json">
{
  "video_info": {
    "total_frames": 69602,
    "fps": 30.0,
    "width": 1920,
    "height": 1080,
    "duration": 2320.0666666666666,
    "analysis_start": 50.0,
    "analysis_end": 52.0
  },
  "positions": [
    {
      "frame": 1500,
      "timestamp": 50.0,
      "x": 51.93,
      "y": 56.75,
      "team": "B",
      "confidence": 0.82
    },
    {
      "frame": 1500,
      "timestamp": 50.0,
      "x": 54.75,
      "y": 34.6,
      "team": "B",
      "confidence": 0.78
    },
    {
      "frame": 1500,
      "timestamp": 50.0,
      "x": 10.67,
      "y": 35.87,
      "team": "A",
      "confidence": 0.75
    },
    {
      "frame": 1500,
      "timestamp": 50.0,
      "x": 42.41,
      "y": 32.87,
      "team": "A",
      "confidence": 0.71
    },
    {
      "frame": 1500,
      "timestamp": 50.0,
      "x": 46.53,
      "y": 48.9,
      "team": "A",
      "confidence": 0.65
    },
    {
      "frame": 1500,
      "timestamp": 50.0,
      "x": 46.85,
      "y": 25.46,
      "team": "A",
      "confidence": 0.62
    },
    {
      "frame": 1500,
      "timestamp": 50.0,
      "x": 37.86,
      "y": 12.08,
      "team": "A",
      "confidence": 0.57
    },
    {
      "frame": 1505,
      "timestamp": 50.17,
      "x": 13.25,
      "y": 35.62,
      "team": "A",
      "confidence": 0.79
    },
    {
      "frame": 1505,
      "timestamp": 50.17,
      "x": 2.06,
      "y": 34.23,
      "team": "A",
      "confidence": 0.78
    },
    {
      "frame": 1505,
      "timestamp": 50.17,
      "x": 55.45,
      "y": 56.04,
      "team": "B",
      "confidence": 0.73
    },
    {
      "frame": 1505,
      "timestamp": 50.17,
      "x": 49.15,
      "y": 48.21,
      "team": "A",
      "confidence": 0.71
    },
    {
      "frame": 1505,
      "timestamp": 50.17,
      "x": 56.81,
      "y": 34.84,
      "team": "B",
      "confidence": 0.7
    },
    {
      "frame": 1505,
      "timestamp": 50.17,
      "x": 47.69,
      "y": 25.04,
      "team": "A",
      "confidence": 0.62
    },
    {
      "frame": 1505,
      "timestamp": 50.17,
      "x": 44.73,
      "y": 32.88,
      "team": "A",
      "confidence": 0.6
    },
    {
      "frame": 1505,
      "timestamp": 50.17,
      "x": 20.81,
      "y": 13.66,
      "team": "A",
      "confidence": 0.58
    },
    {
      "frame": 1505,
      "timestamp": 50.17,
      "x": 38.62,
      "y": 12.13,
      "team": "A",
      "confidence": 0.5
    },
    {
      "frame": 1510,
      "timestamp": 50.33,
      "x": 58.73,
      "y": 55.51,
      "team": "B",
      "confidence": 0.82
    },
    {
      "frame": 1510,
      "timestamp": 50.33,
      "x": 59.21,
      "y": 34.14,
      "team": "B",
      "confidence": 0.8
    },
    {
      "frame": 1510,
      "timestamp": 50.33,
      "x": 52.35,
      "y": 48.28,
      "team": "B",
      "confidence": 0.74
    },
    {
      "frame": 1510,
      "timestamp": 50.33,
      "x": 47.5,
      "y": 32.67,
      "team": "A",
      "confidence": 0.64
    },
    {
      "frame": 1510,
      "timestamp": 50.33,
      "x": 16.06,
      "y": 35.34,
      "team": "A",
      "confidence": 0.64
    },
    {
      "frame": 1510,
      "timestamp": 50.33,
      "x": 22.06,
      "y": 13.69,
      "team": "A",
      "confidence": 0.6
    },
    {
      "frame": 1510,
      "timestamp": 50.33,
      "x": 5.51,
      "y": 34.33,
      "team": "A",
      "confidence": 0.6
    },
    {
      "frame": 1510,
      "timestamp": 50.33,
      "x": 6.1,
      "y": 34.3,
      "team": "A",
      "confidence": 0.59
    },
    {
      "frame": 1510,
      "timestamp": 50.33,
      "x": 49.14,
      "y": 25.17,
      "team": "A",
      "confidence": 0.55
    },
    {
      "frame": 1510,
      "timestamp": 50.33,
      "x": 39.86,
      "y": 12.12,
      "team": "A",
      "confidence": 0.52
    },
    {
      "frame": 1515,
      "timestamp": 50.5,
      "x": 62.89,
      "y": 54.84,
      "team": "B",
      "confidence": 0.85
    },
    {
      "frame": 1515,
      "timestamp": 50.5,
      "x": 19.95,
      "y": 35.11,
      "team": "A",
      "confidence": 0.83
    },
    {
      "frame": 1515,
      "timestamp": 50.5,
      "x": 62.17,
      "y": 34.32,
      "team": "B",
      "confidence": 0.8
    },
    {
      "frame": 1515,
      "timestamp": 50.5,
      "x": 9.87,
      "y": 33.93,
      "team": "A",
      "confidence": 0.78
    },
    {
      "frame": 1515,
      "timestamp": 50.5,
      "x": 56.14,
      "y": 47.71,
      "team": "B",
      "confidence": 0.74
    },
    {
      "frame": 1515,
      "timestamp": 50.5,
      "x": 49.76,
      "y": 32.87,
      "team": "A",
      "confidence": 0.62
    },
    {
      "frame": 1515,
      "timestamp": 50.5,
      "x": 51.63,
      "y": 32.62,
      "team": "B",
      "confidence": 0.58
    },
    {
      "frame": 1515,
      "timestamp": 50.5,
      "x": 41.47,
      "y": 12.14,
      "team": "A",
      "confidence": 0.57
    },
    {
      "frame": 1520,
      "timestamp": 50.67,
      "x": 66.74,
      "y": 54.27,
      "team": "B",
      "confidence": 0.83
    },
    {
      "frame": 1520,
      "timestamp": 50.67,
      "x": 64.62,
      "y": 34.51,
      "team": "B",
      "confidence": 0.79
    },
    {
      "frame": 1520,
      "timestamp": 50.67,
      "x": 23.86,
      "y": 34.7,
      "team": "A",
      "confidence": 0.78
    },
    {
      "frame": 1520,
      "timestamp": 50.67,
      "x": 59.43,
      "y": 47.36,
      "team": "B",
      "confidence": 0.78
    },
    {
      "frame": 1520,
      "timestamp": 50.67,
      "x": 2.65,
      "y": 38.54,
      "team": "A",
      "confidence": 0.73
    },
    {
      "frame": 1520,
      "timestamp": 50.67,
      "x": 14.11,
      "y": 33.9,
      "team": "A",
      "confidence": 0.7
    },
    {
      "frame": 1520,
      "timestamp": 50.67,
      "x": 55.07,
      "y": 32.08,
      "team": "B",
      "confidence": 0.7
    },
    {
      "frame": 1520,
      "timestamp": 50.67,
      "x": 43.2,
      "y": 12.32,
      "team": "A",
      "confidence": 0.59
    },
    {
      "frame": 1520,
      "timestamp": 50.67,
      "x": 45.23,
      "y": 25.45,
      "team": "A",
      "confidence": 0.51
    },
    {
      "frame": 1525,
      "timestamp": 50.83,
      "x": 70.64,
      "y": 53.65,
      "team": "B",
      "confidence": 0.84
    },
    {
      "frame": 1525,
      "timestamp": 50.83,
      "x": 6.24,
      "y": 38.24,
      "team": "A",
      "confidence": 0.78
    },
    {
      "frame": 1525,
      "timestamp": 50.83,
      "x": 27.68,
      "y": 34.82,
      "team": "A",
      "confidence": 0.75
    },
    {
      "frame": 1525,
      "timestamp": 50.83,
      "x": 66.7,
      "y": 33.9,
      "team": "B",
      "confidence": 0.7
    },
    {
      "frame": 1525,
      "timestamp": 50.83,
      "x": 18.5,
      "y": 33.72,
      "team": "A",
      "confidence": 0.67
    },
    {
      "frame": 1525,
      "timestamp": 50.83,
      "x": 58.95,
      "y": 32.1,
      "team": "B",
      "confidence": 0.63
    },
    {
      "frame": 1525,
      "timestamp": 50.83,
      "x": 63.22,
      "y": 47.07,
      "team": "B",
      "confidence": 0.55
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 76.38,
      "y": 53.32,
      "team": "B",
      "confidence": 0.78
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 63.57,
      "y": 32.34,
      "team": "B",
      "confidence": 0.74
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 32.38,
      "y": 34.71,
      "team": "A",
      "confidence": 0.73
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 69.57,
      "y": 34.31,
      "team": "B",
      "confidence": 0.73
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 23.97,
      "y": 33.48,
      "team": "A",
      "confidence": 0.72
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 11.08,
      "y": 37.68,
      "team": "A",
      "confidence": 0.71
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 11.14,
      "y": 35.24,
      "team": "A",
      "confidence": 0.7
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 46.84,
      "y": 25.53,
      "team": "A",
      "confidence": 0.61
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 48.11,
      "y": 12.33,
      "team": "A",
      "confidence": 0.61
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 56.84,
      "y": 31.72,
      "team": "B",
      "confidence": 0.55
    },
    {
      "frame": 1530,
      "timestamp": 51.0,
      "x": 67.92,
      "y": 46.83,
      "team": "B",
      "confidence": 0.53
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 66.3,
      "y": 32.49,
      "team": "B",
      "confidence": 0.75
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 13.89,
      "y": 37.24,
      "team": "A",
      "confidence": 0.73
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 79.59,
      "y": 52.49,
      "team": "B",
      "confidence": 0.71
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 71.68,
      "y": 46.57,
      "team": "B",
      "confidence": 0.71
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 27.67,
      "y": 33.46,
      "team": "A",
      "confidence": 0.7
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 71.49,
      "y": 34.74,
      "team": "B",
      "confidence": 0.68
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 36.25,
      "y": 34.96,
      "team": "A",
      "confidence": 0.67
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 47.39,
      "y": 25.05,
      "team": "A",
      "confidence": 0.66
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 58.43,
      "y": 29.56,
      "team": "B",
      "confidence": 0.62
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 49.94,
      "y": 12.09,
      "team": "A",
      "confidence": 0.62
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 14.09,
      "y": 34.56,
      "team": "A",
      "confidence": 0.55
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 3.58,
      "y": 26.02,
      "team": "A",
      "confidence": 0.54
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 24.14,
      "y": 24.39,
      "team": "A",
      "confidence": 0.52
    },
    {
      "frame": 1535,
      "timestamp": 51.17,
      "x": 58.49,
      "y": 31.67,
      "team": "B",
      "confidence": 0.51
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 39.13,
      "y": 34.52,
      "team": "A",
      "confidence": 0.84
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 82.62,
      "y": 52.72,
      "team": "B",
      "confidence": 0.79
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 68.48,
      "y": 31.62,
      "team": "B",
      "confidence": 0.75
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 17.06,
      "y": 37.57,
      "team": "A",
      "confidence": 0.74
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 31.13,
      "y": 33.5,
      "team": "A",
      "confidence": 0.71
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 73.04,
      "y": 34.91,
      "team": "B",
      "confidence": 0.7
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 1.8,
      "y": 55.84,
      "team": "A",
      "confidence": 0.68
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 59.69,
      "y": 32.41,
      "team": "B",
      "confidence": 0.66
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 46.85,
      "y": 25.02,
      "team": "A",
      "confidence": 0.62
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 8.37,
      "y": 26.28,
      "team": "A",
      "confidence": 0.61
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 74.6,
      "y": 46.06,
      "team": "B",
      "confidence": 0.6
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 51.46,
      "y": 12.12,
      "team": "B",
      "confidence": 0.59
    },
    {
      "frame": 1540,
      "timestamp": 51.33,
      "x": 43.27,
      "y": 23.21,
      "team": "A",
      "confidence": 0.56
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 85.17,
      "y": 51.97,
      "team": "B",
      "confidence": 0.83
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 18.74,
      "y": 37.46,
      "team": "A",
      "confidence": 0.8
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 33.0,
      "y": 33.72,
      "team": "A",
      "confidence": 0.78
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 74.1,
      "y": 34.72,
      "team": "B",
      "confidence": 0.77
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 59.54,
      "y": 30.18,
      "team": "B",
      "confidence": 0.66
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 76.96,
      "y": 46.05,
      "team": "B",
      "confidence": 0.65
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 70.11,
      "y": 31.44,
      "team": "B",
      "confidence": 0.64
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 12.41,
      "y": 26.66,
      "team": "A",
      "confidence": 0.64
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 5.51,
      "y": 55.86,
      "team": "A",
      "confidence": 0.63
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 41.92,
      "y": 34.98,
      "team": "A",
      "confidence": 0.61
    },
    {
      "frame": 1545,
      "timestamp": 51.5,
      "x": 52.48,
      "y": 11.91,
      "team": "B",
      "confidence": 0.58
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 86.74,
      "y": 51.88,
      "team": "B",
      "confidence": 0.83
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 8.47,
      "y": 55.05,
      "team": "A",
      "confidence": 0.81
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 79.04,
      "y": 45.3,
      "team": "B",
      "confidence": 0.77
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 44.16,
      "y": 34.58,
      "team": "A",
      "confidence": 0.77
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 20.5,
      "y": 36.77,
      "team": "A",
      "confidence": 0.75
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 74.81,
      "y": 34.91,
      "team": "B",
      "confidence": 0.71
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 71.33,
      "y": 31.56,
      "team": "B",
      "confidence": 0.64
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 34.47,
      "y": 32.82,
      "team": "A",
      "confidence": 0.63
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 59.59,
      "y": 29.07,
      "team": "B",
      "confidence": 0.63
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 53.23,
      "y": 11.84,
      "team": "B",
      "confidence": 0.62
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 20.13,
      "y": 29.16,
      "team": "A",
      "confidence": 0.55
    },
    {
      "frame": 1550,
      "timestamp": 51.67,
      "x": 15.78,
      "y": 25.57,
      "team": "A",
      "confidence": 0.54
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 88.88,
      "y": 51.0,
      "team": "B",
      "confidence": 0.85
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 11.67,
      "y": 54.8,
      "team": "A",
      "confidence": 0.79
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 80.71,
      "y": 45.2,
      "team": "B",
      "confidence": 0.78
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 46.71,
      "y": 34.87,
      "team": "A",
      "confidence": 0.76
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 22.56,
      "y": 36.72,
      "team": "A",
      "confidence": 0.76
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 71.79,
      "y": 30.95,
      "team": "B",
      "confidence": 0.7
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 75.88,
      "y": 35.46,
      "team": "B",
      "confidence": 0.69
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 35.31,
      "y": 32.05,
      "team": "A",
      "confidence": 0.69
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 1.66,
      "y": 39.65,
      "team": "A",
      "confidence": 0.66
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 46.54,
      "y": 22.1,
      "team": "A",
      "confidence": 0.62
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 30.27,
      "y": 23.75,
      "team": "A",
      "confidence": 0.62
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 54.31,
      "y": 11.51,
      "team": "B",
      "confidence": 0.61
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 44.08,
      "y": 22.98,
      "team": "A",
      "confidence": 0.57
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 19.88,
      "y": 13.49,
      "team": "A",
      "confidence": 0.54
    },
    {
      "frame": 1555,
      "timestamp": 51.83,
      "x": 21.98,
      "y": 29.0,
      "team": "A",
      "confidence": 0.52
    }
  ]
}
</file>

<file path="public/international-teams.json">
{
    "TotalClubs": 2,
    "TotalPlayers": 36,
    "Match": {
        "Home": "Algeria",
        "Away": "Nigeria",
        "Type": "Starting Lineups"
    },
    "Clubs": [
        {
            "ClubID": 9002,
            "ClubName": "Algeria",
            "Players": [
                {
                    "ID": 900201,
                    "Forename": "A.",
                    "Surname": "Guendouz",
                    "Number": 1,
                    "ImageURL": ""
                },
                {
                    "ID": 900202,
                    "Forename": "A.",
                    "Surname": "Mandi",
                    "Number": 2,
                    "ImageURL": ""
                },
                {
                    "ID": 900203,
                    "Forename": "Mehdi",
                    "Surname": "Dorval",
                    "Number": 3,
                    "ImageURL": ""
                },
                {
                    "ID": 900205,
                    "Forename": "Z.",
                    "Surname": "Belaid",
                    "Number": 5,
                    "ImageURL": ""
                },
                {
                    "ID": 900206,
                    "Forename": "R.",
                    "Surname": "Zerrouki",
                    "Number": 6,
                    "ImageURL": ""
                },
                {
                    "ID": 900207,
                    "Forename": "R.",
                    "Surname": "Mahrez",
                    "Number": 7,
                    "ImageURL": ""
                },
                {
                    "ID": 900208,
                    "Forename": "H.",
                    "Surname": "Aouar",
                    "Number": 8,
                    "ImageURL": ""
                },
                {
                    "ID": 900209,
                    "Forename": "B.",
                    "Surname": "Bounedjah",
                    "Number": 9,
                    "ImageURL": ""
                },
                {
                    "ID": 900210,
                    "Forename": "I.",
                    "Surname": "Bennacer",
                    "Number": 10,
                    "ImageURL": ""
                },
                {
                    "ID": 900211,
                    "Forename": "A. H.",
                    "Surname": "Moussa",
                    "Number": 11,
                    "ImageURL": ""
                },
                {
                    "ID": 900215,
                    "Forename": "R.",
                    "Surname": "A√Øt-Nouri",
                    "Number": 15,
                    "ImageURL": ""
                }
            ]
        },
        {
            "ClubID": 9004,
            "ClubName": "Nigeria",
            "Players": [
                {
                    "ID": 900401,
                    "Forename": "",
                    "Surname": "Goalkeeper",
                    "Number": 1,
                    "ImageURL": ""
                },
                {
                    "ID": 900402,
                    "Forename": "",
                    "Surname": "Defender",
                    "Number": 2,
                    "ImageURL": ""
                },
                {
                    "ID": 900403,
                    "Forename": "",
                    "Surname": "Defender",
                    "Number": 3,
                    "ImageURL": ""
                },
                {
                    "ID": 900404,
                    "Forename": "",
                    "Surname": "Defender",
                    "Number": 5,
                    "ImageURL": ""
                },
                {
                    "ID": 900405,
                    "Forename": "",
                    "Surname": "Midfielder",
                    "Number": 6,
                    "ImageURL": ""
                },
                {
                    "ID": 900406,
                    "Forename": "",
                    "Surname": "Midfielder",
                    "Number": 8,
                    "ImageURL": ""
                },
                {
                    "ID": 900407,
                    "Forename": "",
                    "Surname": "Midfielder",
                    "Number": 10,
                    "ImageURL": ""
                },
                {
                    "ID": 900408,
                    "Forename": "",
                    "Surname": "Winger",
                    "Number": 11,
                    "ImageURL": ""
                },
                {
                    "ID": 900409,
                    "Forename": "",
                    "Surname": "Forward",
                    "Number": 9,
                    "ImageURL": ""
                },
                {
                    "ID": 900410,
                    "Forename": "",
                    "Surname": "Forward",
                    "Number": 14,
                    "ImageURL": ""
                },
                {
                    "ID": 900411,
                    "Forename": "",
                    "Surname": "Forward",
                    "Number": 18,
                    "ImageURL": ""
                }
            ]
        }
    ]
}
</file>

<file path="public/lfp-clubs-players-data-2025-11-20T13-57-58.json">
{
  "TotalClubs": 16,
  "TotalPlayers": 418,
  "Clubs": [
    {
      "ClubID": 409,
      "ClubName": "Club 409",
      "Players": [
        {
          "ID": 59521,
          "Forename": "ÿ≠ÿØŸäÿØÿØŸä",
          "Surname": "ÿ®ÿØÿ±ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634601-1760556467.png"
        },
        {
          "ID": 41900,
          "Forename": "ÿ±ÿ≠ÿßŸÑ ÿ¨ŸÑÿßŸÑ",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634615-1760555782.png"
        },
        {
          "ID": 377220,
          "Forename": "MAACHOU",
          "Surname": "REDOUANE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634706-1760556215.png"
        },
        {
          "ID": 42353,
          "Forename": "ÿ±ÿ¨ÿßŸÖ",
          "Surname": "ŸÖÿπÿßÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634362-1760556445.png"
        },
        {
          "ID": 40499,
          "Forename": "YACINE",
          "Surname": "ZEGHAD",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634616-1760555918.png"
        },
        {
          "ID": 40680,
          "Forename": "Fouad",
          "Surname": "RAHMANI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634628-1760556159.png"
        },
        {
          "ID": 504258,
          "Forename": "SIAKA",
          "Surname": "BAGAYOKO",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 504326,
          "Forename": "FATAWU Hamidu",
          "Surname": "ABDUL",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635422-1760555890.png"
        },
        {
          "ID": 499672,
          "Forename": "SAIKOU",
          "Surname": "DJIGO",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636645-1760555845.png"
        },
        {
          "ID": 41712,
          "Forename": "ŸÖŸäÿØŸàŸÜ",
          "Surname": "ŸÖÿ≥ÿπŸàÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634361-1760555985.png"
        },
        {
          "ID": 40316,
          "Forename": "ÿ®ŸÑÿπÿ±Ÿäÿ®Ÿä ŸÖÿ≠ŸÖÿØ ÿπŸÑÿßÿ°",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634431-1760556234.png"
        },
        {
          "ID": 44528,
          "Forename": "ÿ®ŸÜ ÿ≥ÿßÿ≥Ÿä ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑŸÜÿßÿµÿ±",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 52363,
          "Forename": "ÿ®ŸÑŸÇŸàÿ±ÿßŸä ŸÖÿ≠ŸÖÿØ",
          "Surname": "ŸÅÿßŸäÿ≤",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634621-1760556195.png"
        },
        {
          "ID": 41193,
          "Forename": "BADR EDDINE",
          "Surname": "TOUKI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634993-1760555940.png"
        },
        {
          "ID": 40501,
          "Forename": "Necer Marouane",
          "Surname": "BENZID",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636626-1760556252.png"
        },
        {
          "ID": 44213,
          "Forename": "ÿ™ŸÑŸäŸÑŸä ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿπÿ®ÿØÿßŸÑŸàŸáÿßÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637052-1760556339.png"
        },
        {
          "ID": 505312,
          "Forename": "ŸÜÿ∫ÿßŸÜÿØÿ≤ŸäÿßŸÖŸä ÿ®ÿßŸÜÿØŸäÿ≥Ÿä ÿ¨ŸàŸÑŸäŸà",
          "Surname": "ŸÉÿ±Ÿäÿ≥ÿØŸàŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637493-1760556358.png"
        },
        {
          "ID": 377993,
          "Forename": "ÿ®ŸÜ ÿ≥ÿßÿ≥Ÿä ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑŸÇÿØŸàÿ≥",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641532-1760556053.png"
        },
        {
          "ID": 44586,
          "Forename": "ŸÖÿ±ÿ¨ÿ©",
          "Surname": "ŸÜŸàŸÅŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634366-1760556295.png"
        },
        {
          "ID": 58259,
          "Forename": "ÿ®ŸÜ ÿ≥ÿßÿ±Ÿä ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿßŸäŸáÿßÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634386-1760556397.png"
        },
        {
          "ID": 40877,
          "Forename": "KHAYREDDINE",
          "Surname": "MERZOUGUI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634415-1760556271.png"
        },
        {
          "ID": 227499,
          "Forename": "ÿ®ŸÜ ÿÆŸäÿ±ÿ©",
          "Surname": "ŸÜÿßÿ¨Ÿä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634436-1760555961.png"
        },
        {
          "ID": 41055,
          "Forename": "ÿπŸÖÿ±ÿßŸÜ",
          "Surname": "ŸÅÿßÿ¶ŸÇ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634618-1760556033.png"
        },
        {
          "ID": 42050,
          "Forename": "ÿ¨ÿ≠ÿØŸà ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿ±ÿ∂ÿß",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634622-1760556319.png"
        },
        {
          "ID": 40580,
          "Forename": "Abderraouf",
          "Surname": "OTHMANI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634996-1760556421.png"
        },
        {
          "ID": 41122,
          "Forename": "Massinissa",
          "Surname": "NEZLA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635738-1760556006.png"
        },
        {
          "ID": 105885,
          "Forename": "ÿ®ŸÜ ÿ≥ÿßÿ≥Ÿä ÿ£ÿ≠ŸÖÿØ",
          "Surname": "ŸÖÿ±ÿ™ÿ∂Ÿâ",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        }
      ]
    },
    {
      "ClubID": 524,
      "ClubName": "Club 524",
      "Players": [
        {
          "ID": 25739,
          "Forename": "ÿ™ÿ±ŸÇŸà ÿ™ÿßÿ¨",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637740-1756651992.png"
        },
        {
          "ID": 40753,
          "Forename": "Mohamed",
          "Surname": "MEDJADJI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637770-1756650442.png"
        },
        {
          "ID": 41116,
          "Forename": "ŸÖÿ¨ÿßÿØŸÑ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ±ÿ≠ŸÖÿßŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640361-1756651351.png"
        },
        {
          "ID": 40900,
          "Forename": "Mohammed El-Amine",
          "Surname": "BARKA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637413-1756650523.png"
        },
        {
          "ID": 378265,
          "Forename": "ÿ®Ÿàÿπÿ®ÿ∑ÿ©",
          "Surname": "ÿ∑ÿßÿ±ŸÇ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637415-1756651563.png"
        },
        {
          "ID": 44392,
          "Forename": "ÿµÿØÿßÿ≠ŸäŸÜ",
          "Surname": "ÿ£ŸäŸàÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637419-1756650630.png"
        },
        {
          "ID": 40922,
          "Forename": "Belkacem",
          "Surname": "BRAHIMI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637421-1756651516.png"
        },
        {
          "ID": 40891,
          "Forename": "Abdelhak",
          "Surname": "DEBBARI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637423-1756651753.png"
        },
        {
          "ID": 50864,
          "Forename": "ÿπŸÄÿ≤Ÿàÿ≤",
          "Surname": "ŸÉŸÄÿ±ŸäŸÄŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637425-1756651222.png"
        },
        {
          "ID": 54039,
          "Forename": "ÿ®ÿØÿßŸÜŸä ŸÖÿ≠ŸÖÿØ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ•ŸÑŸá",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637426-1756651868.png"
        },
        {
          "ID": 40534,
          "Forename": "Chems Eddine",
          "Surname": "BEKKOUCHE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639661-1756651296.png"
        },
        {
          "ID": 41177,
          "Forename": "Achref",
          "Surname": "ABADA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640362-1756651676.png"
        },
        {
          "ID": 50009,
          "Forename": "ÿπÿ®ÿØŸÑŸä",
          "Surname": "ÿ≤ŸÉÿ±Ÿäÿßÿ°",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 40814,
          "Forename": "Imad eddine",
          "Surname": "LARBI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637416-1756651018.png"
        },
        {
          "ID": 377413,
          "Forename": "ABBOUB MOHAMMED",
          "Surname": "ILYAS",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637420-1756650948.png"
        },
        {
          "ID": 40307,
          "Forename": "Ibrahim ben halima",
          "Surname": "FARHI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637422-1756650565.png"
        },
        {
          "ID": 40912,
          "Forename": "ÿ®ŸÑÿπÿßŸÑŸÖ",
          "Surname": "ÿ¨ŸÖÿßŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637741-1756651393.png"
        },
        {
          "ID": 377677,
          "Forename": "ŸÖÿ≠ÿßŸÖÿßÿØŸà ŸÖŸàÿ≥Ÿâ",
          "Surname": "ÿßÿ≥ŸÖÿßÿπŸäŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637745-1756651120.png"
        },
        {
          "ID": 44084,
          "Forename": "ÿ≠ÿ≥ÿßŸÜ ÿÆŸàÿ¨ÿ© ÿØŸÑŸäŸÑ",
          "Surname": "ÿπÿßÿØŸÑ",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 40852,
          "Forename": "ANIS ELHADJ",
          "Surname": "BENCHOUYA",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 367090,
          "Forename": "ÿ®Ÿàÿ™ŸÖÿßŸÜ ÿ≤ŸäŸÜ",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637418-1756651068.png"
        },
        {
          "ID": 64769,
          "Forename": "ŸÇŸàÿßÿØÿ±Ÿä Ÿáÿ®ÿßÿ≤",
          "Surname": "ÿ£ŸäŸÖŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637424-1756651466.png"
        },
        {
          "ID": 200405,
          "Forename": "ŸÅÿØÿßŸÑ",
          "Surname": "ÿπŸäÿ≥Ÿâ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637742-1756651795.png"
        },
        {
          "ID": 496830,
          "Forename": "ŸÑŸäÿØŸÑŸàŸÖ ÿßŸäÿØŸàÿßÿ±ÿØ",
          "Surname": "ÿØÿßÿØŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637762-1756651633.png"
        },
        {
          "ID": 499684,
          "Forename": "ÿßŸÅŸàÿ™Ÿàÿ± ŸÉŸàŸÉŸà",
          "Surname": "ÿ®ÿ±ŸäŸÜŸà",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637765-1756651714.png"
        },
        {
          "ID": 164212,
          "Forename": "ÿØÿ≠ŸÖÿßŸÜ ÿ®ŸàŸÜŸàÿ©",
          "Surname": "ŸÖÿ≠ŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639931-1756651940.png"
        }
      ]
    },
    {
      "ClubID": 653,
      "ClubName": "Club 653",
      "Players": [
        {
          "ID": 377252,
          "Forename": "MORCELY",
          "Surname": "ABDELKADER",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 51916,
          "Forename": "ÿ≤Ÿäÿ™ŸàŸÜŸä",
          "Surname": "Ÿäÿßÿ≥ÿ±",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 40455,
          "Forename": "Oussama",
          "Surname": "LITIM",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 40955,
          "Forename": "Mohamed Abdelali",
          "Surname": "GUEMROUD",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634712-1757781368.png"
        },
        {
          "ID": 377854,
          "Forename": "BADJO SERGE",
          "Surname": "ANTHONY",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636464-1757617720.png"
        },
        {
          "ID": 40927,
          "Forename": "Mohammed Amine",
          "Surname": "EZZEMANI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636731-1757616593.png"
        },
        {
          "ID": 75461,
          "Forename": "ŸÖÿØŸàÿ± ÿ≤ŸäŸÜ",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636753-1757616534.png"
        },
        {
          "ID": 40988,
          "Forename": "Bedr Eddine",
          "Surname": "SOUYAD",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637352-1757617749.png"
        },
        {
          "ID": 40721,
          "Forename": "ABDELHAMID",
          "Surname": "DRIS",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637484-1757616661.png"
        },
        {
          "ID": 53994,
          "Forename": "ŸÇÿ±Ÿàÿ¨ÿ©",
          "Surname": "Ÿàÿßÿ¶ŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639206-1757617693.png"
        },
        {
          "ID": 193496,
          "Forename": "ÿ≥ÿßŸÖÿ± ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ≠ŸÉŸäŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636729-1757617789.png"
        },
        {
          "ID": 40909,
          "Forename": "Ahmida",
          "Surname": "ZENASNI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637406-1757781278.png"
        },
        {
          "ID": 40285,
          "Forename": "Mohamed islam",
          "Surname": "BAKIR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637427-1757615005.png"
        },
        {
          "ID": 41068,
          "Forename": "Mohammed Reda",
          "Surname": "BOUMECHRA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637430-1757617961.png"
        },
        {
          "ID": 40892,
          "Forename": "Samir",
          "Surname": "AIBOUD",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637431-1757617932.png"
        },
        {
          "ID": 499650,
          "Forename": "ÿ≥ÿßŸÖÿßŸÜŸÇŸàÿß ŸÜŸÇŸàŸÑŸà",
          "Surname": "ŸÉÿ±Ÿäÿ≥ÿ™ŸàŸÅÿßÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637432-1757615132.png"
        },
        {
          "ID": 377306,
          "Forename": "CHEKAL AFFARI",
          "Surname": "HADJI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-638268-1757714100.png"
        },
        {
          "ID": 40590,
          "Forename": "Aymen Abdeldjalil",
          "Surname": "BENDAOUD",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641456-1757714138.png"
        },
        {
          "ID": 504216,
          "Forename": "ÿßŸäÿ™ŸàŸÇÿß ŸÖÿ®ŸäŸÑÿß ŸÅÿ±ÿßŸÜŸÉ",
          "Surname": "ÿ™Ÿäÿ±Ÿä",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 377267,
          "Forename": "ESSANG-MATOUTI Edlin",
          "Surname": "RANDY",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634714-1757618412.png"
        },
        {
          "ID": 72256,
          "Forename": "ŸÇÿßÿ®Ÿàÿ¥",
          "Surname": "ÿßŸäŸàÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636755-1757617885.png"
        },
        {
          "ID": 41027,
          "Forename": "AMMAR ABDELMALEK",
          "Surname": "OUKIL",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637407-1757617817.png"
        },
        {
          "ID": 377518,
          "Forename": "ÿ¨ÿßŸàÿ¥Ÿä",
          "Surname": "ÿ≠ŸÖŸäÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637429-1757616827.png"
        }
      ]
    },
    {
      "ClubID": 657,
      "ClubName": "Club 657",
      "Players": [
        {
          "ID": 41180,
          "Forename": "ÿ¥ÿ±ŸäŸÅ ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿßŸÑÿ∑Ÿäÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636593-1756645871.png"
        },
        {
          "ID": 64540,
          "Forename": "ÿ®Ÿàÿ¥ŸäÿÆŸä ŸÜÿ®ŸäŸÑ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑŸÇÿßÿØÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636601-1756646252.png"
        },
        {
          "ID": 41219,
          "Forename": "ÿµÿßŸÑÿ≠Ÿä ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑŸÇÿßÿØÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637343-1756644128.png"
        },
        {
          "ID": 50106,
          "Forename": "ÿ≠ÿØÿßÿØ",
          "Surname": "ÿπÿßÿØŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636587-1756645775.png"
        },
        {
          "ID": 40303,
          "Forename": "ŸÖÿ±ŸàÿßŸÜŸä",
          "Surname": "ŸÖÿ≠ŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636628-1756644268.png"
        },
        {
          "ID": 40879,
          "Forename": "Adel",
          "Surname": "GHANEM",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636630-1756644329.png"
        },
        {
          "ID": 40919,
          "Forename": "KHALED",
          "Surname": "BOUHAKAK",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636710-1756644173.png"
        },
        {
          "ID": 43448,
          "Forename": "Ÿäÿ±Ÿà",
          "Surname": "ÿ£ÿ≥ÿßŸÖÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637346-1756645816.png"
        },
        {
          "ID": 42238,
          "Forename": "ÿ®ŸÜ ÿπÿ®ÿØÿ© ÿ≤Ÿáÿ±",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637348-1756645994.png"
        },
        {
          "ID": 40621,
          "Forename": "ÿπÿ∑ÿßŸÑŸÑŸá",
          "Surname": "ÿßŸÑŸäÿßÿ≥",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637394-1756646162.png"
        },
        {
          "ID": 41163,
          "Forename": "ABDELLAH",
          "Surname": "MEDDAH",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640760-1756646051.png"
        },
        {
          "ID": 18192,
          "Forename": "ÿÆŸäÿßÿ±Ÿä",
          "Surname": "ÿßÿ≥ÿßŸÖÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636596-1756646135.png"
        },
        {
          "ID": 63147,
          "Forename": "ÿ®Ÿàÿ¥Ÿàÿ¥ÿ© ŸÖÿπÿ™ÿ≤",
          "Surname": "ÿ®ÿßŸÑŸÑŸá",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636599-1756646197.png"
        },
        {
          "ID": 40378,
          "Forename": "MORTADA KHIR EDDINE",
          "Surname": "KENICHE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636631-1756644622.png"
        },
        {
          "ID": 41148,
          "Forename": "KHALID",
          "Surname": "DAHAMNI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636632-1756645734.png"
        },
        {
          "ID": 40418,
          "Forename": "ISLAM EDDINE",
          "Surname": "KAIDI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636660-1756645926.png"
        },
        {
          "ID": 55402,
          "Forename": "ŸÖÿ≠ÿ®Ÿàÿ® ÿßÿ≠ŸÖÿØ",
          "Surname": "ÿßŸÖŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636888-1756646023.png"
        },
        {
          "ID": 41097,
          "Forename": "AMMAR",
          "Surname": "ELORFI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637344-1756644396.png"
        },
        {
          "ID": 41008,
          "Forename": "ÿ¥Ÿäÿ™ÿ©",
          "Surname": "ÿ£ÿ≥ÿßŸÖÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641042-1757342248.png"
        },
        {
          "ID": 377251,
          "Forename": "YAICHE",
          "Surname": "ILYES",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 505326,
          "Forename": "ÿ£ŸÖŸÇÿ±ÿßŸÜ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ≠ŸÉŸäŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636575-1756645696.png"
        },
        {
          "ID": 63664,
          "Forename": "ÿ¥ŸÑÿßŸÑŸä ÿπÿ®ÿØ ÿßŸÑŸÇÿßÿØÿ±",
          "Surname": "ÿ£ŸÉÿ±ŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636664-1756646229.png"
        },
        {
          "ID": 377293,
          "Forename": "BENYAHIA DHIYA",
          "Surname": "EDDINE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636666-1756646090.png"
        },
        {
          "ID": 40677,
          "Forename": "ÿπÿ¨Ÿàÿ∑",
          "Surname": "ÿßŸÑŸàŸÜÿßÿ≥",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636680-1756644439.png"
        },
        {
          "ID": 42313,
          "Forename": "ÿ®ŸÑŸÖŸäŸÑŸàÿØ",
          "Surname": "ŸÉŸÖÿßŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636718-1756645897.png"
        },
        {
          "ID": 40692,
          "Forename": "Mohamed",
          "Surname": "BELKHADEM.",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636950-1756645847.png"
        }
      ]
    },
    {
      "ClubID": 670,
      "ClubName": "Club 670",
      "Players": [
        {
          "ID": 42110,
          "Forename": "ŸÖÿÆÿ™ÿßÿ± ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿßŸÜÿ≥",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636711-1757631510.png"
        },
        {
          "ID": 377622,
          "Forename": "ÿ≤ÿ∫ÿ®ÿ©",
          "Surname": "ŸÖÿµÿ∑ŸÅŸâ",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 40946,
          "Forename": "Farid",
          "Surname": "CHAAL",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640659-1757631877.png"
        },
        {
          "ID": 52598,
          "Forename": "ÿπÿ®ÿßÿ≥Ÿä",
          "Surname": "ÿßÿ≥ŸÑÿßŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636712-1757631537.png"
        },
        {
          "ID": 41181,
          "Forename": "YOUNES ABDELHAK",
          "Surname": "OUASSA",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 377223,
          "Forename": "LAOUAFI",
          "Surname": "YOUCEF",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637057-1757631652.png"
        },
        {
          "ID": 377257,
          "Forename": "BENAYADA",
          "Surname": "HOUCINE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637296-1757633980.png"
        },
        {
          "ID": 91362,
          "Forename": "ÿ®ŸÜ ŸÉŸäÿ≠ŸàŸÑ",
          "Surname": "ÿ£ÿ≥ÿßŸÖÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640102-1757631423.png"
        },
        {
          "ID": 40947,
          "Forename": "Chouhaib",
          "Surname": "KEDDAD",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640650-1757629283.png"
        },
        {
          "ID": 377287,
          "Forename": "KHACEF Mohamed",
          "Surname": "NAOUFEL",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640654-1757631752.png"
        },
        {
          "ID": 377327,
          "Forename": "BOUKARCHAOUI",
          "Surname": "BILLEL",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640655-1757631848.png"
        },
        {
          "ID": 377418,
          "Forename": "BEKKOUR",
          "Surname": "ABDERRAHMANE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640658-1757629469.png"
        },
        {
          "ID": 41168,
          "Forename": "ŸÉÿπÿ≥Ÿäÿ≥",
          "Surname": "ÿ¨ÿßÿ®ÿ±",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 505558,
          "Forename": "ÿ≥ŸäŸÉŸäÿ≥Ÿä",
          "Surname": "ÿßŸÜÿØÿ±Ÿä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637054-1757631295.png"
        },
        {
          "ID": 52637,
          "Forename": "ŸÇŸÑÿßŸÑÿ¥ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑŸÖÿßŸÑŸÉ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640100-1757631163.png"
        },
        {
          "ID": 41196,
          "Forename": "Abderaouf",
          "Surname": "BENGUIT",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640651-1757631254.png"
        },
        {
          "ID": 40894,
          "Forename": "Housseyn",
          "Surname": "SELMI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640652-1757631468.png"
        },
        {
          "ID": 505216,
          "Forename": "ŸÉÿ≥ŸäŸÉÿ≥ÿß",
          "Surname": "ÿ±ŸàÿØŸàŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636706-1757631573.png"
        },
        {
          "ID": 505392,
          "Forename": "ÿ®ŸÜ ÿ≠ŸÖŸàÿØÿ© ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿπŸÑŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636714-1757631616.png"
        },
        {
          "ID": 377261,
          "Forename": "BELHOCINI Abdennour",
          "Surname": "IHEB",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637202-1757631199.png"
        },
        {
          "ID": 40538,
          "Forename": "Mohammed Islem",
          "Surname": "BELKHIR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640040-1757631694.png"
        },
        {
          "ID": 42101,
          "Forename": "ÿ®ŸàÿµŸàÿßÿ±",
          "Surname": "ŸÑÿ∑ŸÅŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640653-1757631387.png"
        },
        {
          "ID": 40932,
          "Forename": "Abderrahmane MEZIANE",
          "Surname": "BENTAHAR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640657-1757631344.png"
        },
        {
          "ID": 507470,
          "Forename": "ÿßŸÑŸÖŸÑÿßŸÑŸä",
          "Surname": "ŸÅÿ±ŸäÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641361-1757631813.png"
        },
        {
          "ID": 77025,
          "Forename": "ŸÇÿ±ŸÇŸàÿ±",
          "Surname": "ÿßŸÑÿ¥ÿßŸÅÿπŸä",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        }
      ]
    },
    {
      "ClubID": 672,
      "ClubName": "Club 672",
      "Players": [
        {
          "ID": 52220,
          "Forename": "ÿ≥ŸÇÿßÿ±Ÿä",
          "Surname": "ÿ≤ŸÉÿ±Ÿäÿßÿ°",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635403-1756747454.png"
        },
        {
          "ID": 47664,
          "Forename": "ŸÖÿ±ÿ≠ÿßÿ® ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ®ÿßÿ±Ÿäÿ°",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636115-1757068140.png"
        },
        {
          "ID": 41921,
          "Forename": "ÿ¨ŸÄŸàÿØÿßÿ± ÿπŸÄÿ®ŸÄÿØ",
          "Surname": "ÿßŸÑŸÄŸÜŸÄÿßÿµŸÄÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636221-1756746787.png"
        },
        {
          "ID": 377249,
          "Forename": "MATALLAH SID",
          "Surname": "AHMED",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635622-1756752371.png"
        },
        {
          "ID": 41151,
          "Forename": "RIYANE",
          "Surname": "AKACEM",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636220-1756746851.png"
        },
        {
          "ID": 40281,
          "Forename": "ABDELKADER",
          "Surname": "BOUTICHE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636222-1756746942.png"
        },
        {
          "ID": 43310,
          "Forename": "ÿ®ÿ±ÿßŸáŸäŸÖŸä",
          "Surname": "ÿ±ŸÅŸäŸÇ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636223-1756746975.png"
        },
        {
          "ID": 377228,
          "Forename": "ZAALANI",
          "Surname": "NASREDDINE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636224-1756747223.png"
        },
        {
          "ID": 42862,
          "Forename": "ÿ≠ÿØŸàÿ¥ ÿ•ŸÑŸäÿßÿ≥",
          "Surname": "ŸÅŸäÿµŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636225-1756752234.png"
        },
        {
          "ID": 377351,
          "Forename": "BARKAT",
          "Surname": "ABDENOUR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636229-1756747903.png"
        },
        {
          "ID": 40417,
          "Forename": "Fay√ßal",
          "Surname": "MEBARKI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636232-1756746900.png"
        },
        {
          "ID": 46095,
          "Forename": "ÿ∑ÿßŸáŸàÿ±Ÿä ÿπÿµÿßŸÖ",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637178-1756747414.png"
        },
        {
          "ID": 506321,
          "Forename": "ŸÇÿßŸä ŸÉÿßŸÇŸÜŸà ŸÜŸäŸÜ ŸàŸÑŸÅÿ±ŸäÿØ",
          "Surname": "ÿ≥ŸäŸÖŸàŸÑŸà",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640612-1757067852.png"
        },
        {
          "ID": 504141,
          "Forename": "ŸàÿßŸäŸà",
          "Surname": "ŸÉŸÜÿ≥ÿ∑Ÿà",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634571-1756747610.png"
        },
        {
          "ID": 44832,
          "Forename": "ÿπŸÑÿßŸàŸä ÿÆÿßŸÑÿØ",
          "Surname": "ŸÖŸÜŸäÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636231-1756747829.png"
        },
        {
          "ID": 119671,
          "Forename": "ÿ®ÿØÿßŸàŸä",
          "Surname": "ŸÖÿµÿ∑ŸÅŸâ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636315-1756748069.png"
        },
        {
          "ID": 41028,
          "Forename": "ÿ£ŸàŸÇÿßÿ≥Ÿä",
          "Surname": "ÿ¨Ÿàÿ®ÿß",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636410-1756747555.png"
        },
        {
          "ID": 42187,
          "Forename": "ÿÆŸàŸÖÿßŸÜŸä ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ≠ŸÇ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641392-1756752404.png"
        },
        {
          "ID": 237175,
          "Forename": "ÿ®ŸÜ ÿ∑ÿßŸÑÿ®",
          "Surname": "ÿßÿ≥ÿßŸÖÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636226-1756752340.png"
        },
        {
          "ID": 41080,
          "Forename": "Adel",
          "Surname": "BOUCHIBA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636227-1756747952.png"
        },
        {
          "ID": 40641,
          "Forename": "Mohamed El Amine",
          "Surname": "HAMMIA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636230-1756748004.png"
        },
        {
          "ID": 110114,
          "Forename": "ŸÑÿπŸàŸÅŸä",
          "Surname": "ŸÅÿßÿ±ŸàŸÇ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636720-1756752299.png"
        },
        {
          "ID": 41188,
          "Forename": "NOUR EL ISLAM",
          "Surname": "FETTOUHI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636722-1756747068.png"
        },
        {
          "ID": 40313,
          "Forename": "ISMAIL",
          "Surname": "SAADI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636723-1756747147.png"
        },
        {
          "ID": 499541,
          "Forename": "ÿ®Ÿäÿ∞Ÿä ŸÇÿßŸä",
          "Surname": "ÿ≥ÿ™ŸäŸÅÿßŸÜ",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 507235,
          "Forename": "ÿßŸÑŸäŸÖŸä ÿ≥ŸÉŸäÿ±Ÿä",
          "Surname": "ÿßÿØŸàÿßŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640765-1756814540.png"
        },
        {
          "ID": 129191,
          "Forename": "ÿπŸäÿßÿØ",
          "Surname": "ÿßŸÑÿπŸäÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641213-1756746650.png"
        }
      ]
    },
    {
      "ClubID": 673,
      "ClubName": "Club 673",
      "Players": [
        {
          "ID": 41104,
          "Forename": "ABDELMOUMENE",
          "Surname": "SIFOUR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636427-1758119219.png"
        },
        {
          "ID": 40282,
          "Forename": "Kamel",
          "Surname": "SOUFI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636431-1758120016.png"
        },
        {
          "ID": 40921,
          "Forename": "Oussama",
          "Surname": "BENBOT",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 40429,
          "Forename": "Hocine",
          "Surname": "DEHIRI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634797-1758119883.png"
        },
        {
          "ID": 504446,
          "Forename": "ÿ¥Ÿä ŸÖÿßŸÑŸàŸÜ ŸÅŸàŸÜÿØŸá",
          "Surname": "ÿ¨ŸàŸÜŸäŸàÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634852-1758119384.png"
        },
        {
          "ID": 53207,
          "Forename": "ÿπÿ´ŸÖÿßŸÜŸâŸá ÿµŸÅŸâ",
          "Surname": "ÿßŸÑÿØŸâŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636428-1758119318.png"
        },
        {
          "ID": 68884,
          "Forename": "ŸÉŸàÿ±ÿ∞Ÿâ",
          "Surname": "ŸàŸÑŸäÿ∞",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636437-1758119271.png"
        },
        {
          "ID": 40983,
          "Forename": "Saadi",
          "Surname": "RADOUANI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636442-1758120161.png"
        },
        {
          "ID": 41144,
          "Forename": "Adem",
          "Surname": "ALILET",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636443-1758120250.png"
        },
        {
          "ID": 377459,
          "Forename": "CHETI",
          "Surname": "ILYES",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636444-1758120405.png"
        },
        {
          "ID": 52077,
          "Forename": "ŸÖÿ≠ÿ±Ÿàÿ≤ ÿ±ŸäÿßŸÜ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑŸÖÿ¨ŸäÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639561-1758120207.png"
        },
        {
          "ID": 40290,
          "Forename": "Haithem",
          "Surname": "LOUCIF",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639563-1758119807.png"
        },
        {
          "ID": 41121,
          "Forename": "Ghiles",
          "Surname": "GUENAOUI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635063-1758119712.png"
        },
        {
          "ID": 40928,
          "Forename": "DRAOUI",
          "Surname": "ZAKARIA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635070-1758119419.png"
        },
        {
          "ID": 41114,
          "Forename": "ISLAM",
          "Surname": "MERILI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636429-1758119611.png"
        },
        {
          "ID": 53891,
          "Forename": "ÿ®ŸàŸÑÿπÿ±ÿßÿ≥",
          "Surname": "ÿπŸÖÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637269-1758120715.png"
        },
        {
          "ID": 41064,
          "Forename": "BRAHIM",
          "Surname": "BENZAZA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639562-1758119920.png"
        },
        {
          "ID": 40634,
          "Forename": "Salim",
          "Surname": "BOUKHANCHOUCHE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639564-1758120110.png"
        },
        {
          "ID": 507223,
          "Forename": "ÿ™ŸÜÿØŸÜŸÇ ÿßÿ™ÿßŸÜ ÿ¨ŸÜŸäŸàÿ±",
          "Surname": "ÿßŸÖŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641081-1758120909.png"
        },
        {
          "ID": 507651,
          "Forename": "ÿßÿ±ŸÜÿ≥ÿ©",
          "Surname": "ÿ•ŸÖŸÜŸäÿßŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641560-1758119971.png"
        },
        {
          "ID": 64817,
          "Forename": "ÿ®ŸàÿØÿ±ÿ®ÿßŸÑÿ©",
          "Surname": "ŸÖÿÆŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634289-1758120462.png"
        },
        {
          "ID": 41048,
          "Forename": "KHALED",
          "Surname": "BOUSSELIOU",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636430-1758120075.png"
        },
        {
          "ID": 377487,
          "Forename": "ÿ∫ÿ¥ÿ© ÿ≠ÿ≥ÿßŸÖ",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636433-1758120805.png"
        },
        {
          "ID": 41117,
          "Forename": "AHMED",
          "Surname": "KHALDI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636434-1758119548.png"
        },
        {
          "ID": 115685,
          "Forename": "ÿ®Ÿàÿ∑ÿßŸàŸä ŸÖŸÜÿµŸÅ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ±ÿ≠ŸÖŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636440-1758120284.png"
        },
        {
          "ID": 40289,
          "Forename": "ÿ®ŸÜ ÿπŸäÿßÿØ",
          "Surname": "ÿ±Ÿäÿßÿ∂",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639565-1758119650.png"
        },
        {
          "ID": 377559,
          "Forename": "ŸÑŸäŸÉŸàŸÜÿ≤ ÿ£ÿØŸÜÿ∫Ÿà",
          "Surname": "ÿ∫ŸÑŸàÿØŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639566-1758119763.png"
        }
      ]
    },
    {
      "ClubID": 674,
      "ClubName": "Club 674",
      "Players": [
        {
          "ID": 377484,
          "Forename": "ŸÖÿ±ÿ®ÿßÿ≠",
          "Surname": "ŸÇÿßŸäÿß",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639570-1756764946.png"
        },
        {
          "ID": 40804,
          "Forename": "Mohamed Idir",
          "Surname": "HADID",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639571-1756765383.png"
        },
        {
          "ID": 43665,
          "Forename": "ÿ®ŸÜ ÿ±ÿßÿ®ÿ≠",
          "Surname": "ÿ≥ŸäŸÅ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639572-1756764232.png"
        },
        {
          "ID": 66164,
          "Forename": "ÿ®ŸÜ ÿπÿ∑Ÿäÿ©",
          "Surname": "ÿßÿ≥ÿßŸÖÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637555-1756764112.png"
        },
        {
          "ID": 68980,
          "Forename": "ÿ¥ÿ±Ÿäÿ± ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ≠ŸÇ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637559-1756765727.png"
        },
        {
          "ID": 41159,
          "Forename": "ZINEDDINE",
          "Surname": "BELAID",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-638114-1756765041.png"
        },
        {
          "ID": 40311,
          "Forename": "Hamza",
          "Surname": "MOUALI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-638152-1756765199.png"
        },
        {
          "ID": 40357,
          "Forename": "LAID CHAHINE",
          "Surname": "BELLAOUEL",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-638169-1756765346.png"
        },
        {
          "ID": 40588,
          "Forename": "Mohamed reda",
          "Surname": "HAMIDI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639031-1756897941.png"
        },
        {
          "ID": 499648,
          "Forename": "ÿ®ŸÜ ÿ¥ÿßÿπÿ© ÿ±ÿ∂ÿß ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿ£ŸÖŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639576-1756765078.png"
        },
        {
          "ID": 40901,
          "Forename": "Mohamed Amine",
          "Surname": "MADANI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639577-1756766044.png"
        },
        {
          "ID": 40565,
          "Forename": "FARES NECHAT",
          "Surname": "DJABRI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640373-1756765463.png"
        },
        {
          "ID": 65177,
          "Forename": "ÿ®Ÿàÿ∑ ŸÖÿµÿ∑ŸÅŸâ ÿ±ÿ≤ŸÇ",
          "Surname": "ÿßŸÑŸÑŸá",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641198-1756764963.png"
        },
        {
          "ID": 506173,
          "Forename": "ÿ®ÿßÿØÿß ÿ¨Ÿàÿ≤ÿßŸÅÿßÿ™",
          "Surname": "ÿ£ÿ±ÿ™ÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-638145-1756765678.png"
        },
        {
          "ID": 377532,
          "Forename": "ÿµÿßÿ±",
          "Surname": "ÿ®ÿßÿ®ÿßŸÉÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639573-1756766286.png"
        },
        {
          "ID": 76594,
          "Forename": "ÿßÿ≤ŸÖ",
          "Surname": "ŸäŸàÿ≥ŸÅ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640117-1756764775.png"
        },
        {
          "ID": 499682,
          "Forename": "ÿ®Ÿàÿ¨ŸÖÿπÿ©",
          "Surname": "ŸÖŸáÿØŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640371-1756765608.png"
        },
        {
          "ID": 499407,
          "Forename": "ŸÖÿ±ÿ∫ŸÖ",
          "Surname": "ŸÖŸáÿØŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640983-1756764146.png"
        },
        {
          "ID": 41077,
          "Forename": "Aimen",
          "Surname": "MAHIOUS",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637372-1756766248.png"
        },
        {
          "ID": 164398,
          "Forename": "ÿ≥ŸÑŸäŸÖÿßŸÜ ÿ™ÿ®ÿ¥ ÿ™Ÿäÿ¥ ÿßÿ≥ŸÑÿßŸÖ",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639495-1756764276.png"
        },
        {
          "ID": 41026,
          "Forename": "Aimen Abdelaziz",
          "Surname": "LAHMERI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639568-1756765584.png"
        },
        {
          "ID": 378260,
          "Forename": "ÿ®ŸàÿØÿ®Ÿàÿ≤",
          "Surname": "ÿ±Ÿäÿßÿ∂",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639569-1756764861.png"
        },
        {
          "ID": 41070,
          "Forename": "AHMED",
          "Surname": "MAMMERI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639574-1756766336.png"
        },
        {
          "ID": 65352,
          "Forename": "ŸÖŸÑŸÉŸä",
          "Surname": "ŸàŸÑŸäÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640372-1756766375.png"
        },
        {
          "ID": 42131,
          "Forename": "ÿß ÿÆÿ±Ÿäÿ®",
          "Surname": "ŸÑÿ≠ŸÑŸà",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640478-1756765649.png"
        },
        {
          "ID": 40306,
          "Forename": "Billal",
          "Surname": "MESSAOUDI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641050-1756765629.png"
        }
      ]
    },
    {
      "ClubID": 675,
      "ClubName": "Club 675",
      "Players": [
        {
          "ID": 66130,
          "Forename": "ŸÖŸÜÿØŸäŸÑ ÿßŸÜŸäÿ≥",
          "Surname": "ŸÖŸáÿØŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634697-1757637382.png"
        },
        {
          "ID": 377474,
          "Forename": "ÿπŸÇŸàŸÜ ŸÑŸäŸàŸÜÿßÿ± ÿ£ŸÜÿ∑ŸàÿßŸÜ",
          "Surname": "ÿ±ŸàŸÜŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636234-1757796708.png"
        },
        {
          "ID": 40291,
          "Forename": "Mokhtar",
          "Surname": "FERRAHI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641380-1757636989.png"
        },
        {
          "ID": 41071,
          "Forename": "Abderrahim",
          "Surname": "HAMRA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634684-1757637212.png"
        },
        {
          "ID": 56167,
          "Forename": "ÿπÿØŸä",
          "Surname": "ÿ™ŸàŸÅŸäŸÇ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634694-1757637319.png"
        },
        {
          "ID": 40860,
          "Forename": "Mokhtar",
          "Surname": "BELKHITHER",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635555-1757637080.png"
        },
        {
          "ID": 41066,
          "Forename": "OUSSAMA SAFA",
          "Surname": "KADDOUR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635835-1757636889.png"
        },
        {
          "ID": 377463,
          "Forename": "ŸÖÿπŸÖÿ± ÿ¥ÿßŸàÿ¥ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑŸÉÿ±ŸäŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636233-1757636600.png"
        },
        {
          "ID": 40416,
          "Forename": "ABDELKADER ALAA EDDINE",
          "Surname": "BELHARRANE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636240-1757637181.png"
        },
        {
          "ID": 40401,
          "Forename": "ahmed",
          "Surname": "KERROUM",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636243-1757637239.png"
        },
        {
          "ID": 41199,
          "Forename": "IBRAHIM",
          "Surname": "HACHOUD",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641340-1757636670.png"
        },
        {
          "ID": 42134,
          "Forename": "ÿπŸàÿ¨ÿßŸÜ",
          "Surname": "ÿ¥ŸÉŸäÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634685-1757637019.png"
        },
        {
          "ID": 55383,
          "Forename": "ŸÖÿ≠ÿØÿßŸÜ ŸÖŸÜŸäÿ±",
          "Surname": "ÿßŸÑŸÖŸáÿØŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634698-1757637348.png"
        },
        {
          "ID": 377222,
          "Forename": "MOHUTSIWA GAPE",
          "Surname": "EDWIN",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635420-1757636958.png"
        },
        {
          "ID": 69436,
          "Forename": "ŸÅÿßÿ∑ŸÖŸä",
          "Surname": "ÿßÿ≥ÿßŸÖÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635556-1757637269.png"
        },
        {
          "ID": 41013,
          "Forename": "JUBA",
          "Surname": "AGUIEB",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636235-1757636757.png"
        },
        {
          "ID": 40941,
          "Forename": "Abderrahmane",
          "Surname": "BOURDIM",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636236-1757636633.png"
        },
        {
          "ID": 377472,
          "Forename": "ÿ®ŸàÿÆŸà ŸÑÿØÿ© ÿ¥Ÿáÿ±",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636239-1757636823.png"
        },
        {
          "ID": 377225,
          "Forename": "SENHADJI MOHAMED ES",
          "Surname": "SEDDIK",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636241-1757636928.png"
        },
        {
          "ID": 377271,
          "Forename": "EMBAREK",
          "Surname": "OMAR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636283-1757636697.png"
        },
        {
          "ID": 377290,
          "Forename": "BAAKOH",
          "Surname": "MAXWELL",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637300-1757636725.png"
        },
        {
          "ID": 66305,
          "Forename": "ŸÇŸàÿ¨ŸäŸÑ",
          "Surname": "Ÿäÿßÿ≥ŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634683-1757636785.png"
        },
        {
          "ID": 41797,
          "Forename": "ŸÖŸàŸÑÿßŸä ÿπÿ®ÿØÿßŸÑÿπÿ≤Ÿäÿ≤",
          "Surname": "ÿπÿ®ÿØÿßŸÑŸÇÿßÿØÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636242-1757637111.png"
        },
        {
          "ID": 41141,
          "Forename": "Yacine",
          "Surname": "ALIANE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636244-1757637292.png"
        },
        {
          "ID": 499668,
          "Forename": "ÿ¨Ÿàÿ® ÿ®ÿß",
          "Surname": "ÿπŸÖÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637295-1757636849.png"
        },
        {
          "ID": 69571,
          "Forename": "ŸÖŸäŸÑŸàÿØŸä",
          "Surname": "ÿßŸÑŸäÿßÿ≥",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641407-1757637056.png"
        }
      ]
    },
    {
      "ClubID": 676,
      "ClubName": "Club 676",
      "Players": [
        {
          "ID": 40334,
          "Forename": "ÿ®Ÿàÿ≥ÿØÿ±",
          "Surname": "ÿ∑ÿßÿ±ŸÇ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636401-1758032750.png"
        },
        {
          "ID": 40700,
          "Forename": "ÿ®Ÿà ÿπŸàŸÜ ÿπŸÑÿßÿ°",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 41032,
          "Forename": "ÿ≥ÿπŸäÿØŸä",
          "Surname": "ÿ≤ŸÉÿ±Ÿäÿßÿ°",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637309-1757238622.png"
        },
        {
          "ID": 41887,
          "Forename": "ÿØÿ±ÿØÿßÿ±",
          "Surname": "ÿπÿØÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633831-1757238453.png"
        },
        {
          "ID": 41025,
          "Forename": "KAMEL",
          "Surname": "HAMIDI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633832-1757239047.png"
        },
        {
          "ID": 41829,
          "Forename": "ÿ®Ÿàÿ≤ŸäÿßŸÜ",
          "Surname": "ŸÑÿ≠ÿ≥ŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633838-1757238564.png"
        },
        {
          "ID": 52326,
          "Forename": "ŸÜÿπŸäŸÖ ÿπÿµÿßŸÖ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ≠ŸÖŸäÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633851-1757237220.png"
        },
        {
          "ID": 366698,
          "Forename": "ÿ®ŸàÿØÿ¥Ÿäÿ¥ÿ©",
          "Surname": "ÿπŸäÿ≥Ÿâ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634079-1757239002.png"
        },
        {
          "ID": 40310,
          "Forename": "ÿØŸàÿßÿ±",
          "Surname": "ŸäŸàÿ≥ŸÅ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636402-1757237311.png"
        },
        {
          "ID": 40893,
          "Forename": "ŸÅÿ±ÿ≠ÿßŸÜŸä",
          "Surname": "ŸáŸàÿßÿ±Ÿä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636403-1757237612.png"
        },
        {
          "ID": 40994,
          "Forename": "ÿ®Ÿàÿ®ŸÉÿ± ÿπŸÖÿßÿØ",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636406-1757237252.png"
        },
        {
          "ID": 40858,
          "Forename": "ÿ®ŸÉÿßŸÉÿ¥Ÿä ÿßÿ®ÿ±ÿßŸáŸäŸÖ",
          "Surname": "ÿßŸÑÿÆŸÑŸäŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636447-1757238923.png"
        },
        {
          "ID": 49579,
          "Forename": "ÿ®ŸÜ ÿ≥ŸÑŸäŸÖÿßŸÜ",
          "Surname": "Ÿáÿßÿ¥ŸÖŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633852-1757238879.png"
        },
        {
          "ID": 41774,
          "Forename": "ÿØÿπÿ®Ÿäÿ¥",
          "Surname": "ÿ£Ÿàÿ≥ÿßŸÖÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633853-1757237344.png"
        },
        {
          "ID": 62859,
          "Forename": "ÿπÿ±Ÿäÿ® ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ±ÿ§ŸàŸÅ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633967-1757238509.png"
        },
        {
          "ID": 41194,
          "Forename": "ÿ∑ŸàÿßŸÑ ÿÆŸäÿ±",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634583-1757238415.png"
        },
        {
          "ID": 504149,
          "Forename": "ŸÖŸàÿØÿßÿ≥Ÿäÿ±Ÿà",
          "Surname": "ÿ≥ÿßŸÑŸäŸÅŸà",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634588-1757239130.png"
        },
        {
          "ID": 40650,
          "Forename": "ÿ¨ÿ≠ŸÜŸäÿ∑",
          "Surname": "ÿ£ŸÉÿ±ŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636404-1757238361.png"
        },
        {
          "ID": 40616,
          "Forename": "ÿ®ŸàŸÉÿ±ŸÖÿ©",
          "Surname": "ŸÖÿ≠ŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636408-1757238656.png"
        },
        {
          "ID": 52986,
          "Forename": "ÿ®ŸÜ ŸÑÿ®ŸÜÿ© ŸÖÿ≠ŸÖÿØ ÿ¥ŸÖÿ≥",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633850-1757238322.png"
        },
        {
          "ID": 504119,
          "Forename": "ÿ≥ŸäŸÑÿßŸá",
          "Surname": "ÿ¨ÿ®ÿ±ŸäŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633982-1757238749.png"
        },
        {
          "ID": 41091,
          "Forename": "Aymane Issad",
          "Surname": "LAKDJA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634489-1757238700.png"
        },
        {
          "ID": 504334,
          "Forename": "ÿ£ÿ®ŸäÿØŸä",
          "Surname": "ÿ®Ÿäÿ±ŸÖÿßŸáŸäÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634652-1757238965.png"
        },
        {
          "ID": 40482,
          "Forename": "Merouane",
          "Surname": "ZERROUKI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635078-1757238821.png"
        },
        {
          "ID": 65106,
          "Forename": "ÿ∫ÿ±ÿ®Ÿä",
          "Surname": "ŸäŸàÿ≥ŸÅ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636407-1757239087.png"
        },
        {
          "ID": 40465,
          "Forename": "ÿ®Ÿàÿ¥ÿßŸÖÿ© ÿµŸÑÿßÿ≠ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ™Ÿàÿßÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637306-1757237391.png"
        }
      ]
    },
    {
      "ClubID": 677,
      "ClubName": "Club 677",
      "Players": [
        {
          "ID": 41011,
          "Forename": "Alexis",
          "Surname": "GUENDOUZ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636271-1757108872.png"
        },
        {
          "ID": 40559,
          "Forename": "ABDELATIF",
          "Surname": "RAMDANE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640745-1757107454.png"
        },
        {
          "ID": 40309,
          "Forename": "Aimen",
          "Surname": "BOUGUERRA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636717-1757108812.png"
        },
        {
          "ID": 40345,
          "Forename": "MERWANE",
          "Surname": "KHELIF",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640746-1757107790.png"
        },
        {
          "ID": 377224,
          "Forename": "ABDELLAOUI",
          "Surname": "AYOUB",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640747-1757107860.png"
        },
        {
          "ID": 40980,
          "Forename": "Ayoub",
          "Surname": "GHEZALA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641218-1757108484.png"
        },
        {
          "ID": 377232,
          "Forename": "HALAIMIA MED",
          "Surname": "REDHA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641219-1757108524.png"
        },
        {
          "ID": 377233,
          "Forename": "MENEZLA",
          "Surname": "ABDELKADER",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 66435,
          "Forename": "ÿØŸÜÿØÿßŸàŸä",
          "Surname": "ÿ±ÿ≥ÿ™ŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641228-1757107582.png"
        },
        {
          "ID": 377250,
          "Forename": "BENKHEMASSA",
          "Surname": "MOHAMMED",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640748-1757107946.png"
        },
        {
          "ID": 366695,
          "Forename": "ÿ≤Ÿàÿ∫ÿ±ÿßŸÜÿß",
          "Surname": "ŸÖÿ≠ŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640753-1757108267.png"
        },
        {
          "ID": 51972,
          "Forename": "ÿπŸäÿ≥ÿßŸàŸä",
          "Surname": "ÿ≥ŸäÿØÿ£ÿ≠ŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640779-1757109080.png"
        },
        {
          "ID": 507337,
          "Forename": "ÿ®ŸÜÿ∫Ÿàÿ±ÿß",
          "Surname": "ÿßŸÑÿ≠ÿ≥ŸÜ",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 40820,
          "Forename": "MEHDI",
          "Surname": "BOUCHERIT",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641216-1757108424.png"
        },
        {
          "ID": 40904,
          "Forename": "Larbi",
          "Surname": "TABTI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641221-1757108572.png"
        },
        {
          "ID": 66418,
          "Forename": "ÿ≥Ÿäÿ®Ÿàÿ≥ ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿßÿ≥ŸÑÿßŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641230-1757108364.png"
        },
        {
          "ID": 367335,
          "Forename": "ÿ®ŸàÿßŸÑÿµŸàŸÅ",
          "Surname": "ÿ∑ŸÑÿßŸÑ",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 377256,
          "Forename": "BAYAZID",
          "Surname": "SOFIANE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640749-1757108140.png"
        },
        {
          "ID": 499683,
          "Forename": "ÿ®ÿßŸÜÿ∫Ÿàÿ±ÿß ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿ≥ÿßŸÑŸäŸàÿß",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 377282,
          "Forename": "NAIDJI",
          "Surname": "ZAKARIA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640752-1757108743.png"
        },
        {
          "ID": 377461,
          "Forename": "ZUNON KIPRE TIAGOURI EMMANUEL",
          "Surname": "JUNIOR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641222-1757108611.png"
        },
        {
          "ID": 377347,
          "Forename": "BENHAOUA",
          "Surname": "OUSSAMA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641225-1757108936.png"
        },
        {
          "ID": 377669,
          "Forename": "ŸÖÿ≥Ÿàÿ≥ÿ© ÿ£ŸÖŸäŸÜ ÿπÿ®ÿØ ÿßŸÑÿ±ÿ≠ŸÖÿßŸÜ ÿ®ŸÜ",
          "Surname": "ŸÖŸÑŸäŸÉ",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 63436,
          "Forename": "ÿ≠ŸÖÿß ÿØŸàÿ¥ Ÿäÿß",
          "Surname": "ÿ≥ŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641227-1757108320.png"
        },
        {
          "ID": 55355,
          "Forename": "ÿ®Ÿàÿ®ÿ∑ÿßÿ¥ ÿ¥ŸÖÿ≥",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641229-1757108649.png"
        },
        {
          "ID": 377666,
          "Forename": "ŸÖÿ≤ŸäÿßŸÜŸä",
          "Surname": "ÿ∑Ÿäÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641231-1757108228.png"
        },
        {
          "ID": 507615,
          "Forename": "ŸÅÿ±ÿ≠ÿßÿ™ ÿ≤ŸäŸÜ",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641517-1757108191.png"
        }
      ]
    },
    {
      "ClubID": 678,
      "ClubName": "Club 678",
      "Players": [
        {
          "ID": 40315,
          "Forename": "Zakaria",
          "Surname": "BOUHALFAYA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634388-1756554284.png"
        },
        {
          "ID": 79038,
          "Forename": "ÿÆŸÜŸäÿ¥ ŸÖÿ≠ŸÖÿØ",
          "Surname": "ŸÖÿπÿ™ÿ≤",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636700-1756554847.png"
        },
        {
          "ID": 40664,
          "Forename": "ABDELMALEK",
          "Surname": "NECIR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636704-1756555082.png"
        },
        {
          "ID": 41018,
          "Forename": "ÿ¥ŸäÿÆŸä",
          "Surname": "ÿπÿ®ÿØÿßŸÑŸÖŸàŸÖŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634503-1756555203.png"
        },
        {
          "ID": 40639,
          "Forename": "Oussama",
          "Surname": "MEDDAHI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636262-1756554727.png"
        },
        {
          "ID": 40872,
          "Forename": "Chamseddine",
          "Surname": "DERRADJI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636265-1756554910.png"
        },
        {
          "ID": 377258,
          "Forename": "ÿ®ŸàÿØÿ±ÿßŸÖÿ©",
          "Surname": "ÿ£ÿ¥ÿ±ŸÅ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636268-1756555248.png"
        },
        {
          "ID": 63460,
          "Forename": "ÿ®ŸÜ ÿπÿØŸÑÿ© ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ±ÿ≠ŸÖÿßŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636690-1756554340.png"
        },
        {
          "ID": 378261,
          "Forename": "ŸÜÿØŸäÿßŸä",
          "Surname": "ŸÖŸäŸÑŸà",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637289-1756554380.png"
        },
        {
          "ID": 40979,
          "Forename": "Houari",
          "Surname": "BAOUCHE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637308-1756554557.png"
        },
        {
          "ID": 2198,
          "Forename": "ÿ®ŸÜ ŸÖŸàÿ≥Ÿâ ÿ±ÿ≠ŸÖÿßŸÜŸä ÿπŸÖÿßÿØ",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639330-1756554761.png"
        },
        {
          "ID": 40668,
          "Forename": "ÿ®ÿ±ŸÉÿßŸÜ",
          "Surname": "ŸÖÿµÿ∑ŸÅŸâ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634499-1756554805.png"
        },
        {
          "ID": 40526,
          "Forename": "ÿ®Ÿàÿ≤ŸÉÿ±Ÿä ŸàŸÑÿßÿ°",
          "Surname": "ŸÖŸÜÿ∞ÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634500-1756554495.png"
        },
        {
          "ID": 40859,
          "Forename": "Mohamed",
          "Surname": "BENCHAIRA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636258-1756554440.png"
        },
        {
          "ID": 40910,
          "Forename": "Brahim",
          "Surname": "DIB",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636260-1756554634.png"
        },
        {
          "ID": 40945,
          "Forename": "Messala",
          "Surname": "MERBAH",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636263-1757501416.png"
        },
        {
          "ID": 40924,
          "Forename": "Feth-Allah",
          "Surname": "TAHAR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636270-1756555278.png"
        },
        {
          "ID": 40897,
          "Forename": "Miloud",
          "Surname": "REBIAI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636703-1756555135.png"
        },
        {
          "ID": 377720,
          "Forename": "ÿ∑ÿßÿ®ÿ≥Ÿàÿ®ÿß",
          "Surname": "ÿ≥ÿßŸÑŸäŸÅŸà",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641509-1757501365.png"
        },
        {
          "ID": 40287,
          "Forename": "DADI El hocine",
          "Surname": "MOUAKI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636267-1756554675.png"
        },
        {
          "ID": 40951,
          "Forename": "Rida",
          "Surname": "BENSAYAH",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636707-1756554873.png"
        },
        {
          "ID": 52616,
          "Forename": "ŸÇÿ±ŸäŸÜ",
          "Surname": "ÿ≠ÿßÿ™ŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636890-1756555008.png"
        },
        {
          "ID": 377245,
          "Forename": "OMOYELE TOSIN",
          "Surname": "ABRAHAM",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637291-1756555050.png"
        },
        {
          "ID": 60631,
          "Forename": "ÿÆŸÑŸÅÿßŸàŸä",
          "Surname": "Ÿàÿ¨ŸäŸá",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637307-1756554971.png"
        },
        {
          "ID": 506241,
          "Forename": "ÿßŸÑÿ∫ŸàŸÑ ŸÜÿ≥ŸäŸÖ ÿ¨ŸÑŸàŸÑ",
          "Surname": "ÿ≥ÿßŸÑŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-638220-1756555170.png"
        }
      ]
    },
    {
      "ClubID": 680,
      "ClubName": "Club 680",
      "Players": [
        {
          "ID": 41157,
          "Forename": "AHMED",
          "Surname": "ABDELKADER",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637319-1757431006.png"
        },
        {
          "ID": 66482,
          "Forename": "ÿ®ŸàÿØÿ¨ÿ©",
          "Surname": "ÿßŸÖŸäÿßÿ≥",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637334-1757429122.png"
        },
        {
          "ID": 40649,
          "Forename": "Toufik",
          "Surname": "MOUSSAOUI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641475-1757429604.png"
        },
        {
          "ID": 505576,
          "Forename": "ŸÉŸàŸÜŸä",
          "Surname": "ÿ≥ŸÖÿ®ÿß",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637186-1757429471.png"
        },
        {
          "ID": 41092,
          "Forename": "HAMZA",
          "Surname": "SALEM",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637249-1757429205.png"
        },
        {
          "ID": 41674,
          "Forename": "ŸÉÿ±ŸÖŸäÿ¥",
          "Surname": "ŸÅÿ§ÿßÿØ",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 377343,
          "Forename": "BOUZAHZAH",
          "Surname": "OUANISSE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637326-1757429176.png"
        },
        {
          "ID": 42105,
          "Forename": "ÿ≤ÿßŸàŸä ÿµŸÑÿßÿ≠",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637335-1757429385.png"
        },
        {
          "ID": 40796,
          "Forename": "ÿ±ŸÇŸäŸÇ ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿπŸÖÿßÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637357-1757430630.png"
        },
        {
          "ID": 40757,
          "Forename": "MOHAMED AIT EL",
          "Surname": "HADJ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637310-1757429317.png"
        },
        {
          "ID": 41090,
          "Forename": "Abdeldjalil",
          "Surname": "TAHRI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637314-1757429901.png"
        },
        {
          "ID": 377305,
          "Forename": "BISKER",
          "Surname": "MONCEF",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 40427,
          "Forename": "Taha Yassine",
          "Surname": "TAHAR",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 42154,
          "Forename": "ÿ∑ÿßŸáÿ± ŸÖÿ≠ŸÖÿØ",
          "Surname": "ŸÑŸÖŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637323-1757430008.png"
        },
        {
          "ID": 42151,
          "Forename": "ÿπÿ®ÿØ ÿßŸÑŸÇÿßÿØÿ± ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿßÿ≥ŸÑÿßŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637324-1757429298.png"
        },
        {
          "ID": 55424,
          "Forename": "ÿ≤ÿ®ÿßŸäŸà",
          "Surname": "ÿ¨ÿπŸÅÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637329-1757430417.png"
        },
        {
          "ID": 55462,
          "Forename": "ÿ®ŸàÿØÿ±ŸÉÿ© ŸÖÿ≠ŸÖÿØ ŸÜÿ≤ŸäŸÖ",
          "Surname": "ÿßÿ≤ŸàÿßŸà",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637332-1757429154.png"
        },
        {
          "ID": 377308,
          "Forename": "NAMANI",
          "Surname": "ABDELKRIM",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637356-1757430965.png"
        },
        {
          "ID": 507612,
          "Forename": "ÿ±ÿßŸÅÿßŸÜŸàŸÖŸäÿ≥ŸàŸÜÿ™Ÿàÿ≤ÿßŸà ŸÜŸàŸÖŸäŸÜÿß",
          "Surname": "ŸÑÿßŸÑÿßŸäŸÜÿß",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 40739,
          "Forename": "Adel Amar BELKACEM",
          "Surname": "BOUZIDA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637311-1757429340.png"
        },
        {
          "ID": 377313,
          "Forename": "SOUKKOU Mustapha",
          "Surname": "DJABRIL",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637315-1757429366.png"
        },
        {
          "ID": 377226,
          "Forename": "BENDOUMA",
          "Surname": "ABDELLAH",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637316-1757430518.png"
        },
        {
          "ID": 42252,
          "Forename": "ÿ±ŸÖÿ∂ÿßŸàŸä ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿßŸÑÿßŸÖŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637322-1757429575.png"
        },
        {
          "ID": 74642,
          "Forename": "ŸÑÿ≠ŸÖÿ± ÿ≥ŸäÿØ",
          "Surname": "ÿßÿ≠ŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637327-1757430343.png"
        },
        {
          "ID": 377270,
          "Forename": "DAO",
          "Surname": "YOUSSOUF",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637330-1757429446.png"
        },
        {
          "ID": 55447,
          "Forename": "ŸÉÿ≠ŸäŸÑŸä ÿ®ŸÜ",
          "Surname": "ÿßÿ≠ŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637331-1757429245.png"
        },
        {
          "ID": 377227,
          "Forename": "ÿ®ÿßÿ¥ÿß ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ±ÿ≠ŸÖŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639497-1757430987.png"
        }
      ]
    },
    {
      "ClubID": 694,
      "ClubName": "Club 694",
      "Players": [
        {
          "ID": 185821,
          "Forename": "ÿπÿ≤Ÿäÿ±Ÿäÿ©",
          "Surname": "ŸÖŸÜŸäÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637040-1758063995.png"
        },
        {
          "ID": 377260,
          "Forename": "MBOLHI Adi - Rais, Cobos",
          "Surname": "ADRIEN",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637063-1758055945.png"
        },
        {
          "ID": 43057,
          "Forename": "ŸáŸÜÿßŸÜ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ≥ŸÑÿßŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637301-1758024542.png"
        },
        {
          "ID": 83058,
          "Forename": "ÿ≥ŸÑŸäŸÖÿßŸÜ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ•ŸÑŸá",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636887-1758059556.png"
        },
        {
          "ID": 83068,
          "Forename": "ŸÑÿπÿ±Ÿäÿ¥ ŸÅÿ±ŸäÿØ",
          "Surname": "ÿ≠ŸÖÿ≤ÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636892-1758056042.png"
        },
        {
          "ID": 377297,
          "Forename": "MESMOUDI",
          "Surname": "BOUALEM",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637061-1758024762.png"
        },
        {
          "ID": 40546,
          "Forename": "ÿ®Ÿà ÿßŸÑŸÇÿßÿ®ŸàŸÑ",
          "Surname": "ÿ¥ÿπŸäÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637126-1758048009.png"
        },
        {
          "ID": 40568,
          "Forename": "ÿ®ŸàÿπŸÑÿßŸÇ",
          "Surname": "ÿ£ŸäŸÖŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637162-1758024633.png"
        },
        {
          "ID": 40967,
          "Forename": "BENALI",
          "Surname": "BENAMMAR",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637302-1758024904.png"
        },
        {
          "ID": 377269,
          "Forename": "BENLAMRI",
          "Surname": "DJAMEL",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637303-1758025362.png"
        },
        {
          "ID": 507231,
          "Forename": "ÿ≤ŸÅÿßŸÜ ŸÖŸáÿØŸä",
          "Surname": "ÿßŸÖÿ®ÿßÿ±ŸÉ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-640741-1758059727.png"
        },
        {
          "ID": 40638,
          "Forename": "ÿßŸÑÿπŸÖÿ±Ÿä ÿ≥ŸäÿØ",
          "Surname": "ÿπŸÑŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637161-1758047957.png"
        },
        {
          "ID": 41088,
          "Forename": "ÿ®ÿπŸäŸàÿØ ÿ≠ÿ≥ÿßŸÖ",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637163-1758048139.png"
        },
        {
          "ID": 40939,
          "Forename": "ÿ®ŸÜ ÿÆŸÑŸäŸÅÿ©",
          "Surname": "ÿßŸÑÿ∑ÿßŸáÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637266-1758025672.png"
        },
        {
          "ID": 42949,
          "Forename": "ÿ®Ÿäÿ®Ÿä ÿ£ÿ®Ÿà",
          "Surname": "ÿ®ŸÉÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637304-1758055771.png"
        },
        {
          "ID": 40961,
          "Forename": "Abdelhafid",
          "Surname": "BENAMARA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637369-1758025238.png"
        },
        {
          "ID": 377300,
          "Forename": "ÿßŸÑŸÖŸàÿØŸÜ",
          "Surname": "ÿπÿ®ÿØÿßŸÑŸÑŸá",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637371-1758028963.png"
        },
        {
          "ID": 40925,
          "Forename": "Ahmed",
          "Surname": "GAGAA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637380-1758055856.png"
        },
        {
          "ID": 274351,
          "Forename": "KHODJA EL",
          "Surname": "KACEM",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 40288,
          "Forename": "Mohamed hacene",
          "Surname": "BENGRINA",
          "ImageURL": "https://lfp.dz/images/default-person.png"
        },
        {
          "ID": 62782,
          "Forename": "ÿπŸäÿ¥Ÿàÿ≥ ÿ¢ÿØŸÖ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ±ÿ≠ŸÖŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636842-1758048216.png"
        },
        {
          "ID": 40998,
          "Forename": "ZOUBIR",
          "Surname": "MOTRANI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637032-1758025435.png"
        },
        {
          "ID": 40996,
          "Forename": "AMEUR",
          "Surname": "BOUGUETTAYA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637305-1758055902.png"
        },
        {
          "ID": 377462,
          "Forename": "ÿπÿ≥ŸÉÿ± ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ≠ŸÇ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637367-1758047870.png"
        },
        {
          "ID": 377296,
          "Forename": "Ÿáÿßÿ±ŸàŸÜ",
          "Surname": "ÿπŸÑŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637377-1758028911.png"
        },
        {
          "ID": 40589,
          "Forename": "Boualem Abdelghani",
          "Surname": "SRYER",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-637385-1758059599.png"
        },
        {
          "ID": 40956,
          "Forename": "ZINE MOHAMED TOUMI",
          "Surname": "SIEF",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-638165-1758680031.png"
        }
      ]
    },
    {
      "ClubID": 755,
      "ClubName": "Club 755",
      "Players": [
        {
          "ID": 68942,
          "Forename": "ŸÇÿßÿØÿ±Ÿä ÿ∂ŸäŸÅ",
          "Surname": "ÿßŸÑŸÑŸá",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633778-1756732161.png"
        },
        {
          "ID": 41041,
          "Forename": "Kheir-Eddine",
          "Surname": "BOUSSOUF",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633779-1756731098.png"
        },
        {
          "ID": 42139,
          "Forename": "ÿ®ŸÜ ÿ¥ŸÇÿßŸÑ",
          "Surname": "ŸäŸÜŸäÿ≥",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635868-1756731477.png"
        },
        {
          "ID": 40902,
          "Forename": "Fateh",
          "Surname": "TALAH",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633780-1756731059.png"
        },
        {
          "ID": 378101,
          "Forename": "ÿ¥ÿ≠ÿ±Ÿàÿ±",
          "Surname": "ÿ•ÿ≥ŸÑÿßŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634178-1756730702.png"
        },
        {
          "ID": 40350,
          "Forename": "ŸÑŸÉÿ≠ŸÑ ÿ¥ŸÖÿ≥",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634329-1756730997.png"
        },
        {
          "ID": 41073,
          "Forename": "AYMEN",
          "Surname": "CHAARAOUI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635182-1756730611.png"
        },
        {
          "ID": 42145,
          "Forename": "ÿßŸàŸÉÿßŸÑŸä ÿπÿ®ÿØ ÿßŸÑŸÉÿ±ŸäŸÖ ÿßÿ±ÿ≥ŸÑÿßŸÜ",
          "Surname": "ÿ≠ŸÖÿ≤ÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635640-1756730747.png"
        },
        {
          "ID": 40531,
          "Forename": "ABDELKADER",
          "Surname": "TAMIMI",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635672-1756730661.png"
        },
        {
          "ID": 41083,
          "Forename": "Abderrahmane",
          "Surname": "HACHOUD",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636360-1756731392.png"
        },
        {
          "ID": 42473,
          "Forename": "ÿÆŸÑŸàŸÅ",
          "Surname": "Ÿàÿ≥ŸäŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636375-1756731356.png"
        },
        {
          "ID": 41096,
          "Forename": "ÿ®ŸàŸÜŸàÿ© ÿ±ÿ∂ŸàÿßŸÜ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑŸàÿ≠ŸäÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633815-1756731295.png"
        },
        {
          "ID": 377480,
          "Forename": "Ÿäÿ∑Ÿà ŸÖÿ≠ŸÖÿØ",
          "Surname": "ŸÜÿ≥ŸäŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634180-1756731323.png"
        },
        {
          "ID": 52677,
          "Forename": "ÿπŸäÿ≥ÿßŸÜŸä ÿπŸÑÿßÿ°",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634197-1756730845.png"
        },
        {
          "ID": 40463,
          "Forename": "MASSINISSA",
          "Surname": "BENCHELOUCHE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635198-1756730777.png"
        },
        {
          "ID": 58604,
          "Forename": "ÿ®ŸàÿπŸÖÿßŸÖÿ©",
          "Surname": "ÿ®ÿßÿØŸäÿ≥",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635864-1756730931.png"
        },
        {
          "ID": 377295,
          "Forename": "BENABDI",
          "Surname": "AZIZ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635866-1756731205.png"
        },
        {
          "ID": 59256,
          "Forename": "ÿπÿ±ÿßÿ¥",
          "Surname": "ŸÅÿßÿØŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635870-1756731427.png"
        },
        {
          "ID": 40866,
          "Forename": "Abdeldjalil Taki Eddine",
          "Surname": "SAAD",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634090-1756730874.png"
        },
        {
          "ID": 40644,
          "Forename": "Mohamed",
          "Surname": "SOUIBAAH",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634179-1756731154.png"
        },
        {
          "ID": 376802,
          "Forename": "ŸÖÿ≥ÿπŸàÿØ ÿ≥ÿßŸÑŸÖ",
          "Surname": "ŸÖÿ≠ŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634198-1756731250.png"
        },
        {
          "ID": 40864,
          "Forename": "ÿ¨ÿπÿ®Ÿàÿ∑",
          "Surname": "ÿπÿßÿØŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635197-1756730806.png"
        },
        {
          "ID": 377363,
          "Forename": "ALLAM",
          "Surname": "YANIS",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635867-1756731128.png"
        },
        {
          "ID": 377263,
          "Forename": "ZAOUACHE",
          "Surname": "AHMED",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635869-1756730970.png"
        },
        {
          "ID": 63590,
          "Forename": "ÿπÿ®ÿ±Ÿä",
          "Surname": "ÿ¥ŸÉŸäÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636361-1756731034.png"
        },
        {
          "ID": 377490,
          "Forename": "ŸÖÿ≠ŸÖÿØ ÿ≥ÿØŸäŸÉŸä",
          "Surname": "ÿ≥ŸäŸÑÿß",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-641673-1757791453.png"
        }
      ]
    },
    {
      "ClubID": 758,
      "ClubName": "Club 758",
      "Players": [
        {
          "ID": 42253,
          "Forename": "ÿπŸÑŸäŸÑŸä",
          "Surname": "ÿßÿ≠ŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634311-1756833577.png"
        },
        {
          "ID": 41147,
          "Forename": "ÿ®ŸÜ ÿßŸÑÿ¥ŸäÿÆ ÿßŸÑŸÅŸÇŸàŸÜ",
          "Surname": "ÿ≠ÿßÿ™ŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636418-1756832627.png"
        },
        {
          "ID": 41908,
          "Forename": "ŸÇŸÑŸäŸÑÿ¥ ÿ®ŸÜ",
          "Surname": "ÿπŸàÿØÿ©",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636421-1756833319.png"
        },
        {
          "ID": 503987,
          "Forename": "ÿ®ŸÜ ÿ¥ÿ±ŸäŸÅÿ© ŸÖÿ≠ŸÖÿØ",
          "Surname": "ŸàŸÑŸäÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-633587-1756833071.png"
        },
        {
          "ID": 66675,
          "Forename": "ÿµÿßÿ®ÿ±Ÿä ŸÖÿ≠ŸÖÿØ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ±ÿ≠ŸÖÿßŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634374-1756833218.png"
        },
        {
          "ID": 40949,
          "Forename": "ÿ®ŸÜ ÿπŸÖÿ±ÿßŸÜ ÿÆŸäÿ±",
          "Surname": "ÿßŸÑÿØŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634976-1756832916.png"
        },
        {
          "ID": 48088,
          "Forename": "ÿπŸÑÿß",
          "Surname": "ÿßÿ≠ŸÖÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636148-1756833041.png"
        },
        {
          "ID": 377236,
          "Forename": "ÿ®ÿ≠ŸàÿµŸä ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑÿ¨ŸÑŸäŸÑ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636416-1756833633.png"
        },
        {
          "ID": 40899,
          "Forename": "Billal",
          "Surname": "BOUKARROUM",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636419-1756833278.png"
        },
        {
          "ID": 41987,
          "Forename": "ÿ®Ÿàÿ´ŸÑÿ¨ÿ©",
          "Surname": "ÿ≥ŸÑŸäŸÖÿßŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636422-1757931947.png"
        },
        {
          "ID": 41915,
          "Forename": "ÿ¥ŸÄŸÑŸÄŸÅŸÄÿßŸàŸä ŸÖŸÄÿ≠ŸÄŸÖŸÄÿØ",
          "Surname": "ŸäŸÄÿßÿ≥ŸÄÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636425-1756832774.png"
        },
        {
          "ID": 80374,
          "Forename": "ŸÅÿ±ŸäÿØ ÿ≠ÿßÿ± ÿßŸÖÿßŸÖ ÿπÿ®ÿØ",
          "Surname": "ÿßŸÑŸÖŸÜÿπŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634189-1756832809.png"
        },
        {
          "ID": 237552,
          "Forename": "ÿ®ÿ±ÿßÿ®ÿ≠ ŸÖÿ≠ŸÖÿØ",
          "Surname": "ŸÜÿ¨Ÿäÿ®",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634328-1756833160.png"
        },
        {
          "ID": 41101,
          "Forename": "ALI",
          "Surname": "AMRICHE",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634658-1756833615.png"
        },
        {
          "ID": 72964,
          "Forename": "-",
          "Surname": "-",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636332-1756832671.png"
        },
        {
          "ID": 377221,
          "Forename": "ADDADI",
          "Surname": "TOUFIK",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636413-1756832953.png"
        },
        {
          "ID": 41165,
          "Forename": "ŸÖÿ≥ŸäÿπÿØ",
          "Surname": "Ÿáÿ¥ÿßŸÖ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636415-1756833124.png"
        },
        {
          "ID": 42179,
          "Forename": "ŸÖŸáÿØÿßŸàŸä",
          "Surname": "ŸÖÿ±ŸàÿßŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636423-1756832737.png"
        },
        {
          "ID": 42456,
          "Forename": "ÿ≤ŸäÿØŸä",
          "Surname": "ŸÑŸàŸÜÿßÿ≥",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636424-1756833655.png"
        },
        {
          "ID": 377498,
          "Forename": "ÿ®ŸÜ ÿ≥ÿπÿØ ÿßŸÑŸÑŸá",
          "Surname": "ÿ∏ÿ±ÿßÿ±",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636426-1756833378.png"
        },
        {
          "ID": 377668,
          "Forename": "ÿ≠ŸÖÿ±ŸàŸÜ",
          "Surname": "ÿ±ÿ≤ŸÇŸä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-639068-1756833469.png"
        },
        {
          "ID": 42627,
          "Forename": "ÿ≥ÿØŸäÿ±Ÿä",
          "Surname": "ŸÖÿ≠ŸÜÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-634975-1756833247.png"
        },
        {
          "ID": 40977,
          "Forename": "RAMDANE",
          "Surname": "HITALA",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-635173-1756833423.png"
        },
        {
          "ID": 42567,
          "Forename": "ÿ∫ÿ±ÿ®Ÿä ŸÖÿ≠ŸÖÿØ",
          "Surname": "ÿßŸÖŸäŸÜ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636417-1756833490.png"
        },
        {
          "ID": 377231,
          "Forename": "ÿ≤ÿßŸÖŸàŸÖ",
          "Surname": "ŸàŸÑŸäÿØ",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636420-1756833355.png"
        },
        {
          "ID": 377289,
          "Forename": "OUATTARA DOGNIMIN",
          "Surname": "ROMARIC",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636559-1756832989.png"
        },
        {
          "ID": 505233,
          "Forename": "ÿ≥Ÿäÿ≥ŸàŸÉŸà ÿπŸÑŸä",
          "Surname": "ÿØŸäÿ≥Ÿä",
          "ImageURL": "https://lfp.dz/licence-photo/photo-pro-636563-1756832866.png"
        }
      ]
    }
  ]
}
</file>

<file path="public/SoccerWiki_2025-11-15 - Alg√©rie_1763171594.json">
{
    "PlayerData": [
        {
            "ID": 6775,
            "Forename": "Mehdi",
            "Surname": "KACEM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/6775.png"
        },
        {
            "ID": 29198,
            "Forename": "Foued",
            "Surname": "KADIR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/29198.png"
        },
        {
            "ID": 29200,
            "Forename": "Sofiane",
            "Surname": "FEGHOULI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/29200.png"
        },
        {
            "ID": 35474,
            "Forename": "Ahmed",
            "Surname": "KASHI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/35474.png"
        },
        {
            "ID": 36575,
            "Forename": "Ryad",
            "Surname": "BOUDEBOUZ",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/36575.png"
        },
        {
            "ID": 37852,
            "Forename": "Yannis",
            "Surname": "TAFER",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/37852.png"
        },
        {
            "ID": 38462,
            "Forename": "Adl√®ne",
            "Surname": "GU√âDIOURA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/38462.png"
        },
        {
            "ID": 40988,
            "Forename": "Amir",
            "Surname": "SAYOUD",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/40988.png"
        },
        {
            "ID": 41213,
            "Forename": "Ishak",
            "Surname": "BELFODIL",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/41213.png"
        },
        {
            "ID": 41334,
            "Forename": "Yacine",
            "Surname": "BRAHIMI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/41334.png"
        },
        {
            "ID": 41875,
            "Forename": "Ra√Øs",
            "Surname": "M'BOLHI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/41875.jpg"
        },
        {
            "ID": 42388,
            "Forename": "Anthony",
            "Surname": "OUASFANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/42388.png"
        },
        {
            "ID": 42413,
            "Forename": "Andy",
            "Surname": "DELORT",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/42413.png"
        },
        {
            "ID": 44786,
            "Forename": "Sofiane",
            "Surname": "HANNI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/44786.png"
        },
        {
            "ID": 46042,
            "Forename": "Saphir",
            "Surname": "TA√èDER",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/46042.png"
        },
        {
            "ID": 47039,
            "Forename": "Idriss",
            "Surname": "SAADI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/47039.png"
        },
        {
            "ID": 48200,
            "Forename": "Abdelmoumene",
            "Surname": "DJABOU",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/48200.png"
        },
        {
            "ID": 48520,
            "Forename": "Faouzi",
            "Surname": "GHOULAM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/48520.png"
        },
        {
            "ID": 48942,
            "Forename": "Mourad",
            "Surname": "BERREFANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/48942_1351594235.jpg"
        },
        {
            "ID": 48943,
            "Forename": "Mohamed Khouthir",
            "Surname": "ZITI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/48943.png"
        },
        {
            "ID": 48971,
            "Forename": "Chemseddine",
            "Surname": "NESSAKH",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/48971.jpg"
        },
        {
            "ID": 49002,
            "Forename": "Liassine",
            "Surname": "CADAMURO",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/49002.png"
        },
        {
            "ID": 49316,
            "Forename": "Alexandre",
            "Surname": "OUKIDJA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/49316.png"
        },
        {
            "ID": 49699,
            "Forename": "Mehdi",
            "Surname": "TERKI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/49699.png"
        },
        {
            "ID": 51221,
            "Forename": "El Arbi Hillel",
            "Surname": "SOUDANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/51221.png"
        },
        {
            "ID": 51323,
            "Forename": "A√Øssa",
            "Surname": "MANDI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/51323.png"
        },
        {
            "ID": 51905,
            "Forename": "Rachid",
            "Surname": "GHEZZAL",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/51905.png"
        },
        {
            "ID": 53285,
            "Forename": "Yassine",
            "Surname": "BENZIA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/53285.png"
        },
        {
            "ID": 53301,
            "Forename": "Mehdi",
            "Surname": "ABEID",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/53301.png"
        },
        {
            "ID": 53503,
            "Forename": "Billel",
            "Surname": "OMRANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/53503.png"
        },
        {
            "ID": 54362,
            "Forename": "Nabil",
            "Surname": "GHILAS",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/54362.png"
        },
        {
            "ID": 55098,
            "Forename": "Rachid",
            "Surname": "BOUHENNA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/55098.png"
        },
        {
            "ID": 55968,
            "Forename": "Mehdi",
            "Surname": "ZEFFANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/55968.png"
        },
        {
            "ID": 56360,
            "Forename": "Abderrahmane",
            "Surname": "HACHOUD",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/56360.png"
        },
        {
            "ID": 56410,
            "Forename": "Zinedine",
            "Surname": "FERHAT",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/56410.png"
        },
        {
            "ID": 56942,
            "Forename": "Zineddine",
            "Surname": "MEKKAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/56942.jpg"
        },
        {
            "ID": 58585,
            "Forename": "Farid",
            "Surname": "BOULAYA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/58585.png"
        },
        {
            "ID": 58616,
            "Forename": "Riyad",
            "Surname": "MAHREZ",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/58616.png"
        },
        {
            "ID": 58703,
            "Forename": "Yoan",
            "Surname": "BENYAHYA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/58703.png"
        },
        {
            "ID": 59227,
            "Forename": "Djamel Eddine",
            "Surname": "BENLAMRI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/59227.png"
        },
        {
            "ID": 59417,
            "Forename": "Djamel Eddine",
            "Surname": "IBOUZID√àNE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/59417.png"
        },
        {
            "ID": 59423,
            "Forename": "Abdellah",
            "Surname": "EL MOUD√àNE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/59423.png"
        },
        {
            "ID": 60616,
            "Forename": "Najib",
            "Surname": "AMMARI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/60616.jpg"
        },
        {
            "ID": 62354,
            "Forename": "Farouk",
            "Surname": "CHAFA√è",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/62354.png"
        },
        {
            "ID": 62479,
            "Forename": "Islam",
            "Surname": "SLIMANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/62479.png"
        },
        {
            "ID": 62550,
            "Forename": "Youcef",
            "Surname": "BELA√èLI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/62550.png"
        },
        {
            "ID": 64891,
            "Forename": "Amir",
            "Surname": "KARAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/64891.png"
        },
        {
            "ID": 65126,
            "Forename": "Rachid",
            "Surname": "NADJI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/65126.jpg"
        },
        {
            "ID": 68055,
            "Forename": "Nadjib",
            "Surname": "BAOUIA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/68055.png"
        },
        {
            "ID": 68720,
            "Forename": "Rachid",
            "Surname": "A√èT-ATMANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/68720.png"
        },
        {
            "ID": 69493,
            "Forename": "Sofiane",
            "Surname": "KHEDAIRIA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/69493.png"
        },
        {
            "ID": 69817,
            "Forename": "Anthony",
            "Surname": "MANDREA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/69817.png"
        },
        {
            "ID": 70226,
            "Forename": "Baghdad",
            "Surname": "BOUNEDJAH",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/70226.png"
        },
        {
            "ID": 71093,
            "Forename": "Nabil",
            "Surname": "BENTALEB",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/71093.png"
        },
        {
            "ID": 71458,
            "Forename": "Mohamed",
            "Surname": "SAHNOUNE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/71458.png"
        },
        {
            "ID": 72351,
            "Forename": "Rekrouk",
            "Surname": "MOHA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/72351.jpg"
        },
        {
            "ID": 73559,
            "Forename": "Nacereddine",
            "Surname": "KHOUALED",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/73559.png"
        },
        {
            "ID": 73926,
            "Forename": "Hakim",
            "Surname": "KHOUDI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/73926.jpg"
        },
        {
            "ID": 74340,
            "Forename": "Victor",
            "Surname": "LEKHAL",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/74340.png"
        },
        {
            "ID": 74473,
            "Forename": "Ramy",
            "Surname": "BENSEBAINI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/74473.png"
        },
        {
            "ID": 76174,
            "Forename": "Mehdi",
            "Surname": "JEANNIN",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/76174.png"
        },
        {
            "ID": 76179,
            "Forename": "Haris",
            "Surname": "BELKEBLA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/76179.png"
        },
        {
            "ID": 76283,
            "Forename": "Samir",
            "Surname": "A√èBOUD",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/76283.jpg"
        },
        {
            "ID": 76584,
            "Forename": "Oussama",
            "Surname": "DARFALOU",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/76584.png"
        },
        {
            "ID": 77140,
            "Forename": "Abderaouf",
            "Surname": "BELHANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/77140.jpg"
        },
        {
            "ID": 77144,
            "Forename": "Kheireddine",
            "Surname": "ARROUSSI",
            "ImageURL": ""
        },
        {
            "ID": 77145,
            "Forename": "Sofiane",
            "Surname": "BOUCHAR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/77145.png"
        },
        {
            "ID": 77148,
            "Forename": "Mohamed",
            "Surname": "LAGRA√Ç",
            "ImageURL": ""
        },
        {
            "ID": 77151,
            "Forename": "Issam",
            "Surname": "BAOUZ",
            "ImageURL": ""
        },
        {
            "ID": 77152,
            "Forename": "El Hedi",
            "Surname": "BELAMEIRI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/77152.png"
        },
        {
            "ID": 77153,
            "Forename": "Sid Ali",
            "Surname": "LAMRI",
            "ImageURL": ""
        },
        {
            "ID": 77154,
            "Forename": "Mohamed",
            "Surname": "BILLEL RA√èT",
            "ImageURL": ""
        },
        {
            "ID": 77156,
            "Forename": "Abdelhakim",
            "Surname": "AMOKRANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/77156.png"
        },
        {
            "ID": 77157,
            "Forename": "Mohamed",
            "Surname": "BENYETTOU",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/77157.png"
        },
        {
            "ID": 77158,
            "Forename": "Akram",
            "Surname": "DJAHNIT",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/77158.png"
        },
        {
            "ID": 77161,
            "Forename": "Zahir",
            "Surname": "NEMDIL",
            "ImageURL": ""
        },
        {
            "ID": 77512,
            "Forename": "Mehdi",
            "Surname": "TAHRAT",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/77512.png"
        },
        {
            "ID": 77536,
            "Forename": "Julien",
            "Surname": "L√ìPEZ",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/77536.png"
        },
        {
            "ID": 77777,
            "Forename": "Akim",
            "Surname": "ZEDADKA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/77777.png"
        },
        {
            "ID": 77827,
            "Forename": "Billal",
            "Surname": "SEBAIHI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/77827.png"
        },
        {
            "ID": 78015,
            "Forename": "Elias",
            "Surname": "TAGUELMINT",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/78015.png"
        },
        {
            "ID": 78436,
            "Forename": "Maxime",
            "Surname": "SPANO",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/78436.png"
        },
        {
            "ID": 78445,
            "Forename": "Sa√Ød",
            "Surname": "BENRAHMA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/78445.png"
        },
        {
            "ID": 78568,
            "Forename": "Mohamed",
            "Surname": "FARES",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/78568.png"
        },
        {
            "ID": 78785,
            "Forename": "Ilyes",
            "Surname": "SIDHOUM",
            "ImageURL": ""
        },
        {
            "ID": 78901,
            "Forename": "Karim",
            "Surname": "NEMDIL",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/78901.jpg"
        },
        {
            "ID": 79296,
            "Forename": "Oussama",
            "Surname": "CHITA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/79296.jpg"
        },
        {
            "ID": 79683,
            "Forename": "Tarek",
            "Surname": "CHEURFAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/79683.jpg"
        },
        {
            "ID": 79684,
            "Forename": "Ali",
            "Surname": "AMIRI",
            "ImageURL": ""
        },
        {
            "ID": 79971,
            "Forename": "Mohamed",
            "Surname": "DERRAG",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/79971.jpg"
        },
        {
            "ID": 80143,
            "Forename": "Zakaria",
            "Surname": "BENCHERIFA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/80143.jpg"
        },
        {
            "ID": 81369,
            "Forename": "Nassim",
            "Surname": "ZITOUNI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/81369.png"
        },
        {
            "ID": 81476,
            "Forename": "Ilias",
            "Surname": "HASSANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/81476.png"
        },
        {
            "ID": 81611,
            "Forename": "Isma√´l",
            "Surname": "BENNACER",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/81611.png"
        },
        {
            "ID": 83120,
            "Forename": "Luca",
            "Surname": "ZIDANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/83120.png"
        },
        {
            "ID": 83691,
            "Forename": "Adam",
            "Surname": "OUNAS",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/83691.png"
        },
        {
            "ID": 85530,
            "Forename": "Hicham",
            "Surname": "BELKAROUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/85530.jpg"
        },
        {
            "ID": 87135,
            "Forename": "Okacha",
            "Surname": "HAMZAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/87135.png"
        },
        {
            "ID": 87149,
            "Forename": "Houssem",
            "Surname": "AOUAR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/87149.png"
        },
        {
            "ID": 87561,
            "Forename": "R√©da",
            "Surname": "RABEI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/87561.png"
        },
        {
            "ID": 88079,
            "Forename": "Ahmed",
            "Surname": "TOUBA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/88079.png"
        },
        {
            "ID": 88607,
            "Forename": "Rayan",
            "Surname": "SENHADJI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/88607.png"
        },
        {
            "ID": 88609,
            "Forename": "Sofiane",
            "Surname": "DAHAM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/88609.png"
        },
        {
            "ID": 88627,
            "Forename": "Rafik",
            "Surname": "GUITANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/88627.png"
        },
        {
            "ID": 88895,
            "Forename": "Alexis",
            "Surname": "GUENDOUZ",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/88895.png"
        },
        {
            "ID": 88906,
            "Forename": "Mehdi",
            "Surname": "BENEDDINE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/88906.png"
        },
        {
            "ID": 91061,
            "Forename": "Mehdi",
            "Surname": "L√âRIS",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/91061.png"
        },
        {
            "ID": 91341,
            "Forename": "Chahreddine",
            "Surname": "BOUKHOLDA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/91341.png"
        },
        {
            "ID": 91657,
            "Forename": "Youcef",
            "Surname": "ATAL",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/91657.png"
        },
        {
            "ID": 92599,
            "Forename": "Tayeb",
            "Surname": "MEZIANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/92599.png"
        },
        {
            "ID": 92725,
            "Forename": "Bilal",
            "Surname": "SAYOUD",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/92725.png"
        },
        {
            "ID": 93082,
            "Forename": "Amine",
            "Surname": "GOUIRI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/93082.png"
        },
        {
            "ID": 93280,
            "Forename": "Mehdi",
            "Surname": "MERGHEM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/93280.png"
        },
        {
            "ID": 93316,
            "Forename": "Kelyan",
            "Surname": "GUESSOUM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/93316.png"
        },
        {
            "ID": 93538,
            "Forename": "J√©r√©my",
            "Surname": "BEKHECHI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/93538.png"
        },
        {
            "ID": 96937,
            "Forename": "Farid",
            "Surname": "EL MELALI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/96937.png"
        },
        {
            "ID": 97020,
            "Forename": "Abdelaziz",
            "Surname": "ALI GUECHI",
            "ImageURL": ""
        },
        {
            "ID": 97741,
            "Forename": "Idir",
            "Surname": "BOUTRIF",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/97741.png"
        },
        {
            "ID": 98262,
            "Forename": "Mouhamed",
            "Surname": "BELKHEIR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/98262.png"
        },
        {
            "ID": 98410,
            "Forename": "Dylan",
            "Surname": "FONTANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/98410.png"
        },
        {
            "ID": 99465,
            "Forename": "Rayan",
            "Surname": "A√èT-NOURI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/99465.png"
        },
        {
            "ID": 99580,
            "Forename": "Zakaria",
            "Surname": "NAIDJI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/99580.png"
        },
        {
            "ID": 101272,
            "Forename": "Ayoub",
            "Surname": "ABDELLAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/101272.png"
        },
        {
            "ID": 101332,
            "Forename": "Mehdi",
            "Surname": "BOUDJEMAA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/101332.png"
        },
        {
            "ID": 101373,
            "Forename": "Abderrahmane",
            "Surname": "MEZIANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/101373.png"
        },
        {
            "ID": 101649,
            "Forename": "Yasser",
            "Surname": "LAROUCI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/101649.png"
        },
        {
            "ID": 101659,
            "Forename": "Billal",
            "Surname": "BRAHIMI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/101659.png"
        },
        {
            "ID": 101700,
            "Forename": "Mehdi",
            "Surname": "ZERKANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/101700.png"
        },
        {
            "ID": 101926,
            "Forename": "Oussama",
            "Surname": "ABDELDJELIL",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/101926.png"
        },
        {
            "ID": 101997,
            "Forename": "Ramiz",
            "Surname": "ZERROUKI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/101997.png"
        },
        {
            "ID": 102011,
            "Forename": "Hicham",
            "Surname": "BOUDAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/102011.png"
        },
        {
            "ID": 102168,
            "Forename": "Abdelraouf",
            "Surname": "BENGUIT",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/102168.png"
        },
        {
            "ID": 102384,
            "Forename": "Abdeldjalil",
            "Surname": "MEDIOUB",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/102384.png"
        },
        {
            "ID": 102391,
            "Forename": "Mohamed",
            "Surname": "BENKHEMASSA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/102391.png"
        },
        {
            "ID": 102413,
            "Forename": "Haithem",
            "Surname": "LOUCIF",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/102413.png"
        },
        {
            "ID": 102752,
            "Forename": "Ilyes",
            "Surname": "CHETTI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/102752.png"
        },
        {
            "ID": 102953,
            "Forename": "Islam",
            "Surname": "BAKIR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/102953.png"
        },
        {
            "ID": 103988,
            "Forename": "Mohamed R√©da",
            "Surname": "HALAIMIA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/103988.png"
        },
        {
            "ID": 104115,
            "Forename": "Ishak Talal",
            "Surname": "BOUSSOUF",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/104115.png"
        },
        {
            "ID": 104123,
            "Forename": "Naoufel",
            "Surname": "KHACEF",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/104123.png"
        },
        {
            "ID": 104124,
            "Forename": "A√Øssa",
            "Surname": "BOUDECHICHA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/104124.png"
        },
        {
            "ID": 104476,
            "Forename": "Nassim",
            "Surname": "BENAISSA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/104476.png"
        },
        {
            "ID": 104509,
            "Forename": "Bilal",
            "Surname": "BENKHEDIM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/104509.png"
        },
        {
            "ID": 104645,
            "Forename": "Hamza",
            "Surname": "MOUALI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/104645.png"
        },
        {
            "ID": 104712,
            "Forename": "Adem",
            "Surname": "ZORGANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/104712.png"
        },
        {
            "ID": 105227,
            "Forename": "Yanis",
            "Surname": "HAMACHE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/105227.png"
        },
        {
            "ID": 105693,
            "Forename": "Aymen",
            "Surname": "BOUTOUTAOU",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/105693.png"
        },
        {
            "ID": 105713,
            "Forename": "Jaouen",
            "Surname": "HADJAM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/105713.png"
        },
        {
            "ID": 105723,
            "Forename": "Himad",
            "Surname": "ABDELLI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/105723.png"
        },
        {
            "ID": 105772,
            "Forename": "Ilan",
            "Surname": "KEBBAL",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/105772.png"
        },
        {
            "ID": 106097,
            "Forename": "Adam",
            "Surname": "OUDJANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/106097.png"
        },
        {
            "ID": 106102,
            "Forename": "Teddy",
            "Surname": "BOULHENDI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/106102.png"
        },
        {
            "ID": 106108,
            "Forename": "Jor√®s",
            "Surname": "RAHOU",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/106108.png"
        },
        {
            "ID": 106111,
            "Forename": "Karim",
            "Surname": "ARIBI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/106111.png"
        },
        {
            "ID": 107417,
            "Forename": "Abdelmalek",
            "Surname": "MOKDAD",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/107417.png"
        },
        {
            "ID": 107431,
            "Forename": "Yanis",
            "Surname": "BENSABER",
            "ImageURL": ""
        },
        {
            "ID": 107655,
            "Forename": "Hacene",
            "Surname": "BENALI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/107655.png"
        },
        {
            "ID": 107769,
            "Forename": "Sami",
            "Surname": "BELKORCHIA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/107769.png"
        },
        {
            "ID": 108073,
            "Forename": "Mehdi",
            "Surname": "BOUKASSI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/108073.png"
        },
        {
            "ID": 108188,
            "Forename": "Redouane",
            "Surname": "CHERIFI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/108188.png"
        },
        {
            "ID": 108697,
            "Forename": "Samy",
            "Surname": "FARAJ",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/108697.png"
        },
        {
            "ID": 109127,
            "Forename": "Houcine",
            "Surname": "BENAYADA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/109127.png"
        },
        {
            "ID": 111034,
            "Forename": "Zinedine",
            "Surname": "BOUTM√àNE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/111034.png"
        },
        {
            "ID": 111932,
            "Forename": "Abdelkahar",
            "Surname": "KADRI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/111932.png"
        },
        {
            "ID": 112302,
            "Forename": "Sami",
            "Surname": "GUEDIRI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/112302.png"
        },
        {
            "ID": 112573,
            "Forename": "Mohamed",
            "Surname": "AMOURA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/112573.png"
        },
        {
            "ID": 113283,
            "Forename": "Mohamed",
            "Surname": "BELLOUMI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/113283.png"
        },
        {
            "ID": 113331,
            "Forename": "Karim",
            "Surname": "ZEDADKA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/113331.png"
        },
        {
            "ID": 113886,
            "Forename": "Billal",
            "Surname": "MESSAOUDI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/113886.png"
        },
        {
            "ID": 114768,
            "Forename": "Zaki",
            "Surname": "OUALAH",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/114768.png"
        },
        {
            "ID": 114870,
            "Forename": "Yassine",
            "Surname": "BEN HAMED",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/114870.png"
        },
        {
            "ID": 114894,
            "Forename": "Zakaria",
            "Surname": "SILINI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/114894.png"
        },
        {
            "ID": 115042,
            "Forename": "Wassim",
            "Surname": "AOUACHRIA",
            "ImageURL": ""
        },
        {
            "ID": 115123,
            "Forename": "Joakim",
            "Surname": "KADA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/115123.png"
        },
        {
            "ID": 115136,
            "Forename": "Yanis",
            "Surname": "GUERMOUCHE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/115136.png"
        },
        {
            "ID": 115149,
            "Forename": "Nabil",
            "Surname": "OUENNAS",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/115149.png"
        },
        {
            "ID": 115385,
            "Forename": "Houssam",
            "Surname": "GHACHA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/115385.png"
        },
        {
            "ID": 116185,
            "Forename": "Rafik",
            "Surname": "BELGHALI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/116185.png"
        },
        {
            "ID": 117022,
            "Forename": "Karim",
            "Surname": "BOUHMIDI",
            "ImageURL": ""
        },
        {
            "ID": 117355,
            "Forename": "Mehdi",
            "Surname": "OUAMRI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/117355.png"
        },
        {
            "ID": 117820,
            "Forename": "Yousri",
            "Surname": "BOUZOK",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/117820.png"
        },
        {
            "ID": 118141,
            "Forename": "Yacine",
            "Surname": "TITRAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/118141.png"
        },
        {
            "ID": 118358,
            "Forename": "Ahmed",
            "Surname": "KENDOUCI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/118358.png"
        },
        {
            "ID": 118464,
            "Forename": "Moustapha",
            "Surname": "ZEGHBA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/118464.png"
        },
        {
            "ID": 118637,
            "Forename": "Sofiane",
            "Surname": "BENDEBKA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/118637.png"
        },
        {
            "ID": 118727,
            "Forename": "Mohamed Amine",
            "Surname": "TOUGAI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/118727.png"
        },
        {
            "ID": 119080,
            "Forename": "Ma√Ødine",
            "Surname": "DOUANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/119080.png"
        },
        {
            "ID": 119374,
            "Forename": "Abde",
            "Surname": "REBBACH",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/119374.png"
        },
        {
            "ID": 119408,
            "Forename": "Ewan",
            "Surname": "HATFOUT",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/119408.png"
        },
        {
            "ID": 119411,
            "Forename": "L√©onard",
            "Surname": "AGGOUNE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/119411.png"
        },
        {
            "ID": 119413,
            "Forename": "Zakaria",
            "Surname": "SAIDI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/119413.png"
        },
        {
            "ID": 119414,
            "Forename": "Abderrahmane",
            "Surname": "MEDJADEL",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/119414.png"
        },
        {
            "ID": 119415,
            "Forename": "Farid",
            "Surname": "CHA√ÇL",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/119415.png"
        },
        {
            "ID": 119416,
            "Forename": "Zakaria",
            "Surname": "BOUHALFAYA",
            "ImageURL": ""
        },
        {
            "ID": 119814,
            "Forename": "Nadhir",
            "Surname": "BENBOUALI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/119814.png"
        },
        {
            "ID": 120575,
            "Forename": "Zakaria",
            "Surname": "BENCHA√Ç",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/120575.png"
        },
        {
            "ID": 120607,
            "Forename": "Badredine",
            "Surname": "BOUANANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/120607.png"
        },
        {
            "ID": 120622,
            "Forename": "Adel Amar",
            "Surname": "BELKACEM BOUZIDA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/120622.png"
        },
        {
            "ID": 121096,
            "Forename": "Ayoub",
            "Surname": "TAZOUTI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/121096.png"
        },
        {
            "ID": 121629,
            "Forename": "Belkacem",
            "Surname": "YADADEN",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/121629.png"
        },
        {
            "ID": 121630,
            "Forename": "Aymen",
            "Surname": "CHADLI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/121630.png"
        },
        {
            "ID": 121631,
            "Forename": "Abdelhafid",
            "Surname": "BENAMARA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/121631.png"
        },
        {
            "ID": 121632,
            "Forename": "Hichem Abdelkader",
            "Surname": "TALHA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/121632.png"
        },
        {
            "ID": 121633,
            "Forename": "Sofiane",
            "Surname": "KHADIR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/121633.png"
        },
        {
            "ID": 121634,
            "Forename": "Walid",
            "Surname": "ALLATI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/121634.png"
        },
        {
            "ID": 122901,
            "Forename": "Far√®s",
            "Surname": "CHA√èBI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/122901.png"
        },
        {
            "ID": 122938,
            "Forename": "Camiel",
            "Surname": "NEGHLI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/122938.png"
        },
        {
            "ID": 122959,
            "Forename": "Kevin",
            "Surname": "VAN DEN KERKHOF",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/122959.png"
        },
        {
            "ID": 122971,
            "Forename": "Kamil",
            "Surname": "MANSERI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/122971.png"
        },
        {
            "ID": 123512,
            "Forename": "Mehdi",
            "Surname": "BOUSSA√èD",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/123512.png"
        },
        {
            "ID": 123518,
            "Forename": "Ryad",
            "Surname": "HACHEM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/123518.png"
        },
        {
            "ID": 123672,
            "Forename": "Abdessalem",
            "Surname": "BOUJENFA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/123672.png"
        },
        {
            "ID": 123673,
            "Forename": "Djessine",
            "Surname": "SEBA",
            "ImageURL": ""
        },
        {
            "ID": 124054,
            "Forename": "Houssem",
            "Surname": "MREZIGUE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/124054.png"
        },
        {
            "ID": 124057,
            "Forename": "Mohamed Islam",
            "Surname": "BELKHIR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/124057.png"
        },
        {
            "ID": 124060,
            "Forename": "Mouad",
            "Surname": "HADDED",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/124060.png"
        },
        {
            "ID": 124061,
            "Forename": "Belaid",
            "Surname": "HAMIDI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/124061.png"
        },
        {
            "ID": 124746,
            "Forename": "Mehdi",
            "Surname": "DORVAL",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/124746.png"
        },
        {
            "ID": 125034,
            "Forename": "Yuliwes",
            "Surname": "BELLACHE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/125034.png"
        },
        {
            "ID": 125268,
            "Forename": "Mohamed",
            "Surname": "FARSI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/125268.png"
        },
        {
            "ID": 125325,
            "Forename": "Mehdi",
            "Surname": "BAALOUDJ",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/125325.png"
        },
        {
            "ID": 125538,
            "Forename": "Reda",
            "Surname": "BENCHAA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/125538.png"
        },
        {
            "ID": 125730,
            "Forename": "Noa",
            "Surname": "CERVANTES",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/125730.png"
        },
        {
            "ID": 125812,
            "Forename": "Yanis",
            "Surname": "HADJEM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/125812.png"
        },
        {
            "ID": 125816,
            "Forename": "Samir",
            "Surname": "BELLOUMOU",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/125816.png"
        },
        {
            "ID": 125819,
            "Forename": "Amine",
            "Surname": "HEMIA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/125819.png"
        },
        {
            "ID": 126221,
            "Forename": "Monsef",
            "Surname": "BAKRAR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/126221.png"
        },
        {
            "ID": 127047,
            "Forename": "Youcef",
            "Surname": "BECHOU",
            "ImageURL": ""
        },
        {
            "ID": 127839,
            "Forename": "Ka√Øs",
            "Surname": "BENABDELOUAHED",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/127839.png"
        },
        {
            "ID": 128000,
            "Forename": "Tijany",
            "Surname": "ATALLAH",
            "ImageURL": ""
        },
        {
            "ID": 128023,
            "Forename": "Na√Øm",
            "Surname": "LAIDOUNI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/128023.png"
        },
        {
            "ID": 128149,
            "Forename": "Abdelkader",
            "Surname": "BEDRANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/128149.png"
        },
        {
            "ID": 128195,
            "Forename": "Amine",
            "Surname": "MESSOUSSA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/128195.png"
        },
        {
            "ID": 128226,
            "Forename": "Yannis",
            "Surname": "LAGHA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/128226.png"
        },
        {
            "ID": 128231,
            "Forename": "Younes",
            "Surname": "AITAMER",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/128231.png"
        },
        {
            "ID": 128511,
            "Forename": "Akram",
            "Surname": "BOURAS",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/128511.png"
        },
        {
            "ID": 131481,
            "Forename": "Abdelkarim",
            "Surname": "MAMMAR CHAOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 132670,
            "Forename": "Mehdi",
            "Surname": "PUCH",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/132670.png"
        },
        {
            "ID": 134085,
            "Forename": "Gaya",
            "Surname": "MERBAH",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/134085.png"
        },
        {
            "ID": 134668,
            "Forename": "Adil",
            "Surname": "BOULBINA",
            "ImageURL": ""
        },
        {
            "ID": 134859,
            "Forename": "Mohamed Walid",
            "Surname": "BENCHERIFA",
            "ImageURL": ""
        },
        {
            "ID": 135182,
            "Forename": "Ibrahim",
            "Surname": "MAZA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/135182.png"
        },
        {
            "ID": 135235,
            "Forename": "Ibrahim Ben Halima",
            "Surname": "FARHI",
            "ImageURL": ""
        },
        {
            "ID": 135238,
            "Forename": "Abdelkader",
            "Surname": "KAIBOU",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/135238.png"
        },
        {
            "ID": 135420,
            "Forename": "Imadeddine",
            "Surname": "BOUBEKEUR",
            "ImageURL": ""
        },
        {
            "ID": 135435,
            "Forename": "Abderrahim",
            "Surname": "DEGHMOUM",
            "ImageURL": ""
        },
        {
            "ID": 135929,
            "Forename": "Ivane",
            "Surname": "CHEGRA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/135929.png"
        },
        {
            "ID": 136067,
            "Forename": "Rezki",
            "Surname": "HAMROUNE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/136067.png"
        },
        {
            "ID": 136376,
            "Forename": "Edhy",
            "Surname": "ZULIANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/136376.png"
        },
        {
            "ID": 136441,
            "Forename": "Djibrail",
            "Surname": "DIB",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/136441.png"
        },
        {
            "ID": 136627,
            "Forename": "Noham",
            "Surname": "ABDELLAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/136627.png"
        },
        {
            "ID": 136777,
            "Forename": "Abdelkrim",
            "Surname": "KHECHMAR",
            "ImageURL": ""
        },
        {
            "ID": 137149,
            "Forename": "Hedy",
            "Surname": "CHAABI",
            "ImageURL": ""
        },
        {
            "ID": 137426,
            "Forename": "Yacine",
            "Surname": "GAYA",
            "ImageURL": ""
        },
        {
            "ID": 137454,
            "Forename": "Riad",
            "Surname": "BENAYAD",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/137454.png"
        },
        {
            "ID": 137455,
            "Forename": "Zakaria",
            "Surname": "DRAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/137455.png"
        },
        {
            "ID": 137532,
            "Forename": "Anis",
            "Surname": "HADJ MOUSSA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/137532.png"
        },
        {
            "ID": 138294,
            "Forename": "Kamel",
            "Surname": "SOUFI",
            "ImageURL": ""
        },
        {
            "ID": 138443,
            "Forename": "Nasreddine",
            "Surname": "BOULDJEDRI",
            "ImageURL": ""
        },
        {
            "ID": 138510,
            "Forename": "Sohaib",
            "Surname": "NAIR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/138510.png"
        },
        {
            "ID": 138584,
            "Forename": "Mohamed Amine",
            "Surname": "BOUZIANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/138584.png"
        },
        {
            "ID": 138592,
            "Forename": "Ghiles",
            "Surname": "GUENAOUI",
            "ImageURL": ""
        },
        {
            "ID": 138768,
            "Forename": "Aimen",
            "Surname": "MAHIOUS",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/138768.png"
        },
        {
            "ID": 138940,
            "Forename": "Ibrahim",
            "Surname": "CHENIHI",
            "ImageURL": ""
        },
        {
            "ID": 138942,
            "Forename": "Lahouari",
            "Surname": "TOUIL",
            "ImageURL": ""
        },
        {
            "ID": 138952,
            "Forename": "Ayoub",
            "Surname": "AZZI",
            "ImageURL": ""
        },
        {
            "ID": 138963,
            "Forename": "R√©dha",
            "Surname": "BENSAYAH",
            "ImageURL": ""
        },
        {
            "ID": 138984,
            "Forename": "Amar Khaled",
            "Surname": "N√àCHE",
            "ImageURL": ""
        },
        {
            "ID": 138986,
            "Forename": "Hamid",
            "Surname": "DJAOUCHI",
            "ImageURL": ""
        },
        {
            "ID": 139002,
            "Forename": "Aimen Abdelaziz",
            "Surname": "LAHMERI",
            "ImageURL": ""
        },
        {
            "ID": 139560,
            "Forename": "Rayan",
            "Surname": "KOLLI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/139560.png"
        },
        {
            "ID": 139854,
            "Forename": "Sadek",
            "Surname": "ABDALLAH EL HADJ",
            "ImageURL": ""
        },
        {
            "ID": 140520,
            "Forename": "Amin",
            "Surname": "CHIAKHA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/140520.png"
        },
        {
            "ID": 141209,
            "Forename": "Houari",
            "Surname": "FERHANI",
            "ImageURL": ""
        },
        {
            "ID": 141233,
            "Forename": "Mohamed Amine",
            "Surname": "EZZEMANI",
            "ImageURL": ""
        },
        {
            "ID": 141270,
            "Forename": "Stan",
            "Surname": "BERKANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/141270.png"
        },
        {
            "ID": 142018,
            "Forename": "Moslem",
            "Surname": "ANATOUF",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/142018.png"
        },
        {
            "ID": 142123,
            "Forename": "Zineddine",
            "Surname": "BELAID",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/142123.png"
        },
        {
            "ID": 142124,
            "Forename": "Oussama",
            "Surname": "BENBOUT",
            "ImageURL": ""
        },
        {
            "ID": 142871,
            "Forename": "Jonas",
            "Surname": "ALBENAS",
            "ImageURL": ""
        },
        {
            "ID": 144051,
            "Forename": "Sid Ahmed",
            "Surname": "AISSAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/144051.png"
        },
        {
            "ID": 144293,
            "Forename": "Mohamed El Amine",
            "Surname": "RAMDAOUI",
            "ImageURL": ""
        },
        {
            "ID": 144974,
            "Forename": "Ben Ahmed",
            "Surname": "KOHILI",
            "ImageURL": ""
        },
        {
            "ID": 144975,
            "Forename": "Redouane",
            "Surname": "BERKANE",
            "ImageURL": ""
        },
        {
            "ID": 144976,
            "Forename": "Oussama",
            "Surname": "MELLALA",
            "ImageURL": ""
        },
        {
            "ID": 144978,
            "Forename": "Taha Yassine",
            "Surname": "TAHAR",
            "ImageURL": ""
        },
        {
            "ID": 145321,
            "Forename": "Toufik",
            "Surname": "CHERIFI",
            "ImageURL": ""
        },
        {
            "ID": 145604,
            "Forename": "Abderraouf",
            "Surname": "OTHMANI",
            "ImageURL": ""
        },
        {
            "ID": 145900,
            "Forename": "Anis",
            "Surname": "BAKHOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 145994,
            "Forename": "Idris",
            "Surname": "BOUNAAS",
            "ImageURL": ""
        },
        {
            "ID": 146106,
            "Forename": "Mohamed",
            "Surname": "AZZI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/146106.png"
        },
        {
            "ID": 146107,
            "Forename": "Acheref",
            "Surname": "BOUDRAMA",
            "ImageURL": ""
        },
        {
            "ID": 146108,
            "Forename": "Mokhtar",
            "Surname": "BELKHITER",
            "ImageURL": ""
        },
        {
            "ID": 146109,
            "Forename": "Chouaib",
            "Surname": "KEDDAD",
            "ImageURL": ""
        },
        {
            "ID": 146111,
            "Forename": "Youcef Amine",
            "Surname": "LAOUAFI",
            "ImageURL": ""
        },
        {
            "ID": 146114,
            "Forename": "Redouane",
            "Surname": "MAACHOU",
            "ImageURL": ""
        },
        {
            "ID": 146115,
            "Forename": "Mounir",
            "Surname": "BELHAIDJA",
            "ImageURL": ""
        },
        {
            "ID": 146118,
            "Forename": "Housseyn",
            "Surname": "SELMI",
            "ImageURL": ""
        },
        {
            "ID": 146121,
            "Forename": "Merouane",
            "Surname": "ZERROUKI",
            "ImageURL": ""
        },
        {
            "ID": 146202,
            "Forename": "Juba",
            "Surname": "CHIRANI",
            "ImageURL": ""
        },
        {
            "ID": 146203,
            "Forename": "Abdessamed",
            "Surname": "BOUNACER",
            "ImageURL": ""
        },
        {
            "ID": 146204,
            "Forename": "Abdelkader",
            "Surname": "BOUTICHE",
            "ImageURL": ""
        },
        {
            "ID": 146266,
            "Forename": "Oussama",
            "Surname": "AMAR",
            "ImageURL": ""
        },
        {
            "ID": 146296,
            "Forename": "Oussama",
            "Surname": "BARKAT",
            "ImageURL": ""
        },
        {
            "ID": 146297,
            "Forename": "Mustapha",
            "Surname": "BOUCHINA",
            "ImageURL": ""
        },
        {
            "ID": 146298,
            "Forename": "Nabil",
            "Surname": "LAMARA",
            "ImageURL": ""
        },
        {
            "ID": 146299,
            "Forename": "Hocine",
            "Surname": "DEHIRI",
            "ImageURL": ""
        },
        {
            "ID": 146300,
            "Forename": "Adem",
            "Surname": "ALILET",
            "ImageURL": ""
        },
        {
            "ID": 146301,
            "Forename": "Sa√¢di",
            "Surname": "RADOUANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/146301.png"
        },
        {
            "ID": 146302,
            "Forename": "Abdelmoumen",
            "Surname": "SIFOUR",
            "ImageURL": ""
        },
        {
            "ID": 146303,
            "Forename": "Abdelkrim",
            "Surname": "NAMANI",
            "ImageURL": ""
        },
        {
            "ID": 146305,
            "Forename": "Omar",
            "Surname": "EMBAREK",
            "ImageURL": ""
        },
        {
            "ID": 146306,
            "Forename": "Mohamed",
            "Surname": "AIT EL HADJ",
            "ImageURL": ""
        },
        {
            "ID": 146307,
            "Forename": "Salim",
            "Surname": "BOUKHANCHOUCHE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/146307.png"
        },
        {
            "ID": 146308,
            "Forename": "Islam",
            "Surname": "MERILI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/146308.png"
        },
        {
            "ID": 146309,
            "Forename": "Brahim",
            "Surname": "BENZAZA",
            "ImageURL": ""
        },
        {
            "ID": 146310,
            "Forename": "Abderrahmane",
            "Surname": "BACHA",
            "ImageURL": ""
        },
        {
            "ID": 146312,
            "Forename": "Khaled",
            "Surname": "BOUSSELIOU",
            "ImageURL": ""
        },
        {
            "ID": 146313,
            "Forename": "Ismail",
            "Surname": "BELKACEMI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/146313.png"
        },
        {
            "ID": 146314,
            "Forename": "Oussama",
            "Surname": "BELATR√àCHE",
            "ImageURL": ""
        },
        {
            "ID": 146315,
            "Forename": "Seif Eddine",
            "Surname": "BELKHIR",
            "ImageURL": ""
        },
        {
            "ID": 146316,
            "Forename": "Abdelatif",
            "Surname": "RAMDANE",
            "ImageURL": ""
        },
        {
            "ID": 146317,
            "Forename": "Oussama",
            "Surname": "LITIM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/146317.png"
        },
        {
            "ID": 146318,
            "Forename": "Abdelkader",
            "Surname": "MENEZLA",
            "ImageURL": ""
        },
        {
            "ID": 146319,
            "Forename": "Ayoub",
            "Surname": "GHEZALA",
            "ImageURL": ""
        },
        {
            "ID": 146320,
            "Forename": "Kamel",
            "Surname": "HAMIDI",
            "ImageURL": ""
        },
        {
            "ID": 146321,
            "Forename": "Massinissa",
            "Surname": "BENCHELOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 146322,
            "Forename": "Dalil",
            "Surname": "HASSEN-KHODJA",
            "ImageURL": ""
        },
        {
            "ID": 146350,
            "Forename": "Khalid",
            "Surname": "DAHAMNI",
            "ImageURL": ""
        },
        {
            "ID": 146351,
            "Forename": "Ammar",
            "Surname": "EL ORFI",
            "ImageURL": ""
        },
        {
            "ID": 146352,
            "Forename": "Badr Eddine",
            "Surname": "TOUKI",
            "ImageURL": ""
        },
        {
            "ID": 146353,
            "Forename": "Larbi",
            "Surname": "TABTI",
            "ImageURL": ""
        },
        {
            "ID": 146354,
            "Forename": "Fethallah",
            "Surname": "TAHAR",
            "ImageURL": ""
        },
        {
            "ID": 146356,
            "Forename": "Mehdi",
            "Surname": "BOUCHERIT",
            "ImageURL": ""
        },
        {
            "ID": 146357,
            "Forename": "Oualaa Moundhir",
            "Surname": "BOUZEKRI",
            "ImageURL": ""
        },
        {
            "ID": 146359,
            "Forename": "Kheiredine",
            "Surname": "MERZOUGUI",
            "ImageURL": ""
        },
        {
            "ID": 146360,
            "Forename": "Soufiane",
            "Surname": "BAYAZID",
            "ImageURL": ""
        },
        {
            "ID": 146361,
            "Forename": "Zakaria",
            "Surname": "BOUKEBAL",
            "ImageURL": ""
        },
        {
            "ID": 146362,
            "Forename": "Fouad",
            "Surname": "KERMICHE",
            "ImageURL": ""
        },
        {
            "ID": 146363,
            "Forename": "Sid Ali",
            "Surname": "KHERBOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 146364,
            "Forename": "Idir",
            "Surname": "MOKEDDEM",
            "ImageURL": ""
        },
        {
            "ID": 146365,
            "Forename": "Abdellah",
            "Surname": "BENDOUMA",
            "ImageURL": ""
        },
        {
            "ID": 146366,
            "Forename": "Ahmed",
            "Surname": "AIT ABDESSLEM",
            "ImageURL": ""
        },
        {
            "ID": 146367,
            "Forename": "Mohamed R√©da",
            "Surname": "HAMIDI",
            "ImageURL": ""
        },
        {
            "ID": 146368,
            "Forename": "Youcef",
            "Surname": "DOUAR",
            "ImageURL": ""
        },
        {
            "ID": 146369,
            "Forename": "Mokhtar",
            "Surname": "FERRAHI",
            "ImageURL": ""
        },
        {
            "ID": 146370,
            "Forename": "Mohamed Hady",
            "Surname": "SAHNOUN",
            "ImageURL": ""
        },
        {
            "ID": 146371,
            "Forename": "Toufik",
            "Surname": "MOUSSAOUI",
            "ImageURL": ""
        },
        {
            "ID": 146373,
            "Forename": "Abdelhak",
            "Surname": "BELMAAZIZ",
            "ImageURL": ""
        },
        {
            "ID": 146374,
            "Forename": "Abdeldjalil",
            "Surname": "TAHRI",
            "ImageURL": ""
        },
        {
            "ID": 146375,
            "Forename": "Chouaib",
            "Surname": "BOULKABOUL",
            "ImageURL": ""
        },
        {
            "ID": 146376,
            "Forename": "Hicham",
            "Surname": "MESSIAD",
            "ImageURL": ""
        },
        {
            "ID": 146453,
            "Forename": "Abderrahmane",
            "Surname": "BERKOUNE",
            "ImageURL": ""
        },
        {
            "ID": 146454,
            "Forename": "Djaber",
            "Surname": "KAASSIS",
            "ImageURL": ""
        },
        {
            "ID": 146456,
            "Forename": "Aymen Zakarya",
            "Surname": "SAIS",
            "ImageURL": ""
        },
        {
            "ID": 146457,
            "Forename": "Zerroug",
            "Surname": "BOUCIF",
            "ImageURL": ""
        },
        {
            "ID": 146458,
            "Forename": "Mustapha Djabril",
            "Surname": "SOUKKOU",
            "ImageURL": ""
        },
        {
            "ID": 146459,
            "Forename": "Mohamed",
            "Surname": "BOUKERMA",
            "ImageURL": ""
        },
        {
            "ID": 146460,
            "Forename": "Seifeddine",
            "Surname": "CHETTIH",
            "ImageURL": ""
        },
        {
            "ID": 146461,
            "Forename": "Chamseddine",
            "Surname": "DERRADJI",
            "ImageURL": ""
        },
        {
            "ID": 146462,
            "Forename": "La√Ød Chahine",
            "Surname": "BELLAOUEL",
            "ImageURL": ""
        },
        {
            "ID": 146463,
            "Forename": "Amir",
            "Surname": "BELAILI",
            "ImageURL": ""
        },
        {
            "ID": 146464,
            "Forename": "Oussama",
            "Surname": "MEDDAHI",
            "ImageURL": ""
        },
        {
            "ID": 146465,
            "Forename": "Mohamed Amine",
            "Surname": "MADANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/146465.png"
        },
        {
            "ID": 146466,
            "Forename": "Houari",
            "Surname": "BAOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 146467,
            "Forename": "Nasreddine",
            "Surname": "ZAALANI",
            "ImageURL": ""
        },
        {
            "ID": 146468,
            "Forename": "Aimen",
            "Surname": "BOUGUERRA",
            "ImageURL": ""
        },
        {
            "ID": 146469,
            "Forename": "Abdelmalek",
            "Surname": "NECIR",
            "ImageURL": ""
        },
        {
            "ID": 146470,
            "Forename": "Kheireddine",
            "Surname": "BOUSSOUF",
            "ImageURL": ""
        },
        {
            "ID": 146471,
            "Forename": "Miloud",
            "Surname": "REBIAI",
            "ImageURL": ""
        },
        {
            "ID": 146472,
            "Forename": "Abdennour Iheb",
            "Surname": "BELHOCINI",
            "ImageURL": ""
        },
        {
            "ID": 146473,
            "Forename": "Hadji",
            "Surname": "CHEKAL AFFARI",
            "ImageURL": ""
        },
        {
            "ID": 146474,
            "Forename": "Zakaria",
            "Surname": "MESSIBAH",
            "ImageURL": ""
        },
        {
            "ID": 146475,
            "Forename": "Mohamed",
            "Surname": "BENCHAIRA",
            "ImageURL": ""
        },
        {
            "ID": 146476,
            "Forename": "Messala",
            "Surname": "MERBAH",
            "ImageURL": ""
        },
        {
            "ID": 146477,
            "Forename": "Brahim",
            "Surname": "DIB",
            "ImageURL": ""
        },
        {
            "ID": 146478,
            "Forename": "Ishak Salaheddine",
            "Surname": "HARRARI",
            "ImageURL": ""
        },
        {
            "ID": 146480,
            "Forename": "Mounder",
            "Surname": "TEMINE",
            "ImageURL": ""
        },
        {
            "ID": 146481,
            "Forename": "Ahmed",
            "Surname": "KHALDI",
            "ImageURL": ""
        },
        {
            "ID": 146482,
            "Forename": "Mohamed Amine",
            "Surname": "BENMESSABIH",
            "ImageURL": ""
        },
        {
            "ID": 146486,
            "Forename": "Mohamed Imad",
            "Surname": "REGUIEG",
            "ImageURL": ""
        },
        {
            "ID": 146487,
            "Forename": "Abdelmoumen",
            "Surname": "CHIKHI",
            "ImageURL": ""
        },
        {
            "ID": 146488,
            "Forename": "Belkacem",
            "Surname": "BRAHIMI",
            "ImageURL": ""
        },
        {
            "ID": 146489,
            "Forename": "Tarek",
            "Surname": "AGGOUN",
            "ImageURL": ""
        },
        {
            "ID": 146490,
            "Forename": "Yacine",
            "Surname": "ZEGHAD",
            "ImageURL": ""
        },
        {
            "ID": 146491,
            "Forename": "Drice",
            "Surname": "CHAABI",
            "ImageURL": ""
        },
        {
            "ID": 146492,
            "Forename": "Mohamed Lotfi Anis",
            "Surname": "OSMANI",
            "ImageURL": ""
        },
        {
            "ID": 146493,
            "Forename": "Imad",
            "Surname": "BENCHLEF",
            "ImageURL": ""
        },
        {
            "ID": 146494,
            "Forename": "Zineddine",
            "Surname": "BENBOULAID",
            "ImageURL": ""
        },
        {
            "ID": 146495,
            "Forename": "Rachid",
            "Surname": "BOUMESSOUS",
            "ImageURL": ""
        },
        {
            "ID": 146497,
            "Forename": "Taher",
            "Surname": "BENKHELIFA",
            "ImageURL": ""
        },
        {
            "ID": 146498,
            "Forename": "Salah Abd Etouab",
            "Surname": "BOUCHAMA",
            "ImageURL": ""
        },
        {
            "ID": 146499,
            "Forename": "Abdesslem",
            "Surname": "BOUCHOUAREB",
            "ImageURL": ""
        },
        {
            "ID": 146500,
            "Forename": "Youcef",
            "Surname": "AOUISSI",
            "ImageURL": ""
        },
        {
            "ID": 146501,
            "Forename": "Ramdane",
            "Surname": "HITALA",
            "ImageURL": ""
        },
        {
            "ID": 146502,
            "Forename": "Mohamed",
            "Surname": "BENCHOUCHA",
            "ImageURL": ""
        },
        {
            "ID": 146503,
            "Forename": "Moulay Abdelaziz",
            "Surname": "ABDELKADER",
            "ImageURL": ""
        },
        {
            "ID": 146504,
            "Forename": "Walid",
            "Surname": "ZAMOUM",
            "ImageURL": ""
        },
        {
            "ID": 146505,
            "Forename": "Ammar",
            "Surname": "OUKIL",
            "ImageURL": ""
        },
        {
            "ID": 146506,
            "Forename": "Abdelhamid",
            "Surname": "DRIS",
            "ImageURL": ""
        },
        {
            "ID": 146507,
            "Forename": "Fares",
            "Surname": "NECHAT",
            "ImageURL": ""
        },
        {
            "ID": 146508,
            "Forename": "Ahmed",
            "Surname": "MAMMERI",
            "ImageURL": ""
        },
        {
            "ID": 146509,
            "Forename": "Oussama",
            "Surname": "GATAL",
            "ImageURL": ""
        },
        {
            "ID": 146510,
            "Forename": "Khaled",
            "Surname": "BOUHAKAK",
            "ImageURL": ""
        },
        {
            "ID": 146511,
            "Forename": "Moussa",
            "Surname": "BENZAID",
            "ImageURL": ""
        },
        {
            "ID": 146512,
            "Forename": "Seif",
            "Surname": "BENRABAH",
            "ImageURL": ""
        },
        {
            "ID": 146513,
            "Forename": "Fouad",
            "Surname": "ZEGRAR",
            "ImageURL": ""
        },
        {
            "ID": 146514,
            "Forename": "Mohamed Idir",
            "Surname": "HADID",
            "ImageURL": ""
        },
        {
            "ID": 146515,
            "Forename": "Chamseddine",
            "Surname": "RAHMANI",
            "ImageURL": ""
        },
        {
            "ID": 146516,
            "Forename": "Massinissa",
            "Surname": "NAIT SALEM",
            "ImageURL": ""
        },
        {
            "ID": 146517,
            "Forename": "Aymen",
            "Surname": "BENDAOUD",
            "ImageURL": ""
        },
        {
            "ID": 146518,
            "Forename": "R√©da",
            "Surname": "BOUMECHRA",
            "ImageURL": ""
        },
        {
            "ID": 146519,
            "Forename": "Faik",
            "Surname": "AMRANE",
            "ImageURL": ""
        },
        {
            "ID": 146520,
            "Forename": "Sid Ahmed",
            "Surname": "MATALLAH",
            "ImageURL": ""
        },
        {
            "ID": 146521,
            "Forename": "Ali",
            "Surname": "AMRICHE",
            "ImageURL": ""
        },
        {
            "ID": 146523,
            "Forename": "Massinissa",
            "Surname": "NEZLA",
            "ImageURL": ""
        },
        {
            "ID": 146524,
            "Forename": "Adem",
            "Surname": "REDJEM",
            "ImageURL": ""
        },
        {
            "ID": 146525,
            "Forename": "Dadi El Hocine",
            "Surname": "MOUAKI",
            "ImageURL": ""
        },
        {
            "ID": 146526,
            "Forename": "Kouceila",
            "Surname": "BOUALIA",
            "ImageURL": ""
        },
        {
            "ID": 146532,
            "Forename": "Abdelkader",
            "Surname": "TAMIMI",
            "ImageURL": ""
        },
        {
            "ID": 146533,
            "Forename": "Abderrahmane",
            "Surname": "NEHARI",
            "ImageURL": ""
        },
        {
            "ID": 146534,
            "Forename": "H'mida",
            "Surname": "SALAH",
            "ImageURL": ""
        },
        {
            "ID": 146535,
            "Forename": "Ahmed",
            "Surname": "KERROUM",
            "ImageURL": ""
        },
        {
            "ID": 146536,
            "Forename": "Mohammed",
            "Surname": "HAMADI",
            "ImageURL": ""
        },
        {
            "ID": 146537,
            "Forename": "Faris",
            "Surname": "BOUKERRIT",
            "ImageURL": ""
        },
        {
            "ID": 146538,
            "Forename": "Bachir",
            "Surname": "DELLA KRACHAI",
            "ImageURL": ""
        },
        {
            "ID": 146540,
            "Forename": "Ilyes",
            "Surname": "CHERIF EL OUAZZANI",
            "ImageURL": ""
        },
        {
            "ID": 146541,
            "Forename": "Seddik",
            "Surname": "SENHADJI",
            "ImageURL": ""
        },
        {
            "ID": 146544,
            "Forename": "Amine",
            "Surname": "BENBELAID",
            "ImageURL": ""
        },
        {
            "ID": 146546,
            "Forename": "Imed",
            "Surname": "SAIHI",
            "ImageURL": ""
        },
        {
            "ID": 146547,
            "Forename": "Merouane",
            "Surname": "DAHAR",
            "ImageURL": ""
        },
        {
            "ID": 146548,
            "Forename": "Salim",
            "Surname": "BENNAI",
            "ImageURL": ""
        },
        {
            "ID": 146549,
            "Forename": "Juba",
            "Surname": "OUKACI",
            "ImageURL": ""
        },
        {
            "ID": 146554,
            "Forename": "Mohamed Hacene",
            "Surname": "BENGRINA",
            "ImageURL": ""
        },
        {
            "ID": 146555,
            "Forename": "Zoubir",
            "Surname": "MOTRANI",
            "ImageURL": ""
        },
        {
            "ID": 146556,
            "Forename": "Mourad",
            "Surname": "BENAYAD",
            "ImageURL": ""
        },
        {
            "ID": 146557,
            "Forename": "Oualid",
            "Surname": "ARDJI",
            "ImageURL": ""
        },
        {
            "ID": 146558,
            "Forename": "Sofiane Yacine",
            "Surname": "GUENINA",
            "ImageURL": ""
        },
        {
            "ID": 146559,
            "Forename": "Merouane",
            "Surname": "BOUSSALEM",
            "ImageURL": ""
        },
        {
            "ID": 146563,
            "Forename": "Mohamed Roufid",
            "Surname": "ARAB",
            "ImageURL": ""
        },
        {
            "ID": 146773,
            "Forename": "Fateh",
            "Surname": "ACHOUR",
            "ImageURL": ""
        },
        {
            "ID": 146774,
            "Forename": "Abderrahim",
            "Surname": "HAMRA",
            "ImageURL": ""
        },
        {
            "ID": 146775,
            "Forename": "Abdelhak",
            "Surname": "DEBBARI",
            "ImageURL": ""
        },
        {
            "ID": 146777,
            "Forename": "Achref",
            "Surname": "ABADA",
            "ImageURL": ""
        },
        {
            "ID": 146778,
            "Forename": "Sofiane",
            "Surname": "KACEM",
            "ImageURL": ""
        },
        {
            "ID": 146779,
            "Forename": "Mohamed",
            "Surname": "ALAOUCHICHE",
            "ImageURL": ""
        },
        {
            "ID": 146780,
            "Forename": "Redouane",
            "Surname": "BOUNOUA",
            "ImageURL": ""
        },
        {
            "ID": 146781,
            "Forename": "Kamel Mohand Seghir",
            "Surname": "BELARBI",
            "ImageURL": ""
        },
        {
            "ID": 146782,
            "Forename": "Mustapha",
            "Surname": "ALILI",
            "ImageURL": ""
        },
        {
            "ID": 146783,
            "Forename": "Ahmida",
            "Surname": "ZENASNI",
            "ImageURL": ""
        },
        {
            "ID": 146784,
            "Forename": "Juba",
            "Surname": "AGUIEB",
            "ImageURL": ""
        },
        {
            "ID": 146785,
            "Forename": "Abdelkader",
            "Surname": "BOUSSAID",
            "ImageURL": ""
        },
        {
            "ID": 146786,
            "Forename": "Toufik",
            "Surname": "ADDADI",
            "ImageURL": ""
        },
        {
            "ID": 146788,
            "Forename": "Abderrahmane",
            "Surname": "BOURDIM",
            "ImageURL": ""
        },
        {
            "ID": 146789,
            "Forename": "Redouane",
            "Surname": "ZERDOUM",
            "ImageURL": ""
        },
        {
            "ID": 146790,
            "Forename": "Ayoub",
            "Surname": "KERSSANI",
            "ImageURL": ""
        },
        {
            "ID": 146791,
            "Forename": "Boualem Abdelghani",
            "Surname": "SRYER",
            "ImageURL": ""
        },
        {
            "ID": 146792,
            "Forename": "Zakaria",
            "Surname": "HADDOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 146793,
            "Forename": "Dhiya Eddine",
            "Surname": "BENYAHIA",
            "ImageURL": ""
        },
        {
            "ID": 146794,
            "Forename": "Yacine",
            "Surname": "ALIANE",
            "ImageURL": ""
        },
        {
            "ID": 146796,
            "Forename": "Rabah",
            "Surname": "HADDADOU",
            "ImageURL": ""
        },
        {
            "ID": 146797,
            "Forename": "Fay√ßal",
            "Surname": "MEBARKI",
            "ImageURL": ""
        },
        {
            "ID": 146798,
            "Forename": "Abdenour",
            "Surname": "BARKAT",
            "ImageURL": ""
        },
        {
            "ID": 146799,
            "Forename": "Benali",
            "Surname": "BENAMAR",
            "ImageURL": ""
        },
        {
            "ID": 146800,
            "Forename": "Riyane",
            "Surname": "AKACEM",
            "ImageURL": ""
        },
        {
            "ID": 146801,
            "Forename": "Marwane",
            "Surname": "KHELIF",
            "ImageURL": ""
        },
        {
            "ID": 146802,
            "Forename": "Mohamed",
            "Surname": "AMRANE",
            "ImageURL": ""
        },
        {
            "ID": 146803,
            "Forename": "Abdennasser",
            "Surname": "DJOUDAR",
            "ImageURL": ""
        },
        {
            "ID": 146804,
            "Forename": "Aymen",
            "Surname": "MOUYET",
            "ImageURL": ""
        },
        {
            "ID": 146805,
            "Forename": "Walid",
            "Surname": "OUABDI",
            "ImageURL": ""
        },
        {
            "ID": 146806,
            "Forename": "Tahir Nadhir",
            "Surname": "BOUDOUHIOU",
            "ImageURL": ""
        },
        {
            "ID": 146807,
            "Forename": "Ilyes",
            "Surname": "ATALLAH",
            "ImageURL": ""
        },
        {
            "ID": 146808,
            "Forename": "Moslah",
            "Surname": "KHANNOUSSI",
            "ImageURL": ""
        },
        {
            "ID": 146809,
            "Forename": "Mohamed Amine",
            "Surname": "OUIS",
            "ImageURL": ""
        },
        {
            "ID": 146810,
            "Forename": "Adel",
            "Surname": "BOUCHIBA",
            "ImageURL": ""
        },
        {
            "ID": 146811,
            "Forename": "Khathir",
            "Surname": "BAAZIZ",
            "ImageURL": ""
        },
        {
            "ID": 146812,
            "Forename": "Mohamed",
            "Surname": "TAIB",
            "ImageURL": ""
        },
        {
            "ID": 146814,
            "Forename": "Cheikh",
            "Surname": "AMIOUR",
            "ImageURL": ""
        },
        {
            "ID": 146815,
            "Forename": "Mohamed El Amine",
            "Surname": "HAMMIA",
            "ImageURL": ""
        },
        {
            "ID": 146816,
            "Forename": "Nour El Islam",
            "Surname": "FETTOUHI",
            "ImageURL": ""
        },
        {
            "ID": 146817,
            "Forename": "Abdelhak",
            "Surname": "ABDELHAFID",
            "ImageURL": ""
        },
        {
            "ID": 146818,
            "Forename": "Mohamed",
            "Surname": "SOUIBAA",
            "ImageURL": ""
        },
        {
            "ID": 146819,
            "Forename": "Ismail",
            "Surname": "SAADI",
            "ImageURL": ""
        },
        {
            "ID": 146820,
            "Forename": "Abdeljalil",
            "Surname": "SA√ÇD",
            "ImageURL": ""
        },
        {
            "ID": 146821,
            "Forename": "Moncef",
            "Surname": "MEROUANI",
            "ImageURL": ""
        },
        {
            "ID": 146823,
            "Forename": "Sabri",
            "Surname": "CHERAITIA",
            "ImageURL": ""
        },
        {
            "ID": 146824,
            "Forename": "Amir",
            "Surname": "LAIDOUNI",
            "ImageURL": ""
        },
        {
            "ID": 146825,
            "Forename": "M'hammed",
            "Surname": "MEROUANI",
            "ImageURL": ""
        },
        {
            "ID": 146826,
            "Forename": "Chemseddine",
            "Surname": "LAKEHAL",
            "ImageURL": ""
        },
        {
            "ID": 146827,
            "Forename": "Ismail",
            "Surname": "GHANEMI",
            "ImageURL": ""
        },
        {
            "ID": 146828,
            "Forename": "Ibrahim",
            "Surname": "BEKAKCHI",
            "ImageURL": ""
        },
        {
            "ID": 146829,
            "Forename": "Aymen",
            "Surname": "ATTOU",
            "ImageURL": ""
        },
        {
            "ID": 146830,
            "Forename": "Salah Eddine",
            "Surname": "CHEMOURI",
            "ImageURL": ""
        },
        {
            "ID": 146831,
            "Forename": "Abdelkadir",
            "Surname": "SALHI",
            "ImageURL": ""
        },
        {
            "ID": 146832,
            "Forename": "Mohamed Tayeb",
            "Surname": "CHERIF",
            "ImageURL": ""
        },
        {
            "ID": 146833,
            "Forename": "Benharat",
            "Surname": "ALOUANE",
            "ImageURL": ""
        },
        {
            "ID": 146834,
            "Forename": "Karm",
            "Surname": "BENKOUIDER",
            "ImageURL": ""
        },
        {
            "ID": 146836,
            "Forename": "Zakarya",
            "Surname": "KEMOUKH",
            "ImageURL": ""
        },
        {
            "ID": 146837,
            "Forename": "Mohamed Es Said",
            "Surname": "BOURAHLA",
            "ImageURL": ""
        },
        {
            "ID": 146839,
            "Forename": "Fouad",
            "Surname": "HADDED",
            "ImageURL": ""
        },
        {
            "ID": 146841,
            "Forename": "Mohammed",
            "Surname": "DJAIDJA",
            "ImageURL": ""
        },
        {
            "ID": 146842,
            "Forename": "Mounib",
            "Surname": "BENMERZOUG",
            "ImageURL": ""
        },
        {
            "ID": 146843,
            "Forename": "Yanis",
            "Surname": "BOUGHANEM",
            "ImageURL": ""
        },
        {
            "ID": 146844,
            "Forename": "Chakib",
            "Surname": "BARKANI",
            "ImageURL": ""
        },
        {
            "ID": 146845,
            "Forename": "Hamza",
            "Surname": "DEMANE",
            "ImageURL": ""
        },
        {
            "ID": 146846,
            "Forename": "Imad",
            "Surname": "MOUSSAOUI",
            "ImageURL": ""
        },
        {
            "ID": 146847,
            "Forename": "Bouzid",
            "Surname": "DADACHE",
            "ImageURL": ""
        },
        {
            "ID": 146848,
            "Forename": "Mostafa",
            "Surname": "BERKANE",
            "ImageURL": ""
        },
        {
            "ID": 146849,
            "Forename": "La√Ød",
            "Surname": "SA√èDI",
            "ImageURL": ""
        },
        {
            "ID": 146850,
            "Forename": "Billal",
            "Surname": "BOUKAROUM",
            "ImageURL": ""
        },
        {
            "ID": 146851,
            "Forename": "Aymen",
            "Surname": "CHAHMAT",
            "ImageURL": ""
        },
        {
            "ID": 146852,
            "Forename": "Ahmed Redha",
            "Surname": "HOUHOU",
            "ImageURL": ""
        },
        {
            "ID": 146853,
            "Forename": "Ayoub",
            "Surname": "DERBAL",
            "ImageURL": ""
        },
        {
            "ID": 146855,
            "Forename": "Saleheddine",
            "Surname": "BENLARIBI",
            "ImageURL": ""
        },
        {
            "ID": 146856,
            "Forename": "Adel",
            "Surname": "LAKHDARI",
            "ImageURL": ""
        },
        {
            "ID": 146857,
            "Forename": "Abdelhak",
            "Surname": "BELKACEMI",
            "ImageURL": ""
        },
        {
            "ID": 146858,
            "Forename": "Tarek",
            "Surname": "ADOUANE",
            "ImageURL": ""
        },
        {
            "ID": 146859,
            "Forename": "Abderrahmane",
            "Surname": "AMRI",
            "ImageURL": ""
        },
        {
            "ID": 146860,
            "Forename": "Ahmed",
            "Surname": "ABDELKADER",
            "ImageURL": ""
        },
        {
            "ID": 146869,
            "Forename": "Hatem",
            "Surname": "DAKHIA",
            "ImageURL": ""
        },
        {
            "ID": 146870,
            "Forename": "Yacine",
            "Surname": "MEDANE",
            "ImageURL": ""
        },
        {
            "ID": 146871,
            "Forename": "Hamza",
            "Surname": "OUNNAS",
            "ImageURL": ""
        },
        {
            "ID": 146872,
            "Forename": "Mustapha",
            "Surname": "ZEGHNOUN",
            "ImageURL": ""
        },
        {
            "ID": 146873,
            "Forename": "Tayeb",
            "Surname": "HAMOUDI",
            "ImageURL": ""
        },
        {
            "ID": 146874,
            "Forename": "Mohamed Larbi",
            "Surname": "KHOUALED",
            "ImageURL": ""
        },
        {
            "ID": 146875,
            "Forename": "Abdellah",
            "Surname": "DAOUADJI",
            "ImageURL": ""
        },
        {
            "ID": 146876,
            "Forename": "Riad Wael",
            "Surname": "RAHMOUN",
            "ImageURL": ""
        },
        {
            "ID": 146877,
            "Forename": "Nizar",
            "Surname": "TAMER",
            "ImageURL": ""
        },
        {
            "ID": 146878,
            "Forename": "Khalil",
            "Surname": "DARFALOU",
            "ImageURL": ""
        },
        {
            "ID": 146879,
            "Forename": "Ch√©rif",
            "Surname": "SIAM",
            "ImageURL": ""
        },
        {
            "ID": 146880,
            "Forename": "Mohamed El Seddik",
            "Surname": "BA√ÇLI",
            "ImageURL": ""
        },
        {
            "ID": 146881,
            "Forename": "Abdelhafid",
            "Surname": "HOGGAS",
            "ImageURL": ""
        },
        {
            "ID": 146882,
            "Forename": "Abdellah",
            "Surname": "MEDDAH",
            "ImageURL": ""
        },
        {
            "ID": 146883,
            "Forename": "Hocine",
            "Surname": "LARIBI",
            "ImageURL": ""
        },
        {
            "ID": 146884,
            "Forename": "Hamza",
            "Surname": "REBIAI",
            "ImageURL": ""
        },
        {
            "ID": 146885,
            "Forename": "Nabil",
            "Surname": "SA√ÇDOU",
            "ImageURL": ""
        },
        {
            "ID": 146886,
            "Forename": "Mohamed",
            "Surname": "GUEMROUD",
            "ImageURL": ""
        },
        {
            "ID": 146887,
            "Forename": "Oussama Safa",
            "Surname": "KADDOUR",
            "ImageURL": ""
        },
        {
            "ID": 146888,
            "Forename": "Oussama",
            "Surname": "FILALI",
            "ImageURL": ""
        },
        {
            "ID": 146889,
            "Forename": "Abdelwaheb Sofiane",
            "Surname": "KHEDAIRIA",
            "ImageURL": ""
        },
        {
            "ID": 146891,
            "Forename": "Hacene",
            "Surname": "OGBI BEN HADDOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 146892,
            "Forename": "Mohamed",
            "Surname": "ATHMANI",
            "ImageURL": ""
        },
        {
            "ID": 146893,
            "Forename": "Ahmed",
            "Surname": "GAGA√Ç",
            "ImageURL": ""
        },
        {
            "ID": 146894,
            "Forename": "Abdelhakim",
            "Surname": "SAMEUR",
            "ImageURL": ""
        },
        {
            "ID": 146895,
            "Forename": "Sid Ali",
            "Surname": "LAMRI",
            "ImageURL": ""
        },
        {
            "ID": 146896,
            "Forename": "Mohamed Amine",
            "Surname": "SEMAHI",
            "ImageURL": ""
        },
        {
            "ID": 146897,
            "Forename": "Karim",
            "Surname": "SABOUNI",
            "ImageURL": ""
        },
        {
            "ID": 146898,
            "Forename": "Ilyes",
            "Surname": "YAICHE",
            "ImageURL": ""
        },
        {
            "ID": 146899,
            "Forename": "Chouaib",
            "Surname": "DEBBIH",
            "ImageURL": ""
        },
        {
            "ID": 146903,
            "Forename": "Abdeselem",
            "Surname": "NAILI",
            "ImageURL": ""
        },
        {
            "ID": 146904,
            "Forename": "Mohamed Ali",
            "Surname": "HAMZAOUI",
            "ImageURL": ""
        },
        {
            "ID": 146905,
            "Forename": "Abdelkader",
            "Surname": "MORCELY",
            "ImageURL": ""
        },
        {
            "ID": 146906,
            "Forename": "Abdessamad",
            "Surname": "BOUNAAMA",
            "ImageURL": ""
        },
        {
            "ID": 146907,
            "Forename": "Kheireddine",
            "Surname": "BENAMRANE",
            "ImageURL": ""
        },
        {
            "ID": 146908,
            "Forename": "Belaid",
            "Surname": "KOUAR",
            "ImageURL": ""
        },
        {
            "ID": 146909,
            "Forename": "Mohamed Azzedine",
            "Surname": "BERRIAH",
            "ImageURL": ""
        },
        {
            "ID": 146910,
            "Forename": "Adel",
            "Surname": "AMAOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 146911,
            "Forename": "Anis",
            "Surname": "KHEMAISSIA",
            "ImageURL": ""
        },
        {
            "ID": 146912,
            "Forename": "Abdeldjalil",
            "Surname": "BAHOUSSI",
            "ImageURL": ""
        },
        {
            "ID": 146913,
            "Forename": "Mohamed El Amine",
            "Surname": "BARKA",
            "ImageURL": ""
        },
        {
            "ID": 146914,
            "Forename": "Brahim",
            "Surname": "ZOUAD",
            "ImageURL": ""
        },
        {
            "ID": 146915,
            "Forename": "El Amine",
            "Surname": "ANTAR",
            "ImageURL": ""
        },
        {
            "ID": 146916,
            "Forename": "Abdenour",
            "Surname": "ABBES",
            "ImageURL": ""
        },
        {
            "ID": 146917,
            "Forename": "Ibrahim",
            "Surname": "MORSLI",
            "ImageURL": ""
        },
        {
            "ID": 146918,
            "Forename": "Djamel",
            "Surname": "BELALEM",
            "ImageURL": ""
        },
        {
            "ID": 146919,
            "Forename": "Yasser",
            "Surname": "BELARIBI",
            "ImageURL": ""
        },
        {
            "ID": 146920,
            "Forename": "Benamar",
            "Surname": "MELLAL",
            "ImageURL": ""
        },
        {
            "ID": 146921,
            "Forename": "Necer Marouane",
            "Surname": "BENZID",
            "ImageURL": ""
        },
        {
            "ID": 146922,
            "Forename": "M'hend",
            "Surname": "SEDIRI",
            "ImageURL": ""
        },
        {
            "ID": 146923,
            "Forename": "Ramzi Abdelmoudjib",
            "Surname": "TENNAH",
            "ImageURL": ""
        },
        {
            "ID": 146925,
            "Forename": "Youcef",
            "Surname": "SERRAOUI",
            "ImageURL": ""
        },
        {
            "ID": 146926,
            "Forename": "Abdelillah",
            "Surname": "BARKAT",
            "ImageURL": ""
        },
        {
            "ID": 146927,
            "Forename": "Mohamed",
            "Surname": "BRAHIMI",
            "ImageURL": ""
        },
        {
            "ID": 146928,
            "Forename": "Kamel",
            "Surname": "BELMILOUD",
            "ImageURL": ""
        },
        {
            "ID": 146929,
            "Forename": "Ahmed",
            "Surname": "GHENAM",
            "ImageURL": ""
        },
        {
            "ID": 146930,
            "Forename": "Mohamed",
            "Surname": "MESSADI",
            "ImageURL": ""
        },
        {
            "ID": 147172,
            "Forename": "Mohamed",
            "Surname": "ZEGHADI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/147172.png"
        },
        {
            "ID": 148835,
            "Forename": "Adel",
            "Surname": "GHANEM",
            "ImageURL": ""
        },
        {
            "ID": 151973,
            "Forename": "Cyril",
            "Surname": "KHETIR",
            "ImageURL": ""
        },
        {
            "ID": 152055,
            "Forename": "Amine",
            "Surname": "SA√èD",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/152055.png"
        },
        {
            "ID": 152678,
            "Forename": "Sami",
            "Surname": "BELDI",
            "ImageURL": ""
        },
        {
            "ID": 152733,
            "Forename": "Omar",
            "Surname": "MOHAMED",
            "ImageURL": ""
        },
        {
            "ID": 152768,
            "Forename": "Khalil",
            "Surname": "ZOHIR",
            "ImageURL": ""
        },
        {
            "ID": 153061,
            "Forename": "Yaniss",
            "Surname": "SAIDI",
            "ImageURL": ""
        },
        {
            "ID": 154096,
            "Forename": "Nassim",
            "Surname": "MEKID√àCHE",
            "ImageURL": ""
        },
        {
            "ID": 154542,
            "Forename": "Zyed",
            "Surname": "BELTAIEF",
            "ImageURL": ""
        },
        {
            "ID": 154692,
            "Forename": "Walid",
            "Surname": "HAMIDI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/154692.png"
        },
        {
            "ID": 154693,
            "Forename": "Fouad",
            "Surname": "SALEH",
            "ImageURL": ""
        },
        {
            "ID": 154694,
            "Forename": "Chemseddine",
            "Surname": "BEKKOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 154968,
            "Forename": "Rafik",
            "Surname": "MESSALI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/154968.png"
        },
        {
            "ID": 155849,
            "Forename": "Adam",
            "Surname": "LAAREF",
            "ImageURL": ""
        },
        {
            "ID": 156207,
            "Forename": "Issam",
            "Surname": "BOUAOUNE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/156207.png"
        },
        {
            "ID": 156409,
            "Forename": "Lahlou",
            "Surname": "AKHRIB",
            "ImageURL": ""
        },
        {
            "ID": 156410,
            "Forename": "Salah Eddine",
            "Surname": "BOUZIANI",
            "ImageURL": ""
        },
        {
            "ID": 158699,
            "Forename": "Selman",
            "Surname": "NASSAR-CHOUITER",
            "ImageURL": ""
        },
        {
            "ID": 159381,
            "Forename": "Safi Eddine",
            "Surname": "ATMANIA",
            "ImageURL": ""
        },
        {
            "ID": 159382,
            "Forename": "Rayane Abdelmadjid",
            "Surname": "MAHROUZ",
            "ImageURL": ""
        },
        {
            "ID": 159383,
            "Forename": "Imadeddine",
            "Surname": "AZZI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/159383.png"
        },
        {
            "ID": 159385,
            "Forename": "Mohamed Sa√Ød",
            "Surname": "BENMAZOUZ",
            "ImageURL": ""
        },
        {
            "ID": 159387,
            "Forename": "Oussama",
            "Surname": "BENHAOUA",
            "ImageURL": ""
        },
        {
            "ID": 159390,
            "Forename": "Lofti",
            "Surname": "BOUSSOUAR",
            "ImageURL": ""
        },
        {
            "ID": 159391,
            "Forename": "Bilal",
            "Surname": "BOUKERCHAOUI",
            "ImageURL": ""
        },
        {
            "ID": 159393,
            "Forename": "Oussama",
            "Surname": "DAIBECHE",
            "ImageURL": ""
        },
        {
            "ID": 159394,
            "Forename": "Abderrahmane",
            "Surname": "BEKKOUR",
            "ImageURL": ""
        },
        {
            "ID": 159395,
            "Forename": "Badreddine",
            "Surname": "SOUYAD",
            "ImageURL": ""
        },
        {
            "ID": 159396,
            "Forename": "Mostapha Rezkallah",
            "Surname": "BOTT",
            "ImageURL": ""
        },
        {
            "ID": 159397,
            "Forename": "Oualid",
            "Surname": "MALKI",
            "ImageURL": ""
        },
        {
            "ID": 159398,
            "Forename": "Abdesslam",
            "Surname": "HANNANE",
            "ImageURL": ""
        },
        {
            "ID": 159399,
            "Forename": "Mohammed Reyad",
            "Surname": "LEZOUL",
            "ImageURL": ""
        },
        {
            "ID": 159400,
            "Forename": "Chems-Eddine",
            "Surname": "REDAOUI",
            "ImageURL": ""
        },
        {
            "ID": 159401,
            "Forename": "Boualem",
            "Surname": "MASMOUDI",
            "ImageURL": ""
        },
        {
            "ID": 159402,
            "Forename": "Khaled",
            "Surname": "CHOUARI",
            "ImageURL": ""
        },
        {
            "ID": 159403,
            "Forename": "Riadh",
            "Surname": "DAHMANI",
            "ImageURL": ""
        },
        {
            "ID": 159404,
            "Forename": "Mohamed",
            "Surname": "BEGHDADI",
            "ImageURL": ""
        },
        {
            "ID": 159405,
            "Forename": "Chakib",
            "Surname": "AOUDJANE",
            "ImageURL": ""
        },
        {
            "ID": 159407,
            "Forename": "Houcine",
            "Surname": "AOUED",
            "ImageURL": ""
        },
        {
            "ID": 159408,
            "Forename": "Noureddine",
            "Surname": "HAMRI",
            "ImageURL": ""
        },
        {
            "ID": 159409,
            "Forename": "Hamza",
            "Surname": "SALEM",
            "ImageURL": ""
        },
        {
            "ID": 159410,
            "Forename": "Salah Eddine",
            "Surname": "ZAOUI",
            "ImageURL": ""
        },
        {
            "ID": 159411,
            "Forename": "Mohamed Abderahmane",
            "Surname": "SAADI",
            "ImageURL": ""
        },
        {
            "ID": 159412,
            "Forename": "Mohamed Nassim",
            "Surname": "YATTOU",
            "ImageURL": ""
        },
        {
            "ID": 159413,
            "Forename": "Islam",
            "Surname": "BOULOUD√àNE",
            "ImageURL": ""
        },
        {
            "ID": 159414,
            "Forename": "Mohamed Islam",
            "Surname": "ABDELKADER",
            "ImageURL": ""
        },
        {
            "ID": 159415,
            "Forename": "Abdelmoumene",
            "Surname": "GUESSOUM",
            "ImageURL": ""
        },
        {
            "ID": 159416,
            "Forename": "Anwar",
            "Surname": "KHEMMAR",
            "ImageURL": ""
        },
        {
            "ID": 159417,
            "Forename": "Nizar",
            "Surname": "TAMER",
            "ImageURL": ""
        },
        {
            "ID": 159418,
            "Forename": "Mohammed Fodil",
            "Surname": "BELKHADEM",
            "ImageURL": ""
        },
        {
            "ID": 159419,
            "Forename": "Fouad",
            "Surname": "GHANEM",
            "ImageURL": ""
        },
        {
            "ID": 159421,
            "Forename": "Ameur",
            "Surname": "BOUGUETTAYA",
            "ImageURL": ""
        },
        {
            "ID": 159422,
            "Forename": "Akram Abou Bakr",
            "Surname": "BIBI",
            "ImageURL": ""
        },
        {
            "ID": 159423,
            "Forename": "Tarek",
            "Surname": "BOUSSEDER",
            "ImageURL": ""
        },
        {
            "ID": 159425,
            "Forename": "Bassem",
            "Surname": "MECHAAR",
            "ImageURL": ""
        },
        {
            "ID": 159427,
            "Forename": "Mohamed",
            "Surname": "MESSAOUD SALEM",
            "ImageURL": ""
        },
        {
            "ID": 159428,
            "Forename": "Anis Mahdi",
            "Surname": "MENDIL",
            "ImageURL": ""
        },
        {
            "ID": 159429,
            "Forename": "Yanis",
            "Surname": "RAMDANI",
            "ImageURL": ""
        },
        {
            "ID": 159431,
            "Forename": "Oussama",
            "Surname": "BENATTIA",
            "ImageURL": ""
        },
        {
            "ID": 159432,
            "Forename": "Mohamed Zakaria",
            "Surname": "HAOULI",
            "ImageURL": ""
        },
        {
            "ID": 159433,
            "Forename": "Rafik",
            "Surname": "BRAHIMI",
            "ImageURL": ""
        },
        {
            "ID": 159434,
            "Forename": "Khaled Mounir",
            "Surname": "ALLAOUI",
            "ImageURL": ""
        },
        {
            "ID": 159435,
            "Forename": "Abdelkader",
            "Surname": "GHORAB",
            "ImageURL": ""
        },
        {
            "ID": 159436,
            "Forename": "Mohamed Ayoub",
            "Surname": "BELHACHEMI",
            "ImageURL": ""
        },
        {
            "ID": 159437,
            "Forename": "Oussama",
            "Surname": "BENTALEB",
            "ImageURL": ""
        },
        {
            "ID": 159440,
            "Forename": "Mohamed",
            "Surname": "MEDJADJI",
            "ImageURL": ""
        },
        {
            "ID": 159441,
            "Forename": "Tarek",
            "Surname": "BOUABTA",
            "ImageURL": ""
        },
        {
            "ID": 159442,
            "Forename": "Houssam",
            "Surname": "KELLOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 159443,
            "Forename": "Imad Eddine",
            "Surname": "LARBI",
            "ImageURL": ""
        },
        {
            "ID": 159444,
            "Forename": "Ayoub",
            "Surname": "SADAHINE",
            "ImageURL": ""
        },
        {
            "ID": 159446,
            "Forename": "Moussa",
            "Surname": "BOUKHENNA",
            "ImageURL": ""
        },
        {
            "ID": 159448,
            "Forename": "Zakaria",
            "Surname": "ZAITRI",
            "ImageURL": ""
        },
        {
            "ID": 159449,
            "Forename": "Adil",
            "Surname": "DJABOUT",
            "ImageURL": ""
        },
        {
            "ID": 159450,
            "Forename": "Abdeldjalil",
            "Surname": "OULD AMMAR",
            "ImageURL": ""
        },
        {
            "ID": 159615,
            "Forename": "Akram",
            "Surname": "DEMANE",
            "ImageURL": ""
        },
        {
            "ID": 159616,
            "Forename": "Hatem",
            "Surname": "BENCHEIKH EL FEGOUN",
            "ImageURL": ""
        },
        {
            "ID": 159617,
            "Forename": "Benaouda",
            "Surname": "KLILECHE",
            "ImageURL": ""
        },
        {
            "ID": 159618,
            "Forename": "Slimane",
            "Surname": "BOUTELDJA",
            "ImageURL": ""
        },
        {
            "ID": 159619,
            "Forename": "Younes Abdelhak",
            "Surname": "OUASSA",
            "ImageURL": ""
        },
        {
            "ID": 159620,
            "Forename": "Mohamed Yasser",
            "Surname": "CHELFAOUI",
            "ImageURL": ""
        },
        {
            "ID": 159633,
            "Forename": "Mohammed",
            "Surname": "BOUHALFAYA",
            "ImageURL": ""
        },
        {
            "ID": 159667,
            "Forename": "Merouane",
            "Surname": "MEHDAOUI",
            "ImageURL": ""
        },
        {
            "ID": 159668,
            "Forename": "Louanes",
            "Surname": "ZIDI",
            "ImageURL": ""
        },
        {
            "ID": 159669,
            "Forename": "Massinissa",
            "Surname": "BENAMARA",
            "ImageURL": ""
        },
        {
            "ID": 159670,
            "Forename": "Dhirar",
            "Surname": "BENSAADALLAH",
            "ImageURL": ""
        },
        {
            "ID": 159671,
            "Forename": "Ali",
            "Surname": "HAROUN",
            "ImageURL": ""
        },
        {
            "ID": 159672,
            "Forename": "Abdelhak",
            "Surname": "ASKAR",
            "ImageURL": ""
        },
        {
            "ID": 159673,
            "Forename": "Sofiane Fouad",
            "Surname": "LACHAHAB",
            "ImageURL": ""
        },
        {
            "ID": 159674,
            "Forename": "Omar",
            "Surname": "ADRAR",
            "ImageURL": ""
        },
        {
            "ID": 159675,
            "Forename": "Mohamed Amine",
            "Surname": "GHERBI",
            "ImageURL": ""
        },
        {
            "ID": 159676,
            "Forename": "Lounas",
            "Surname": "ADJOUT",
            "ImageURL": ""
        },
        {
            "ID": 159677,
            "Forename": "Mohamed",
            "Surname": "HAMADOUCHE",
            "ImageURL": ""
        },
        {
            "ID": 159678,
            "Forename": "Bensidhoum",
            "Surname": "ABDELHAMID",
            "ImageURL": ""
        },
        {
            "ID": 159679,
            "Forename": "Aymen",
            "Surname": "CHAARAOUI",
            "ImageURL": ""
        },
        {
            "ID": 159681,
            "Forename": "Fateh",
            "Surname": "TALAH",
            "ImageURL": ""
        },
        {
            "ID": 159682,
            "Forename": "Yacine",
            "Surname": "SALHI",
            "ImageURL": ""
        },
        {
            "ID": 159683,
            "Forename": "Ahmed",
            "Surname": "OUKKAL",
            "ImageURL": ""
        },
        {
            "ID": 159684,
            "Forename": "Ahmed Yacine",
            "Surname": "ADOUANE",
            "ImageURL": ""
        },
        {
            "ID": 159686,
            "Forename": "Aymen",
            "Surname": "BOUDA",
            "ImageURL": ""
        },
        {
            "ID": 159687,
            "Forename": "Mohamed Ouassim",
            "Surname": "ZERARI",
            "ImageURL": ""
        },
        {
            "ID": 159688,
            "Forename": "Abdouel Ali",
            "Surname": "HADJI",
            "ImageURL": ""
        },
        {
            "ID": 159689,
            "Forename": "Mohamed",
            "Surname": "ALAOUCHICHE",
            "ImageURL": ""
        },
        {
            "ID": 159690,
            "Forename": "Zahreddine",
            "Surname": "BENABDA",
            "ImageURL": ""
        },
        {
            "ID": 159691,
            "Forename": "Oussama",
            "Surname": "YEROU",
            "ImageURL": ""
        },
        {
            "ID": 159692,
            "Forename": "Islam",
            "Surname": "CHAHROUR",
            "ImageURL": ""
        },
        {
            "ID": 159693,
            "Forename": "Mohamed Alaeddine",
            "Surname": "BELARIBI",
            "ImageURL": ""
        },
        {
            "ID": 159694,
            "Forename": "Kheir Eddine",
            "Surname": "TOUAL",
            "ImageURL": ""
        },
        {
            "ID": 159695,
            "Forename": "Mohamed",
            "Surname": "TOUMI SIEF",
            "ImageURL": ""
        },
        {
            "ID": 159696,
            "Forename": "Abdel Ali",
            "Surname": "HAMADI",
            "ImageURL": ""
        },
        {
            "ID": 159784,
            "Forename": "Abdelmalek",
            "Surname": "KELALECHE",
            "ImageURL": ""
        },
        {
            "ID": 160097,
            "Forename": "Mourad",
            "Surname": "HAKEM",
            "ImageURL": ""
        },
        {
            "ID": 160147,
            "Forename": "Fares",
            "Surname": "BELAILI",
            "ImageURL": ""
        },
        {
            "ID": 161289,
            "Forename": "Jebryl",
            "Surname": "SAHRAOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/161289.png"
        },
        {
            "ID": 161384,
            "Forename": "Abdelghani",
            "Surname": "LALLAM",
            "ImageURL": ""
        },
        {
            "ID": 161387,
            "Forename": "Massil",
            "Surname": "ADJAOUDI",
            "ImageURL": ""
        },
        {
            "ID": 162038,
            "Forename": "Zaid",
            "Surname": "BETTEKA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/162038.png"
        },
        {
            "ID": 162362,
            "Forename": "Abderrezzek",
            "Surname": "SAIDI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/player\/162362.png"
        },
        {
            "ID": 162391,
            "Forename": "Djamal",
            "Surname": "BERRABHA",
            "ImageURL": ""
        },
        {
            "ID": 162597,
            "Forename": "Maisser Ramy",
            "Surname": "BOUTEBA",
            "ImageURL": ""
        },
        {
            "ID": 162684,
            "Forename": "Toufik",
            "Surname": "ZEGHDANE",
            "ImageURL": ""
        },
        {
            "ID": 164234,
            "Forename": "Abdelmalek",
            "Surname": "AMARA",
            "ImageURL": ""
        },
        {
            "ID": 165026,
            "Forename": "Ouanisse",
            "Surname": "BOUZAHZAH",
            "ImageURL": ""
        },
        {
            "ID": 165619,
            "Forename": "Nabil",
            "Surname": "BOUCHENTOUF",
            "ImageURL": ""
        },
        {
            "ID": 165755,
            "Forename": "Hadi",
            "Surname": "BENTEBBAL",
            "ImageURL": ""
        },
        {
            "ID": 166349,
            "Forename": "Abdelkader",
            "Surname": "BELHARRANE",
            "ImageURL": ""
        },
        {
            "ID": 166350,
            "Forename": "Sofyan",
            "Surname": "COLA",
            "ImageURL": ""
        },
        {
            "ID": 166351,
            "Forename": "Mohammed",
            "Surname": "DJENIDI",
            "ImageURL": ""
        },
        {
            "ID": 166352,
            "Forename": "Diaa Eddine",
            "Surname": "MECHID",
            "ImageURL": ""
        },
        {
            "ID": 166854,
            "Forename": "Samy",
            "Surname": "MERZOUK",
            "ImageURL": ""
        }
    ],
    "ClubData": [
        {
            "ID": 1608,
            "Name": "ES S√©tif",
            "ShortName": "ESS",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/1608.png"
        },
        {
            "ID": 1634,
            "Name": "JS Kabylie",
            "ShortName": "JSK",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/1634.png"
        },
        {
            "ID": 1685,
            "Name": "ASO Chlef",
            "ShortName": "ASO",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/1685.png"
        },
        {
            "ID": 1930,
            "Name": "USM Alger",
            "ShortName": "USM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/1930.png"
        },
        {
            "ID": 2017,
            "Name": "USM El Harrach",
            "ShortName": "USM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2017.png"
        },
        {
            "ID": 2042,
            "Name": "CS Constantine",
            "ShortName": "CSC",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2042.png"
        },
        {
            "ID": 2059,
            "Name": "JSM B√©ja√Øa",
            "ShortName": "JSM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2059.png"
        },
        {
            "ID": 2080,
            "Name": "MC El Eulma",
            "ShortName": "MCE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2080.png"
        },
        {
            "ID": 2188,
            "Name": "CR Belouizdad",
            "ShortName": "CRB",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2188.png"
        },
        {
            "ID": 2272,
            "Name": "MC Alger",
            "ShortName": "MCA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2272.png"
        },
        {
            "ID": 2273,
            "Name": "MC Oran",
            "ShortName": "MCO",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2273.png"
        },
        {
            "ID": 2274,
            "Name": "CA Batna",
            "ShortName": "CAB",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2274.png"
        },
        {
            "ID": 2275,
            "Name": "JS Saoura",
            "ShortName": "JSS",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2275.png"
        },
        {
            "ID": 2276,
            "Name": "CABB Arr√©ridj",
            "ShortName": "BBA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2276.png"
        },
        {
            "ID": 2277,
            "Name": "WA Tlemcen",
            "ShortName": "WAT",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2277.png"
        },
        {
            "ID": 2278,
            "Name": "USM Bel Abb√®s",
            "ShortName": "ABB",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2278.png"
        },
        {
            "ID": 2937,
            "Name": "RC Arba√¢",
            "ShortName": "RCA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2937.jpg"
        },
        {
            "ID": 2938,
            "Name": "MO B√©ja√Øa",
            "ShortName": "MOB",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2938.png"
        },
        {
            "ID": 2939,
            "Name": "CRB A√Øn Fakroun",
            "ShortName": "FAK",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/2939.png"
        },
        {
            "ID": 3326,
            "Name": "NA Hussein Dey",
            "ShortName": "HD",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/3326.png"
        },
        {
            "ID": 4015,
            "Name": "DRB Tadjenanet",
            "ShortName": "TAD",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/4015.png"
        },
        {
            "ID": 4016,
            "Name": "RC Relizane",
            "ShortName": "RCR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/4016.png"
        },
        {
            "ID": 4017,
            "Name": "ASM Oran",
            "ShortName": "ASM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/4017.png"
        },
        {
            "ID": 4018,
            "Name": "USM Blida",
            "ShortName": "BLI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/4018.png"
        },
        {
            "ID": 4224,
            "Name": "Paradou AC",
            "ShortName": "PAC",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/4224.png"
        },
        {
            "ID": 4246,
            "Name": "Olympique de M√©d√©a",
            "ShortName": "OM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/4246.png"
        },
        {
            "ID": 4439,
            "Name": "SA Mohammadia",
            "ShortName": "SAM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/4439.png"
        },
        {
            "ID": 4879,
            "Name": "US Biskra",
            "ShortName": "USB",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/4879.png"
        },
        {
            "ID": 5272,
            "Name": "AS Ain M'lila",
            "ShortName": "ASA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/5272.png"
        },
        {
            "ID": 5799,
            "Name": "NC Magra",
            "ShortName": "NCM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/5799.png"
        },
        {
            "ID": 5800,
            "Name": "HB Chelghoum La√Ød",
            "ShortName": "HBC",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/5800.png"
        },
        {
            "ID": 6399,
            "Name": "MC El Bayadh",
            "ShortName": "MCE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/6399.png"
        },
        {
            "ID": 6400,
            "Name": "ES Ben Aknoun",
            "ShortName": "ESB",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/6400.png"
        },
        {
            "ID": 6401,
            "Name": "US Souf",
            "ShortName": "USS",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/6401.png"
        },
        {
            "ID": 6402,
            "Name": "USM Khenchela",
            "ShortName": "USM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/6402.png"
        },
        {
            "ID": 6688,
            "Name": "ES Mostaganem",
            "ShortName": "ESM",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/6688.png"
        },
        {
            "ID": 6689,
            "Name": "Olympique Akbou",
            "ShortName": "OA",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/6689.png"
        },
        {
            "ID": 6863,
            "Name": "MB Rouissat",
            "ShortName": "MBR",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/clubs\/6863.png"
        }
    ],
    "LeagueData": [
        {
            "ID": 152,
            "Name": "Ligue Professionnelle 1",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/leagues\/152.jpg"
        },
        {
            "ID": 188,
            "Name": "Ligue Professionnelle 2",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/leagues\/188.jpg"
        }
    ],
    "CupData": [
        {
            "ID": 68,
            "Name": "Coupe d'Alg√©rie",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/logos\/cups\/68.jpg"
        }
    ],
    "StadiumData": [
        {
            "ID": 1755,
            "Name": "Stade 8 Mai 1945"
        },
        {
            "ID": 1782,
            "Name": "1er Novembre"
        },
        {
            "ID": 1837,
            "Name": "Boumezrag Mohamed"
        },
        {
            "ID": 2091,
            "Name": "Omar Hammadi"
        },
        {
            "ID": 2184,
            "Name": "1er Novembre 1954"
        },
        {
            "ID": 2208,
            "Name": "Mohamed Hamlaoui"
        },
        {
            "ID": 2225,
            "Name": "l'Unit√© Maghr√©bine"
        },
        {
            "ID": 2250,
            "Name": "Messaoud Zougar"
        },
        {
            "ID": 2362,
            "Name": "Stade 20 Ao√ªt 1955"
        },
        {
            "ID": 1382,
            "Name": "Stade 5 Juillet 1962"
        },
        {
            "ID": 2442,
            "Name": "Ahmed Zabana"
        },
        {
            "ID": 2443,
            "Name": "Seffouhi"
        },
        {
            "ID": 2444,
            "Name": "20 Ao√ªt 1955 B√©char"
        },
        {
            "ID": 2445,
            "Name": "20 ao√ªt 1955 BBA"
        },
        {
            "ID": 2446,
            "Name": "Akid Lotfi"
        },
        {
            "ID": 2447,
            "Name": "Stade 24 Fevrier 1956"
        },
        {
            "ID": 3062,
            "Name": "Omar Hamadi de Bologhine"
        },
        {
            "ID": 3063,
            "Name": "Stade Municipal A√Øn Fakroun"
        },
        {
            "ID": 4058,
            "Name": "Stade Laghouat Smail"
        },
        {
            "ID": 4059,
            "Name": "Stade Tahar Zoughari"
        },
        {
            "ID": 4060,
            "Name": "Stade Habib Bouakeul"
        },
        {
            "ID": 4061,
            "Name": "Stade Mustapha Tchaker"
        },
        {
            "ID": 4276,
            "Name": "Stade Imam Lyes de M√©d√©a"
        },
        {
            "ID": 4457,
            "Name": "Stade Mohamed Ouali"
        },
        {
            "ID": 4877,
            "Name": "Complexe Sportif d'El Alia"
        },
        {
            "ID": 5270,
            "Name": "Stade des Fr√®res Demane-Debbih"
        },
        {
            "ID": 5789,
            "Name": "Boucheligue Brothers Stadium"
        },
        {
            "ID": 5790,
            "Name": "December 11, 1961 Stadium"
        },
        {
            "ID": 6250,
            "Name": "Zakaria Medjdoub Stadium"
        },
        {
            "ID": 6251,
            "Name": "El Mokrani Stadium"
        },
        {
            "ID": 6252,
            "Name": "20 Ao√ªt 1955 El Oued"
        },
        {
            "ID": 6253,
            "Name": "Amar Hamam Stadium"
        },
        {
            "ID": 6394,
            "Name": "Mohamed Bensa√Ød Stadium"
        },
        {
            "ID": 6531,
            "Name": "18 February Stadium"
        }
    ],
    "ManagerData": [
        {
            "ID": 1583,
            "Forename": "Rabah",
            "Surname": "SAADANE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/manager\/1583_1268611504.jpg"
        },
        {
            "ID": 2508,
            "Forename": "Djamel",
            "Surname": "BELMADI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/manager\/2508_1336984441.jpg"
        },
        {
            "ID": 4095,
            "Forename": "Rachid",
            "Surname": "BELHOUT",
            "ImageURL": ""
        },
        {
            "ID": 4314,
            "Forename": "Abdelkader",
            "Surname": "YA√èCHE",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/manager\/4314.jpg"
        },
        {
            "ID": 4966,
            "Forename": "Nasser",
            "Surname": "SENDJAK",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/manager\/4966.jpg"
        },
        {
            "ID": 5099,
            "Forename": "Azzedine",
            "Surname": "A√èT DJOUDI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/manager\/5099.jpg"
        },
        {
            "ID": 5129,
            "Forename": "Noureddine",
            "Surname": "SA√ÇDI",
            "ImageURL": ""
        },
        {
            "ID": 5328,
            "Forename": "Ishack",
            "Surname": "BENZHAOULI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/manager\/5328.jpg"
        },
        {
            "ID": 5381,
            "Forename": "Mohand Cherif",
            "Surname": "HANNACHI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/manager\/5381.jpg"
        },
        {
            "ID": 6535,
            "Forename": "Kheirredine",
            "Surname": "MADOUI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/manager\/6535.jpg"
        },
        {
            "ID": 6743,
            "Forename": "Taoufik",
            "Surname": "ROUABAH",
            "ImageURL": ""
        },
        {
            "ID": 6892,
            "Forename": "Noureddine",
            "Surname": "ZEKRI",
            "ImageURL": ""
        },
        {
            "ID": 6909,
            "Forename": "Abdelkader",
            "Surname": "AMRANI",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/manager\/6909.jpg"
        },
        {
            "ID": 7079,
            "Forename": "Lyes",
            "Surname": "ARAB",
            "ImageURL": ""
        },
        {
            "ID": 7152,
            "Forename": "Khaled",
            "Surname": "STAMBOULI",
            "ImageURL": ""
        },
        {
            "ID": 7506,
            "Forename": "Abdelhak",
            "Surname": "BENCHIKHA",
            "ImageURL": ""
        },
        {
            "ID": 8826,
            "Forename": "Mohamed",
            "Surname": "BRADJA",
            "ImageURL": ""
        },
        {
            "ID": 8948,
            "Forename": "Madjid",
            "Surname": "BOUGHERRA",
            "ImageURL": ""
        },
        {
            "ID": 9085,
            "Forename": "Rabah",
            "Surname": "MADJER",
            "ImageURL": ""
        },
        {
            "ID": 11215,
            "Forename": "Brahim",
            "Surname": "HEMDANI",
            "ImageURL": ""
        },
        {
            "ID": 12131,
            "Forename": "Mehdi",
            "Surname": "LAOUAMEN",
            "ImageURL": ""
        },
        {
            "ID": 12201,
            "Forename": "Youcef",
            "Surname": "BOUZIDI",
            "ImageURL": ""
        },
        {
            "ID": 12216,
            "Forename": "Ch√©rif",
            "Surname": "HADJAR",
            "ImageURL": ""
        },
        {
            "ID": 12217,
            "Forename": "Fouad",
            "Surname": "BOUALI",
            "ImageURL": ""
        },
        {
            "ID": 12218,
            "Forename": "Lyamine",
            "Surname": "BOUGHERARA",
            "ImageURL": ""
        },
        {
            "ID": 12219,
            "Forename": "Mounir",
            "Surname": "ZEGHDOUD",
            "ImageURL": ""
        },
        {
            "ID": 12243,
            "Forename": "Billel",
            "Surname": "DZIRI",
            "ImageURL": ""
        },
        {
            "ID": 12244,
            "Forename": "Abdelhak",
            "Surname": "BELAID",
            "ImageURL": ""
        },
        {
            "ID": 13161,
            "Forename": "Samir",
            "Surname": "ZAOUI",
            "ImageURL": ""
        },
        {
            "ID": 13162,
            "Forename": "Nadhir",
            "Surname": "LEKNAOUI",
            "ImageURL": ""
        },
        {
            "ID": 13163,
            "Forename": "Abdellah",
            "Surname": "LAGHROUR",
            "ImageURL": ""
        },
        {
            "ID": 13164,
            "Forename": "Lyamine",
            "Surname": "BOUGHRARA",
            "ImageURL": ""
        },
        {
            "ID": 13165,
            "Forename": "Lotfi",
            "Surname": "AMROUCHE",
            "ImageURL": ""
        }
    ],
    "InternationalData": [
        {
            "ID": "ALG",
            "Name": "Algeria",
            "ShortName": "ALG",
            "ImageURL": "https:\/\/cdn.soccerwiki.org\/images\/international\/ALG.png"
        }
    ],
    "InternationalCupData": [
        {
            "ID": 1,
            "Name": "FIFA World Cup"
        },
        {
            "ID": 13,
            "Name": "European Championship"
        },
        {
            "ID": 25,
            "Name": "FIFA Confederations Cup"
        },
        {
            "ID": 37,
            "Name": "AFC Asian Cup"
        },
        {
            "ID": 39,
            "Name": "Copa Am√©rica"
        },
        {
            "ID": 41,
            "Name": "Africa Cup of Nations"
        },
        {
            "ID": 52,
            "Name": "European U-21 Championship"
        },
        {
            "ID": 89,
            "Name": "AFF Cup"
        },
        {
            "ID": 116,
            "Name": "SAFF Championship"
        },
        {
            "ID": 209,
            "Name": "CONCACAF Gold Cup"
        },
        {
            "ID": 226,
            "Name": "CONMEBOL-UEFA Cup of Champions"
        }
    ],
    "PlayerImages": {
        "12": {
            "ImageActionURL": "12-action.png"
        },
        "25": {
            "ImageActionURL": "25-action.png"
        },
        "27": {
            "ImageActionURL": "27-action.png"
        },
        "160": {
            "ImageActionURL": "160-action.png"
        },
        "455": {
            "ImageActionURL": "455-action.png"
        },
        "467": {
            "ImageActionURL": "467-action.png"
        },
        "471": {
            "ImageActionURL": "471-action.png"
        },
        "473": {
            "ImageActionURL": "473-action.png"
        },
        "998": {
            "ImageActionURL": "998-action.png"
        },
        "1004": {
            "ImageActionURL": "1004-action.png"
        },
        "1083": {
            "ImageActionURL": "1083-action.png"
        },
        "1123": {
            "ImageActionURL": "1123-action.png"
        },
        "1128": {
            "ImageActionURL": "1128-action.png"
        },
        "1131": {
            "ImageActionURL": "1131-action.png"
        },
        "1215": {
            "ImageActionURL": "1215-action.png"
        },
        "2365": {
            "ImageActionURL": "2365-action.png"
        },
        "2372": {
            "ImageActionURL": "2372-action.png"
        },
        "2378": {
            "ImageActionURL": "2378-action.png"
        },
        "2382": {
            "ImageActionURL": "2382-action.png"
        },
        "2460": {
            "ImageActionURL": "2460-action.png"
        },
        "2465": {
            "ImageActionURL": "2465-action.png"
        },
        "2474": {
            "ImageActionURL": "2474-action.png"
        },
        "2475": {
            "ImageActionURL": "2475-action.png"
        },
        "2476": {
            "ImageActionURL": "2476-action.png"
        },
        "2751": {
            "ImageActionURL": "2751-action.png"
        },
        "2761": {
            "ImageActionURL": "2761-action.png"
        },
        "2767": {
            "ImageActionURL": "2767-action.png"
        },
        "2772": {
            "ImageActionURL": "2772-action.png"
        },
        "2774": {
            "ImageActionURL": "2774-action.png"
        },
        "2900": {
            "ImageActionURL": "2900-action.png"
        },
        "2907": {
            "ImageActionURL": "2907-action.png"
        },
        "2912": {
            "ImageActionURL": "2912-action.png"
        },
        "2916": {
            "ImageActionURL": "2916-action.png"
        },
        "2918": {
            "ImageActionURL": "2918-action.png"
        },
        "2919": {
            "ImageActionURL": "2919-action.png"
        },
        "2920": {
            "ImageActionURL": "2920-action.png"
        },
        "2950": {
            "ImageActionURL": "2950-action.png"
        },
        "3875": {
            "ImageActionURL": "3875-action.png"
        },
        "3884": {
            "ImageActionURL": "3884-action.png"
        },
        "3898": {
            "ImageActionURL": "3898-action.png"
        },
        "3942": {
            "ImageActionURL": "3942-action.png"
        },
        "4336": {
            "ImageActionURL": "4336-action.png"
        },
        "4554": {
            "ImageActionURL": "4554-action.png"
        },
        "6378": {
            "ImageActionURL": "6378-action.png"
        },
        "16053": {
            "ImageActionURL": "16053-action.png"
        },
        "18649": {
            "ImageActionURL": "18649-action.png"
        },
        "19587": {
            "ImageActionURL": "19587-action.png"
        },
        "29738": {
            "ImageActionURL": "29738-action.png"
        },
        "31121": {
            "ImageActionURL": "31121-action.png"
        },
        "34893": {
            "ImageActionURL": "34893-action.png"
        },
        "36211": {
            "ImageActionURL": "36211-action.png"
        },
        "38125": {
            "ImageActionURL": "38125-action.png"
        },
        "38147": {
            "ImageActionURL": "38147-action.png"
        },
        "38457": {
            "ImageActionURL": "38457-action.png"
        },
        "38848": {
            "ImageActionURL": "38848-action.png"
        },
        "39419": {
            "ImageActionURL": "39419-action.png"
        },
        "41018": {
            "ImageActionURL": "41018-action.png"
        },
        "41105": {
            "ImageActionURL": "41105-action.png",
            "ImagePeakURL": "41105-peak.png",
            "ImageYouthURL": "41105-youth.png"
        },
        "41780": {
            "ImageActionURL": "41780-action.png"
        },
        "42005": {
            "ImageActionURL": "42005-action.png"
        },
        "43493": {
            "ImageActionURL": "43493-action.png"
        },
        "44009": {
            "ImageActionURL": "44009-action.png"
        },
        "45184": {
            "ImageActionURL": "45184-action.png"
        },
        "45279": {
            "ImageActionURL": "45279-action.png"
        },
        "45710": {
            "ImageActionURL": "45710-action.png"
        },
        "46443": {
            "ImageActionURL": "46443-action.png"
        },
        "46883": {
            "ImageActionURL": "46883-action.png"
        },
        "47215": {
            "ImageActionURL": "47215-action.png"
        },
        "49590": {
            "ImageActionURL": "49590-action.png"
        },
        "49618": {
            "ImageActionURL": "49618-action.png"
        },
        "52690": {
            "ImageActionURL": "52690-action.png"
        },
        "53468": {
            "ImageActionURL": "53468-action.png",
            "ImageYouthURL": "53468-youth.png"
        },
        "53792": {
            "ImageActionURL": "53792-action.png"
        },
        "54915": {
            "ImageActionURL": "54915-action.png"
        },
        "56394": {
            "ImageActionURL": "56394-action.png"
        },
        "56409": {
            "ImageActionURL": "56409-action.png"
        },
        "56786": {
            "ImageActionURL": "56786-action.png"
        },
        "58172": {
            "ImageActionURL": "58172-action.png"
        },
        "61102": {
            "ImageActionURL": "61102-action.png"
        },
        "64070": {
            "ImageActionURL": "64070-action.png"
        },
        "64586": {
            "ImageActionURL": "64586-action.png"
        },
        "64598": {
            "ImageActionURL": "64598-action.png"
        },
        "65977": {
            "ImageActionURL": "65977-action.png"
        },
        "68341": {
            "ImageActionURL": "68341-action.png"
        },
        "68359": {
            "ImageActionURL": "68359-action.png"
        },
        "70860": {
            "ImageActionURL": "70860-action.png"
        },
        "73424": {
            "ImageActionURL": "73424-action.png"
        },
        "76101": {
            "ImageActionURL": "76101-action.png"
        },
        "76517": {
            "ImageActionURL": "76517-action.png",
            "ImageActionPeakURL": "76517-action-peak.png"
        },
        "76578": {
            "ImageActionURL": "76578-action.png"
        },
        "80266": {
            "ImageActionURL": "80266-action.png"
        },
        "81249": {
            "ImageActionURL": "81249-action.png"
        },
        "81621": {
            "ImageActionURL": "81621-action.png"
        },
        "81664": {
            "ImageActionURL": "81664-action.png"
        },
        "81689": {
            "ImageActionURL": "81689-action.png"
        },
        "82178": {
            "ImageActionURL": "82178-action.png"
        },
        "82209": {
            "ImageActionURL": "82209-action.png"
        },
        "82275": {
            "ImageActionURL": "82275-action.png"
        },
        "82312": {
            "ImageActionURL": "82312-action.png"
        },
        "82491": {
            "ImageActionURL": "82491-action.png"
        },
        "83844": {
            "ImageActionURL": "83844-action.png"
        },
        "84046": {
            "ImageActionURL": "84046-action.png"
        },
        "84076": {
            "ImageActionURL": "84076-action.png"
        },
        "84372": {
            "ImageActionURL": "84372-action.png"
        },
        "84384": {
            "ImageActionURL": "84384-action.png"
        },
        "84738": {
            "ImageActionURL": "84738-action.png"
        },
        "85260": {
            "ImageActionURL": "85260-action.png"
        },
        "85388": {
            "ImageActionURL": "85388-action.png"
        },
        "85954": {
            "ImageActionURL": "85954-action.png"
        },
        "85984": {
            "ImageActionURL": "85984-action.png"
        },
        "85994": {
            "ImageActionURL": "85994-action.png"
        },
        "86085": {
            "ImageActionURL": "86085-action.png"
        },
        "86836": {
            "ImageActionURL": "86836-action.png"
        },
        "86903": {
            "ImageActionURL": "86903-action.png"
        },
        "87019": {
            "ImageActionURL": "87019-action.png"
        },
        "87638": {
            "ImageActionURL": "87638-action.png"
        },
        "87683": {
            "ImageActionURL": "87683-action.png"
        },
        "87870": {
            "ImageActionURL": "87870-action.png"
        },
        "87889": {
            "ImageActionURL": "87889-action.png"
        },
        "87941": {
            "ImageActionURL": "87941-action.png"
        },
        "88100": {
            "ImageActionURL": "88100-action.png"
        },
        "88385": {
            "ImageActionURL": "88385-action.png"
        },
        "88949": {
            "ImageActionURL": "88949-action.png"
        },
        "89018": {
            "ImageActionURL": "89018-action.png"
        },
        "89264": {
            "ImageActionURL": "89264-action.png"
        },
        "89344": {
            "ImageActionURL": "89344-action.png"
        },
        "89761": {
            "ImageActionURL": "89761-action.png"
        },
        "89787": {
            "ImageActionURL": "89787-action.png"
        },
        "90068": {
            "ImageActionURL": "90068-action.png"
        },
        "90287": {
            "ImageActionURL": "90287-action.png"
        },
        "90862": {
            "ImageActionURL": "90862-action.png"
        },
        "90892": {
            "ImageActionURL": "90892-action.png"
        },
        "90916": {
            "ImageActionURL": "90916-action.png"
        },
        "90936": {
            "ImageActionURL": "90936-action.png"
        },
        "91084": {
            "ImageActionURL": "91084-action.png"
        },
        "93302": {
            "ImageActionURL": "93302-action.png"
        },
        "93823": {
            "ImageActionURL": "93823-action.png"
        },
        "94241": {
            "ImageActionURL": "94241-action.png"
        },
        "94350": {
            "ImageActionURL": "94350-action.png"
        },
        "94642": {
            "ImageActionURL": "94642-action.png"
        },
        "94708": {
            "ImageActionURL": "94708-action.png"
        },
        "95052": {
            "ImageActionURL": "95052-action.png"
        },
        "95199": {
            "ImageActionURL": "95199-action.png"
        },
        "95236": {
            "ImageActionURL": "95236-action.png"
        },
        "95525": {
            "ImageActionURL": "95525-action.png"
        },
        "97322": {
            "ImageActionURL": "97322-action.png"
        },
        "97458": {
            "ImageActionURL": "97458-action.png"
        },
        "97514": {
            "ImageActionURL": "97514-action.png"
        },
        "97651": {
            "ImageActionURL": "97651-action.png"
        },
        "97934": {
            "ImageActionURL": "97934-action.png"
        },
        "98514": {
            "ImageActionURL": "98514-action.png"
        },
        "99086": {
            "ImageActionURL": "99086-action.png"
        },
        "99273": {
            "ImageActionURL": "99273-action.png"
        },
        "99589": {
            "ImageActionURL": "99589-action.png"
        },
        "99607": {
            "ImageActionURL": "99607-action.png"
        },
        "99727": {
            "ImageActionURL": "99727-action.png"
        },
        "99729": {
            "ImageActionURL": "99729-action.png"
        },
        "100768": {
            "ImageActionURL": "100768-action.png"
        },
        "100840": {
            "ImageActionURL": "100840-action.png"
        },
        "100881": {
            "ImageActionURL": "100881-action.png"
        },
        "101303": {
            "ImageActionURL": "101303-action.png"
        },
        "101763": {
            "ImageActionURL": "101763-action.png"
        },
        "101780": {
            "ImageActionURL": "101780-action.png"
        },
        "101902": {
            "ImageActionURL": "101902-action.png"
        },
        "102243": {
            "ImageActionURL": "102243-action.png"
        },
        "102354": {
            "ImageActionURL": "102354-action.png"
        },
        "102524": {
            "ImageActionURL": "102524-action.png"
        },
        "102708": {
            "ImageActionURL": "102708-action.png"
        },
        "102857": {
            "ImageActionURL": "102857-action.png"
        },
        "103252": {
            "ImageActionURL": "103252-action.png"
        },
        "103403": {
            "ImageActionURL": "103403-action.png"
        },
        "104266": {
            "ImageActionURL": "104266-action.png"
        },
        "104435": {
            "ImageActionURL": "104435-action.png"
        },
        "104640": {
            "ImageActionURL": "104640-action.png"
        },
        "104679": {
            "ImageActionURL": "104679-action.png"
        },
        "104825": {
            "ImageActionURL": "104825-action.png"
        },
        "105634": {
            "ImageActionURL": "105634-action.png"
        },
        "105942": {
            "ImageActionURL": "105942-action.png"
        },
        "106073": {
            "ImageActionURL": "106073-action.png"
        },
        "107694": {
            "ImageActionURL": "107694-action.png"
        },
        "107765": {
            "ImageActionURL": "107765-action.png"
        },
        "107796": {
            "ImageActionURL": "107796-action.png"
        },
        "108912": {
            "ImageActionURL": "108912-action.png"
        },
        "111917": {
            "ImageActionURL": "111917-action.png"
        },
        "115745": {
            "ImageActionURL": "115745-action.png"
        },
        "117462": {
            "ImageActionURL": "117462-action.png"
        },
        "119238": {
            "ImageActionURL": "119238-action.png"
        },
        "120264": {
            "ImageActionURL": "120264-action.png"
        },
        "120840": {
            "ImageActionURL": "120840-action.png"
        },
        "124453": {
            "ImageActionURL": "124453-action.png"
        },
        "126349": {
            "ImageActionURL": "126349-action.png"
        },
        "126898": {
            "ImageActionURL": "126898-action.png"
        },
        "135567": {
            "ImageActionURL": "135567-action.png"
        },
        "156594": {
            "ImageActionURL": "156594-action.png"
        },
        "89017": {
            "ImagePeakURL": "89017-peak.png"
        }
    }
}
</file>

<file path="python/advanced_engines.py">
#!/usr/bin/env python3
"""
Advanced Analysis Engines
Passing Prediction and Tactical Event Detection
"""

import numpy as np
from typing import Dict, List, Tuple, Optional
from collections import defaultdict
from dataclasses import dataclass

from soccer_analysis_core import TrackPoint, logger


@dataclass
class PassingPrediction:
    """Predicted pass from ball carrier to potential receiver"""
    frame: int
    timestamp: float
    ball_carrier_id: int
    receiver_id: int
    probability: float  # 0.0 to 1.0
    distance: float
    receiver_position: Tuple[float, float]


@dataclass
class TacticalAlert:
    """Real-time tactical event"""
    frame: int
    timestamp: float
    event_type: str  # 'counter_attack', 'high_press', 'defensive_line_break'
    team: str
    severity: str  # 'low', 'medium', 'high'
    description: str
    players_involved: List[int]


class PassingEngine:
    """Predicts likely pass targets based on player positions and movement"""
    
    def __init__(self, config):
        self.config = config
    
    def predict_passes(self, frames_data: Dict[int, List[Tuple[int, TrackPoint]]], 
                      ball_track: Optional[List[TrackPoint]] = None) -> List[PassingPrediction]:
        """
        Predict passing options for each frame
        
        Algorithm:
        1. Find ball carrier (closest player to ball)
        2. Identify teammates in passing range
        3. Calculate pass probability based on:
           - Distance (closer = higher)
           - Angle (forward passes preferred)
           - Receiver velocity (moving into space = higher)
           - Defensive pressure (fewer defenders nearby = higher)
        """
        predictions = []
        
        for frame, players in frames_data.items():
            if not ball_track:
                continue
            
            # Find ball position for this frame
            ball_pos = next((b for b in ball_track if b.frame == frame), None)
            if not ball_pos or ball_pos.xm_smooth is None:
                continue
            
            # Find ball carrier (closest player to ball)
            carrier_id, carrier = self._find_ball_carrier(players, ball_pos)
            if carrier_id is None:
                continue
            
            # Get teammates
            teammates = [(pid, p) for pid, p in players 
                        if p.team == carrier.team and pid != carrier_id]
            
            if not teammates:
                continue
            
            # Calculate pass probabilities
            for receiver_id, receiver in teammates:
                if receiver.xm_smooth is None:
                    continue
                
                prob = self._calculate_pass_probability(
                    carrier, receiver, players, ball_pos
                )
                
                if prob > 0.3:  # Only include likely passes
                    distance = np.sqrt(
                        (receiver.xm_smooth - ball_pos.xm_smooth)**2 +
                        (receiver.ym_smooth - ball_pos.ym_smooth)**2
                    )
                    
                    predictions.append(PassingPrediction(
                        frame=frame,
                        timestamp=ball_pos.timestamp,
                        ball_carrier_id=carrier_id,
                        receiver_id=receiver_id,
                        probability=round(prob, 3),
                        distance=round(distance, 2),
                        receiver_position=(receiver.xm_smooth, receiver.ym_smooth)
                    ))
        
        return predictions
    
    def _find_ball_carrier(self, players: List[Tuple[int, TrackPoint]], 
                          ball: TrackPoint) -> Tuple[Optional[int], Optional[TrackPoint]]:
        """Find player closest to ball"""
        min_dist = float('inf')
        carrier_id = None
        carrier = None
        
        for pid, p in players:
            if p.xm_smooth is None or p.team == "BALL":
                continue
            
            dist = np.sqrt(
                (p.xm_smooth - ball.xm_smooth)**2 +
                (p.ym_smooth - ball.ym_smooth)**2
            )
            
            if dist < min_dist and dist < 2.0:  # Within 2m
                min_dist = dist
                carrier_id = pid
                carrier = p
        
        return carrier_id, carrier
    
    def _calculate_pass_probability(self, carrier: TrackPoint, receiver: TrackPoint,
                                    all_players: List[Tuple[int, TrackPoint]],
                                    ball: TrackPoint) -> float:
        """Calculate probability of pass to receiver"""
        # Distance factor (optimal 5-20m)
        distance = np.sqrt(
            (receiver.xm_smooth - ball.xm_smooth)**2 +
            (receiver.ym_smooth - ball.ym_smooth)**2
        )
        
        if distance < 3 or distance > 40:
            return 0.0
        
        distance_score = 1.0 - min(abs(distance - 12) / 30, 1.0)
        
        # Forward pass bonus (attacking direction)
        forward_score = 1.0
        if receiver.xm_smooth > carrier.xm_smooth:
            forward_score = 1.3
        
        # Receiver movement score (moving into space)
        movement_score = min(receiver.velocity / 5.0, 1.0) if receiver.velocity > 0 else 0.5
        
        # Defensive pressure (count opponents near receiver)
        opponents = [p for pid, p in all_players 
                    if p.team != carrier.team and p.team != "BALL" and p.xm_smooth is not None]
        
        pressure_count = sum(1 for p in opponents if np.sqrt(
            (p.xm_smooth - receiver.xm_smooth)**2 +
            (p.ym_smooth - receiver.ym_smooth)**2
        ) < 5.0)
        
        pressure_score = max(0.3, 1.0 - (pressure_count * 0.2))
        
        # Combined probability
        probability = (distance_score * 0.4 + 
                      forward_score * 0.2 + 
                      movement_score * 0.2 + 
                      pressure_score * 0.2)
        
        return min(probability, 1.0)


class TacticalEngine:
    """Detects tactical events in real-time"""
    
    def __init__(self, config):
        self.config = config
        self.last_alerts = defaultdict(float)  # Debounce alerts
    
    def detect_events(self, frames_data: Dict[int, List[Tuple[int, TrackPoint]]]) -> List[TacticalAlert]:
        """Detect tactical events across frames"""
        alerts = []
        
        for frame, players in frames_data.items():
            # Separate teams
            team_a = [(pid, p) for pid, p in players if p.team == "A" and p.xm_smooth is not None]
            team_b = [(pid, p) for pid, p in players if p.team == "B" and p.xm_smooth is not None]
            
            if not team_a or not team_b:
                continue
            
            timestamp = players[0][1].timestamp if players else 0
            
            # Detect counter attacks
            alerts.extend(self._detect_counter_attack(frame, timestamp, team_a, team_b))
            alerts.extend(self._detect_counter_attack(frame, timestamp, team_b, team_a))
            
            # Detect high press
            alerts.extend(self._detect_high_press(frame, timestamp, team_a, team_b))
            alerts.extend(self._detect_high_press(frame, timestamp, team_b, team_a))
        
        return alerts
    
    def _detect_counter_attack(self, frame: int, timestamp: float,
                               attacking_team: List[Tuple[int, TrackPoint]],
                               defending_team: List[Tuple[int, TrackPoint]]) -> List[TacticalAlert]:
        """Detect counter attack: fast forward movement with numerical advantage"""
        alerts = []
        
        # Check if multiple attackers are sprinting forward
        sprinting_attackers = [(pid, p) for pid, p in attacking_team if p.is_sprinting]
        
        if len(sprinting_attackers) < 2:
            return alerts
        
        # Check if they're in attacking half
        avg_x = np.mean([p.xm_smooth for _, p in sprinting_attackers])
        if avg_x < 52.5:  # Not in attacking half
            return alerts
        
        # Count defenders in vicinity
        defenders_back = sum(1 for _, p in defending_team if p.xm_smooth > avg_x - 20)
        
        if len(sprinting_attackers) > defenders_back:
            # Debounce (don't alert within 3 seconds)
            alert_key = f"counter_{attacking_team[0][1].team}_{frame // 90}"
            if timestamp - self.last_alerts[alert_key] > 3.0:
                self.last_alerts[alert_key] = timestamp
                
                alerts.append(TacticalAlert(
                    frame=frame,
                    timestamp=timestamp,
                    event_type='counter_attack',
                    team=attacking_team[0][1].team,
                    severity='high',
                    description=f"Counter attack! {len(sprinting_attackers)} vs {defenders_back}",
                    players_involved=[pid for pid, _ in sprinting_attackers]
                ))
        
        return alerts
    
    def _detect_high_press(self, frame: int, timestamp: float,
                          pressing_team: List[Tuple[int, TrackPoint]],
                          pressed_team: List[Tuple[int, TrackPoint]]) -> List[TacticalAlert]:
        """Detect high press: multiple defenders in opponent's half"""
        alerts = []
        
        # Count pressers in opponent's defensive third
        pressers = [(pid, p) for pid, p in pressing_team 
                   if p.xm_smooth < 35 and p.velocity > 2.0]
        
        if len(pressers) >= 3:
            alert_key = f"press_{pressing_team[0][1].team}_{frame // 90}"
            if timestamp - self.last_alerts[alert_key] > 5.0:
                self.last_alerts[alert_key] = timestamp
                
                alerts.append(TacticalAlert(
                    frame=frame,
                    timestamp=timestamp,
                    event_type='high_press',
                    team=pressing_team[0][1].team,
                    severity='medium',
                    description=f"High press with {len(pressers)} players",
                    players_involved=[pid for pid, _ in pressers]
                ))
        
        return alerts
</file>

<file path="python/analytics/tactical_analytics.py">
import numpy as np
from collections import defaultdict

class TacticalAnalytics:
    def __init__(self, fps=30):
        self.fps = fps
        self.player_histories = defaultdict(list) # id -> list of (frame, x, y)
        self.team_centroids = defaultdict(list) # frame -> (x, y)
        
    def update(self, frame_idx, tracks, field_coords):
        """
        Update analytics with new frame data.
        tracks: [x1, y1, x2, y2, id, score, cls]
        field_coords: [x, y] corresponding to tracks
        """
        if len(tracks) != len(field_coords):
            return
            
        current_positions = {}
        
        for i, track in enumerate(tracks):
            track_id = int(track[4])
            x, y = field_coords[i]
            
            # Store history
            self.player_histories[track_id].append((frame_idx, x, y))
            current_positions[track_id] = (x, y)
            
        # Calculate Team Centroid (assuming we know teams, here just all players)
        if len(field_coords) > 0:
            centroid = np.mean(field_coords, axis=0)
            self.team_centroids[frame_idx] = centroid
            
    def calculate_speed(self, track_id, window_frames=15):
        """
        Calculate current speed in m/s (or km/h)
        """
        history = self.player_histories[track_id]
        if len(history) < 2:
            return 0.0
            
        # Get recent history
        recent = history[-window_frames:]
        if len(recent) < 2:
            return 0.0
            
        # Calculate distance traveled
        start_pos = np.array(recent[0][1:])
        end_pos = np.array(recent[-1][1:])
        dist = np.linalg.norm(end_pos - start_pos)
        
        # Calculate time
        time_sec = (recent[-1][0] - recent[0][0]) / self.fps
        
        if time_sec == 0: return 0.0
        
        speed_mps = dist / time_sec
        speed_kmh = speed_mps * 3.6
        
        return speed_kmh
        
    def get_heatmap(self, track_id, grid_size=(105, 68)):
        """
        Generate 2D histogram for player position
        """
        history = self.player_histories[track_id]
        if not history:
            return np.zeros(grid_size)
            
        x_coords = [p[1] for p in history]
        y_coords = [p[2] for p in history]
        
        heatmap, _, _ = np.histogram2d(x_coords, y_coords, bins=grid_size, range=[[0, 105], [0, 68]])
        return heatmap
</file>

<file path="python/analyze_image_fixed.py">
"""
STANDALONE FIXED ANALYSIS SCRIPT
This version has ALL fixes built-in with no external dependencies.
GUARANTEED to produce high-contrast team colors.

Save this as: analyze_image_fixed.py
Run: python analyze_image_fixed.py your_image.jpg
"""

import sys
from pathlib import Path
import cv2
import numpy as np
import torch
import supervision as sv

PROJECT_DIR = Path(__file__).resolve().parent
sys.path.append(str(PROJECT_DIR))

from pipelines import TacticalPipeline, DepthPipeline
from player_clustering import ClusteringManager
from constants import model_path
from keypoint_detection.keypoint_constants import keypoint_model_path


def get_team_brightness(crops):
    """Calculate average brightness of team crops."""
    if not crops:
        return 128
    brightnesses = [np.mean(crop) for crop in crops]
    return np.mean(brightnesses)


def assign_high_contrast_colors(team0_crops, team1_crops):
    """
    Assign guaranteed high-contrast colors based on brightness.
    WHITE team ‚Üí Light gray
    COLORED team ‚Üí Bright red
    """
    team0_bright = get_team_brightness(team0_crops)
    team1_bright = get_team_brightness(team1_crops)
    
    print(f"\n{'='*70}")
    print("üé® HIGH-CONTRAST COLOR ASSIGNMENT")
    print(f"{'='*70}")
    print(f"Team 0 brightness: {team0_bright:.1f}")
    print(f"Team 1 brightness: {team1_bright:.1f}")
    
    if team0_bright > team1_bright:
        # Team 0 is brighter
        colors = {
            'team0': (230, 230, 230),  # Light gray (white team)
            'team1': (50, 50, 220),    # Bright red (colored team)
            'team0_name': 'Light Gray (White Jerseys)',
            'team1_name': 'Bright Red (Colored Jerseys)'
        }
    else:
        # Team 1 is brighter
        colors = {
            'team0': (50, 50, 220),    # Bright red (colored team)
            'team1': (230, 230, 230),  # Light gray (white team)
            'team0_name': 'Bright Red (Colored Jerseys)',
            'team1_name': 'Light Gray (White Jerseys)'
        }
    
    # Calculate and verify contrast
    distance = np.linalg.norm(np.array(colors['team0']) - np.array(colors['team1']))
    
    print(f"‚úÖ Team 0 ‚Üí {colors['team0_name']}: {colors['team0']}")
    print(f"‚úÖ Team 1 ‚Üí {colors['team1_name']}: {colors['team1']}")
    print(f"‚úÖ Color distance: {distance:.1f} (Excellent!)")
    print(f"{'='*70}\n")
    
    return colors['team0'], colors['team1']


def analyze_image_fixed(image_path, output_path="fixed_result.jpg", show=True):
    """
    Analyze image with GUARANTEED high-contrast colors.
    No automatic color extraction - uses brightness-based assignment.
    """
    
    print("="*70)
    print("FIXED SOCCER ANALYSIS - HIGH CONTRAST MODE")
    print("="*70)
    print(f"Input: {image_path}")
    print(f"Output: {output_path}")
    
    # Load image
    frame = cv2.imread(str(image_path))
    if frame is None:
        print(f"‚ùå ERROR: Cannot read image: {image_path}")
        return
    
    h, w = frame.shape[:2]
    print(f"Image size: {w}x{h}")
    
    # Initialize
    print("\nüì¶ Initializing models...")
    tactical_pipeline = TacticalPipeline(str(keypoint_model_path), str(model_path))
    depth_pipeline = DepthPipeline()
    tactical_pipeline.initialize_models()
    depth_pipeline.initialize_model()
    
    # Detect
    print("üîç Running detection...")
    with torch.no_grad():
        player_dets, ball_dets, ref_dets = tactical_pipeline.detect_frame_objects(frame)
        keypoints = tactical_pipeline.detect_frame_keypoints(frame)
        depth_map = depth_pipeline.estimate_depth(frame)
    
    print(f"   Players: {len(player_dets) if player_dets else 0}")
    print(f"   Balls: {len(ball_dets) if ball_dets else 0}")
    print(f"   Referees: {len(ref_dets) if ref_dets else 0}")
    
    # Cluster players
    team0_color = (230, 230, 230)  # Default
    team1_color = (50, 50, 220)    # Default
    
    if player_dets is not None and len(player_dets) > 1:
        print("\nüîÑ Clustering players...")
        clustering_manager = ClusteringManager(n_clusters=2)
        player_crops = clustering_manager.embedding_extractor.get_player_crops(frame, player_dets)
        
        if player_crops and len(player_crops) > 1:
            player_labels, _, _ = clustering_manager.train_clustering_models(player_crops)
            player_dets.class_id = player_labels
            
            # Get team crops
            team0_crops = [player_crops[i] for i, label in enumerate(player_labels) if label == 0]
            team1_crops = [player_crops[i] for i, label in enumerate(player_labels) if label == 1]
            
            print(f"   Team 0: {len(team0_crops)} players")
            print(f"   Team 1: {len(team1_crops)} players")
            
            # CRITICAL: Assign high-contrast colors
            team0_color, team1_color = assign_high_contrast_colors(team0_crops, team1_crops)
    
    # Referee color (gray for visibility)
    referee_color = (100, 100, 100)
    
    # Generate tactical view with FIXED colors
    print("üéØ Generating tactical view with high-contrast colors...")
    tactical_frame, metadata = tactical_pipeline.process_detections_for_tactical_analysis(
        player_dets, ball_dets, ref_dets, keypoints,
        team1_color=team0_color,
        team2_color=team1_color,
        referee_color=referee_color,
        attacking_direction="left-to-right"
    )
    
    # Create dashboard
    print("üé® Creating dashboard...")
    annotator_manager = tactical_pipeline.detection_pipeline.annotator_manager if hasattr(tactical_pipeline.detection_pipeline, 'annotator_manager') else None
    
    if annotator_manager:
        annotated_frame = annotator_manager.annotate_all(frame, player_dets, ball_dets, ref_dets)
    else:
        annotated_frame = frame.copy()
    
    dashboard = tactical_pipeline.create_side_by_side_frame(
        annotated_frame, tactical_frame, metadata, frame_height=480
    )
    
    # Add depth map
    depth_viz = depth_pipeline.visualize_depth(depth_map)
    depth_small = cv2.resize(depth_viz, (240, 135))
    h_db, w_db = dashboard.shape[:2]
    dashboard[h_db-145:h_db-10, 10:250] = depth_small
    
    # Add color indicator text on dashboard
    cv2.putText(dashboard, "HIGH CONTRAST MODE", (w_db//2 - 150, 30),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
    
    # Save
    cv2.imwrite(str(output_path), dashboard)
    print(f"\n‚úÖ SAVED: {output_path}")
    
    # Show
    if show:
        try:
            display_frame = dashboard
            if w_db > 1920 or h_db > 1080:
                scale = min(1920/w_db, 1080/h_db)
                display_frame = cv2.resize(dashboard, (int(w_db*scale), int(h_db*scale)))
            
            cv2.imshow("Fixed Analysis - High Contrast", display_frame)
            print("üëÄ Press any key to close...")
            cv2.waitKey(0)
            cv2.destroyAllWindows()
        except:
            print("‚ö†Ô∏è  Cannot show window (headless mode)")
    
    print("\n" + "="*70)
    print("‚úÖ ANALYSIS COMPLETE - CHECK THE TACTICAL VIEW!")
    print("   Teams should be clearly visible:")
    print(f"   - Team 0: {team0_color}")
    print(f"   - Team 1: {team1_color}")
    print("="*70)


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Fixed soccer analysis with guaranteed high contrast")
    parser.add_argument("image", help="Input image path")
    parser.add_argument("--output", default="fixed_result.jpg", help="Output path")
    parser.add_argument("--no-show", action="store_true", help="Don't display window")
    
    args = parser.parse_args()
    
    analyze_image_fixed(args.image, args.output, not args.no_show)
</file>

<file path="python/analyze_match.py">
import argparse
import cv2
import json
import sys
import os
import numpy as np
from tqdm import tqdm

# Add project root to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from python.models.fusion_detector import FusionDetector
from python.trackers.hybrid_tracker import HybridTracker
from python.utils.scene_analyzer import SceneAnalyzer
from python.utils.optical_flow import OpticalFlowEngine
from python.utils.field_calibration import FieldCalibrator
from python.analytics.tactical_analytics import TacticalAnalytics

def analyze_match(video_path, output_path, calibration_points=None):
    print(f"Starting Elite Analysis for: {video_path}")
    
    # 1. Initialize Pipeline Components
    detector = FusionDetector()
    tracker = HybridTracker()
    scene_analyzer = SceneAnalyzer()
    optical_flow = OpticalFlowEngine()
    calibrator = FieldCalibrator()
    analytics = TacticalAnalytics()
    
    # Set manual calibration if provided
    if calibration_points:
        calibrator.calibrate_manual(calibration_points)
    else:
        # Default fallback (approximate for demo)
        # Assuming 1920x1080 video looking at full pitch
        calibrator.calibrate_manual([[200, 200], [1720, 200], [1920, 1080], [0, 1080]])

    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print("Error: Could not open video.")
        return

    fps = cap.get(cv2.CAP_PROP_FPS)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    
    results = {
        "metadata": {
            "fps": fps,
            "width": width,
            "height": height,
            "total_frames": total_frames
        },
        "tracks": [],
        "analytics": {
            "speeds": {},
            "distances": {}
        }
    }
    
    # 2. Process Video
    frame_idx = 0
    pbar = tqdm(total=total_frames, desc="Processing Frames")
    
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
            
        # A. Scene Analysis
        scene_info = scene_analyzer.analyze(frame)
        
        # B. Multi-Model Detection
        detections = detector.detect(frame, scene_info)
        
        # C. Hybrid Tracking
        tracks = tracker.update(detections, frame)
        
        # D. Optical Flow Stabilization
        tracks = optical_flow.stabilize(tracks, frame)
        
        # E. Field Calibration
        field_coords = calibrator.transform(tracks)
        
        # F. Analytics Update
        analytics.update(frame_idx, tracks, field_coords)
        
        # Store frame results
        frame_data = {
            "frame": frame_idx,
            "timestamp": frame_idx / fps,
            "scene": {
                "is_crowded": bool(scene_info.is_crowded),
                "is_shaky": bool(scene_info.is_shaky)
            },
            "objects": []
        }
        
        for i, track in enumerate(tracks):
            track_id = int(track[4])
            x1, y1, x2, y2 = map(int, track[:4])
            
            obj_data = {
                "id": track_id,
                "box": [x1, y1, x2, y2],
                "score": float(track[5]),
                "class": int(track[6])
            }
            
            if i < len(field_coords):
                fx, fy = field_coords[i]
                obj_data["field_pos"] = [float(fx), float(fy)]
                obj_data["speed"] = analytics.calculate_speed(track_id)
                
            frame_data["objects"].append(obj_data)
            
        results["tracks"].append(frame_data)
        
        frame_idx += 1
        pbar.update(1)
        
    pbar.close()
    cap.release()
    
    # 3. Save Results
    print(f"Saving results to {output_path}...")
    with open(output_path, 'w') as f:
        json.dump(results, f)
        
    print("Analysis Complete!")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("video_path", help="Path to input video")
    parser.add_argument("--output", default="analysis_results.json", help="Path to output JSON")
    args = parser.parse_args()
    
    analyze_match(args.video_path, args.output)
</file>

<file path="python/annotators/__init__.py">
from .annotators import AnnotatorManager
</file>

<file path="python/annotators/annotators.py">
import sys
from pathlib import Path
import numpy as np
import cv2

# Adjust project path to allow imports from other packages if needed
PROJECT_DIR = Path(__file__).resolve().parent.parent
if str(PROJECT_DIR) not in sys.path:
    sys.path.append(str(PROJECT_DIR))

try:
    import supervision as sv
except ImportError:
    # Fallback to prevent crash if supervision is not installed
    class MockAnnotator:
        def annotate(self, frame, detections, labels=None, **kwargs): return frame
    
    class sv:
        class Color:
            GREEN = (0, 255, 0)
            BLUE = (255, 0, 0)
        
        class Detections:
            def __init__(self, xyxy, class_id=None, tracker_id=None, confidence=None):
                self.xyxy = xyxy
                self.class_id = class_id
                self.tracker_id = tracker_id
                self.confidence = confidence
            def __len__(self): return len(self.xyxy)
            
        EllipseAnnotator = TriangleAnnotator = LabelAnnotator = BoxAnnotator = VertexAnnotator = EdgeAnnotator = MockAnnotator


class AnnotatorManager:
    """
    Manager class for all annotation functionality.
    Provides a unified interface for annotating players, ball, referees, and keypoints.
    """

    def __init__(self, edges=None):
        """Initialize all annotation tools."""
        # Basic annotators
        self.ellipse_annotator = sv.EllipseAnnotator()
        self.triangle_annotator = sv.TriangleAnnotator()
        self.label_annotator = sv.LabelAnnotator()
        self.box_annotator = sv.BoxAnnotator()

        # Keypoint annotators
        try:
            self.vertex_annotator = sv.VertexAnnotator(color=sv.Color.GREEN, radius=8)
            self.edge_annotator = sv.EdgeAnnotator(color=sv.Color.BLUE, thickness=3, edges=edges)
        except:
            self.vertex_annotator = sv.VertexAnnotator()
            self.edge_annotator = sv.EdgeAnnotator()

    def annotate_players(self, frame: np.ndarray, player_detections: 'sv.Detections') -> np.ndarray:
        """
        Annotate only players on the frame.
        """
        if player_detections is None or len(player_detections.xyxy) == 0:
            return frame

        if getattr(player_detections, 'tracker_id', None) is None:
            player_detections.tracker_id = np.arange(len(player_detections.xyxy))
        
        player_labels = [f'#{tracker_id}' for tracker_id in player_detections.tracker_id]
        frame = self.ellipse_annotator.annotate(frame, player_detections)
        frame = self.label_annotator.annotate(frame, detections=player_detections, labels=player_labels)

        return frame

    def annotate_ball(self, frame: np.ndarray, ball_detections: 'sv.Detections') -> np.ndarray:
        """
        Annotate ball detections on frame.
        """
        if ball_detections is not None and len(ball_detections.xyxy) > 0:
            return self.triangle_annotator.annotate(frame, ball_detections)
        return frame

    def annotate_referees(self, frame: np.ndarray, referee_detections: 'sv.Detections') -> np.ndarray:
        """
        Annotate referee detections on frame.
        """
        if referee_detections is not None and len(referee_detections.xyxy) > 0:
            if getattr(referee_detections, 'tracker_id', None) is None:
                referee_detections.tracker_id = np.arange(len(referee_detections.xyxy))
            return self.ellipse_annotator.annotate(frame, referee_detections)
        return frame

    def annotate_all(self, frame: np.ndarray, player_detections, ball_detections, referee_detections) -> np.ndarray:
        """
        Annotate players, ball, and referees on the frame using separate methods.
        """
        target_frame = frame.copy()

        # Annotate each type separately
        target_frame = self.annotate_players(target_frame, player_detections)
        target_frame = self.annotate_ball(target_frame, ball_detections)
        target_frame = self.annotate_referees(target_frame, referee_detections)

        return target_frame

    def annotate_bboxes(self, frame: np.ndarray, detections: 'sv.Detections', class_names: dict = None) -> np.ndarray:
        """
        Annotate frame with object detections bboxes.
        """
        if detections is None or len(detections.xyxy) == 0:
            return frame

        annotated_frame = frame.copy()

        # Annotate with boxes
        annotated_frame = self.box_annotator.annotate(annotated_frame, detections)

        # Add labels if class_names provided
        if class_names is not None:
            labels = []
            for class_id, conf in zip(detections.class_id, detections.confidence):
                class_name = class_names.get(class_id, f'Class {class_id}')
                labels.append(f"{class_name} {conf:.2f}")
            annotated_frame = self.label_annotator.annotate(annotated_frame, detections, labels)

        return annotated_frame

    def annotate_keypoints(self, frame: np.ndarray, keypoints: np.ndarray, confidence_threshold: float = 0.5,
                          draw_vertices: bool = True, draw_edges = None, draw_labels: bool = True,
                          KEYPOINT_CONNECTIONS=[], KEYPOINT_NAMES={}, 
                          KEYPOINT_COLOR=(0, 255, 0), CONNECTION_COLOR=(255, 0, 0), TEXT_COLOR=(255, 255, 255)) -> np.ndarray:
        """
        Annotate frame with detected keypoints using Vertex and Edge annotators.
        """
        for kpts in keypoints:
            # Draw keypoint connections
            if draw_edges:
                for connection in KEYPOINT_CONNECTIONS:
                    pt1_idx, pt2_idx = connection
                    if pt1_idx < len(kpts) and pt2_idx < len(kpts):
                        pt1 = kpts[pt1_idx]
                        pt2 = kpts[pt2_idx]
                        if pt1[2] > confidence_threshold and pt2[2] > confidence_threshold:
                            cv2.line(frame,
                                (int(pt1[0]), int(pt1[1])),
                                (int(pt2[0]), int(pt2[1])),
                                CONNECTION_COLOR, 2)

            # Draw keypoints
            for kpt_idx, kpt in enumerate(kpts):
                if kpt[2] > confidence_threshold:
                    x, y = int(kpt[0]), int(kpt[1])
                    cv2.circle(frame, (x, y), 5, KEYPOINT_COLOR, -1)
                    if draw_labels:
                        label = f"{kpt_idx}: {KEYPOINT_NAMES.get(kpt_idx, 'Unknown')}"
                        cv2.putText(frame, label, (x + 10, y - 10),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.4, TEXT_COLOR, 1)

        return frame

    def convert_tracks_to_detections(self, player_tracks, ball_tracks, referee_tracks, player_classids=None):
        """
        Convert tracking data back to supervision detections format.
        """
        # Get the player detections
        if player_tracks is not None:
            if player_classids is not None:
                class_ids = [player_classids[tracker_id] for tracker_id in player_tracks.keys()]
            else:
                class_ids = [0] * len(player_tracks)
            
            player_detections = sv.Detections(
                xyxy=np.array(list(player_tracks.values())),
                class_id=np.array(class_ids),
                tracker_id=np.array(list(player_tracks.keys()))
            )
        else:
            player_detections = None

        # Get the ball detections
        if ball_tracks is not None:
            ball_detections = sv.Detections(
                xyxy=np.array([ball_tracks]),
                class_id=np.array([2]),
            )
        else:
            ball_detections = None

        # Get the referee detections
        if referee_tracks is not None:
            referee_detections = sv.Detections(
                xyxy=np.array(list(referee_tracks.values())),
                class_id=np.array([3] * len(referee_tracks)),
                tracker_id=np.array(list(referee_tracks.keys()))
            )
        else:
            referee_detections = None

        return player_detections, ball_detections, referee_detections
</file>

<file path="python/api_server.py">
"""
Flask API Server for Soccer Analysis
Provides endpoints for video analysis, tracking, and metrics calculation
"""

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from werkzeug.utils import secure_filename
import os
import json
import uuid
import threading
from datetime import datetime
import cv2
import numpy as np

# Import analysis modules
import sys
sys.path.append(os.path.dirname(__file__))

from detection.fusion_detector import FusionDetector
from tracking.hybrid_tracker import HybridTracker
from utils.optical_flow import OpticalFlowEngine
from utils.field_calibration import FieldCalibrator
from analytics.tactical_analytics import TacticalAnalytics

app = Flask(__name__)
CORS(app)

# Configuration
UPLOAD_FOLDER = 'uploads'
RESULTS_FOLDER = 'results'
ALLOWED_EXTENSIONS = {'mp4', 'avi', 'mov', 'mkv'}
MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024  # 2GB

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(RESULTS_FOLDER, exist_ok=True)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['RESULTS_FOLDER'] = RESULTS_FOLDER
app.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE

# Job storage (in production, use Redis or database)
analysis_jobs = {}


def allowed_file(filename):
    """Check if file extension is allowed"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS


def analyze_video_task(job_id, video_path, calibration_points, models):
    """Background task for video analysis"""
    try:
        # Update job status
        analysis_jobs[job_id]['status'] = 'processing'
        analysis_jobs[job_id]['progress'] = 0
        
        # Open video
        cap = cv2.VideoCapture(video_path)
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        fps = cap.get(cv2.CAP_PROP_FPS)
        
        analysis_jobs[job_id]['total_frames'] = total_frames
        analysis_jobs[job_id]['fps'] = fps
        
        # Initialize components
        detector = FusionDetector(
            yolo_model='yolov10x.pt',
            rtdetr_model='rtdetr-x.pt',
            device='cuda' if 'cuda' in models else 'cpu'
        )
        
        tracker = HybridTracker(max_age=30, n_init=3)
        optical_flow = OpticalFlowEngine()
        
        # Field calibration
        calibrator = None
        if calibration_points and len(calibration_points) == 4:
            calibrator = FieldCalibrator()
            calibrator.calibrate(calibration_points)
        
        # Analytics
        analytics = TacticalAnalytics()
        
        # Storage for results
        tracking_data = []
        events = []
        
        frame_idx = 0
        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break
            
            # Detect players and ball
            detections = detector.detect(frame)
            
            # Track
            tracks = tracker.update(detections, frame)
            
            # Optical flow stabilization
            if frame_idx > 0:
                flow = optical_flow.compute_flow(prev_frame, frame)
            
            # Store tracking data
            frame_data = {
                'frame': frame_idx,
                'timestamp': frame_idx / fps,
                'players': []
            }
            
            for track in tracks:
                player_data = {
                    'id': int(track['id']),
                    'team': track.get('team', 'TEAM_A'),
                    'bbox': track['bbox'].tolist(),
                    'confidence': float(track['confidence'])
                }
                
                # Convert to field coordinates if calibrated
                if calibrator:
                    center_x = (track['bbox'][0] + track['bbox'][2]) / 2
                    center_y = track['bbox'][3]  # Bottom of bbox
                    field_coords = calibrator.pixel_to_field(center_x, center_y)
                    player_data['x'] = float(field_coords[0])
                    player_data['y'] = float(field_coords[1])
                
                frame_data['players'].append(player_data)
            
            tracking_data.append(frame_data)
            
            # Update progress
            frame_idx += 1
            progress = int((frame_idx / total_frames) * 100)
            analysis_jobs[job_id]['progress'] = progress
            analysis_jobs[job_id]['current_frame'] = frame_idx
            
            prev_frame = frame.copy()
        
        cap.release()
        
        # Calculate metrics
        metrics = analytics.calculate_all_metrics(tracking_data)
        
        # Generate events from tracking data
        detected_events = analytics.detect_events(tracking_data)
        
        # Save results
        results = {
            'tracking': tracking_data,
            'events': detected_events,
            'metrics': metrics,
            'metadata': {
                'total_frames': total_frames,
                'fps': fps,
                'duration': total_frames / fps,
                'processed_at': datetime.now().isoformat()
            }
        }
        
        result_path = os.path.join(RESULTS_FOLDER, f'{job_id}.json')
        with open(result_path, 'w') as f:
            json.dump(results, f)
        
        # Update job status
        analysis_jobs[job_id]['status'] = 'completed'
        analysis_jobs[job_id]['progress'] = 100
        analysis_jobs[job_id]['results'] = results
        
    except Exception as e:
        analysis_jobs[job_id]['status'] = 'failed'
        analysis_jobs[job_id]['error'] = str(e)
        print(f"Error analyzing video: {e}")


@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat()
    })


@app.route('/api/analyze-video', methods=['POST'])
def analyze_video():
    """
    Upload and analyze video
    
    Form data:
        - video: Video file
        - calibration: JSON string with 4 calibration points
        - models: JSON array of models to use
    """
    # Check if video file is present
    if 'video' not in request.files:
        return jsonify({'error': 'No video file provided'}), 400
    
    file = request.files['video']
    
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
    
    if not allowed_file(file.filename):
        return jsonify({'error': 'Invalid file type'}), 400
    
    # Save video file
    filename = secure_filename(file.filename)
    job_id = str(uuid.uuid4())
    video_filename = f"{job_id}_{filename}"
    video_path = os.path.join(app.config['UPLOAD_FOLDER'], video_filename)
    file.save(video_path)
    
    # Get calibration points
    calibration_points = None
    if 'calibration' in request.form:
        try:
            calibration_points = json.loads(request.form['calibration'])
        except:
            pass
    
    # Get models
    models = ['yolov10', 'rtdetr', 'deepsort']
    if 'models' in request.form:
        try:
            models = json.loads(request.form['models'])
        except:
            pass
    
    # Create job
    analysis_jobs[job_id] = {
        'id': job_id,
        'status': 'queued',
        'progress': 0,
        'video_path': video_path,
        'created_at': datetime.now().isoformat(),
        'current_frame': 0,
        'total_frames': 0
    }
    
    # Start analysis in background thread
    thread = threading.Thread(
        target=analyze_video_task,
        args=(job_id, video_path, calibration_points, models)
    )
    thread.daemon = True
    thread.start()
    
    return jsonify({
        'success': True,
        'job_id': job_id,
        'status': 'queued'
    })


@app.route('/api/analysis-status/<job_id>', methods=['GET'])
def get_analysis_status(job_id):
    """Get status of analysis job"""
    if job_id not in analysis_jobs:
        return jsonify({'error': 'Job not found'}), 404
    
    job = analysis_jobs[job_id]
    
    response = {
        'job_id': job_id,
        'status': job['status'],
        'progress': job['progress'],
        'current_frame': job.get('current_frame', 0),
        'total_frames': job.get('total_frames', 0)
    }
    
    if job['status'] == 'completed':
        response['results'] = job.get('results')
    elif job['status'] == 'failed':
        response['error'] = job.get('error')
    
    return jsonify(response)


@app.route('/api/calculate-metrics', methods=['POST'])
def calculate_metrics():
    """
    Calculate advanced metrics from tracking data
    
    JSON body:
        - tracking_data: Array of frame tracking data
        - metrics: Array of metric names to calculate
    """
    data = request.get_json()
    
    if not data or 'tracking_data' not in data:
        return jsonify({'error': 'No tracking data provided'}), 400
    
    tracking_data = data['tracking_data']
    requested_metrics = data.get('metrics', ['xg', 'xthreat', 'vaep', 'ppda'])
    
    analytics = TacticalAnalytics()
    
    results = {}
    
    if 'xg' in requested_metrics:
        results['xg'] = analytics.calculate_xg(tracking_data)
    
    if 'xthreat' in requested_metrics:
        results['xthreat'] = analytics.calculate_xthreat(tracking_data)
    
    if 'vaep' in requested_metrics:
        results['vaep'] = analytics.calculate_vaep(tracking_data)
    
    if 'ppda' in requested_metrics:
        results['ppda'] = analytics.calculate_ppda(tracking_data)
    
    return jsonify(results)


@app.route('/api/results/<job_id>', methods=['GET'])
def get_results(job_id):
    """Get full results for a completed job"""
    result_path = os.path.join(RESULTS_FOLDER, f'{job_id}.json')
    
    if not os.path.exists(result_path):
        return jsonify({'error': 'Results not found'}), 404
    
    with open(result_path, 'r') as f:
        results = json.load(f)
    
    return jsonify(results)


@app.route('/api/jobs', methods=['GET'])
def list_jobs():
    """List all analysis jobs"""
    jobs = []
    for job_id, job in analysis_jobs.items():
        jobs.append({
            'id': job_id,
            'status': job['status'],
            'progress': job['progress'],
            'created_at': job['created_at']
        })
    
    return jsonify({'jobs': jobs})


if __name__ == '__main__':
    print("üöÄ Starting Soccer Analysis API Server...")
    print(f"üìÅ Upload folder: {UPLOAD_FOLDER}")
    print(f"üìÅ Results folder: {RESULTS_FOLDER}")
    print("üåê Server running on http://localhost:5000")
    
    app.run(host='0.0.0.0', port=5000, debug=True, threaded=True)
</file>

<file path="python/api.py">
import os
import shutil
import json
import uvicorn
from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pathlib import Path
import base64
import cv2
import numpy as np
from typing import Optional

# Global analyzer instance for single-frame detection
_global_analyzer = None

def get_analyzer():
    global _global_analyzer
    if _global_analyzer is None and SoccerMatchAnalyzer:
        config = AnalysisConfig(confidence_threshold=0.3)
        _global_analyzer = SoccerMatchAnalyzer(config)
        _global_analyzer.load_model()
        _global_analyzer.load_roboflow_model()
    return _global_analyzer

# Import analysis modules
try:
    from soccer_analysis_processor import SoccerMatchAnalyzer, AnalysisConfig
except Exception as e:
    print(f"Error: Could not import soccer_analysis_processor: {e}")
    import traceback
    traceback.print_exc()
    # Mock for testing if modules missing
    SoccerMatchAnalyzer = None

# Check GPU availability
import torch
if torch.cuda.is_available():
    print(f"‚úÖ GPU Detected: {torch.cuda.get_device_name(0)}")
else:
    print("‚ö†Ô∏è  No GPU detected! Running on CPU.")

app = FastAPI(title="Soccer Analysis API")

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
def health_check():
    return {"status": "healthy", "service": "soccer-analysis-api"}

@app.post("/analyze")
async def analyze_match(
    video: UploadFile = File(...),
    clips: str = Form(None),
    generate_video: bool = Form(False),
    conf: float = Form(0.3)
):
    if not SoccerMatchAnalyzer:
        raise HTTPException(status_code=500, detail="Analysis modules not loaded")

    try:
        # Create temp directory
        temp_dir = Path("temp_uploads")
        temp_dir.mkdir(exist_ok=True)
        
        # Save uploaded video
        video_path = temp_dir / video.filename
        with open(video_path, "wb") as buffer:
            shutil.copyfileobj(video.file, buffer)
            
        print(f"Received video: {video.filename}, Size: {os.path.getsize(video_path)} bytes")
        
        # Parse clips
        clips_data = None
        if clips:
            try:
                clips_data = json.loads(clips)
                print(f"Processing {len(clips_data)} clips")
            except json.JSONDecodeError:
                print("Invalid clips JSON")
        
        # Run Analysis
        print("Starting analysis...")
        config = AnalysisConfig(confidence_threshold=conf)
        analyzer = SoccerMatchAnalyzer(config)
        
        results = analyzer.analyze(
            video_path=str(video_path),
            clips=clips_data
        )
        
        # Cleanup
        if video_path.exists():
            os.remove(video_path)
            
        return {"success": True, "results": results}

    except Exception as e:
        print(f"Analysis failed: {str(e)}")
        import traceback
        traceback.print_exc()
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e)}
        )

@app.post("/api/detect-players")
async def detect_players_endpoint(
    image: str = Form(...),
    homography: Optional[str] = Form(None),
    high_contrast: bool = Form(False)
):
    """Detect players in a single frame and project them onto the pitch."""
    analyzer = get_analyzer()
    if analyzer is None:
        raise HTTPException(status_code=500, detail="Analysis modules not loaded")

    try:
        print(f"üì• Received detect-players request. High contrast: {high_contrast}")
        analyzer.config.use_high_contrast_colors = high_contrast
        # Decode base64 image
        header, encoded = image.split(",", 1) if "," in image else (None, image)
        image_data = base64.b64decode(encoded)
        nparr = np.frombuffer(image_data, np.uint8)
        frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)

        if frame is None:
            print("‚ùå Error: Failed to decode image")
            raise ValueError("Failed to decode image")

        print(f"üñºÔ∏è Decoded image size: {frame.shape}")

        # Setup homography if provided
        if homography:
            print(f"üó∫Ô∏è Setting up homography: {homography[:50]}...")
            from soccer_analysis_core import HomographyTransform
            analyzer.homography = HomographyTransform.from_string(homography)

        # Run single frame detection
        print("üîç Running detection...")
        if analyzer.roboflow_model:
            print("‚ú® Using Roboflow model")
            detections = analyzer.roboflow_model.get_detections(frame, confidence=analyzer.config.confidence_threshold)
            boxes = detections.xyxy
            confs = detections.confidence
            cls_ids = detections.class_id
            
            final_results = []
            for bbox, conf, cls_id in zip(boxes, confs, cls_ids):
                final_results.append({
                    'bbox': bbox,
                    'conf': conf,
                    'cls': cls_id
                })
        else:
            print("üöÄ Using local YOLO model")
            results = analyzer.model.predict(
                frame,
                conf=analyzer.config.confidence_threshold,
                classes=[0, 32], # Person and Ball
                verbose=False
            )
            
            final_results = []
            for result in results:
                boxes = result.boxes.xyxy.cpu().numpy()
                confs = result.boxes.conf.cpu().numpy()
                cls_ids = result.boxes.cls.cpu().numpy().astype(int)
                for bbox, conf, cls_id in zip(boxes, confs, cls_ids):
                    final_results.append({
                        'bbox': bbox,
                        'conf': conf,
                        'cls': cls_id
                    })

        print(f"‚úÖ Found {len(final_results)} objects")
        players = []
        for detection in final_results:
            x1, y1, x2, y2 = detection['bbox']
            conf = detection['conf']
            cls_id = detection['cls']
            
            # Bottom-center for feet-level projection
            foot_x, foot_y = float((x1 + x2) / 2), float(y2)
            
            # Transform to meters
            xm, ym = None, None
            if analyzer.homography and analyzer.homography.enabled:
                xm, ym = analyzer.homography.transform(foot_x, foot_y)
            
            players.append({
                "id": len(players) + 1,
                "bbox": [float(x1), float(y1), float(x2), float(y2)],
                "center": [foot_x, foot_y],
                "pitch_coords": [xm, ym] if xm is not None else None,
                "team": "BALL" if cls_id == 32 else "Unknown",
                "confidence": float(conf),
                "cls": int(cls_id)
            })

        return {"success": True, "players": players}

    except Exception as e:
        print(f"‚ùå Detection failed: {str(e)}")
        import traceback
        traceback.print_exc()
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e), "traceback": traceback.format_exc()}
        )


# --- CROWD ANNOTATION ENDPOINTS ---
from pydantic import BaseModel
from typing import Optional
import sqlite3

class CrowdReviewRequest(BaseModel):
    video_path: str
    timestamp_seconds: float
    event_type: Optional[str] = None  # Optional pre-tag by analyst
    match_name: Optional[str] = "Unknown Match"
    window_seconds: float = 10.0

# Path to TactaBot database
TACTABOT_DB = Path(__file__).parent / "tactabot.db"
CLIPS_DIR = Path(__file__).parent.parent / "public" / "clips"
UPLOADS_DIR = Path(__file__).parent.parent / "public" / "uploads"

@app.post("/api/crowd/request-review-upload")
async def request_crowd_review_upload(
    video: UploadFile = File(...),
    timestamp_seconds: float = Form(...),
    match_name: str = Form("Unknown Match"),
    window_seconds: float = Form(10.0),
    event_type: Optional[str] = Form(None)
):
    """
    Analyst-triggered endpoint to send a specific moment to the crowd for annotation.
    Accepts video file upload.
    """
    try:
        from clip_generator import extract_clip_at_timestamp
        
        # Save uploaded video to temp location with unique name to avoid Windows locks/collisions
        import uuid
        temp_uuid = uuid.uuid4().hex[:8]
        temp_video_path = UPLOADS_DIR / f"temp_{temp_uuid}_{video.filename}"
        
        with open(temp_video_path, "wb") as buffer:
            shutil.copyfileobj(video.file, buffer)
        
        # Generate unique clip filename
        import uuid
        clip_filename = f"crowd_{int(timestamp_seconds)}_{uuid.uuid4().hex[:8]}.mp4"
        CLIPS_DIR.mkdir(parents=True, exist_ok=True)
        output_path = CLIPS_DIR / clip_filename
        
        # Extract the clip
        print(f"üìπ Extracting clip at {timestamp_seconds}s from {temp_video_path}")
        result = extract_clip_at_timestamp(
            str(temp_video_path),
            str(output_path),
            timestamp_seconds,
            window_seconds
        )
        
        # Cleanup temp video
        if temp_video_path.exists():
            os.remove(temp_video_path)
        
        if not result:
            raise HTTPException(status_code=500, detail="Failed to extract clip")
        
        # Add to TactaBot database
        with sqlite3.connect(TACTABOT_DB) as conn:
            c = conn.cursor()
            c.execute("INSERT OR IGNORE INTO matches (name) VALUES (?)", (match_name,))
            c.execute("SELECT match_id FROM matches WHERE name = ? ORDER BY match_id DESC LIMIT 1", (match_name,))
            match_id = c.fetchone()[0]
            
            c.execute('''
                INSERT INTO clips (match_id, filename, qc_stage, status, required_tags, is_priority, pre_tag)
                VALUES (?, ?, 'crowd_voting', 'pending', 10, 1, ?)
            ''', (match_id, clip_filename, event_type))
            clip_id = c.lastrowid
            conn.commit()
        
        print(f"‚úÖ Clip added to crowd queue: {clip_filename} (ID: {clip_id})")
        
        return {
            "success": True,
            "clip_id": clip_id,
            "clip_filename": clip_filename,
            "message": f"Clip sent to crowd for annotation. Minimum 10 votes required for consensus."
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Crowd review request failed: {str(e)}")
        import traceback
        traceback.print_exc()
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e)}
        )

@app.post("/api/crowd/request-review")
async def request_crowd_review(request: CrowdReviewRequest):
    """
    Analyst-triggered endpoint to send a specific moment to the crowd for annotation.
    
    Workflow:
    1. Analyst tags a timestamp as "ambiguous" or "needs review"
    2. This endpoint extracts a 10s clip around that timestamp
    3. The clip is added to the TactaBot queue for fan voting
    4. Results come back through the bot's consensus mechanism
    """
    try:
        from clip_generator import extract_clip_at_timestamp
        
        # Validate video path
        video_path = Path(request.video_path)
        if not video_path.exists():
            raise HTTPException(status_code=404, detail=f"Video not found: {request.video_path}")
        
        # Generate unique clip filename
        import uuid
        clip_filename = f"crowd_{int(request.timestamp_seconds)}_{uuid.uuid4().hex[:8]}.mp4"
        CLIPS_DIR.mkdir(parents=True, exist_ok=True)
        output_path = CLIPS_DIR / clip_filename
        
        # Extract the clip
        print(f"üìπ Extracting clip at {request.timestamp_seconds}s from {video_path}")
        result = extract_clip_at_timestamp(
            str(video_path),
            str(output_path),
            request.timestamp_seconds,
            request.window_seconds
        )
        
        if not result:
            raise HTTPException(status_code=500, detail="Failed to extract clip")
        
        # Add to TactaBot database
        with sqlite3.connect(TACTABOT_DB) as conn:
            c = conn.cursor()
            
            # Create or get match
            c.execute("INSERT OR IGNORE INTO matches (name) VALUES (?)", (request.match_name,))
            c.execute("SELECT match_id FROM matches WHERE name = ? ORDER BY match_id DESC LIMIT 1", (request.match_name,))
            match_id = c.fetchone()[0]
            
            # Insert clip for crowd voting
            c.execute('''
                INSERT INTO clips (match_id, filename, qc_stage, status, required_tags, is_priority, pre_tag)
                VALUES (?, ?, 'crowd_voting', 'pending', 10, 1, ?)
            ''', (match_id, clip_filename, request.event_type))
            clip_id = c.lastrowid
            conn.commit()
        
        print(f"‚úÖ Clip added to crowd queue: {clip_filename} (ID: {clip_id})")
        
        return {
            "success": True,
            "clip_id": clip_id,
            "clip_filename": clip_filename,
            "message": f"Clip sent to crowd for annotation. Minimum 10 votes required for consensus."
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Crowd review request failed: {str(e)}")
        import traceback
        traceback.print_exc()
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e)}
        )


@app.get("/api/crowd/status/{clip_id}")
async def get_crowd_status(clip_id: int):
    """Check the voting status of a clip in the crowd queue."""
    try:
        with sqlite3.connect(TACTABOT_DB) as conn:
            c = conn.cursor()
            
            # Get clip info
            c.execute('''
                SELECT c.clip_id, c.filename, c.qc_stage, c.status, c.consensus_event,
                       (SELECT COUNT(*) FROM tags WHERE clip_id = c.clip_id) as vote_count,
                       c.required_tags
                FROM clips c WHERE c.clip_id = ?
            ''', (clip_id,))
            row = c.fetchone()
            
            if not row:
                raise HTTPException(status_code=404, detail=f"Clip not found: {clip_id}")
            
            # Get vote breakdown
            c.execute('''
                SELECT event_type, COUNT(*) as count
                FROM tags WHERE clip_id = ?
                GROUP BY event_type
                ORDER BY count DESC
            ''', (clip_id,))
            votes = {row[0]: row[1] for row in c.fetchall()}
            
        return {
            "success": True,
            "clip_id": row[0],
            "filename": row[1],
            "stage": row[2],
            "status": row[3],
            "consensus_event": row[4],
            "vote_count": row[5],
            "required_votes": row[6],
            "vote_breakdown": votes
        }
        
    except HTTPException:
        raise
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e)}
        )

@app.get("/api/community/leaderboard")
async def get_leaderboard():
    try:
        with sqlite3.connect(TACTABOT_DB) as conn:
            c = conn.cursor()
            c.execute("SELECT COALESCE(nickname, username, 'Analyst ' || user_id), xp FROM users ORDER BY xp DESC LIMIT 10")
            overall = [{"nickname": r[0], "xp": r[1]} for r in c.fetchall()]
            
            c.execute("SELECT COALESCE(nickname, username, 'Analyst ' || user_id), monthly_xp FROM users ORDER BY monthly_xp DESC LIMIT 10")
            monthly = [{"nickname": r[0], "xp": r[1]} for r in c.fetchall()]
            
        return {"success": True, "overall": overall, "monthly": monthly}
    except Exception as e:
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.get("/api/community/clubs")
async def get_club_rankings():
    try:
        with sqlite3.connect(TACTABOT_DB) as conn:
            c = conn.cursor()
            c.execute('''
                SELECT club, SUM(xp) as total_xp, COUNT(user_id) as members 
                FROM users 
                WHERE club IS NOT NULL 
                GROUP BY club 
                ORDER BY total_xp DESC
            ''')
            clubs = [{"name": r[0], "xp": r[1], "members": r[2]} for r in c.fetchall()]
            
        return {"success": True, "clubs": clubs}
    except Exception as e:
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.get("/api/community/user/{user_id}")
async def get_user_stats(user_id: int):
    try:
        with sqlite3.connect(TACTABOT_DB) as conn:
            c = conn.cursor()
            c.execute("SELECT COALESCE(nickname, username, 'Analyst ' || user_id), xp, monthly_xp, streak_days, trust_score, club FROM users WHERE user_id = ?", (user_id,))
            row = c.fetchone()
            if not row:
                return {"success": False, "error": "User not found"}
            
            c.execute("SELECT badge_type FROM badges WHERE user_id = ?", (user_id,))
            badges = [b[0] for b in c.fetchall()]
            
        return {
            "success": True,
            "stats": {
                "nickname": row[0],
                "xp": row[1],
                "monthly_xp": row[2],
                "streak": row[3],
                "trust": row[4],
                "club": row[5],
                "badges": badges
            }
        }
    except Exception as e:
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
</file>

<file path="python/camera_movement_estimator/__init__.py">
from .camera_movement_estimator import CameraMovementEstimator
</file>

<file path="python/camera_movement_estimator/camera_movement_estimator.py">
import pickle
import cv2
import numpy as np
import os
import sys 
sys.path.append('../')
from utils import measure_distance,measure_xy_distance

class CameraMovementEstimator():
    def __init__(self, frame=None):
        self.minimum_distance = 5

        self.lk_params = dict(
            winSize = (15,15),
            maxLevel = 2,
            criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT,10,0.03)
        )

        self.features = dict(
            maxCorners = 100,
            qualityLevel = 0.3,
            minDistance =3,
            blockSize = 7,
            mask = None
        )
        
        self.old_gray = None
        self.old_features = None
        
        if frame is not None:
            self.initialize(frame)

    def initialize(self, frame):
        first_frame_grayscale = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        mask_features = np.zeros_like(first_frame_grayscale)
        mask_features[:,0:20] = 1
        mask_features[:,900:1050] = 1
        
        self.features['mask'] = mask_features
        
        self.old_gray = first_frame_grayscale
        self.old_features = cv2.goodFeaturesToTrack(self.old_gray, **self.features)
    
    def step(self, frame):
        if self.old_gray is None:
            self.initialize(frame)
            return [0, 0]
            
        frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        
        if self.old_features is None or len(self.old_features) == 0:
             self.old_features = cv2.goodFeaturesToTrack(self.old_gray, **self.features)
             
        if self.old_features is None: # Still no features
             self.old_gray = frame_gray
             return [0, 0]

        new_features, _, _ = cv2.calcOpticalFlowPyrLK(self.old_gray, frame_gray, self.old_features, None, **self.lk_params)

        max_distance = 0
        camera_movement_x, camera_movement_y = 0, 0

        if new_features is not None:
            for i, (new, old) in enumerate(zip(new_features, self.old_features)):
                new_features_point = new.ravel()
                old_features_point = old.ravel()

                distance = measure_distance(new_features_point, old_features_point)
                if distance > max_distance:
                    max_distance = distance
                    camera_movement_x, camera_movement_y = measure_xy_distance(old_features_point, new_features_point)

        if max_distance > self.minimum_distance:
            self.old_features = cv2.goodFeaturesToTrack(frame_gray, **self.features)
        
        self.old_gray = frame_gray.copy()
        
        return [camera_movement_x, camera_movement_y]

    def add_adjust_positions_to_tracks(self,tracks, camera_movement_per_frame):
        for object, object_tracks in tracks.items():
            for frame_num, track in enumerate(object_tracks):
                for track_id, track_info in track.items():
                    position = track_info['position']
                    camera_movement = camera_movement_per_frame[frame_num]
                    position_adjusted = (position[0]-camera_movement[0],position[1]-camera_movement[1])
                    tracks[object][frame_num][track_id]['position_adjusted'] = position_adjusted
                    


    def get_camera_movement(self,frames,read_from_stub=False, stub_path=None):
        # Read the stub 
        if read_from_stub and stub_path is not None and os.path.exists(stub_path):
            with open(stub_path,'rb') as f:
                return pickle.load(f)

        camera_movement = [[0,0]]*len(frames)

        old_gray = cv2.cvtColor(frames[0],cv2.COLOR_BGR2GRAY)
        old_features = cv2.goodFeaturesToTrack(old_gray,**self.features)

        for frame_num in range(1,len(frames)):
            frame_gray = cv2.cvtColor(frames[frame_num],cv2.COLOR_BGR2GRAY)
            new_features, _,_ = cv2.calcOpticalFlowPyrLK(old_gray,frame_gray,old_features,None,**self.lk_params)

            max_distance = 0
            camera_movement_x, camera_movement_y = 0,0

            for i, (new,old) in enumerate(zip(new_features,old_features)):
                new_features_point = new.ravel()
                old_features_point = old.ravel()

                distance = measure_distance(new_features_point,old_features_point)
                if distance>max_distance:
                    max_distance = distance
                    camera_movement_x,camera_movement_y = measure_xy_distance(old_features_point, new_features_point ) 
            
            if max_distance > self.minimum_distance:
                camera_movement[frame_num] = [camera_movement_x,camera_movement_y]
                old_features = cv2.goodFeaturesToTrack(frame_gray,**self.features)

            old_gray = frame_gray.copy()
        
        if stub_path is not None:
            with open(stub_path,'wb') as f:
                pickle.dump(camera_movement,f)

        return camera_movement
    
    def draw_camera_movement(self,frames, camera_movement_per_frame):
        output_frames=[]

        for frame_num, frame in enumerate(frames):
            frame= frame.copy()

            overlay = frame.copy()
            cv2.rectangle(overlay,(0,0),(500,100),(255,255,255),-1)
            alpha =0.6
            cv2.addWeighted(overlay,alpha,frame,1-alpha,0,frame)

            x_movement, y_movement = camera_movement_per_frame[frame_num]
            frame = cv2.putText(frame,f"Camera Movement X: {x_movement:.2f}",(10,30), cv2.FONT_HERSHEY_SIMPLEX,1,(0,0,0),3)
            frame = cv2.putText(frame,f"Camera Movement Y: {y_movement:.2f}",(10,60), cv2.FONT_HERSHEY_SIMPLEX,1,(0,0,0),3)

            output_frames.append(frame) 

        return output_frames
</file>

<file path="python/cleanup_db.py">
import sqlite3
import os

DB_PATH = 'python/tactabot.db'

conn = sqlite3.connect(DB_PATH)
c = conn.cursor()

# Show current clips
print("Current clips in database:")
c.execute('SELECT clip_id, match_id, video_path FROM clips')
for row in c.fetchall():
    print(f"  ID {row[0]}: Match {row[1]} - {row[2]}")

# Delete dummy HTTP clips
c.execute('DELETE FROM clips WHERE video_path LIKE "http%"')
deleted = c.rowcount
conn.commit()

print(f"\nDeleted {deleted} dummy clips")

# Show remaining clips
print("\nRemaining clips:")
c.execute('SELECT clip_id, match_id, video_path FROM clips')
for row in c.fetchall():
    exists = "‚úì" if os.path.exists(row[2]) else "‚úó"
    print(f"  {exists} ID {row[0]}: {os.path.basename(row[2])}")

conn.close()
</file>

<file path="python/clip_generator.py">
import cv2
import os
import random
import logging
import subprocess
import shutil

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')


def extract_clip_at_timestamp(video_path: str, output_path: str, timestamp_seconds: float, window_seconds: float = 10.0) -> str | None:
    """
    Extracts a short clip from a video, centered around the given timestamp.
    Uses FFMPEG for accurate seeking and fast extraction.

    Args:
        video_path: Path to the source video file.
        output_path: Path where the clip will be saved.
        timestamp_seconds: The center point of the clip in seconds.
        window_seconds: The total duration of the clip (default 10s, i.e., ¬±5s).

    Returns:
        The output_path if successful, None otherwise.
    """
    if not os.path.exists(video_path):
        logging.error(f"Video file not found: {video_path}")
        return None

    # Check if ffmpeg is available
    if not shutil.which('ffmpeg'):
        logging.warning("ffmpeg not found, falling back to OpenCV method.")
        return _extract_clip_opencv(video_path, output_path, timestamp_seconds, window_seconds)

    start_time = max(0, timestamp_seconds - (window_seconds / 2))
    
    # FFMPEG command for fast and accurate extraction
    # -ss before -i for fast seeking, -t for duration
    cmd = [
        'ffmpeg',
        '-y',  # Overwrite output
        '-ss', str(start_time),
        '-i', video_path,
        '-t', str(window_seconds),
        '-c:v', 'libx264',  # Re-encode for compatibility
        '-preset', 'fast',
        '-crf', '23',
        '-c:a', 'aac',
        '-b:a', '128k',
        '-movflags', '+faststart',
        output_path
    ]

    try:
        logging.info(f"Extracting clip: {start_time:.2f}s to {start_time + window_seconds:.2f}s")
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
        
        if result.returncode != 0:
            logging.error(f"FFMPEG error: {result.stderr}")
            return None
            
        logging.info(f"Successfully extracted clip to: {output_path}")
        return output_path
        
    except subprocess.TimeoutExpired:
        logging.error("FFMPEG timed out during extraction.")
        return None
    except Exception as e:
        logging.error(f"Error during clip extraction: {e}")
        return None


def _extract_clip_opencv(video_path: str, output_path: str, timestamp_seconds: float, window_seconds: float) -> str | None:
    """Fallback method using OpenCV if FFMPEG is not available."""
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        logging.error("Could not open video with OpenCV.")
        return None

    fps = cap.get(cv2.CAP_PROP_FPS) or 30.0
    start_time = max(0, timestamp_seconds - (window_seconds / 2))
    start_frame = int(start_time * fps)
    end_frame = int((start_time + window_seconds) * fps)

    cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
    
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

    current_frame = start_frame
    while current_frame < end_frame and cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        out.write(frame)
        current_frame += 1

    out.release()
    cap.release()
    
    if current_frame > start_frame:
        logging.info(f"Successfully extracted clip (OpenCV) to: {output_path}")
        return output_path
    return None

def generate_clips_from_video(video_path, output_dir, num_clips=5, min_duration=5, max_duration=12):
    """
    Generates random clips from a video file using OpenCV.
    Each clip has a random duration between min_duration and max_duration seconds.
    Returns a list of paths to the generated clips.
    """
    if not os.path.exists(video_path):
        logging.error(f"Video file not found: {video_path}")
        return []

    os.makedirs(output_dir, exist_ok=True)
    
    generated_clips = []
    logging.info(f"Generating {num_clips} clips from {video_path}...")

    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        logging.error("Could not open video.")
        return []

    fps = cap.get(cv2.CAP_PROP_FPS)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    
    if fps == 0: fps = 30.0
    
    # Calculate num_clips dynamically if requested
    if num_clips == -1:
        video_duration = total_frames / fps
        avg_clip_duration = (min_duration + max_duration) / 2
        num_clips = int(video_duration / avg_clip_duration)
        logging.info(f"Video duration: {video_duration:.2f}s. Calculated {num_clips} clips.")
        
        # Safety cap
        if num_clips > 20:
            logging.warning(f"Capping clips at 20 (calculated {num_clips})")
            num_clips = 20
        if num_clips < 1:
            num_clips = 1

    for i in range(num_clips):
        # Random clip duration between min and max
        clip_duration = random.uniform(min_duration, max_duration)
        
        # Ensure we don't go past video end
        max_start_time = (total_frames / fps) - clip_duration - 1
        if max_start_time <= 0:
            logging.warning(f"Video too short for clip duration {clip_duration}s")
            continue
            
        start_time = random.uniform(0, max_start_time)
        start_frame = int(start_time * fps)
        end_frame = int((start_time + clip_duration) * fps)
        
        clip_name = f"clip_{int(start_time)}_{random.randint(1000,9999)}.mp4"
        output_path = os.path.join(output_dir, clip_name)
        
        # Setup VideoWriter
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
        
        cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
        
        current_frame = start_frame
        while current_frame < end_frame and cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break
            out.write(frame)
            current_frame += 1
            
        out.release()
        logging.info(f"Generated: {clip_name}")
        generated_clips.append(output_path)

    cap.release()
    return generated_clips
</file>

<file path="python/colab_notebook.py">
# ==========================================
# GOOGLE COLAB NOTEBOOK SCRIPT
# Copy and paste this entire script into a code cell in Google Colab.
# ==========================================

# 1. Check GPU
import subprocess
import os

print("üîç Checking GPU...")
gpu_info = subprocess.run(['nvidia-smi'], capture_output=True, text=True)
if gpu_info.returncode == 0:
    print("‚úÖ GPU Available!")
    print(gpu_info.stdout)
else:
    print("‚ö†Ô∏è  No GPU detected. Go to Runtime -> Change runtime type -> GPU")

# 2. Clone or Upload Code
print("\nüì¶ Setting up code...")

# Option A: Upload the zip file manually
# Click the folder icon on the left, then upload python_kaggle.zip
# Then uncomment these lines:
# !unzip -o python_kaggle.zip
# %cd python

# Option B: Clone from GitHub (if you have a public repo)
# !git clone https://github.com/your-username/your-repo.git
# %cd your-repo/python

# For now, we'll assume you uploaded python_kaggle.zip
if os.path.exists('python_kaggle.zip'):
    print("Found python_kaggle.zip, extracting...")
    !unzip -qo python_kaggle.zip
    %cd python
elif os.path.exists('/content/python_kaggle.zip'):
    print("Found python_kaggle.zip in /content, extracting...")
    !unzip -qo /content/python_kaggle.zip
    %cd python
else:
    print("‚ö†Ô∏è  Please upload python_kaggle.zip to Colab")
    print("   1. Click the folder icon on the left sidebar")
    print("   2. Click the upload button")
    print("   3. Select python_kaggle.zip")
    print("   4. Run this cell again")
    raise Exception("Code not found")

# 3. Install System Dependencies
print("\nüì¶ Installing system dependencies...")
!apt-get update -qq
!apt-get install -y -qq libgl1 libglib2.0-0

# 4. Install Python Dependencies
print("\nüì¶ Installing Python libraries...")
!pip install -q 'numpy<2.0.0' -r requirements.txt
!pip install -q pyngrok

# 5. Setup Ngrok
print("\nüîê Setting up Ngrok...")
from pyngrok import ngrok, conf

# Get authtoken
print("="*60)
print("NGROK SETUP")
print("1. Go to: https://dashboard.ngrok.com/get-started/your-authtoken")
print("2. Copy your authtoken")
print("="*60)

from getpass import getpass
authtoken = getpass("Paste your Ngrok authtoken here: ")
ngrok.set_auth_token(authtoken)

# 6. Start Server in Background
print("\nüöÄ Starting server...")

# Create a startup script
with open('start_server.sh', 'w') as f:
    f.write('#!/bin/bash\n')
    f.write('python api.py\n')

!chmod +x start_server.sh

# Start server in background
import threading
import time

def run_server():
    os.system('./start_server.sh')

server_thread = threading.Thread(target=run_server, daemon=True)
server_thread.start()

# Wait for server to start
print("Waiting for server to start...")
time.sleep(5)

# 7. Create Ngrok Tunnel
public_url = ngrok.connect(8000, bind_tls=True)
print("\n" + "="*60)
print(f"‚úÖ PUBLIC URL: {public_url}")
print("="*60)
print("\nCopy this URL and paste it into your app's 'Remote Server URL' setting.")
print("\nThe server is now running! Keep this notebook open.")
print("To stop: Runtime -> Interrupt execution")

# Keep the cell running
try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    print("\nüõë Server stopped")
    ngrok.disconnect(public_url)
</file>

<file path="python/constants.py">
from pathlib import Path

# Paths
model_path = r"c:\Users\lenovo\Downloads\soccer-controller-log-main\soccer-controller-log-main\yolov8m.pt"
# keypoint_model_path is in keypoint_detection/keypoint_constants.py
</file>

<file path="python/development_and_analysis/color_assignement.ipynb">
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "import cv2\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "from sklearn.cluster import KMeans"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "image_path = \"../output_videos/cropped_image.jpg\"\n",
    "image = cv2.imread(image_path)\n",
    "image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAPoAAAGgCAYAAACDjnoYAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuNSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/xnp5ZAAAACXBIWXMAAA9hAAAPYQGoP6dpAABRsElEQVR4nO29e5AdZZ3H/e3uc5vrmUuSmQzJQMBouIiXCGGEXRWjKYqXgiWvqxZbolDLqhNWktp1zZbg6qpBaktY3ICXogLWLotmd2F3pcTCuGKJCWDQfUU0BsySgWQm1zNnbufW3e8fkxzm932enJ4zmcCJ/ftUTVWePn26n+5znvT5/q5OGIYhFEX5g8Z9vSegKMqpRxe6osQAXeiKEgN0oStKDNCFrigxQBe6osQAXeiKEgN0oStKDNCFrigxQBe6osSAU7bQN2/ejLPOOguZTAarVq3C008/fapOpShKBM6piHX/zne+g4985CP4+te/jlWrVuGuu+7C1q1bsWvXLixatKjme4MgwL59+9DW1gbHceZ7aoryB0UYhhgbG0NfXx9ct8ZzOzwFXHzxxeHg4GB17Pt+2NfXF27atCnyvUNDQyEA/dM//avjb2hoqOa6SmCeKZVK2LlzJzZu3Fjd5rouVq9eje3btxv7F4tFFIvF6jg89gPj/13/LiTT09PjJ3tIP0I8z/yfLJGU28rlihhXAl+MM5m0fL0iX/d9OQaAIDA2ScLa8w4dT4w9T44BGP9L+xW6jlCOEwn+SOUkA8ukHcjz8jz5d5XxS0vujsC33Bi63zwPF7VvpuMla84RMG63+YSjYcgTpzk4xpUDjvGe+uA5Gtdh+RVr3u9X31MuVvDIV3+Gtra2mued94V+6NAh+L6Pnp4esb2npwe//e1vjf03bdqEz3/+88b2ZDqBVGa2C91cILzQaU3BDeQxUxn5RXIr8nXfNz+AwFz7NM/6Frq5SM0va4Xm5dD6SCZpQaD2AgNOfqE7Ad8ry42hfepf6PLezGmh03fAPAYtdNuii1C6UWozmOeFfsJ9iHlf6PWyceNGbNiwoTrO5/NYunSp2IdvBn+RbF9eXtl8I5L0xeHXbf95GPDCNca8O2+Q867Q0xowr42vvRKUa+7vuNFPIOMrQvPkBcNjvle2L11QCWvuY37fI/6TtC10HvN7gqh7MYd7FXHOeq/Ddl21FnoQRv2snGbeF/qCBQvgeR5GRkbE9pGREfT29hr7p9NppNNpY7uiKPPHvLvXUqkUVq5ciW3btlW3BUGAbdu2YWBgYL5PpyjKLDglP903bNiA66+/Hu94xztw8cUX46677sLExAQ+9rGPnYrTKYoSwSlZ6B/84Adx8OBB3HbbbRgeHsZb3/pWPPbYY4aBrubEXAeJY1qQdUtgaC+LTvFra25D95NVnnWoY5FvvM3QgDQt07Yg9bVNn5V9una+VrLGuaTnbAY+xqHfdXxdbGyLsl/Yzln05bU6dH8DNuAZ9yI6psL4ntC9Mq3sdAbbh2zuVPOcUTqf5xD13Z4+JRk/a57fzikzxq1btw7r1q07VYdXFKUONNZdUWKALnRFiQGvux/9RJQrFTjHZJ2hUWhsi/GtGfcLi7YhLVwin7bVbxtE+Ujl/lES0HYO4yrouljzsS5l33ylWDLOYfjm2Z9vBBdJd6hHIp9fnz6H1OiRLlWXNPns3MXyLa+BRjeh7wBfB+89C40d5ZufDfpEV5QYoAtdUWKALnRFiQG60BUlBjSsMc4JXzVesenBc6PTOznFsEIBMWXfNEqJ/ckgZU3UoP8nZ5OgII4Z1m9UNOchr90wQFHK6OT4hHGOQqEgxuWyNJy5oZxDkoxtKUoQylSajXN4npx3Opky9jl52GLHhsqohJNoi18YETDDwUeUPGic0xYgw/B7/BmfsTVT0II+0RUlBuhCV5QYoAtdUWJAw2p013Wr+nS2gfsziSrYEKVtorWxWUGGz2kUgTACfzibxDYPLurA96J2gknAJbFKZXMfsl94HOhDE0uwbYFedywFHvj2BUGEDSQiWcQWM2Ir/STmabyJNXlUworFBmJWF5FHjAhumc03u2bhich6ZtPoE11RYoAudEWJAbrQFSUGNKxGr1QqOC5PDa1L5Z292RTIo+QCj7StURTCqChqai3+X9IophBGF00U+9sqtJImN+ZlSMTatgfbORIUh5BKyEqyyaT0m3NCCheasCcUUYEMw6ct9w6d2vYNW7IIb4oy7ThO7WIkgeVemgUm6ToCTmqJmgNdl9XOwNvqt1npE11RYoAudEWJAbrQFSUGNKxGdxznVf3i1vZXVyy6k/8H4xhlnwozzmwLBVi6wSTNW8Ux9kajA4e6i7CIpDj0sqX1i2uIcGMHMTSKcpA9I2Mp+MCavLVJxqpnMnLMGp2bYRTLMnYeAEq0rUz335SdpHUj8gqmN9L9NWIOol6PuNdzwNTsEb5+m0avEX8RVWDl1eMqivIHjy50RYkButAVJQY0rEYPnVclV7lSu3gh+9UBIMEx4qSNEimpS7mgodHF1GIHqLdhAHc2NTSipSFi6NU+hyEk+Rh07zo7s8Y5Ugl57RnKFW9tli15Db85+cgzTWauuefJ846NjYrxxOS4fH1K5s17NCcvY/nqhmyvqN0skl/nz9hLmt+roMgx+uY0xJQ49p0+voDm4Fk0d82GoL5qdEVRjqELXVFigC50RYkBDavR/SCoaiY3IfV2OllDs5zoeKyX2aXKdefomEmLH51tBSyfjcaNXlTsu8UOwP5/jhmPzGmXGt1NmPo5nabYdk+OSyVZX69UmDSOMRNbvH0yJa999OgRMZ4symOyLz7V3CTGXqbFOAeFLRiaO6hQo0ey7Rh2GW5kgVl81/h7FdV8hN5uc90bMR0zvkfG538C9ImuKDFAF7qixABd6IoSA+pe6D/5yU9w1VVXoa+vD47j4JFHHhGvh2GI2267DYsXL0ZTUxNWr16N3bt3z9d8FUWZA3Ub4yYmJvCWt7wFN9xwA6699lrj9TvuuAN33303HnjgASxbtgy33nor1qxZg+effx6ZTGbW55kZMBNVBIILPgCWYAnjdUr456IFZBZJWIJy/DIZnahJQcqThi9OWmFjnZOwBGiQIcZNnLiYPwB4dG+SbGijBBbANBK6NI9KkTvLynNykkszBdgAQCotz5GfkAEziTQlrTgykWbSl0lHZRpPz4sMXYnaxs+ADJVsZ/ND0xjHBSZN41xU0krt5BxbQ4dahUwrvjlHG3Uv9CuuuAJXXHGF9bUwDHHXXXfhs5/9LK6++moAwLe//W309PTgkUcewYc+9CHjPcViUWSO5fP5eqekKEoE86rR9+zZg+HhYaxevbq6LZvNYtWqVdi+fbv1PZs2bUI2m63+LV26dD6npCgK5nmhDw8PAwB6enrE9p6enuprzMaNGzE6Olr9Gxoams8pKYqCBgiYSafThsYDpnU5a/PjGM0YrMUho5onUBNG0s9G8ETJ1E6suT0qNljhIB0OfKDEmgoXY4AZIGMi55CiYBc4tfU3AFANS5Qp4IUOgWxnhxh3dchxW5sZzNLaJgNezljaS3vI6zyaz4nxgdFDYvzSvr3GOaampsQ4EdYuaskBTmZTCUv4CgfEsOampCKHEm3402RNzo0gp7fJd80MYCoXZ6fR5/WJ3ts7/eGNjIyI7SMjI9XXFEV57ZnXhb5s2TL09vZi27Zt1W35fB5PPfUUBgYG5vNUiqLUQd0/3cfHx/HCCy9Ux3v27MEvf/lLdHV1ob+/H7fccgu++MUvYvny5VX3Wl9fH6655pr5nLeiKHVQ90L/+c9/jve85z3V8YYNGwAA119/Pe6//358+tOfxsTEBG666SbkcjlcdtlleOyxx+ryoQPTBfyPF/E39DXt61t8iUZDBqNJH/lcXfZvUhEJS1E/1nzsz+eCiKzROXlkctJMFklREQcu+sAFNZKk+13SiFzAYfqYcptD86xMSZ/1RFEWhehKdIrx8vPeZJyjr2+RnEeCbSZy/8mCPMevdj8nxuGvjFNg5NBBMR4dk8UsioFMzjGKQnDDSkt8RoKLV/AOdL+N/J6I+pOBLbGJP48Z8RdljuU4AXUv9He/+901u5s6joMvfOEL+MIXvlDvoRVFOUVorLuixABd6IoSA153P/qJcF23qptN/VzbPw3YavnXfo8RT0xx67aifRxnznukUlL71opZBoCFC7uNbWedc5YYc+RgWKl9XawRc4dlwQcA+L/fvyTG43mpbcvU3ILtBGd4S8S4ravdOEdzq4x/T4L9y2RnodCKZecsE2M3Y8bsj47J8OnfUjLVgQMHxPhoLifGbKvwLEUmjJwIHlPwh0PFPcHNJcOo2HmTmfvMZn9An+iKEgt0oStKDNCFrigxoGE1eiaTQcqiw4BZ6GuYfnOjMSMV/iuXZZw5xyAnk+ZcOAa8qUnGc7OW5TkcGZV6OeWYPu5zzjlHjM87/1w5B/q/2gPHB8g5vDK0zzjH6Lj0WR+mwo2cB1AoyHuVaJKCuqlN5pIDZu53viLP6Rq1OSm3v0Weo/+cM41zMBmKuX/+N78R4xxp+ij9DZj5DQ7ZcjhfnQMEuJgjN/XgzxOA0Yxz5vfKUofTij7RFSUG6EJXlBigC11RYkDDavRUJl3V6Kx1WaNzgwEAmCLfr9EAkePnPW4SIce2Wl5pqr+WapLx/KwzVyyXepvz6H3fzEdf2LNQjEPq0leh9wSunFNITQu6F8u4dAB40wVvEOPRMZn7ffDgYTH2HHmOli5pmyiH5ueRp3lwk4c0HbNMfvXAjdDCAJJJqeN7+2QBlMOjOTF+bpfU7EadA0tuOPfJ5BiPpMOxFfJ7xN87N2Q7jiW/nHS9MyPnnc9/IvSJrigxQBe6osQAXeiKEgN0oStKDGhYY1wlCOAeM6Bxsr9LQQrloiwKCABTtI0NY4ePSANTS4sMrkikZNCHrVDlVFEamM5aJIsrnH/++WKcaabAklZ5zuYWs0hmyugQKo2MXHjCJyNWhYxDnmdeSPsiea2tC6RRcf9ReS9b2ihpJS0tVJOhDIYBgIzHhRnlvApUpCNBAUpshPQtRquAPqRMqzQS9i5dLMbNra1i/PK+V8S4UjLPkaXknJa0PIdLLV2DChWSKHOHVzIS2+pRcrMRa8/V2ugTXVFigC50RYkButAVJQY0rEaH60z/ARiflJqPmxGWLMUhKxSMMk6FAvk9XlkGeZTHpe7MZrPGOZae2S/GnIDSvXCBGDeRZuRYB9fSyNEDBZpwI0DS5A41EEhwwAZHfABIN8vznvuWN4pxS1bOmxN8uhdREE7C0uwipGAgNhVQgQZOgjE0ukWnJvmG0v1MZaSdoCVLdplDlLhkKQjKRUInS9J+4foULFShwKyAGmrQ5+PZjEGcPTUH9ImuKDFAF7qixABd6IoSAxpWo0+MT6BUmZ6e0cCeGh4WKYEFACqklZrIh93cIn3FfAyPklyam81iCmeffbYYL1++XIwzVIiCKfpS3/mBqZ+50R/7n7nwATezCLjpn6VxYIJsHj2USNOzUMYH8BzamqVv2ear5yQW/kxZc4fgJCQ+YnRjTZCuT1FQwsJFshjnkSOy4MbEhBkPwKcoUrIOymQzIfNREtIOkPQ4ESr62avFIRVFsaILXVFigC50RYkBDavRK5VKVd8kElIvF6nQRKFoNiccGxsTY45l7+mRRQkWLpS6NNsufcOt7VKHAsAZZ5whxmkqPMF2gsCprTttRQQC0rbsZnX5/2rWvoHUkLY6BbbClzNpb5PX7lNAdoILHlp785EG53kEPJTXzc0UvKT51eUYcJ5FIiW/R719fWI8Qc0k9+zZY5yjMCFj8l0uIkrFSIyiEeRX58/DqtG5KQRUoyuKYkEXuqLEgLoW+qZNm3DRRRehra0NixYtwjXXXINdu3aJfQqFAgYHB9Hd3Y3W1lasXbsWIyMj8zppRVHqoy6N/sQTT2BwcBAXXXQRKpUK/vZv/xbvf//78fzzz1c18Pr16/Hoo49i69atyGazWLduHa699lo8+eSTdU0sCCo47lbmwoBcLLI1KfOKASCVln5zLyGP0dndIcYXXChzxxcukBqemzMApqaempJ+V/Y3U1izoTNLZTMegP3PrsfNK6SjNiS/OcdrVywV/x2ygZBbHVMVyvcn44LPOtSiG42cappmiBPrUAAok2Yvh5YiirTNo0KZGYqFOHOZzFXgz+PoUVmzAAD2Uc5ESMaGprQ8p8PGiKK8cJfiNRxLrDvbafjezIa6Fvpjjz0mxvfffz8WLVqEnTt34o//+I8xOjqK++67Dw8++CAuv/xyAMCWLVtw7rnnYseOHbjkkkvqnqCiKCfPSWn00dFRAEBXVxcAYOfOnSiXy1i9enV1nxUrVqC/vx/bt2+3HqNYLCKfz4s/RVHmlzkv9CAIcMstt+DSSy/FBRdcAAAYHh5GKpVCR0eH2LenpwfDw8PW42zatAnZbLb6x/2/FUU5eebsRx8cHMRzzz2Hn/70pyc1gY0bN2LDhg3VcT6fx9KlS5HwElUtzv5o1pStLWYcel+nrA82OSm1VWenzC9f1Cv96N2dXWLsJcxbxb76YsXU2DM5evSoGLOGLwdmAwfHlfqsp2cRvU6anZpHsluX9R4AgHL3jTh0Swy+hDS6RUMGpFVDbo5AtgSH7ACcGj5ZMOPQK1R/rbVd1rZLQMY58ANpivzottiJJOW0V6aogQbFSiSphlzo1c49CCy5CLXuzWz96HNa6OvWrcP3vvc9/OQnP8GSJUuq23t7e1EqlZDL5cRNHBkZQW9vr/VY6XQa6bRZFFFRlPmjrp/uYRhi3bp1ePjhh/GjH/0Iy5YtE6+vXLkSyWQS27Ztq27btWsX9u7di4GBgfmZsaIodVPXE31wcBAPPvgg/vM//xNtbW1V3Z3NZtHU1IRsNosbb7wRGzZsQFdXF9rb23HzzTdjYGBALe6K8jpS10K/9957AQDvfve7xfYtW7bgox/9KADgzjvvhOu6WLt2LYrFItasWYN77rmn7omFTlCtE5bJpMRr2S4Zh3722WcZ71+wSGruPS/JuOVm0vU+B1uT9uW644CpyT1uzEgafN/IPjHm5pBeyvyBxRquqU3Ouz0rx6FPdcP5eJ6Zx83x8IzHjnUiAOtOcx/jHLQPu48rZGuYnJT5DPv2mcbdYkGeY6asBICFC6XdJg0pGdsopp/rDQDAxJicx4H9B8S4XObcAvKTG/EDvMHU6GyfmEuse10L3Z6sIMlkMti8eTM2b95cz6EVRTmFaKy7osQAXeiKEgN0oStKDGjcwhN+Cc6xAIjubmlYa2+XSSwLFslGCQCwqJcCS1JcRFEGgYxN5MS4VJLGN1uhAy4g6bqU+MIGJmpiUA6kMS4MzEL9IQWzHM7JRIt0CyWkkEGvRE0ZLT0JEJKFiIs8lGiebAByqMGALWCGczt4HzboleheFckYevjwQeMc+bwMispk5OfR1tYh55Ch+01BPIsosQkAFiyQxrejh3JiPFWQCUCeR4k29BlzgI0tXsbIhpq5k/0NBvpEV5QYoAtdUWKALnRFiQENq9HDMKgWXUhRMv+bL7xAjBf2mBo9TQ0aWjpkVhwHqwzte0WMX3zxRfl+S4IDa9USFfPngJkpKmLJcQmVMTNwxcvIjyhTlrqzSAk/ZWpuAY+KLBpnMINyKtzgkMJuAgrK8Tz5+djiLRxXXgcXteSApdExmQB08IC0TRw8fMg4x5FD8j1HDo+KcVubTGQ6c4n8TJOuDKBZ1m8GzIzlpB3guV88J8alKfl5JDiIiq4znZbBYFb7BicViUIftkYWJvpEV5QYoAtdUWKALnRFiQENq9E9z6kmU5gN+qjAXsLiHGb/JDuQqRFguSy11VRJ6un9v99vnMJIWKBThEZBRDknbirR3ikLJQBAE9kaeMx+WE7GcRwqqghbEQl5DJd0okf3jos+TE1JH3e5bJ6DdXtAzxgutMk+8fFxWeTjMBXxAMxEGM+V49zhnBgv7ZFzyqTkvU16Uj8DwKJOWVfhvDfIoqL/R00fygX5vQLVtGQ7jiXnyIjXcGbcK8eb3bNan+iKEgN0oStKDNCFrigxoGE1euBXEFSmNZTpl+Vihha/LSfr0z5cVHF8SmrAsUlZdvrF3+82z8FeaTomFytMpeTtXtgrY6mbs1KzA4CbrN2NcHQsJ191pAh0ElIvW2pcwiVfL5keUClKnXm8zPdxxvNSsxcKZpEOz5MnTqVlPADHJBw+LDX46CH5eRw4IGPOASCTpCIcJXnM0aPyGE0J6TcvFuW9aoH5efR0yc/sLW9+mxjnDubEeH9eFhtpSkg7gEfFI22FJFxjn3DGv7XJoqIox9CFrigxQBe6osSAhtXorutWfasJEo2GT7Zi+m0N3yM3OKSGfAkqgFgsyjxuo2EiAJd88dyUwPc5dp10KuvWlPlxcEPJSiDnXSnKeVUc8ttSE8YCFTcETHsF2wG4MGMxwm/ucHMGAClITe7RvfHJd8+5CNz8wta6K5Wl5goUI350RB4j9CnennzeXoa6XwDoapO1EZreKGsj/PrZX4vxvr2yiGWSYttdStS3KW7+vtffYlGf6IoSC3ShK0oM0IWuKDGgYTV6Ah4Sx/yHrNfGyI/b0kq12gC0ZWWusR/RSHBht8xpX7xY+ksLBVPbHj0q58FNF4004mZpKGhupmYMrWbOeys1FQg9juGn3HHuqpiQGn180tS2EwW5ja91YoJj26X9IkX+6LYWqVsBIEnx8iWyHXgUk5BJyWMuf8MbxTh3UN5rAPBLHLcgj+GX5ettCXlvOzuozqBxBmCqLK+9u1lq9s522ZzTJTuAS80jjaaYnlkxwJjHTF3PxfhOgD7RFSUG6EJXlBigC11RYoAudEWJAQ1rjPN9H8frBhylon/Dr4yIcYaKMQBA7xmycyZ3GQUFwHR2yg6tndkOMT7QYiY4cOIFk05LY1CKDGWppBwnk2aABgefcJKLR+NSSE0hKNii1VLkMkzIe8FdYn1qrlCmzqjUIwKppPl5pFNcULJ20wejwUY+J8YcSAQA+SPSqNhGhTEnx2Sgz0tDL4vx8qXL5QFthq6ynKdLjUHaMrJ4SIqKV1ANFaNIpjeLZ+9MQ7ImtSiKUkUXuqLEgLoW+r333osLL7wQ7e3taG9vx8DAAL7//e9XXy8UChgcHER3dzdaW1uxdu1ajIyM1DiioiivBXVp9CVLluD222/H8uXLEYYhHnjgAVx99dX4xS9+gfPPPx/r16/Ho48+iq1btyKbzWLdunW49tpr8eSTT9Y9MSd04BwLLhinQJQjR46IcecRs6hipSx1ZCJFiTGU5dLUJINuFi8+Q4z37ZPJCQDghlScv0xalporlBJSzFao0IGtbiNrupRLzRKoOGS5JK97jApTtGZlkA4AtFFQDhfQyNC9maIkF78o90+4pq2BNXUiIbUrNz7I5aTerhQoMMjSJIIDew4UZCNGtyDnNfT7vWL8xjPeJMYtrmz4AAAJsgdxoE+WGjm2t8pjFIuyCWMiRfeKP3AAgc9FU2bsPrsei/Ut9KuuukqMv/SlL+Hee+/Fjh07sGTJEtx333148MEHcfnllwMAtmzZgnPPPRc7duzAJZdcYj1msVgUmWK2rCRFUU6OOWt03/fx0EMPYWJiAgMDA9i5cyfK5TJWr15d3WfFihXo7+/H9u3bT3icTZs2IZvNVv+WLl16wn0VRZkbdS/0X/3qV2htbUU6ncbHP/5xPPzwwzjvvPMwPDyMVCqFjo4OsX9PTw+Gh82fvcfZuHEjRkdHq39DQ0N1X4SiKLWp24/+pje9Cb/85S8xOjqKf/u3f8P111+PJ554Ys4TSKfThr8ZAFzHqxbFK1JBgAnS7DZ/9tio3KezW/rJU9QYkH3D2WaZmJFJmsX8mzNSr5WoKCLrSPaT8zidMs/R0S7tD15G/t9cpiYFXHjiYE7OyUmbfldu8sCNJTJ0nZyMg4B8yxb/s0P2jFJB3m9uvuBX5L0bG5UNHSYtBTSa0qSfAyomUpL34tAh2aiRC2x4Lebn4TnmNjkHac9ozsh7OTEmr4NjKfheAmasxFz86HUv9FQqhTe84Q0AgJUrV+KZZ57BP/7jP+KDH/wgSqUScrmceKqPjIygt7f3BEdTFOW14KT96EEQoFgsYuXKlUgmk9i2bVv1tV27dmHv3r0YGBg42dMoinIS1PVE37hxI6644gr09/djbGwMDz74IH784x/jBz/4AbLZLG688UZs2LABXV1daG9vx80334yBgYETWtwVRXltqGuhHzhwAB/5yEewf/9+ZLNZXHjhhfjBD36A973vfQCAO++8E67rYu3atSgWi1izZg3uueeeOU0sdFyExxyGqYzUPUfIx7rMMzU+a2ouMAkqRFGhAocJej3bZBa38KekT3RqTM4rQ1o2qEj9nErL29/abMbTN6XlMby0/BGWdKTWLZSlL3nBAllQoxCYzRW4+WOBiyRSDEKqiZoR0r0tF6mTIABQAYYpaqYwOSZjDBKhvDest7kwBQCEFNvOfT3SaamHh4dlrPvwiGy2sOAcWXwEAMpUODMF+T1b0tsvxiWKlfDJJ57gRo4Jy72DpfNindS10O+7776ar2cyGWzevBmbN28+qUkpijK/aKy7osQAXeiKEgMaNh+9Ug7guNPaJJ2i4v+e1DnFSUqIBlCaktrIpXDuBOWGJyivOEm3pjVlxoj3dMliguwbnixIDd+2UPrmO9ulb9+Wj86+YR/c+EDCPu+KJ/W27V5VKrUDpkslqRtdejyECYrxr3DjCoDS5I0GGSUqOFmgeXKTiLBi6taQfNC2nPWZcM7E7hd/J8adHbLwIwAszErd7lMTS47Rd2hOk5PyO5GlIqYVyo8AzPs9s9Cp1R5iQZ/oihIDdKErSgzQha4oMaBhNXoqkULymMbyKUfXL0tdMjluxj1P5qU/+QjJ0KYm6YdtbZMavC0jtVNXmyzMDwALsnLbwYMydrpQkDpzSa/McV+8QOq9hR3S5w0AoMYHAeS1B+QD51prxuFY8MGMyS+X2Q5AdevoGPx+1t8A4BfkPDl3fJw+Qx6ztrX0vAQ/txxHjjmefmJMHvPFF18U476eM40zNHky1iGfl7Hrzz33/4kx30vOI+Dr4OYYABDS93+m7aHMNQ1OgD7RFSUG6EJXlBigC11RYkADa/QkUsnp6U0VpZBJUG4z+2gBYOyIzEcvTcgY79ZWqZU8yqEuuvKglaLpa24mHb+QmvRxbnFfzxIxXkQaPemaH0dI+rhIeo11p6mvZ6Ph5LWzbgwpaJztAL4vzzlFOQCAqdG5RpzhV6fGmhy3nkxaYt2T8nvBNdP5OlOU/5/L5cT4xd0vGOdIUT76ONWK37NnjxgnEvKcXEHp8GFp13FgNln0uVunuI7ZxcHrE11RYoAudEWJAbrQFSUG6EJXlBjQsMY4J3ThHCs2kKZkDzbMjFNwDAC8uPv3YszJHl1ZWXQxdzAnxtkumXBSmTKNHkcPyKKUE3lphOpd0CfGnASTpKIDbOgBgBKkUYoNYQFZzozEGFe+Plkxg4sYboDI5zDmQAFMxSnTOupTAwY2tgV0TOohAZ+fSZYiisZTi2xYARmukpTYNDYqE1Ke+7UMfgGA4VdkReP9+w7QKWsHH43tl0biRIIMiJaAJjeQy/R40dTpfxu7W9EnuqLEAF3oihIDdKErSgxoWI1eKZfhHBNqRpF6EnBTU2bBw+GXpZbq6pIJKC1USCKdlDpzPEdJFZaGAS6kxuukJJd2KipgJGL4VJSxbCmg4chtnECSJp3pUlEOlzRjU0raKgBTR5Yq8pzphAxOKZDOr9CFcRAPYDZ/LFHCT4Ve516DCUd+VW1hQClqdOB6tRtLcINEh16fmjJtP/sLr8h50rOyVKZAH/7uku0hqskHULuAhk3TW/eb1V6KopzW6EJXlBigC11RYkDDanQ3mYB3LKmF/bjccIB1DmDq9jFqbpdJ5Wqev1iggoieeavOOXu5GCepIYNLDQ1ZT3HyR7LZ9KNPleU+DknsBM2rDPZh107kAIB0WR6UE0w8atDgkV52QnmvuCAiAPhl+ZkVi6TZqcgha/SQC1j65jPKmCd9vV02HdD3KJGQ94b97gDgBHIelYDiASgBhb+bHKPAmnw2knumDUQ1uqIoVXShK0oM0IWuKDGgYTV64Pvw/Wmt55DfPGDdM4eCh4eOHBZjbrawsFsWajySk8X+AaCtIyvGnd0dYpyk2PUwIbUr+1ht/meGtSuS8jodyGN6NHYC816lKOa+tUkW5WDNzv5oHnMuwvR55cawwoHoUg9z0YgQHEthiQmnfbivZsol+wTZDeBQPIBvNqLgBcOFG5NU/IKLYIJiL0JqJum6ph+dmanLVaMrilJFF7qixICTWui33347HMfBLbfcUt1WKBQwODiI7u5utLa2Yu3atRgZGTnZeSqKchLMWaM/88wz+MY3voELL7xQbF+/fj0effRRbN26FdlsFuvWrcO1116LJ598sr4TeMf+IJvKAWaxQjdhScqlhvMBvWeyKDX56LjMReaifWWjQB/gHT4oxm9InC3GZ3TIhg2OR3HRvtTkXsWMdU81sc4nHUlNF82CiNQ80hI3HRrVIKnwIunrIsUoBNTw0AnNz4PjyLkhZUjn8CKeQUYMOWDEkfO8udmFR8fgPHub/uVjuBRf79Nn2tQs7yUfk+0IbCewMdNmxfarEzGnJ/r4+Diuu+46fOtb30Jn56sFGkZHR3Hffffhq1/9Ki6//HKsXLkSW7Zswc9+9jPs2LFjLqdSFGUemNNCHxwcxJVXXonVq1eL7Tt37kS5XBbbV6xYgf7+fmzfvt16rGKxiHw+L/4URZlf6v7p/tBDD+HZZ5/FM888Y7w2PDyMVCqFjo4Osb2npwfDw8PG/gCwadMmfP7zn693Goqi1EFdC31oaAif+tSn8Pjjjxs12ObKxo0bsWHDhuo4n89PF7l3UP29wfoOHNtu0WshFdMqU9xySJq7TNqK/eo2H3drtlWMJ6ZknnZuTP466Up31Ny/qc1sSsCazp9lwf7jJPhHm2P6aZ1Ebd+7R773IC31tUMavTRh2hoKgdzGjTIdn5pJkl5m/79ruQ8uNfYwc8H5PVyvjXa3yl95TOOQ7Mt3a8dO8DkdSxACx4TMfM8s3ej1/XTfuXMnDhw4gLe//e1IJBJIJBJ44okncPfddyORSKCnpwelUsnoeDEyMoLe3l7rMdPpNNrb28WfoijzS11P9Pe+97341a9+JbZ97GMfw4oVK/A3f/M3WLp0KZLJJLZt24a1a9cCAHbt2oW9e/diYGBg/matKEpd1LXQ29racMEFF4htLS0t6O7urm6/8cYbsWHDBnR1daG9vR0333wzBgYGcMkll8zfrBVFqYt5j3W/88474bou1q5di2KxiDVr1uCee+6Z79MoilIHJ73Qf/zjH4txJpPB5s2bsXnz5pM6bgAfAY4ntZBBg/Z1zAaURmV73iegYApuYpmgBIjAUimfA2CKVBhwqiADS7i4P8jAxwE0AJCg4v1cDCGkAAuHrC4uXZjtA2eDX4KKKqYy0oCXpJOkqHjklKWQ5gRkckdQlsY2j6+TPh/XMMAapzAMXRx7Yhh1I7AGzPAxaRdOsGJjXZQxzt4dlQ10M8faTVVRlGPoQleUGKALXVFiQMMWnpgJ6xoOhuExYCZFOJxMkJSX7pEO8qkYoZc0b9XYuCw4mc7LIKIWCqiZmpJBIy2JqCIFgEun5T6MxnWRnOM6jRwMA5jFKhwq/uilqKAhZWIkqFjCkZQs6gGYOp4LfoICZDxKjHFmESQ1y36DM+CCGdHPPWsyTa39yfbjzMOzdeYcZjsffaIrSgzQha4oMUAXuqLEgIbV6K6bgHtMoLI/09DoluyDkHzB7MMOHdbw8lZQLX+4gemsL1LxCi5AybAu9UjbBlysEKauZx92mhoABBHa1jUqHQAJEpI+FbNIkC+e9TbbBdoysoElAEw0yW2s68vUMIMrTDrkL3ZtBReMXpy1i3DYvjd0BPMUEZI48ph0XaHRdbF+S8Ns0Ce6osQAXeiKEgN0oStKDGhYje6ETrXIoBEfTFqrbGb/g4PXudC+Iei8CH80+30BJNIZ2offI8chafCpCWqyGJgfh+/KeQfUbMFJhLXHXMiAg7NhaXxA+tmoX0hNCHxPniPb1mGcg3shtLfIGIOD47JBRkiNGxPUnNBaE5E+UiP2neMFjCuLfu5FaXB+PWp/sziGJT6ghmEg2s4wjT7RFSUG6EJXlBigC11RYkADa3S3GntsNAQw8o5no1PIb85jOgUX6vdtp2CftZH0Xvt1vyT1dyJlfhzlktSqYYEbCEjNnqZz8JSM5oYwYwo4bsHh1yMaOXa2y+aTAJAm3/vMfgAAcHDkqBizTYQLWNrg++tSzD58vi6OOaB4DVt8BjeLZE3O9QJmqaGrc7A8e83P42Sj+hVF+YNEF7qixABd6IoSAxpWo8NxqlrE1CRSi3EdNQDwqJi/0RzP8KFKXJcb1Ju6qFKRNeEccN0zuX9AOe7lkBohmH0PkEhQAwfyxftluo609HG7pK+D0KxL57MepnsX8vOA4uUdX76/OWPW5s8k2sS4rVmO2d0f0jH5O8C12QDA4/wFtiUY9dyinnO2WHeOl6f7yfYkluiWBg11vT5H9ImuKDFAF7qixABd6IoSA3ShK0oMaFhjXKVShHOsyH/Kk8EW5UAaQLjYAgCMTcp9OjpkgEaKkkPYyEU2MJQgDW8AkOxoEuOuzg4xbmmVgSN9ZywV48CX1jevyTQQhh51faWiEKAgD248YQRbhGY3VQRc5IECeyps1OIgHfn5+GUzKMelQJ2Abmd7kzTOBQnqtmo0QjBOYXxmZnAQB17xMTkRyjwH2EjIQVNGoU0y3kHOKSQjcWBY76abmUhevVDfmtBlok90RYkButAVJQboQleUGNCwGr2ltbna3G+qILXsZEHq1JIlqaVSltvG8lIUenTpVDvBSNywacJKIOfhebVvZyY1JPen3Tu7LYEmbbK4hZeSGrslJe0ETSlZ0IH1nc8VIGC26XNJq3qOPCfHdHCzjKaUaQfw0nKfFee8SYzzR3Ni/MrLL4txC12XZ5GmHJDkGMVCIopC0NhoxAlb0klUIQoec9FSOv4s8lVmzlsLTyiKUkUXuqLEgLoW+t/93d/BORaDfvxvxYoV1dcLhQIGBwfR3d2N1tZWrF27FiMjI/M+aUVR6qNujX7++efjhz/84asHSLx6iPXr1+PRRx/F1q1bkc1msW7dOlx77bV48skn657Yeeeej0zztH+WfYVT5POe4OL/AIpFue3okTExdqkIgeFzJe1TKpWMcxwdlQUNR145KMaVonzPWE7Ooa29RYwPHZTFFwCgrVvu09QifdjdC2V8APu4vRT52alQBQAkk3If1uRhIO9NkopHJjiZB+bnwUry3PPPE+NDR+S9O3RANmrkppcILOcwYgZonODrql2Y0SZ/OcHHaMBg7E9+86j9LbYH7kMhmnLMqujKHBZ6IpFAb2+vsX10dBT33XcfHnzwQVx++eUAgC1btuDcc8/Fjh07cMkll1iPVywWUSy+amzL5/P1TklRlAjq1ui7d+9GX18fzj77bFx33XXYu3cvAGDnzp0ol8tYvXp1dd8VK1agv78f27dvP+HxNm3ahGw2W/1bunTpCfdVFGVu1LXQV61ahfvvvx+PPfYY7r33XuzZswd/9Ed/hLGxMQwPDyOVSqGjo0O8p6enB8PDwyc85saNGzE6Olr9GxoaOuG+iqLMjbp+ul9xxRXVf1944YVYtWoVzjzzTHz3u99FU1NTjXeemHQ6jXQ6bWw///w3o6VtujFfukn6kku+1FJTRVM/F6jwYu7ouBibGl1qHY/0mm2Ov/nd82L84p4XaA95zOKU9GEfPbxPjFvbzHuYOSB1ZaZZaux83wS9Q/rA2zqk/7mF/PIA4HLhRQoq8NzaBTV8R95rLiYJABUq0NCckbaHMxYvEeMzl0rNvvd3/yeP55vn8GgeHjXaBBcPqbPZwpwwGj1GnNNS4ITj52fmL1jqb1g5KfdaR0cH3vjGN+KFF15Ab28vSqUScrmc2GdkZMSq6RVFee04qYU+Pj6OF198EYsXL8bKlSuRTCaxbdu26uu7du3C3r17MTAwcNITVRRl7tT10/2v/uqvcNVVV+HMM8/Evn378LnPfQ6e5+HDH/4wstksbrzxRmzYsAFdXV1ob2/HzTffjIGBgRNa3BVFeW2oa6G//PLL+PCHP4zDhw9j4cKFuOyyy7Bjxw4sXLgQAHDnnXfCdV2sXbsWxWIRa9aswT333DOniXV2LUDrMT9zMi11aakiRWIHF+oHENClLVsqtWuKGgqkXTlOUiPBkm/aARb2SEnS1ip92s8//5wYF8uTYuz58pzDew8Z5/Bded4M+dELk/L1bDv51eneZJKmRg+TVHCSfudRf0MkuThkQo4TnOgNGJ0k/EDOu6tjoRgv6pTjfZD2DFvTSy7g6ZI+5jHHsrMP22gcArPZRVSsO0ezR/nhbeecj4KRdS30hx56qObrmUwGmzdvxubNm09qUoqizC8a664oMUAXuqLEgIbNR8/lcigf08XNrdLnGlIstsvJ5ADKPtWMa+sQ4yRYV5LuJJ3Z6kl/NACc3b9MjCsl6SdfTBr+xd/tFuMXdu8S49wRM9ad6+GFFJfuVBI0Ji08JYUn+/IBwCmQViVNyLn5bW2yvhvX3zOaGwLI0FdtvCw/n4wnbQdsI2EbCje/AGAYF4yGDqx/ORmcfdqW5HCXdjGr4/Eh+HvF7+A6gdHB7jN1veajK4pSRRe6osQAXeiKEgMaVqPv2bMHTS3Tuq0tK2upNbd2iHFTs9TwgNkkMSRdGZLuDAzfr9ROZYt2KpSkX7y1Ver44uSUPCIFJvuUR18pmLqzWJb18tilOnFUxrofGZE6v1yQc6hUzDzuBOl+P0J5jh+VqcRNGamvO9rM2nd+U7MYvzIka8Ll86NinAyk7m9JyfcXSvK6ADO+wmHNTh8hq1uWu7bmnSzz+UkZVWWd7R2GwrbYBbg2fGKG7re53e3nVRTlDx5d6IoSA3ShK0oM0IWuKDGgYY1xhw4dQmZyOkhi+ICsJNvUIg1r2c4u4/2ZtCziwMEsSQqmaGmiBgEcyGCxehSpoOTwiKykkz8sDUz/96IsTDE5JYthIDCNYJWCTP4okfnm6OGcGI+8vF/OIScNZVZjXEZea8BNLCmBJEH3LpmQX6NDGbOARhsZ4/a//Io8B93LsCivsy0tP3PH7HkJUNNKNqhysUijwCRbxmyFF10OLqLEGW6qyON5KG6hDRwURbGiC11RYoAudEWJAQ2r0V944YVqk8WuBd3itWKF9HbSbOrncIN5SoJwEzIgo+JL0VcqyfcXCqYoLJOG2zv0ohy/+JIYHz4iNfzUpNToFUNjAkUKDOHCE1Nj8hgv75VVdFvapV5OpjiJAljUK4s8cNRHcUrOK09BOLnDMkhnclQ2qgCA4oQ8RhdVC+4mO0t7i7SZLMrKOfqTpq1hapwaadLXggtiVHz6jnDtSGtRCdLk3IyT9uZjGMc0TD+WCJhakT2zbOCgT3RFiQG60BUlBuhCV5QY0LAavVwqV32W+Zz0R4+NjdUcA9P162YyOS4TMVozUgNyg4aAGjn6vsXHTT7Mw0ekv//oqCz2OFWQ8yxXSPcHZgHKpiapydNJ+ZEdb3JxnFZK8EmQUM2R3x0wk28myXZQLkv7htEfr0wNHyw6M0XFQryAmkJQjko5lPe7MCHvTVg2z+E58l5xApATRPi0uZeCpZkCE5JBw6hdQb78uXjR56E2pD7RFSUO6EJXlBigC11RYkDDanTfL8E9VkggPyb1WZnitZ3DsiEfMN3HfSZHD8l92ppl7HRTymyiKM5hKQjAflfuGnskJ89ZrshCFQmKm840mfEATZ68jgRpdMMvzl0IKJ47Tz5vACik5DEnyE8+s389AIxSEUtuCtGUMmPdE3SO4rj8TKcq8pzcBBOBHHOTRsBs/lgoF+h10tNkdnE5xMDSwTB0qLgF+8mNRo60f2RsunlO/u7NJV5en+iKEgN0oStKDNCFrigxoGE1ehAEVU3F2iqgvG3W7ICpa8olqQnzyZwYp7yIW+HZ9Jocc2/4cfLvu6StPOpemEyadoJ0k9SiPmk+9vX6vvR5O+Tj5rx8wLw09oOz/znhSlsCp9FPjktbBABUHPLFH5G++I6WrBgv7Jb5DU1N8t6kLHaADOW0T5WkbcEv1c6zd6lZJOeWA4BDup3tNOxID7nJYkQ1RzMTwXLMWRaEnIk+0RUlBuhCV5QYUPdCf+WVV/Bnf/Zn6O7uRlNTE9785jfj5z//efX1MAxx2223YfHixWhqasLq1auxe/fuGkdUFOVUU5dGP3r0KC699FK85z3vwfe//30sXLgQu3fvRmdnZ3WfO+64A3fffTceeOABLFu2DLfeeivWrFmD559/3og/r0VY8RF602KENQlrW9fi72RYj7FvuAKp4Vl72c7BerlEdgCHgpQ98nl7FP+dNBy5AMhvmyBBnfBIP1P8AM/bScl4cABw6f/7BOn+liaPxjK+fmpC+qunxmRTCQAoFuW9mchL+wU3s+BnEDeFaGmXcRAAkExI3Z5JU4MMkP0ilPc/pNXgh6btxwfXOSD9HDE2Rb2Em3sClhgOi+0giroW+le+8hUsXboUW7ZsqW5btuzVjqJhGOKuu+7CZz/7WVx99dUAgG9/+9vo6enBI488gg996EN1T1BRlJOnrp/u//Vf/4V3vOMd+MAHPoBFixbhbW97G771rW9VX9+zZw+Gh4exevXq6rZsNotVq1Zh+/bt1mMWi0Xk83nxpyjK/FLXQv/973+Pe++9F8uXL8cPfvADfOITn8Bf/uVf4oEHHgDwaghoT0+PeF9PT48RHnqcTZs2IZvNVv+WLl06l+tQFKUGdS30IAjw9re/HV/+8pfxtre9DTfddBP+/M//HF//+tfnPIGNGzdidHS0+jc0NBT9JkVR6qIujb548WKcd955Ytu5556Lf//3fwcA9Pb2AgBGRkawePHi6j4jIyN461vfaj1mOp02ij4AMmDGMCg5HOExiwIBVAjQVhxB7D+bzppsxKIilV4LJaDQ/p4vT2JNnKGACzaUcSVHNgAytkKabDDi++2TITOTkcY4Tg4JymaRjiIV2WBDZn5cGudKFNwyNSXf31GyFOlokcY47qibTpIR1+iYK89ZLluMcSEXmqjPGGc0kSDsBSlpn3Dmv09BcchLL70Uu3btEtt+97vf4cwzzwQwbZjr7e3Ftm3bqq/n83k89dRTGBgYqOdUiqLMI3U90devX493vvOd+PKXv4w//dM/xdNPP41vfvOb+OY3vwlg+ol0yy234Itf/CKWL19eda/19fXhmmuuORXzVxRlFtS10C+66CI8/PDD2LhxI77whS9g2bJluOuuu3DddddV9/n0pz+NiYkJ3HTTTcjlcrjsssvw2GOP1eVDVxRlfnHC+ej6No/k83lks1n8yYY/QjI9/f+QkXhPOtUWzBJ5WX5trVUm/cxaGQAcSoTh5oQJ+n/U4+KDlWh97SYowYR1fMA6nxoLUoAGBxsBgI/ayTZsi+D/tH3Ssq4l66JclPuUSHNX6HUuzhlQLk46bSluQYE9HmvyNCU6UQANP/bKgdlQo0wFPE3LTW348zBej9DwgPwOlIsVPPKPT2J0dBTt7e0nfI/GuitKDNCFrigxQBe6osSAhi08kUwmkUzaNXqFC+5Z/M9RGp01ODdoYN1vKxjAhQmSHjdbkGOX9DQ3AbTUtkCpInUiFyd0ORGGNXuCCiXY4gFok+ELJvtEpSJ1amuLTDCxacUE2Q6a0tIXz5q8VJD6uUhJL5OTZtPLQkkm05QpKcUP5byLZTnmOdriM9gGwhYP23dRvE4anZOtbBp9Psxo+kRXlBigC11RYoAudEWJAQ2r0QO4CI7/PxTRuM4WHsybWIP7HMtu6NTamh0AQH5wLvrg+BQrTfqZPfOlohm/naBiFayn+bqM2GpnNp5e0vF0TNaduUNHxNjrkXN8x4qLjDMsXLhIjhfIDEcuyLBvn8x2nJiQBSf37d9vnOPAgQNifPCQPMahQzkxTqbkdZcpvj6Rsth+KNahwsU46XuSokIfE5PSjsDx+DY/O+cnzPyMg1m2bdQnuqLEAF3oihIDdKErSgxoWI0ehmFVi9Sb8wtEF7ln3emwE5u7Eljg/yX5mNRD0VRTrJ+NXHNb8wo2JkTl1c9Gw9W+1go1RkinpWbMNEkdaovZT1N8/MIeqdld+io2ZWVDh7GxcTFu7jCLQ3b3LpTn/L2sc1CkOPWjRw+JcYJiEhKWdgqGrcfnegHyW8G2Hdbs/C0KK6cm9USf6IoSA3ShK0oM0IWuKDGgYTX6zJpxrDMNnToHHKNBPR1zDkXyo5jLvKPeE2mLmJXkq30Owxc8IX3BpbL0JZc5fgBApcL12OR7ON/fozjzlhYZG7+ol/zwADq6OsW47Mt4+AOHpe/98NGDcg4cd+6Yy4PtMD7FUrhkdwkpYCNF+RBGHIStsSPFv4cz6x4E6kdXFOUYutAVJQboQleUGKALXVFiQMMa42bCBhAuXjibwhP1GsKiCgjYzsGGL9+pcw5Wy1nthg3m6yePYXAigxH3x2umwhMTE7IZAwDkRo+K8f79r4hxMiOLPZZL8pzjlAxiBp6Y3wsugMEGvUyLDOJx6d66SXN5JLhoKH2mbHTkrr0eBeH43MTDUnjCdU8cIHZKGjgoinJ6ogtdUWKALnRFiQENq9ETrltNEDCaLFqaEDBR2ilKL8/mf0AjyCZCP3NNAU56seGzBiMd73KHQ4KbL8zK9sANHajAZGt7ixgnkvL1Q4dksggAhJQwwtfV3i6TWPJ5mcRSps8vkTG/ukZjCUe+p6lV2gE8mrdvfEfMwB/GbKhBSUh0zND43tHnYyuiQkExMwt8ztb2pE90RYkButAVJQboQleUGNCwGr0WZgHEk/clG40cZ3GOyGL9Ef7/yMIUMJsncCOJ6CuPaNI4i6OwH72piXzelKDyyrD0kQNAulm+p7W1teYxOcklcOV4qkgNEgEEqK2x27LynHyOoi993r7lHFyo0fhMyZ7k0TggQ41hf7IUhzR85XP4uusTXVFigC50RYkBdS30s846C47jGH+Dg4MAgEKhgMHBQXR3d6O1tRVr167FyMjIKZm4oiizpy6N/swzzwi99txzz+F973sfPvCBDwAA1q9fj0cffRRbt25FNpvFunXrcO211+LJJ5+se2K+78P1p8UI+8Dno+mcQ8fg//FCcBECy/+JEdMwikWyfjNi4S0N9nDiOGfbmHENW4N1prWPYSlaOZMSNTHgwhQAMD4u/eIcux6EtePrQ/qmcj9EAPACjlWX97OpXfrZU81Sb09Ro8eKpUCoR98UL0kanf3i9H6+Ltb4tk6b7Ht3Z3wXrY1FLNS10BculFU2b7/9dpxzzjl417vehdHRUdx333148MEHcfnllwMAtmzZgnPPPRc7duzAJZdcYj1msVgUgf+cMKEoyskzZ41eKpXwz//8z7jhhhvgOA527tyJcrmM1atXV/dZsWIF+vv7sX379hMeZ9OmTchms9W/pUuXznVKiqKcgDkv9EceeQS5XA4f/ehHAQDDw8NIpVLo6OgQ+/X09GB4eNg8wDE2btyI0dHR6t/Q0NBcp6QoygmYsx/9vvvuwxVXXIG+vr6TmkA6nUY6nTa219LoUY0FAYsenkUO+8kSpZeNphGzmEKUfz96Did/nRxPzefge1vxzWaRh47IQoyJlNTHiUROjAsleYxUs8w/b++UueYA4EPu05KSMfnw5HWkWuQc3Al5ryolM9Y9oOKPDhWxDHz5OuebF0pTYmw05pxVvEb9Nqo5LfSXXnoJP/zhD/Ef//Ef1W29vb0olUrI5XLiqT4yMoLe3t65nEZRlHliTj/dt2zZgkWLFuHKK6+sblu5ciWSySS2bdtW3bZr1y7s3bsXAwMDJz9TRVHmTN1P9CAIsGXLFlx//fXiZ0c2m8WNN96IDRs2oKurC+3t7bj55psxMDBwQou7oiivDXUv9B/+8IfYu3cvbrjhBuO1O++8E67rYu3atSgWi1izZg3uueeeuU0skaj+R8J6mzUja3bbNtN/WdvHzanlrkXrch52KlU7DpptDYWi1KG26/AS9TVRNPQcXZdN3XHMPd8Ln66d87Y5JsFmR2A/+osvvijGnd3UIJEaN/pUQy6YMPOwF7UuEOMpf1LukJTzWnrmEjF++eW9YmzzUXNcP9eA86jpg0MxCC0tZDfgBHRLQnotu0xUA4/j1L3Q3//+95/wxJlMBps3b8bmzZvrPayiKKcQjXVXlBigC11RYkDD5qO7rlvVSKw72fdokxKmji/XfJ3HLp3TVpurXPZr7sPzjDrnqcD03ZuijjW6sQ/nzRv3m0V+dE6179e2T3Dddt+Rr7e2yRrtAFAsy6aKaao3H5blHI7kjoixQzYX15Lf0EoauzIl51UhW4JDItpzo+I5ou/dzPfMNh5En+iKEgN0oStKDNCFrigxQBe6osSAhjXGOXCqQSoBN0wkw40tsCFJCfxJTybOmIky0lg3m+IWUckeUca2+ShAGYVDAR2Ozdjj0jzZgEcFMYwiHC4bnGyNAuW2Qlka4/hesTHOyZBBloo0AkAiRUUgyBjq0eshWSHLgfwOOJ7ZyLFCTTt4zBjFH8PaSUphGN00IpzRiFGbLCqKUkUXuqLEAF3oihIDGlajz4T1NI85MAUA0mkqKsDJHSEHu9TXjMG2rf6iEBLXUvAwKuDlZO0E0wflQpj13Qu2odhsJnx7uRFFiQpN8Gec8WRhR9u9bG6WQTQp+g44CRns0tndIcbcnCGomPduclImyjgVsgXBtB3UYj4Knc4GfaIrSgzQha4oMUAXuqLEgIbV6GEQnFBfOkZyvrkfJ0nwsaIKTrJunU09PqOpolH4jwo6RMzRRlQzBSN5xNKEIOo9pgav7dsN6XnhW4onUD0G45yFgkxIyeVyYtziygSVjCWppUKaujUh/eBJ8s1ns51izLUNR/aZXYa4CSInBCEqNoKTXOjGhPy9g/m9mHl7Lbfaij7RFSUG6EJXlBigC11RYkDDavRKpVJtpBepIS3alv2y7DdnonzDtnOwxmZ/PvtluVgkv5/tBtPH4I/I4myvA5vfNsqXy/M0dOds4gkiPkMuujg6OibGXkbeh4kxs5EjF/xsbpGaPNPSJMadnVKjn3HGGWI8lpNzAICpnPSjpxyZQ+F55Lvnoh1BRJMPy7OXbVIz8xW08ISiKFV0oStKDNCFrigxoGE1elDTjx6tS6I0uWfEkEsdlCStZdPPQcB+8NpNI6KY3XVx/nJ9x7SdIypePmTfMdkaWKNbY91nEQ8/k2KxKMYlanh4+MBh4z3c8DCVkZ9hSPNsa82KcTc1kVjYbZ7jldFXxJgbexjNMMimYhQIJb+57b64jjxGYuY+hiPfjj7RFSUG6EJXlBigC11RYkDDanTHcU6oWTne25aPzlLHiCuvcAMBqZUyGZn/bDtHKA8RmTcf5a9mP7vtPVEa3Yw5AI2j7QB117qz1KGLeg9C+oCMPAC5/+SY9F+H1D8RAJpbW8W4tVXe/3SaxgnpA+9olX717s5FxjnG2uSJy1P0PSqRBqeacvxk5SaNruXZy+kNzgn+XQt9oitKDNCFrigxoK6F7vs+br31VixbtgxNTU0455xz8Pd///fiZ1kYhrjtttuwePFiNDU1YfXq1di9e/e8T1xRlNlT10L/yle+gnvvvRf/9E//hN/85jf4yle+gjvuuANf+9rXqvvccccduPvuu/H1r38dTz31FFpaWrBmzRoj31hRlNeOuoxxP/vZz3D11VfjyiuvBACcddZZ+Nd//Vc8/fTTAKaf5nfddRc++9nP4uqrrwYAfPvb30ZPTw8eeeQRfOhDH5rTJM0ijPJ1W2BKEEQkpRgGPZkAEVAATcUSgBOVlGLGlUQHrzA2A91MwjCiOCRoTtYKlHQMcBGO2sUsPFfeOy78CACew40kJJzrwUU6igUqCJo2myvsf/mgPKbMk0EmKY11PicMlaVxblHnUuMcqeXyGLt+/VsxzhdHxXhqPC/GlZKc1MJuaQBszsjEGwDw6F6Upl59aPrF6IYPQJ1P9He+853Ytm0bfve73wEA/vd//xc//elPccUVVwAA9uzZg+HhYaxevbr6nmw2i1WrVmH79u3WYxaLReTzefGnKMr8UtcT/TOf+Qzy+TxWrFgBz/Pg+z6+9KUv4brrrgMADA8PAwB6enrE+3p6eqqvMZs2bcLnP//5ucxdUZRZUtcT/bvf/S7+5V/+BQ8++CCeffZZPPDAA/iHf/gHPPDAA3OewMaNGzE6Olr9GxoamvOxFEWxU9cT/a//+q/xmc98pqq13/zmN+Oll17Cpk2bcP3111eL642MjGDx4sXV942MjOCtb32r9ZjpdBrpdNrYHoZhVW9GBY1wsAtg0/W1iz+yFuYEFVtSCxe3YDuA58nbywkLRgM+i2aPCrLh90Qli9iOZxS1pHth3m+/5uv24hYUSMK1N40iifJ13r9k0aat1BSxXJTzLE3I9zQvlA0dUu0ySKolJQtSAkC2WSbCBEU5sRH65fryS3vFOD95lOZIQVauaQuqBJTgU3h1XC7NLnGqrif65OSk8UXyPK/6BV+2bBl6e3uxbdu26uv5fB5PPfUUBgYG6jmVoijzSF1P9Kuuugpf+tKX0N/fj/PPPx+/+MUv8NWvfhU33HADgOknwy233IIvfvGLWL58OZYtW4Zbb70VfX19uOaaa07F/BVFmQV1LfSvfe1ruPXWW/HJT34SBw4cQF9fH/7iL/4Ct912W3WfT3/605iYmMBNN92EXC6Hyy67DI899pgRO64oymuHE75WXd5mST6fRzabxf8zOIBkevr/IbNBImtCU6eY+pcdtbUbC/I5uHihbRsfg/9ziyoWaS3YMJsmiTXg99tiDvhaeR58DL5ubuDABRIBwCE/OhezCCKKXjpk75gsmMUhz1jcJ8ZL+mWxx74+en3JEjFOJ6XG56aNgKmph1/ZJ8f794vxyy/9nxi/8vLLYlygpo2h5fPxy5ws9aptqFzy8cN//TVGR0fR3t5uvPc4GuuuKDFAF7qixABd6IoSAxq28MRMPzoTpdkBW4x4bT9uEFFMcjbzmI3mlnOI1t9R8fBGbHu9zSQRPc/Icxrx9rb4a3ac02fIvQjZDlMm333Z/MxTCWqe4MuDTo6Ni3Hu8BEx7j9DavbubIdxDi72mKFzdrRK3/uSnsVinFsuC06OHpF+9fExMwR8ampK7jMjfr5UKAP4tfEeRp/oihIDdKErSgzQha4oMeC00OimBo/WtuZ7asdjs1z2ErXjv22wnjYKUhoB3vL/WVsBSocK9Ec1mOT4+0o5ukEAEvUVgzTvXe052jAKStJ18BF4/7BisalQzkNbs4xl727vEuPiuCyGMjkqffNjCUvKNPn/UxQzsKhLFpRcsqhXjD3vjWJcokYVR46YTSMODo+IcX7i1XlNTRYAfM+cJ6FPdEWJAbrQFSUG6EJXlBjQsBrdD3y4/om0Xu04dRtR9dpYHyeS0b76SA1OmI0PTp7oBg+zyRWX46jmkOYx6r+Seu8F20iy2ayxT4Vi8Dk33PFr1yAodUgNn8/J+m8AUJiUmjqVkvHx/OQMAhlT4Dq1P49CQfrMAaBMtREmZ8THT9F8ToQ+0RUlBuhCV5QYoAtdUWKALnRFiQENa4zzXG9WQSpzJSohhQM0uIMrALMjaERiTAh7ks5xbMY8Pi3vE/ApaU6zyVfxK/XVHuGiEQ49L1yLcTQqxCmq8IfvS0Ob55nnOHJEJqmMj8skliMHD4hxmYKLcocPifHSpWYDh6RLiTMRRl5OKiqVZJAOdzCaKphtYrnQR2HGPkXq5noi9ImuKDFAF7qixABd6IoSAxpWoyeTSSS5Cd4xuBikLWAmSvOx1o1KFrElg0QdM4qoRgjTE+OCGVTkgfVyhGa0nSNq3lHHsNovGLZn8Mvc2DHiGWRrqHHksEwI4Y+sOS2LdRaooMPBg7JJ4wsvvGCco7u7W4y5KIRDnwfXvPTI9sPNO4tTZsBMoSx1fGZGEUtbIwsb+kRXlBigC11RYoAudEWJAQ2r0V33VY1lNAyIaDgARGtV/j+uUmGdWrvIImBJiijNzqd5HL6O2ZzD9P9HJd/wvbE1WazdRJE1PDeimI0dYDaJR/IN1HiC5u1bYhZSGTmvMhV1GJuUfnWfvlfj42NiPDJitvrme8FJLZkUNWpsk8UvuEnEoSPSLpC0FB/xaFtmRlPSU9JkUVGU0xNd6IoSAxrup/vxn30ze1yVqffU/Px0t5/3VWq7tQAg8Kg/W7G+2vAcEutb6qAF5J7hfGbX5ZrqxhHodUs+Ou1juP0iat2xd83uJoz66V77df7pbqNCP2N5bPSho/vtl/k+WD5zPgZJjIojj8k/rV2qeV+hevWGew6mC7U84xzHrzGqhWLDNVl8+eWXrTHGiqKcmKGhIaNp5EwabqEHQYB9+/YhDEP09/djaGioZpdIJZp8Po+lS5fqvZwnGul+hmGIsbEx9PX11ey403A/3V3XxZIlS5DPT5e0bW9vf91v5h8Kei/nl0a5n7ayWowa4xQlBuhCV5QY0LALPZ1O43Of+xzSM4IDlLmh93J+OR3vZ8MZ4xRFmX8a9omuKMr8oQtdUWKALnRFiQG60BUlBuhCV5QY0LALffPmzTjrrLOQyWSwatUqPP3006/3lBqeTZs24aKLLkJbWxsWLVqEa665Brt27RL7FAoFDA4Ooru7G62trVi7di1GRkZepxmfHtx+++1wHAe33HJLddvpdh8bcqF/5zvfwYYNG/C5z30Ozz77LN7ylrdgzZo1OHDgQPSbY8wTTzyBwcFB7NixA48//jjK5TLe//73Y2JiorrP+vXr8d///d/YunUrnnjiCezbtw/XXnvt6zjrxuaZZ57BN77xDVx44YVi+2l3H8MG5OKLLw4HBwerY9/3w76+vnDTpk2v46xOPw4cOBACCJ944okwDMMwl8uFyWQy3Lp1a3Wf3/zmNyGAcPv27a/XNBuWsbGxcPny5eHjjz8evutd7wo/9alPhWF4et7Hhnuil0ol7Ny5E6tXr65uc10Xq1evxvbt21/HmZ1+jI5O9/fu6pru+71z506Uy2Vxb1esWIH+/n69txYGBwdx5ZVXivsFnJ73seGy1w4dOgTf99HT0yO29/T04Le//e3rNKvTjyAIcMstt+DSSy/FBRdcAAAYHh5GKpVCR0eH2LenpwfDw2Z9tDjz0EMP4dlnn8UzzzxjvHY63seGW+jK/DA4OIjnnnsOP/3pT1/vqZx2DA0N4VOf+hQef/xxZDKZ6DecBjTcT/cFCxbA8zzDgjkyMoLe3t7XaVanF+vWrcP3vvc9/M///I+oOtLb24tSqYRcLif213sr2blzJw4cOIC3v/3tSCQSSCQSeOKJJ3D33XcjkUigp6fntLuPDbfQU6kUVq5ciW3btlW3BUGAbdu2YWBg4HWcWeMThiHWrVuHhx9+GD/60Y+wbNky8frKlSuRTCbFvd21axf27t2r93YG733ve/GrX/0Kv/zlL6t/73jHO3DddddV/33a3cfX2xpo46GHHgrT6XR4//33h88//3x40003hR0dHeHw8PDrPbWG5hOf+ESYzWbDH//4x+H+/furf5OTk9V9Pv7xj4f9/f3hj370o/DnP/95ODAwEA4MDLyOsz49mGl1D8PT7z425EIPwzD82te+Fvb394epVCq8+OKLwx07drzeU2p4MN2dwfjbsmVLdZ+pqanwk5/8ZNjZ2Rk2NzeHf/InfxLu37//9Zv0aQIv9NPtPmo+uqLEgIbT6IqizD+60BUlBuhCV5QYoAtdUWKALnRFiQG60BUlBuhCV5QYoAtdUWKALnRFiQG60BUlBuhCV5QY8P8DnR/K/l9Igj0AAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.imshow(image)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# take the top half of the image"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAcoAAAGeCAYAAAAUg0E9AAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuNSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/xnp5ZAAAACXBIWXMAAA9hAAAPYQGoP6dpAAA/VUlEQVR4nO3de4xc9XnH/885c9v72OvLrheviQEHwsXkFyfAKikl2MFxIgTBPyk3NU6KEiVdoxirSmopl5ImWppKhNA6JmopJFIcR0QxEakCJU68KIpNwakFpKl/4LrFxF4bX/a+OzuX8/uDss0W7/N81zv2Dun7Ja0E+z17zpnvOTPPzno+3ydKkiQRAAA4o3iuTwAAgFpGoQQAwEChBADAQKEEAMBAoQQAwEChBADAQKEEAMBAoQQAwEChBADAkJ7rE/jfKpWKjhw5oubmZkVRNNenAwD4A5UkiYaGhtTR0aE4Nt43JufI3/3d3yUXXnhhksvlkmuuuSZ56qmngn7u8OHDiSS++OKLL774Oi9fhw8fNuvSOXlH+YMf/ECbN2/W/fffr2uvvVb33nuv1q5dqwMHDmjx4sXmzzY3N0uS/t87/1iZ3JlPL+SdZuIsYZtK+X91TmfsbYrFkjleqpTdY9TV5ex9lPx9lMv2NpWKuwtfYs+5N9+v7iJljqdS9rgk+7c+SeWSc00Se1yS0mnvaeFPaMWZ9Ej2Yw2ZT+9ZEPQXGecwlbLzWAPucW8u4oD59ESpjDkedn/a49699+pGzjG8CZfk3V+Rc+WjoGOce958hlwTOfdw2D0+/XGKhZIeuedXk3VnOuekUN5zzz365Cc/qU984hOSpPvvv1//9E//pH/8x3/UX/zFX5g/+9oDz+TSytady0Lpvyh7hdJ53Vdc8c8zW2c/weOSv49y2d4m4LXMlZyHQukXKP/FquTMVxTwmpzJOC+6mn1xqJVCGTn3qPdLmALu8fNTKO1757wVSuc1Iag4eIXSKx5V6HNRjX/18m6NWiiUofup+od5JiYmtG/fPq1Zs+Z/DhLHWrNmjfbs2fO67QuFggYHB6d8AQBQK6peKE+cOKFyuay2trYp329ra1NfX9/rtu/p6VE+n5/86uzsrPYpAQBw1uY8HrJlyxYNDAxMfh0+fHiuTwkAgElV/zfKhQsXKpVK6dixY1O+f+zYMbW3t79u+1wup1zO/kALAABzpeqFMpvNatWqVdq1a5duvfVWSa/+Y/6uXbu0cePGqhwj5B+B/U+CBnyAwPnwifcPwBnnAwYh+wj50JHLma+gDzo4mwT9w3xiz3nJ+cSq5F8377qXKsVZHyOKq/BhCW+DgPn0PlwS8uET7/7y7s9KafYflAj7TMfsPkwWdI974yH7qFTjE6ez20c10udBHyY7H9fE2Wa2H+apOK9Jrzknn3rdvHmzNmzYoLe//e265pprdO+992pkZGTyU7AAALxRnJNC+cEPflCvvPKKvvSlL6mvr09vfetb9dhjj73uAz4AANS6c7aE3caNG6v2p1YAAObKnH/qFQCAWkahBADAQKEEAMBAoQQAwEChBADAUHONm1+TjiOlpwlMhwRVK17YNWTBAacrhxfWDloYwWnVFRIaj5zDeONBIWlnutwuE5IqTtg/ZL6KZXsbdyGJgPYhsRNiDuly4omcy+pdM8nv/FGNxSq8x1oo+ws4RM49XAm4d/xVCWYfs/fuv5BFSsLaaNmikItv78DdxH+uzf5xeHNRjdfxoA45szwHiXeUAACYKJQAABgolAAAGCiUAAAYKJQAABgolAAAGCiUAAAYajZHWSyVFE0T0QrKzjjbhOQTQ7axBGV0nFzgREAzY7dBqpO3q0bj5tlGv0LPw70izjULybl5ebmQBtOlwoQ57jaYDjiGnOuarcu5u0g5gU5vH+WAHGUu55+HK3ae82H9d2flDylH6Qt4TfCuiffzgRnG2e4jqLmzg3eUAAAYKJQAABgolAAAGCiUAAAYKJQAABgolAAAGCiUAAAYKJQAABhqdsGBKJk+xB4SH03FdtPakKa2kXOkktN0uVi2Q+chQoLnXqC24vw+FLbgQBWC1Mm5XwTCDxf7190LlidlP3g+Ojxijo+Pj5vjxaIf5I8Tey4yAQsOZFP2S0BdqcEcT6X8Z2Muk3W3qQ3edQ1ZrGL2jYaTZHarJyRVaNzsNRaXJDn9tt3XpWq8pgQ81rLxfA5pOC/xjhIAABOFEgAAA4USAAADhRIAAAOFEgAAA4USAAADhRIAAEPN5ijjOJ42M1eNTF8IL0/nZXBCMzqWkGyhlyVKnPxiSENab5uwZtrOYwkIyMZOPtZveuvnKD2Vkn9dyxN2DrLiZHBTAbe4l/NNO9ddkmJnH5GbC3QPoUrFfqxBjXXd5/zsz9ObzxCxe6CQjOTsGq0HNZj25vM8NESuxqv4bO+dkLmSzsE7yr/8y79UFEVTvi677LJqHwYAgPPinLyjvOKKK/Szn/3sfw6Srtk3rgAAmM5JBUun02pvbz8XuwYA4Lw6Jx/meeGFF9TR0aGLLrpIH/3oR/XSSy9Nu22hUNDg4OCULwAAakXVC+W1116rhx56SI899pi2bdumQ4cO6Y/+6I80NDR0xu17enqUz+cnvzo7O6t9SgAAnLUoOccfIe3v79eFF16oe+65R7fffvvrxguFggqFwuT/Dw4OqrOzUx/9/I3K5s78l+GQU/Y+LRrSPcQ7jtfhoRrdQ8I+TWpvU3Y+/Rjy6dzqfOrVnvOAD2kqju1/LfA/9erz5iPkU6+nXjlhjv/+PX9GIZ86dD7Bm8v53UO8zw/k6uvM8ZDuIXWN9j5m++nJaqk4n8MMed2puA9ldp1BQs6jKt2AAp5Hfwifei0WSnr0nn/RwMCAWlpapt3unH/KZt68eXrzm9+sF1988YzjuVwu6AkNAMBcOOeFcnh4WAcPHtSf/MmfzOjnSqWSpovMhWRfopTzjnKWPd8kSbH920wqILPnvnsJepfl9Hl0fj4KyGpWEi+/OPt3BUHX1flN15uvOODX2CSZff7Veyxp5y8a2XTGPUYmY/+CWY13lH6O179mcRWymEk0u79oJM5zRHKfziFv8l3eX1VePY5zjzv3Z+LM939vZY56+VlJctqhuoJ6c7rZ1pDXndlfuKr/G+Wf//mfq7e3V//5n/+pX/3qV/rABz6gVCqlD3/4w9U+FAAA51zV31G+/PLL+vCHP6yTJ09q0aJFete73qW9e/dq0aJF1T4UAADnXNUL5Y4dO6q9SwAA5gyLogMAYKBQAgBgoFACAGCgUAIAYKBQAgBgqNn+V6/1sjyjgPCwF/guBYTbvd8iEm/puIq9xJ3kL2UWshxVKmNfRm+5vpDm0HFkHyMk0K2yPefFih/0j70VA7zpqkIj7NhZzEKS6pywv7egQFN9g3+MOnubkAUHMin7uhaK4+b4hDMuSUXveRCUB3eWbXOerUErdXprKAYtj1iNfczyHj9PvEUJgl4THF5j8ZDVKqyG8SGvfa+eBwAAmBaFEgAAA4USAAADhRIAAAOFEgAAA4USAAADhRIAAEPN5iiTaPpYU7Hk5+1KpZI57jV2lqT0dJ2jX9uHkxNKZ/3mu9k6O+sWkvPxMqFuI9iATGni5tgCmh17GbKArspJaraPJSCE5p1HwP03f37eHM+m7etel8m6x2hqaDbHvabMkhQ7jZfr6u3zSKXsxylJQ0MD5vjI6LC/j7ER+zyc+UrVBbzUOZ2Ivabhkv98DdmH93xOZexjVAr2a9+r5+Fu4vJeV5xe26oEzEXKmU8vByw5uegyOUoAAGaNQgkAgIFCCQCAgUIJAICBQgkAgIFCCQCAgUIJAICBQgkAgKFmFxwoVyrTBm/jtL0QgCTlnGbGXnPeEGUvhB9wiMhpqhySDM44j9VbfCFgvQGVi/Y+Yu9xKGTOAxY+8JplO/uIjSauk9wpD2gwnbYD8LmcvRhFJuUvVjExMWGPj4+6+/Akif1YM1n/ug+cPmWOjxb88/QaSGcb6s3xVF2jewynN3lQs/dKyW5SHbLQibdogbuYSjVWEwh57XKO4zZADzgNb0mCoMb2xmtT0OuBeEcJAICJQgkAgIFCCQCAgUIJAICBQgkAgIFCCQCAgUIJAIChZnOUVuPmSkDGJ3aaKkcBDZG9JqveHkLyTF7W0muYLElpJ5tVLjq5v5R/ntmUnQssVvxsoZfFjNL+Nak4uak47eQsA7JwKefeyTgZSEnKpO1tvNxpHDAXJadBb5L4jzWXsxtINzjNobM5P0c5OGI3bk7n/MeaRA3m+Gi5YI4XnXFJSpwnY0h+23vOVwIyuN7LRjlxMs0Brzv+a9Pss5ix8woZkoH0nu/lckDDeEOp7De5ls7iHeWTTz6pm2++WR0dHYqiSI888siU8SRJ9KUvfUlLlixRfX291qxZoxdeeGGmhwEAoCbMuFCOjIzo6quv1tatW884/vWvf1333Xef7r//fj311FNqbGzU2rVrNT5ur6wBAEAtmvGfXtetW6d169adcSxJEt177736whe+oFtuuUWS9N3vfldtbW165JFH9KEPfWh2ZwsAwHlW1Q/zHDp0SH19fVqzZs3k9/L5vK699lrt2bPnjD9TKBQ0ODg45QsAgFpR1ULZ19cnSWpra5vy/ba2tsmx/62np0f5fH7yq7Ozs5qnBADArMx5PGTLli0aGBiY/Dp8+PBcnxIAAJOqWijb29slSceOHZvy/WPHjk2O/W+5XE4tLS1TvgAAqBVVzVEuX75c7e3t2rVrl9761rdKkgYHB/XUU0/pM5/5zIz2VYnC8pLT8fI15YCMmdcfcbb92CSp5OQPvd50klSasLNGXsYxFfn5sJLXezOkL1zWzhaWKnYvP8nvN+nzc1dZrxdkwHx5OcjE2UXR6QMZchr5+fPcfbTOs7dpbrb7ODY1230gJemCzjP/kvw//Gt6erDfHD8+cMIc/68jL7nHGBsbM8fTiZ05lfxcakjv10rF6zfpPNdCekl6GcfYfz5Hib0P76F6GUlJqlTsbSoBE2r1bS06WeTXzLhQDg8P68UXX5z8/0OHDmn//v1qbW3VsmXLtGnTJn31q1/VihUrtHz5cn3xi19UR0eHbr311pkeCgCAOTfjQvnMM8/o3e9+9+T/b968WZK0YcMGPfTQQ/rc5z6nkZERfepTn1J/f7/e9a536bHHHlNdXV31zhoAgPNkxoXyhhtuMP/MFkWRvvKVr+grX/nKrE4MAIBaMOefegUAoJZRKAEAMFAoAQAwUCgBADBQKAEAMNRw4+aKkujMYdKQIL+3RTmgYae3aEHFCeGHnKe3oEBI893EaTTshaBDmlhPFO02aSELDmScIP/o6Ki7j2y93UA6nbZv6ciZK0nKOAsjxE7QWpJSGe887fEoYD5LY3Yz4pHCiLuP1vR8c3zF5Zea4x0di91jpJxm2gFPE42O24/luReeN8eT5/xjHDvxijk+MDTs7qNQmT7cLoU9TyI5K0k4z9d0SFN6b4OAe9xdE8N5qP5MSBVn2YKQ+SwZDeOLXlP7/8Y7SgAADBRKAAAMFEoAAAwUSgAADBRKAAAMFEoAAAwUSgAADDWbo4zjeNqMYUgzYy9fE5K/SZywkZd1CzmGl9VUyg+ZpZz5KDvNTUN+W8pm7dyf+zgCLFq0wN3mTRe/yRzv7Ow0x5NSwHX3rmvAQ+0/ecoc/8//+C9zfHjQz+wVC3aO0suUStIFqaXmeHNrizne0NTsHiPj3GEVBTTPdXomL794uTke1znNuCUNDA2a4//+wgvuPo4fP26On+7vd/fhZWxTTvDUe90K2SapBGTVU85zyWm6HAWcaEgWfTb7CN0/7ygBADBQKAEAMFAoAQAwUCgBADBQKAEAMFAoAQAwUCgBADBQKAEAMNTsggN1dXXKBoSEp+OFxkMC8l5j5ooT5C+V/CB1sVi0jxHSEDljz1Pk9IGtr693j+GF1725kKRTA3YIPxvZQWtJuvjii83xy694izkeBfxumHLa2sax/7T53eEj5vjAsN2I+ORpe64kqVSx7+HxcfvekqR0vZ3kr29uMMcr8p9HgyX7scbO/Sn5wfBso/04ll18oX8QR11zo7vNv/32t+Z4v7OogRSwGIAzXnTuC0mKnIVM4pAgvrNNHDlN6QPuHff5WvZfd6zXrpDFQyTeUQIAYKJQAgBgoFACAGCgUAIAYKBQAgBgoFACAGCgUAIAYKjZHGW2LjdtjjKkIa2Xo5yYmHD3MeY0xvWyg0lAFilK2SGyXMYPmXlZy1zazllm6+vcY3g5tstW2PlGSSon9nyVy37ub1HbInM8iZxsa8AxKrE9X0nJ38eCJfPN8UuvvMQcHxg64R7jlVdOmuOpyM8hN7baGdpiYj9PBgPmInHCarmA8yw6zZ0r8exzgZmMncVs72hz93FyoN8cf/6AnbOU/Ix32WmIHBBPVOw0e884zyNJimW/Nnmvf3Hiv45XKk4W3clqvrrJ9PPlzcPkdkFb/Z4nn3xSN998szo6OhRFkR555JEp4x//+McVRdGUr/e+970zPQwAADVhxoVyZGREV199tbZu3TrtNu9973t19OjRya/vf//7szpJAADmyoz/9Lpu3TqtW7fO3CaXy6m9vf2sTwoAgFpxTj7Ms3v3bi1evFiXXnqpPvOZz+jkyen/LaVQKGhwcHDKFwAAtaLqhfK9732vvvvd72rXrl3667/+a/X29mrdunXT/gN1T0+P8vn85FdnZ2e1TwkAgLNW9U+9fuhDH5r876uuukorV67UxRdfrN27d2v16tWv237Lli3avHnz5P8PDg5SLAEANeOc5ygvuugiLVy4UC+++OIZx3O5nFpaWqZ8AQBQK855oXz55Zd18uRJLVmy5FwfCgCAqpvxn16Hh4envDs8dOiQ9u/fr9bWVrW2tuquu+7S+vXr1d7eroMHD+pzn/ucLrnkEq1du3ZGxylVKoqnCfSnA0KisdOYtFgYc/cx5mzjhfBPnrID4ZLU2Gg3g01n7ca5klRxstRjBTsU/qbFi91jXHHFFeZ4XYMd1pak+ib7sTY4zXclKevcsaWKvUhE5ATTJanshNtLAWHslHP/tSy2r2vTQn8RiKOn7fuzsTngrzM5O50+mthNl+tS/jXzFuYYL467+0g7zcm9hSbKXnBdUsV5ItU1+Q3O2zvtNwQNTU3uPl4+8jtzvDRhP5Z8U7N7jMac/VjiKGAxgJLzPCja4+7PS/L61nuvwZKUyNlJgBkXymeeeUbvfve7J///tX9f3LBhg7Zt26Znn31W3/nOd9Tf36+Ojg7ddNNN+qu/+ivlcv4TCgCAWjPjQnnDDTeYy8M9/vjjszohAABqCYuiAwBgoFACAGCgUAIAYKBQAgBgoFACAGCo2cbNiqNXv85geNTOdklSlLZ/B5go+7mqktNoeHhoeNbHSBXtxrjFYb8Laz6fN8c7L1xmjl98sd90ecGiheZ4fUDGzIu/xin/97aU7Exo4sSqvIykZDd6laS007BWkhKne26uwX6sb7n6ze4xGvP2nGec7KEkLVhsN5hW2p6LYuI3bpYXdUv5ObeKM59ujjIgS5fxbtCA+zNbZ8fgGvN2lliS0iec6+ZkgZOArPDohJ3Bjct+Y3uV7ONEFft54jV+lqSUFxKP/H1UA+8oAQAwUCgBADBQKAEAMFAoAQAwUCgBADBQKAEAMFAoAQAw1GyOcmR4RBOlM59eSA+yyoSdmyoU7L6FklRyskT1Tg/Ghka/p6B3HqmUnxNqaLB7G1500UXm+IoVK9xj1NX7OUlPoWxnt8oVPzMaRfZ19XofRk6fSEkqO/nXipOzlPzzTDs537a2Re4x2hbZfUS9uZCk5ga7d6HXVzNJQq6ZvY+QjGMi+7F4+Vk5Px+0TUAf0qzTMHXR4gXuPk6dOmWOj4w4OfKAh1ooOfnXYkDe2NkkIzsPmkn5r49RNPv3ctb9F1JLJN5RAgBgolACAGCgUAIAYKBQAgBgoFACAGCgUAIAYKBQAgBgoFACAGCo2QUHSqXStIHWdNoP4Rcm7MUCxguj7j6GhobM8cZGuwlrW1ube4xFi+xgeb7FaawrqanFDo1fcMEF5niu3g/+eosvVALC2F4oPPYa50qqOAF3r89rHPK7oReQr/jNir2HEtJU2dPSbF/3cuIH+dNOoDtx9xGwWIA35QEBea9xc8q5ZqmM/1KXOI/Ff6RSOmu/NrV3dLj7GBmzFyE5dOiQOT4+Mu4eI3auayYdcH86907kNHYOeLr7Cw54T3hJkdE5nAUHAACoAgolAAAGCiUAAAYKJQAABgolAAAGCiUAAAYKJQAAhprNUVYqJU3Xx7cS+9mXdNp+aE2ZJncf2ZzdmDmVts9j/oJ57jGuXHmFOb5ooZ/FrHeaKnv5xLExpxGsApoA+9FWN8s2UfSbaXuNguOUnQ/zmjJLUuI1Zg64/0rOeUZOFtjp6yxJGivZjbADuhmr7GXhnJxZSA7Ni2ImRs5t8jjONkUnZ1lM/OsuZ5tU7GcL65wm6hcuX+buw3uenD590hw/MjTsHiNxwq31Of+xRl5AtmBf+DigKX3k5CS9XLXk3zshZvSOsqenR+94xzvU3NysxYsX69Zbb9WBAwembDM+Pq7u7m4tWLBATU1NWr9+vY4dOzbrEwUAYC7MqFD29vaqu7tbe/fu1RNPPKFisaibbrpJIyP/847kzjvv1KOPPqqHH35Yvb29OnLkiG677baqnzgAAOfDjP70+thjj035/4ceekiLFy/Wvn37dP3112tgYEAPPPCAtm/frhtvvFGS9OCDD+otb3mL9u7dq+uuu656Zw4AwHkwqw/zDAwMSJJaW1slSfv27VOxWNSaNWsmt7nsssu0bNky7dmz54z7KBQKGhwcnPIFAECtOOtCWalUtGnTJr3zne/UlVdeKUnq6+tTNpvVvHnzpmzb1tamvr6+M+6np6dH+Xx+8quzs/NsTwkAgKo760LZ3d2t559/Xjt27JjVCWzZskUDAwOTX4cPH57V/gAAqKaziods3LhRP/nJT/Tkk09q6dKlk99vb2/XxMSE+vv7p7yrPHbsmNrb28+4r1wup5wTwwAAYK7M6B1lkiTauHGjdu7cqZ///Odavnz5lPFVq1Ypk8lo165dk987cOCAXnrpJXV1dVXnjAEAOI9m9I6yu7tb27dv149//GM1NzdP/rtjPp9XfX298vm8br/9dm3evFmtra1qaWnRHXfcoa6urhl/4jWdSk+7aIDXRFjyA91NjXYwWJI65i8xx0dH7WDv/Pl59xiL2+3GzQvmt7r7SDmLK3gNqAslP+jvOX36tLuNt2hBMaAhchTbAeO2tsXOz/vtd8slO3ge0tPWDUIn9lyEBPnL063IMSPOggNOWLvidmWWksrsF3CInMUTvF2MjvuLapRK9jVpamlx95GW3QT9f39+40zGnMbNXqP2TJ3/F7rSmP1cC2nEnons153EWfwjivznYsXbZpb3Tmjj5hkVym3btkmSbrjhhinff/DBB/Xxj39ckvSNb3xDcRxr/fr1KhQKWrt2rb71rW/N5DAAANSMGRXKxFuLSlJdXZ22bt2qrVu3nvVJAQBQK1gUHQAAA4USAAADhRIAAAOFEgAAA4USAABDzTZuTqKKkmmyPHV1Wffn863zzfGLLnqTu4+Fi+2M46H/OmSONwRkNcty8koBub/x4rg57uUkUxm/gaqXgTxy7Ii7j4kJO/+ayvq/t3nZq/pme85b8v41Scr2Y/UTZlKUsrcqB2RGPamQ7s6Oirysm/3zQY/D2YfTm1eSVHKyraOjo+b4kSNnXmv69xXG7cfy+6uQTWfRIjt7nZOfcWxutnOSF110kTk+MmTPhSQdP3rcHC8W/esax/brhheBTJx779WNnObPAfeOlQUOzVHyjhIAAAOFEgAAA4USAAADhRIAAAOFEgAAA4USAAADhRIAAEPN5ihL5QlF0/SHW7DAzjdKUktLkzm+cPFCdx+L253ehlk7g1Mu+/0Ch0b6zfGJCTsjKUmpjH0ZUyk77xTH9e4xvCxcKfFzV8WKnaNMKn6eM3H6OJ7sP2mO5xr9Y6SdPOdExe/f6eW7EidklgrId0048xmSEYsiJwvnXPiAdpR+T8uAPN2Ec38VnCzxyZOvuMcYHLT7y9bV+c+T5uZ55nhU599/cvp3Ll7YZo4vXGhnJCXp9Il+c3xsfMzdRyplZ1tTzvM5pOel37IyYD6tnQT0xJR4RwkAgIlCCQCAgUIJAICBQgkAgIFCCQCAgUIJAICBQgkAgIFCCQCAoWYXHEiSipLkzIH9bC7j/vxVK680xxe1+QsO5BrrzPHGeZ3muNeoWJIOH/mdOX7w4EF3H40tdqNXL3g+UfIXC/AaN48V/GaxidOEtTTkn0eqzr5l64p2KLxQ9q9JccIJIaf8hSS8GLTXgLok/xiJ00K64jSglqRUyn4uedcsiv2XkNj5fdxtXi5pYOi0Of7KcXuhiVdOnnCPceqEfYxTJwfcfTQ3583xC5faz1VJysR2c+fly+zGzUP99sIJkvT8vz5vjk+M+c+TtNPwveJc11wu6x7DXfCi4j9PFFn3X0gbdt5RAgBgolACAGCgUAIAYKBQAgBgoFACAGCgUAIAYKBQAgBgqNkcZSoVKZU+cx2fLl/5+7ycWpz2m9rKaSwaed15U/4xikU7rzQ24ecTj/7HUXM8jp3mvAFTkTgbeQ2VJamxsdEcb5nf4u6j3sm2euMhzWIVO9nByL//im4O0j6P2OuULSnl3H+j4yPuPsbG7IbHxaL9OLycpSRVnN/H49j/fd1rqjw8PGSOnzxtZyQlqVRyGhHH9rgk9Z/sN8c72/z5qsva93AmZecPF89vd49x+SVXmOP/eeiQu4/iuJO1dKbLy2ZLUsrZxGtKL0mRcX9FqbD3ijN6R9nT06N3vOMdam5u1uLFi3XrrbfqwIEDU7a54YYbFEXRlK9Pf/rTMzkMAAA1Y0aFsre3V93d3dq7d6+eeOIJFYtF3XTTTRoZmfqb6yc/+UkdPXp08uvrX/96VU8aAIDzZUZ/en3sscem/P9DDz2kxYsXa9++fbr++usnv9/Q0KD2dv/tPwAAtW5WH+YZGHh17cPW1tYp3//e976nhQsX6sorr9SWLVs0Ojr9v7MVCgUNDg5O+QIAoFac9Yd5KpWKNm3apHe+85268sr/WYD8Ix/5iC688EJ1dHTo2Wef1ec//3kdOHBAP/rRj864n56eHt11111nexoAAJxTZ10ou7u79fzzz+uXv/zllO9/6lOfmvzvq666SkuWLNHq1at18OBBXXzxxa/bz5YtW7R58+bJ/x8cHFRnp92VAwCA8+WsCuXGjRv1k5/8RE8++aSWLl1qbnvttddKkl588cUzFspcLqdczm4rAwDAXJlRoUySRHfccYd27typ3bt3a/ny5e7P7N+/X5K0ZMmSszpBAADm0owKZXd3t7Zv364f//jHam5uVl9fnyQpn8+rvr5eBw8e1Pbt2/W+971PCxYs0LPPPqs777xT119/vVauXDmjE6uUS6qUzhzODQk5e4Fub0GCV7fxxr2mtv4xhsfsoPTQqP/hpoP/8YJ9Hl4b4YDzLJXs+cxm/VtpUXubOd6QtxckkKQ4433+zD7PgaF+9xiVyE5KR2l/wYG0Mx2x0/TWWSNCklQq2IHv1z5sZxketBclGB+3FyRIpfzrns3ZzbS9xuKSdPKkvWDAwAn7eXL8+HH3GHWZBnM8mfDPc+C0fR71af+vZ4WCfX81yn6etLXazzNJuvqq/8cc73+l393H0cEj5nh92l44IRX59453b8RB+5j+9S3k3pNmWCi3bdsm6dVFBX7fgw8+qI9//OPKZrP62c9+pnvvvVcjIyPq7OzU+vXr9YUvfGEmhwEAoGbM+E+vls7OTvX29s7qhAAAqCUsig4AgIFCCQCAgUIJAICBQgkAgIFCCQCAoWYbN8dxPG1D13RAyMz7hG6l5GfhvKagkXMaqcRv9Jqepjn1awqFgrsPrwFq7DSQTip+jrJcLjpbBOTpnMxdSBYz7QQUSxV7zksFv1lsKXIa0pb96zo+ZDfc9jO2/nlazQYkqeA0ZZb8xsyRc29kZWckJSnl3DvlgCbVExP2NTntNGYOabaQzdsZx1LFf804fcw+j6TsvzcpOw2RU3UZc7y1eZF7jPo3N5njv/n1b9x9HHmpzxzP5OwG03Hiz4V3Z4Rk6sOSkjbeUQIAYKBQAgBgoFACAGCgUAIAYKBQAgBgoFACAGCgUAIAYKjZHGVaKaWn6TXmZaokacjpxdfY5Oe/mvPN5ng58Xpe+gmeRQsWmuNLlvi95cbH7Tzd6dP2XAwN2T0xJcmLkEUNfra1ocHu99fSZM+3JDU129skKeeaxH4WLknbOTWl/RzlsNNHdGTcHveuqSSNjNi9JMfG/Axu1umP2Nxo5+0ycUAG0smdprx+qZLqsvZ5rrjkzeZ4/yv+PV6e8Hqu+r0ky0V7H81p/x6fP2+xOe7N+FjRv+4LGuys5fyWVncfsZMJjRP7TMulgJy5l2V39yDJymsGZDkl3lECAGCiUAIAYKBQAgBgoFACAGCgUAIAYKBQAgBgoFACAGCgUAIAYKjZBQfK5bLiafKop0/YzVElqe93x8zxusY6dx/tFywxx5Oy01zXaagsSfPnz7fH8/PcfRxvbDTHT57058uTy9lh66wX0peUzdjbZJxxyW8kHGfs3/1SzrgkTST2ghYhzWKbWpyFEdL2vVEo+aHxsuzzKFa8ZttSxTlMNmM/T3JZ/x53G6AHxMbLZXuhiKHBfnPca/gtSYOn7EUgmlP+YhWjQ3az7P86/LK7jxWdK+wNvJB80Z/POGtv01zX4u4jm7IbMyfOdMUB79NSVXgvZy38ErIojMQ7SgAATBRKAAAMFEoAAAwUSgAADBRKAAAMFEoAAAwUSgAADDWbo4ySSNE0jT+HAxoNnzp1yhyff8rPCZWKdg4tnbXzYUnkN6Str7cbSC9ZcoG7jyNH+szxOLHPo1L0c4HFsp0tnEj7ub9SwQlW+TE1N5uVje0sZhL5ub/ihH3dh4b63X005e0m1c1OA2rF/jWpc+6dsVG/+XO5YB8n7cxnSD4xnbbzdhNjfiP2/n4741gat2+MkOyr1wj7+Pgr7j7icXu+Dv/HS+4+3nzBpeZ4Y5w3x9MBGXGvWXa+eZ67j5Ym+zwKhTFzPJ31c9PeE75S9q9rZPVt9n9c0gzfUW7btk0rV65US0uLWlpa1NXVpZ/+9KeT4+Pj4+ru7taCBQvU1NSk9evX69gxO/gPAEAtm1GhXLp0qe6++27t27dPzzzzjG688Ubdcsst+s1vfiNJuvPOO/Xoo4/q4YcfVm9vr44cOaLbbrvtnJw4AADnw4z+9HrzzTdP+f+vfe1r2rZtm/bu3aulS5fqgQce0Pbt23XjjTdKkh588EG95S1v0d69e3XddddV76wBADhPzvrDPOVyWTt27NDIyIi6urq0b98+FYtFrVmzZnKbyy67TMuWLdOePXum3U+hUNDg4OCULwAAasWMC+Vzzz2npqYm5XI5ffrTn9bOnTt1+eWXq6+vT9lsVvPmzZuyfVtbm/r6pv+wSU9Pj/L5/ORXZ2fnjB8EAADnyowL5aWXXqr9+/frqaee0mc+8xlt2LBB//Zv/3bWJ7BlyxYNDAxMfh0+fPis9wUAQLXNOB6SzWZ1ySWXSJJWrVqlp59+Wt/85jf1wQ9+UBMTE+rv75/yrvLYsWNqb2+fdn+5XM5t4QQAwFyZ9YIDlUpFhUJBq1atUiaT0a5duybHDhw4oJdeekldXV2zPQwAAHNiRu8ot2zZonXr1mnZsmUaGhrS9u3btXv3bj3++OPK5/O6/fbbtXnzZrW2tqqlpUV33HGHurq6zuoTr3GUUhyd+fQK435AecRZlCCkmfHQgL2P+QvspsvZlB+o9Zrr5hua3H3UZexAd0OdHUCeGLebzUp+YDuk6bK3TS5rPw5JmtdiLxSRqrN/9ytO1w3895Qi+/56pd+fryhnN4SNIjtI3eg045akOue6NjTYix5Ikir2ecZOk+DIWcxCkibG7Xu8VPKvSblk339DA8Pm+OiQv/hCfc6ez1TFf19RmLDvjRMnTrj7GHUWikg12s+TVOQ/jzz1OXsxC0lqqLPv0ZEh+5p4jdwlufdnSCP2ajRunlGhPH78uD72sY/p6NGjyufzWrlypR5//HG95z3vkSR94xvfUBzHWr9+vQqFgtauXatvfetbMzkEAAA1ZUaF8oEHHjDH6+rqtHXrVm3dunVWJwUAQK1gUXQAAAwUSgAADBRKAAAMFEoAAAwUSgAADDXbuDmJYiXTdNzM1vkZn1NOo9flKX81IC+fmI6dDFniNwkuFe08XTpgH3mngW95zG6gOjbkL0Rf52TyKiU/25rN2bdbU4OfHazP2eeRytm/+2UiO9MnSeNFu4HvwoUL/X1U7Dxd4lzX8YCscMppHJ6t9xv4Zpx7uFhwMo5l/3ftsdP2/TU65Df9Tif2veNlHOuy/vM9SdnPxSigyW8uZ2cD+/pedvfRd+yIOb7w4jZzvCj/NSMr+7Vtafsydx8TTiP2stNUOZ0KyHumvYyt/1irgXeUAAAYKJQAABgolAAAGCiUAAAYKJQAABgolAAAGCiUAAAYajZHWSpWFMVnzsjksn6OMpWyMzyFUT+7NTFm54TiZvvn02m/31o6a/dDywRcoqasnS1sa11sjnv9AiVpdNzOYjYv8vtmzm+x+3eG9LT0egaWZT8W+4q+yuvzWEr5GUfv/io5/RVDTEzYGbM44NfgJG2fR7Fkz2fiT4UKBXsuJsb85+K4M59FJ4+clPy8XeL0PkynZ/9yeerUKXebFw7+f+b4/HmLzPFFeTtnKUnltD1f/U4OXZIiZ75GR+3XjHzeeQGVVCrbN1jIPV42MstuTvi14wRtBQDA/1EUSgAADBRKAAAMFEoAAAwUSgAADBRKAAAMFEoAAAwUSgAADDW74EA2nVVmmoBvOfFj4+WiHSQdHR519zE6aDfwPeVkxuvr/WaxTc32YgHNdX4ot7W51RxfmLfHX3nlhHuM8XE78L20/QJ3H0sW2kHoRfP8hsiK7ZBzRfZ1rwQ0wi6XQ5YlsMVOEjpJnKB/0V8Eoix7H945hJyHt1hAedyfz5ER+3k0HPBc9Lbxwu2VoP6+9nxF0zSS/32lkn3/jQzZ5ylJBw8eNMc72i40x+tTfgP0wcFhc/z555919+Hdo42N9nmEXJMxZzGKJKAWWAtFFJ3m06/hHSUAAAYKJQAABgolAAAGCiUAAAYKJQAABgolAAAGCiUAAIYazlFmlM2c+fTGCn4AJ52kzPGQhrNDp4bM8YmRcXO8qcnPM6US+3eVQuyfaKlgZ+EanCzmonl2Y2dJktOktaNtqbuLxU6OMhP7t2PiZAcLTq7Ky7lJfj6sHNT+2WNf95CMWRLZcxGSBy2X7cc6Nmbn/kJylBNj9j3sZTUlaWLC3oczFcpk/ExzkrFfM+Kg9xX2Ntls1t1Df3+/OX7whRftY0T+MYaH7NeuQ4cOuftIp+3H2tnZaY6fPOnntyPZ16RcCXkuWucZFLCd2TvKbdu2aeXKlWppaVFLS4u6urr005/+dHL8hhtuUBRFU74+/elPz+QQAADUlBm9o1y6dKnuvvturVixQkmS6Dvf+Y5uueUW/eu//quuuOIKSdInP/lJfeUrX5n8mYYGe+UZAABq2YwK5c033zzl/7/2ta9p27Zt2rt372ShbGhoUHt7e/XOEACAOXTWH+Ypl8vasWOHRkZG1NXVNfn9733ve1q4cKGuvPJKbdmyRaOj9hqNhUJBg4ODU74AAKgVM/4wz3PPPaeuri6Nj4+rqalJO3fu1OWXXy5J+shHPqILL7xQHR0devbZZ/X5z39eBw4c0I9+9KNp99fT06O77rrr7B8BAADn0IwL5aWXXqr9+/drYGBAP/zhD7Vhwwb19vbq8ssv16c+9anJ7a666iotWbJEq1ev1sGDB3XxxRefcX9btmzR5s2bJ/9/cHDQ/bQUAADny4wLZTab1SWXXCJJWrVqlZ5++ml985vf1Le//e3XbXvttddKkl588cVpC2Uul1Mu5390GwCAuTDrBQcqlcq0Oaj9+/dLkpYsWTLbwwAAMCdm9I5yy5YtWrdunZYtW6ahoSFt375du3fv1uOPP66DBw9q+/btet/73qcFCxbo2Wef1Z133qnrr79eK1eunPGJRUmsqHLmOp7LZAJ+3h4fdpoyS9LBF/7DHK+rqzPHW/Mt7jH6X+k3x/Ot8919lMbs0Ozp46fN8ZFBv5ls+8IOc7yt1V+0IJOyg9AhQekJ2cFzL2RfCUjyZ7z7K/b3MVrymxFbUik7aC35jyVkwYGK0+C84CwWUB73j+EtFlAJOM/YeT6Xvd/5nQUzpIB3DQHZ9ooTYM+k/deuoQH7A43P/8Zuqtz3uz73GEePHDfHvabgkr8wx9BRe8GWdNq/x73m43HFL2FxNP02Th/4STMqlMePH9fHPvYxHT16VPl8XitXrtTjjz+u97znPTp8+LB+9rOf6d5779XIyIg6Ozu1fv16feELX5jJIQAAqCkzKpQPPPDAtGOdnZ3q7e2d9QkBAFBLWBQdAAADhRIAAAOFEgAAA4USAAADhRIAAEPNNm4uFYuKpglPRVFA+MUJXo2N2Y1LJanvZTuP1Nraao43Zv0WY7mMnWMb7vfzeKND9jax7OzW/Lz9OCSpJW83fw5pNKyyvdF4MaCBb2RvkyT2dc8F5NjilL2POCBjVp+1M7ZeBm2i5M9FLm2vaDUekOUsORfOa3RdnLAfhyRNjNuPpRSwD6cft9JGVk4KikAqm3Eye6mALKbTiD3lNCKWXs2QW8bG7Az40fHfucdInPdIE0W/Ybz7Ouw8TbznquRnmtPp2ZUwL6c5ud2sjgIAwB84CiUAAAYKJQAABgolAAAGCiUAAAYKJQAABgolAAAGCiUAAIaaXXAgzqSVypz59EKa7yaJvU1I2NVblGBoaNgcr8v2u8fwFMbtwLckxSn7Ml580QpzPJMLaH6as8PFIcHdsTG7QXSmwW/cPFa09xHZOX+lnbmSpKLTHDrk98ts1n4suaJ9ooWCv+BAKrbD6yknhC9JUWLfX5HT8Lhc9J+LhYKzuELBv8e9BQeSktfZ2b9m7nwGvFzG3kNxXpckKZ227x2vOXRU8V/bShWnmXbFX6LBew31mo+7DdIlBa4HYLIWzWDBAQAAqoBCCQCAgUIJAICBQgkAgIFCCQCAgUIJAICBQgkAgKFmc5SVclnl8pkzXNM1dJ7y817GJyA/4+WEvOa7J06ddI8xOm7nAhctWOju41T/KXO8eV7eHJ+/YJ57jExkZ7uStN/U1mv06jUJDuHl7ZTx751I9nmmnHFJiir2/ZVN2fPZVN/oHsPLWnpNhEO2iZzpCsnsJSXnogTkomPnd/rEuyYBz/fY2YcTs5QkZWMnCxyQO1XkNNMu2687IS/qifNEyWT8BzsyYjeQltMwPkkCcqmxn7X09zH9tSdHCQBAFVAoAQAwUCgBADBQKAEAMFAoAQAwUCgBADBQKAEAMNRsjlKp//46g3JAT7fECYDFAbk/le19VJxjjBbsjKQkDQwPmuMnT55w91F0eselTr5ijl+Svsg9xgXzLjDHo5T/O9dE2c5Jpkp+D8ZsvZfndDJosjNokp/ZU0COMpO2n1qJlx1Mcu4x5GQYC04/VUmqlJzehon9WKOArObEuD3nSUAWMzXL3+m9DO+rJ+KMB5xnxXltSgWcR7lsP5+97J93DpIUZ+x9lJ3nqiTVN9j3qHeeIblUL1Mawsrdh2TypVm+o7z77rsVRZE2bdo0+b3x8XF1d3drwYIFampq0vr163Xs2LHZHAYAgDlz1oXy6aef1re//W2tXLlyyvfvvPNOPfroo3r44YfV29urI0eO6Lbbbpv1iQIAMBfOqlAODw/rox/9qP7+7/9e8+fPn/z+wMCAHnjgAd1zzz268cYbtWrVKj344IP61a9+pb1791btpAEAOF/OqlB2d3fr/e9/v9asWTPl+/v27VOxWJzy/csuu0zLli3Tnj17zrivQqGgwcHBKV8AANSKGX+YZ8eOHfr1r3+tp59++nVjfX19ymazmjdv3pTvt7W1qa+v74z76+np0V133TXT0wAA4LyY0TvKw4cP67Of/ay+973vqa6urionsGXLFg0MDEx+HT58uCr7BQCgGmZUKPft26fjx4/rbW97m9LptNLptHp7e3XfffcpnU6rra1NExMT6u/vn/Jzx44dU3t7+xn3mcvl1NLSMuULAIBaMaM/va5evVrPPffclO994hOf0GWXXabPf/7z6uzsVCaT0a5du7R+/XpJ0oEDB/TSSy+pq6uremcNAMB5MqNC2dzcrCuvvHLK9xobG7VgwYLJ799+++3avHmzWltb1dLSojvuuENdXV267rrrZnZmkaZ9vxsScpbTdFkBwd8ktrcpyg7DJs5CAJJUdIK9XmNnyW943JRvMsdHxkbdY/QP2R+yas3Nc/fhHae+2Q/ZeyHmsnNNqiEd8oeYyG44GzkLXoQ0h045zaErOX9xhchZcGBixF4EYrziLxJRLtr3ZzRNg/bfV3FC+F6j7DjgvogTOwEftmiBdxw/Ze/1EvZe2kIWxPDXJPD3ETuvj958hfRMjpxFXRJ/MszjBPZtrv7KPN/4xjcUx7HWr1+vQqGgtWvX6lvf+la1DwMAwHkx60K5e/fuKf9fV1enrVu3auvWrbPdNQAAc45F0QEAMFAoAQAwUCgBADBQKAEAMFAoAQAw1Gzj5orKqkyT5Ymc/I7kp4CikKahXk7I2UcloNGrF6tKx3ajYkmquOdp/z5UKE64xxgbt5sAl92ut5KcvKfX2FmS0hX7lq142daARrCR8+tjHJCF855YXh40nfLv8WydndXMeA9EUjZtZ1fHhuzs64hG3GNUik5jceeaSv5zKXZz0+4h3NxfSA/hoIz3LLmNm0PO0znNVEDA0MtiViNHKTf/GtJ42domLHfNO0oAAAwUSgAADBRKAAAMFEoAAAwUSgAADBRKAAAMFEoAAAwUSgAADDW74IAlpIGq13TZG5eklPN7ROQkZuOMP70pJzBbLvmB2pRznKHhYXM8N1jnHqPRaf48NuY38G1M20H9kRE/vB47Uxo56zN410ySYmfKKwHhda/xcuSNRwH3Ttaez0wcsDBCbC9acCp70hz3FiyQpIqXgHeaMktSKnHmqwqN2gMuaxX4999sFy0IajBdBd6CK1GNvA+z5iN0rmrjkQAAUKMolAAAGCiUAAAYKJQAABgolAAAGCiUAAAYai4ekvz3x7yLhel7E3r92CQ//hGyj7LzgXG/L5zf66xctHswlst+PKRUsT9eX3T6AU6MF91jFEbtnpVjI348JHaa4FUCesulnH248ZBsSLTIfqyVaLY98KSK08wv5N5JpezP55dKAX1GC3af0fFhex8TI/69Uxq3H0tcDrgmznwliX2PVyI/guJxIyjye0G6fTMlxbOMhyROlOZ88eIh1YixJAHzaXmtznj7iZLZHqnKXn75ZXV2ds71aQAA/o84fPiwli5dOu14zRXKSqWiI0eOqLm5efI3jsHBQXV2durw4cNqaWmZ4zN842M+q4v5rC7ms7qYz+klSaKhoSF1dHSYfyGsuT+9xnE8bWVvaWnhQlcR81ldzGd1MZ/VxXyeWT6fd7fhwzwAABgolAAAGN4QhTKXy+nLX/6ycjl/AWb4mM/qYj6ri/msLuZz9mruwzwAANSSN8Q7SgAA5gqFEgAAA4USAAADhRIAAAOFEgAAQ80Xyq1bt+pNb3qT6urqdO211+pf/uVf5vqU3hCefPJJ3Xzzzero6FAURXrkkUemjCdJoi996UtasmSJ6uvrtWbNGr3wwgtzc7JvAD09PXrHO96h5uZmLV68WLfeeqsOHDgwZZvx8XF1d3drwYIFampq0vr163Xs2LE5OuPatm3bNq1cuXJytZiuri799Kc/nRxnLs/e3XffrSiKtGnTpsnvMZ+zU9OF8gc/+IE2b96sL3/5y/r1r3+tq6++WmvXrtXx48fn+tRq3sjIiK6++mpt3br1jONf//rXdd999+n+++/XU089pcbGRq1du1bj43Y3if+rent71d3drb179+qJJ55QsVjUTTfdpJGRkclt7rzzTj366KN6+OGH1dvbqyNHjui2226bw7OuXUuXLtXdd9+tffv26ZlnntGNN96oW265Rb/5zW8kMZdn6+mnn9a3v/1trVy5csr3mc9ZSmrYNddck3R3d0/+f7lcTjo6OpKenp45PKs3HknJzp07J/+/Uqkk7e3tyd/8zd9Mfq+/vz/J5XLJ97///Tk4wzee48ePJ5KS3t7eJElenb9MJpM8/PDDk9v89re/TSQle/bsmavTfEOZP39+8g//8A/M5VkaGhpKVqxYkTzxxBPJH//xHyef/exnkyTh3qyGmn1HOTExoX379mnNmjWT34vjWGvWrNGePXvm8Mze+A4dOqS+vr4pc5vP53Xttdcyt4EGBgYkSa2trZKkffv2qVgsTpnTyy67TMuWLWNOHeVyWTt27NDIyIi6urqYy7PU3d2t97///VPmTeLerIaa6x7ymhMnTqhcLqutrW3K99va2vTv//7vc3RWfxj6+vok6Yxz+9oYplepVLRp0ya9853v1JVXXinp1TnNZrOaN2/elG2Z0+k999xz6urq0vj4uJqamrRz505dfvnl2r9/P3M5Qzt27NCvf/1rPf30068b496cvZotlECt6u7u1vPPP69f/vKXc30qb2iXXnqp9u/fr4GBAf3whz/Uhg0b1NvbO9en9YZz+PBhffazn9UTTzyhurq6uT6dP0g1+6fXhQsXKpVKve6TWceOHVN7e/scndUfhtfmj7mduY0bN+onP/mJfvGLX0zpm9re3q6JiQn19/dP2Z45nV42m9Ull1yiVatWqaenR1dffbW++c1vMpcztG/fPh0/flxve9vblE6nlU6n1dvbq/vuu0/pdFptbW3M5yzVbKHMZrNatWqVdu3aNfm9SqWiXbt2qauraw7P7I1v+fLlam9vnzK3g4ODeuqpp5jbaSRJoo0bN2rnzp36+c9/ruXLl08ZX7VqlTKZzJQ5PXDggF566SXmNFClUlGhUGAuZ2j16tV67rnntH///smvt7/97froRz86+d/M5+zU9J9eN2/erA0bNujtb3+7rrnmGt17770aGRnRJz7xibk+tZo3PDysF198cfL/Dx06pP3796u1tVXLli3Tpk2b9NWvflUrVqzQ8uXL9cUvflEdHR269dZb5+6ka1h3d7e2b9+uH//4x2pubp78t518Pq/6+nrl83ndfvvt2rx5s1pbW9XS0qI77rhDXV1duu666+b47GvPli1btG7dOi1btkxDQ0Pavn27du/erccff5y5nKHm5ubJfyt/TWNjoxYsWDD5feZzlub6Y7eev/3bv02WLVuWZLPZ5Jprrkn27t0716f0hvCLX/wikfS6rw0bNiRJ8mpE5Itf/GLS1taW5HK5ZPXq1cmBAwfm9qRr2JnmUlLy4IMPTm4zNjaW/Nmf/Vkyf/78pKGhIfnABz6QHD16dO5Ouob96Z/+aXLhhRcm2Ww2WbRoUbJ69erkn//5nyfHmcvZ+f14SJIwn7NFP0oAAAw1+2+UAADUAgolAAAGCiUAAAYKJQAABgolAAAGCiUAAAYKJQAABgolAAAGCiUAAAYKJQAABgolAACG/x+Az00t5/q0OgAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "top_half_image=  image[0: int(image.shape[0]/2), :]\n",
    "plt.imshow(top_half_image)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Cluster the image into two clusters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/abdullah/python_virtual_env/cv_env/lib/python3.8/site-packages/sklearn/cluster/_kmeans.py:1416: FutureWarning: The default value of `n_init` will change from 10 to 'auto' in 1.4. Set the value of `n_init` explicitly to suppress the warning\n",
      "  super()._check_params_vs_input(X, default_n_init=10)\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAcoAAAGeCAYAAAAUg0E9AAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuNSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/xnp5ZAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAe/ElEQVR4nO3df2xUVd7H8U9r6fCjnYEW2mnTKQuCIGIxVigTXRahUqshIN3EX4nVJRrdgQjNRreJP5ZdTVk3UWSt1ewS1MRag7EYTITFKkOMLQt1G9Bdu4LsQw20qLEzpW6HPvQ+fxjn2VnaA9Pe+dHyfiUnYe69c+fbMy2fnJl7zk2xLMsSAAAYVGqiCwAAIJkRlAAAGBCUAAAYEJQAABgQlAAAGBCUAAAYEJQAABgQlAAAGBCUAAAYpCW6gP82MDCgkydPKjMzUykpKYkuBwAwRlmWpZ6eHuXn5ys11TButGLkhRdesKZPn245HA5r0aJF1oEDBy7qeR0dHZYkGo1Go9Hi0jo6Ooy5FJMR5Ztvvqmqqiq99NJLKikp0ZYtW1RWVqb29nbl5OQYn5uZmSlJ+p9PfiJnBp8MAwBiI3hmQNOv/Vc4d4aSYln2L4peUlKihQsX6oUXXpD0w8epHo9H69ev169//Wvjc4PBoFwul77750w5MwlKAEBsBHsGNOWKLxUIBOR0Ooc8zvYkOnv2rFpbW1VaWvr/L5KaqtLSUjU3N593fCgUUjAYjGgAACQL24Pym2++0blz55SbmxuxPTc3V52dnecdX1NTI5fLFW4ej8fukgAAGLaEf7ZZXV2tQCAQbh0dHYkuCQCAMNsv5pk6daouu+wydXV1RWzv6uqS2+0+73iHwyGHw2F3GQAA2ML2EWV6erqKi4vV1NQU3jYwMKCmpiZ5vV67Xw4AgJiKyfSQqqoqVVZW6rrrrtOiRYu0ZcsW9fb26r777ovFywEAEDMxCcrbb79dX3/9tZ544gl1dnbqmmuu0e7du8+7wAcAgGQXk3mUI8E8SgBAPCRsHiUAAGMJQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAICB7UH5m9/8RikpKRFt7ty5dr8MAABxkRaLk1511VV6//33//9F0mLyMgAAxFxMEiwtLU1utzsWpwYAIK5i8h3lF198ofz8fM2cOVN33323Tpw4MeSxoVBIwWAwogEAkCxsD8qSkhK98sor2r17t+rq6nT8+HH99Kc/VU9Pz6DH19TUyOVyhZvH47G7JAAAhi3Fsiwrli/Q3d2t6dOn69lnn9XatWvP2x8KhRQKhcKPg8GgPB6PvvvnTDkzuSgXABAbwZ4BTbniSwUCATmdziGPi/lVNpMnT9YVV1yho0ePDrrf4XDI4XDEugwAAIYl5kO2M2fO6NixY8rLy4v1SwEAYDvbg/JXv/qV/H6//vWvf+njjz/Wbbfdpssuu0x33nmn3S8FAEDM2f7R61dffaU777xT3377raZNm6YbbrhBLS0tmjZtmt0vBQBAzNkelA0NDXafEgCAhOGyUgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADKIOyv3792vlypXKz89XSkqKdu7cGbHfsiw98cQTysvL04QJE1RaWqovvvjCrnoBAIirqIOyt7dXCxYsUG1t7aD7n3nmGW3dulUvvfSSDhw4oEmTJqmsrEx9fX0jLhYAgHhLi/YJ5eXlKi8vH3SfZVnasmWLHnvsMa1atUqS9Nprryk3N1c7d+7UHXfcMbJqAQCIM1u/ozx+/Lg6OztVWloa3uZyuVRSUqLm5uZBnxMKhRQMBiMaAADJwtag7OzslCTl5uZGbM/NzQ3v+281NTVyuVzh5vF47CwJAIARSfhVr9XV1QoEAuHW0dGR6JIAAAizNSjdbrckqaurK2J7V1dXeN9/czgccjqdEQ0AgGQR9cU8JjNmzJDb7VZTU5OuueYaSVIwGNSBAwf00EMP2flSAOKgLP+aRJcgSdpzsi3RJeASFnVQnjlzRkePHg0/Pn78uNra2pSVlaXCwkJt2LBBTz31lGbPnq0ZM2bo8ccfV35+vlavXm1n3QAAxEXUQXno0CHdeOON4cdVVVWSpMrKSr3yyit65JFH1NvbqwceeEDd3d264YYbtHv3bo0fP96+qgEAiJMUy7KsRBfxn4LBoFwul77750w5MxN+rRFwSeOjV4xlwZ4BTbniSwUCAeP1MSQRAAAGBCUAAAYEJQAABgQlAAAGBCUAAAa2LjgAALEw0qtvuWoWI8GIEgAAA4ISAAADghIAAAOCEgAAA4ISAAADghIAAAOCEgAAA+ZRYkxJlrtdXAjz+uLLjt8L3rNLFyNKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAxYcACjymhZUGC0oD8v3sX0FYsSjE2MKAEAMCAoAQAwICgBADAgKAEAMCAoAQAwICgBADAgKAEAMGAeJWzBfLzoXKi/mI83OvG+jk1Rjyj379+vlStXKj8/XykpKdq5c2fE/nvvvVcpKSkR7eabb7arXgAA4irqoOzt7dWCBQtUW1s75DE333yzTp06FW5vvPHGiIoEACBRov7otby8XOXl5cZjHA6H3G73sIsCACBZxORinn379iknJ0dz5szRQw89pG+//XbIY0OhkILBYEQDACBZ2B6UN998s1577TU1NTXp97//vfx+v8rLy3Xu3LlBj6+pqZHL5Qo3j8djd0kAAAyb7Ve93nHHHeF/X3311SoqKtLll1+uffv2afny5ecdX11draqqqvDjYDBIWAIAkkbM51HOnDlTU6dO1dGjRwfd73A45HQ6IxoAAMki5kH51Vdf6dtvv1VeXl6sXwoAANtF/dHrmTNnIkaHx48fV1tbm7KyspSVlaVNmzapoqJCbrdbx44d0yOPPKJZs2aprKzM1sIRXywoAOBSFXVQHjp0SDfeeGP48Y/fL1ZWVqqurk6HDx/Wq6++qu7ubuXn52vFihX63e9+J4fDYV/VAADESdRBuXTpUlmWNeT+PXv2jKggAACSCYuiAwBgQFACAGBAUAIAYEBQAgBgQFACAGDAjZvBHMkkdDHvyYVuAsz7CtiDESUAAAYEJQAABgQlAAAGBCUAAAYEJQAABgQlAAAGBCUAAAbMo7wEMJ9ubOJ9BeKDESUAAAYEJQAABgQlAAAGBCUAAAYEJQAABgQlAAAGBCUAAAYEJQAABiw4MAYw8RwYHey4ITfijxElAAAGBCUAAAYEJQAABgQlAAAGBCUAAAYEJQAABgQlAAAGzKNMMOZAAvhPF/o/gXmW8RfViLKmpkYLFy5UZmamcnJytHr1arW3t0cc09fXJ5/Pp+zsbGVkZKiiokJdXV22Fg0AQLxEFZR+v18+n08tLS3au3ev+vv7tWLFCvX29oaP2bhxo3bt2qUdO3bI7/fr5MmTWrNmje2FAwAQDymWZVnDffLXX3+tnJwc+f1+LVmyRIFAQNOmTVN9fb1+/vOfS5I+//xzXXnllWpubtbixYsveM5gMCiXy6Xv/jlTzsyx/xUqH70CiAYfvdon2DOgKVd8qUAgIKfTOeRxI0qiQCAgScrKypIktba2qr+/X6WlpeFj5s6dq8LCQjU3Nw96jlAopGAwGNEAAEgWww7KgYEBbdiwQddff73mz58vSers7FR6eromT54ccWxubq46OzsHPU9NTY1cLle4eTye4ZYEAIDthh2UPp9Pn376qRoaGkZUQHV1tQKBQLh1dHSM6HwAANhpWNND1q1bp3fffVf79+9XQUFBeLvb7dbZs2fV3d0dMars6uqS2+0e9FwOh0MOh2M4ZQAAEHNRjSgty9K6devU2NioDz74QDNmzIjYX1xcrHHjxqmpqSm8rb29XSdOnJDX67WnYgAA4iiqEaXP51N9fb3eeecdZWZmhr93dLlcmjBhglwul9auXauqqiplZWXJ6XRq/fr18nq9F3XFKwAAySaqoKyrq5MkLV26NGL79u3bde+990qSnnvuOaWmpqqiokKhUEhlZWV68cUXbSkWAIB4iyooL2bK5fjx41VbW6va2tphFwUAQLIY+zP6AQAYAYISAAADghIAAAOCEgAAA4ISAACDS/bGzXbcteNCq/hzZxAAduPGzvHHiBIAAAOCEgAAA4ISAAADghIAAAOCEgAAA4ISAAADghIAAINLdh6lHZgnCYwOdswt5O/90sWIEgAAA4ISAAADghIAAAOCEgAAA4ISAAADghIAAAOCEgAAA4ISAACDMbvgAJOD4ytZbhbL+45YuZjf8WT4/buYGpLl73W0YEQJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAIDBmJ1HOVZcSvOdkmEOGgD8t6hGlDU1NVq4cKEyMzOVk5Oj1atXq729PeKYpUuXKiUlJaI9+OCDthYNAEC8RBWUfr9fPp9PLS0t2rt3r/r7+7VixQr19vZGHHf//ffr1KlT4fbMM8/YWjQAAPES1Uevu3fvjnj8yiuvKCcnR62trVqyZEl4+8SJE+V2u+2pEACABBrRxTyBQECSlJWVFbH99ddf19SpUzV//nxVV1fr+++/H/IcoVBIwWAwogEAkCyGfTHPwMCANmzYoOuvv17z588Pb7/rrrs0ffp05efn6/Dhw3r00UfV3t6ut99+e9Dz1NTUaNOmTcMtAwCAmBp2UPp8Pn366af66KOPIrY/8MAD4X9fffXVysvL0/Lly3Xs2DFdfvnl552nurpaVVVV4cfBYFAej2e4ZQEAYKthBeW6dev07rvvav/+/SooKDAeW1JSIkk6evTooEHpcDjkcDiGUwYAADEXVVBalqX169ersbFR+/bt04wZMy74nLa2NklSXl7esAoEACCRogpKn8+n+vp6vfPOO8rMzFRnZ6ckyeVyacKECTp27Jjq6+t1yy23KDs7W4cPH9bGjRu1ZMkSFRUVxeQHADD2XUoLb8TDhRb3oL8jRRWUdXV1kn5YVOA/bd++Xffee6/S09P1/vvva8uWLert7ZXH41FFRYUee+wx2woGACCeov7o1cTj8cjv94+oIAAAkgmLogMAYEBQAgBgQFACAGBAUAIAYEBQAgBgwI2bgUvYSOfLcbPtSBfqT/prdGJECQCAAUEJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAfMogSTE/QCB5MGIEgAAA4ISAAADghIAAAOCEgAAA4ISAAADghIAAAOCEgAAA4ISAACDMbvgwFi5gerF1MnkdAB24v+dSIwoAQAwICgBADAgKAEAMCAoAQAwICgBADAgKAEAMCAoAQAwGLPzKIHRzI55vpfSPDcglqIaUdbV1amoqEhOp1NOp1Ner1fvvfdeeH9fX598Pp+ys7OVkZGhiooKdXV12V40AADxElVQFhQUaPPmzWptbdWhQ4e0bNkyrVq1Sp999pkkaePGjdq1a5d27Nghv9+vkydPas2aNTEpHACAeIjqo9eVK1dGPH766adVV1enlpYWFRQUaNu2baqvr9eyZcskSdu3b9eVV16plpYWLV682L6qAQCIk2FfzHPu3Dk1NDSot7dXXq9Xra2t6u/vV2lpafiYuXPnqrCwUM3NzUOeJxQKKRgMRjQAAJJF1EF55MgRZWRkyOFw6MEHH1RjY6PmzZunzs5Opaena/LkyRHH5+bmqrOzc8jz1dTUyOVyhZvH44n6hwAAIFaiDso5c+aora1NBw4c0EMPPaTKykr9/e9/H3YB1dXVCgQC4dbR0THscwEAYLeop4ekp6dr1qxZkqTi4mIdPHhQzz//vG6//XadPXtW3d3dEaPKrq4uud3uIc/ncDjkcDiirxwAgDgY8YIDAwMDCoVCKi4u1rhx49TU1BTe197erhMnTsjr9Y70ZQAASIioRpTV1dUqLy9XYWGhenp6VF9fr3379mnPnj1yuVxau3atqqqqlJWVJafTqfXr18vr9SblFa8XMxl7tNzcGRjMaPn9vZQWRuD/ndEpqqA8ffq07rnnHp06dUoul0tFRUXas2ePbrrpJknSc889p9TUVFVUVCgUCqmsrEwvvvhiTAoHACAeogrKbdu2GfePHz9etbW1qq2tHVFRAAAkCxZFBwDAgKAEAMCAoAQAwICgBADAgKAEAMCAGzePARead3UpzVMDALsxogQAwICgBADAgKAEAMCAoAQAwICgBADAgKAEAMCAoAQAwIB5lIgb7rN3aWIeL0Y7RpQAABgQlAAAGBCUAAAYEJQAABgQlAAAGBCUAAAYEJQAABgQlAAAGLDgAAAkkQst0BCPhTtYJCISI0oAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMCEoAAAyYRwlbcFPmSxPz7XApiGpEWVdXp6KiIjmdTjmdTnm9Xr333nvh/UuXLlVKSkpEe/DBB20vGgCAeIlqRFlQUKDNmzdr9uzZsixLr776qlatWqW//e1vuuqqqyRJ999/v37729+GnzNx4kR7KwYAII6iCsqVK1dGPH766adVV1enlpaWcFBOnDhRbrfbvgoBAEigYV/Mc+7cOTU0NKi3t1derze8/fXXX9fUqVM1f/58VVdX6/vvvzeeJxQKKRgMRjQAAJJF1BfzHDlyRF6vV319fcrIyFBjY6PmzZsnSbrrrrs0ffp05efn6/Dhw3r00UfV3t6ut99+e8jz1dTUaNOmTcP/CQAAiKGog3LOnDlqa2tTIBDQW2+9pcrKSvn9fs2bN08PPPBA+Lirr75aeXl5Wr58uY4dO6bLL7980PNVV1erqqoq/DgYDMrj8QzjRwEAwH5RB2V6erpmzZolSSouLtbBgwf1/PPP6+WXXz7v2JKSEknS0aNHhwxKh8Mhh8MRbRkAAMTFiBccGBgYUCgUGnRfW1ubJCkvL2+kLwMAQEJENaKsrq5WeXm5CgsL1dPTo/r6eu3bt0979uzRsWPHVF9fr1tuuUXZ2dk6fPiwNm7cqCVLlqioqChW9cfUSCdTMwkfox0LCiQf3pP4iyooT58+rXvuuUenTp2Sy+VSUVGR9uzZo5tuukkdHR16//33tWXLFvX29srj8aiiokKPPfZYrGoHACDmogrKbdu2DbnP4/HI7/ePuCAAAJIJi6IDAGBAUAIAYEBQAgBgQFACAGBAUAIAYEBQAgBgQFACAGBAUAIAYEBQAgBgQFACAGBAUAIAYEBQAgBgQFACAGBAUAIAYBDVbbYQnYu5wWo8bu7MDaQBYPgYUQIAYEBQAgBgQFACAGBAUAIAYEBQAgBgQFACAGBAUAIAYMA8ygS7mLmWscY8SwAYGiNKAAAMCEoAAAwISgAADAhKAAAMCEoAAAwISgAADAhKAAAMmEeJpLlvJgAkoxGNKDdv3qyUlBRt2LAhvK2vr08+n0/Z2dnKyMhQRUWFurq6RlonAAAJMeygPHjwoF5++WUVFRVFbN+4caN27dqlHTt2yO/36+TJk1qzZs2ICwUAIBGGFZRnzpzR3XffrT/96U+aMmVKeHsgENC2bdv07LPPatmyZSouLtb27dv18ccfq6WlxbaiAQCIl2EFpc/n06233qrS0tKI7a2trerv74/YPnfuXBUWFqq5uXnQc4VCIQWDwYgGAECyiPpinoaGBn3yySc6ePDgefs6OzuVnp6uyZMnR2zPzc1VZ2fnoOerqanRpk2boi0DAIC4iGpE2dHRoYcfflivv/66xo8fb0sB1dXVCgQC4dbR0WHLeQEAsENUQdna2qrTp0/r2muvVVpamtLS0uT3+7V161alpaUpNzdXZ8+eVXd3d8Tzurq65Ha7Bz2nw+GQ0+mMaAAAJIuoPnpdvny5jhw5ErHtvvvu09y5c/Xoo4/K4/Fo3LhxampqUkVFhSSpvb1dJ06ckNfrta9qAADiJKqgzMzM1Pz58yO2TZo0SdnZ2eHta9euVVVVlbKysuR0OrV+/Xp5vV4tXrzYvqoBAIgT21fmee6555SamqqKigqFQiGVlZXpxRdftPtlAACIixTLsqxEF/GfgsGgXC6XvvvnTDkzWYo2WbCE3aXpYpY3BEarYM+AplzxpQKBgPH6GJIIAAADghIAAAOCEgAAA4ISAAADghIAAANu3AxgSBe62pmrYnEpYEQJAIABQQkAgAFBCQCAAUEJAIABQQkAgAFBCQCAAUEJAIABQQkAgAELDuCiXGhiObfhAjBWMaIEAMCAoAQAwICgBADAgKAEAMCAoAQAwICgBADAIOmmh1iWJUkKnhlIcCWIxv9a/YkuAQkQ7OHvFKPXjznzY+4MJemCsqenR5I0/dp/JbYQROnLRBeABJhyRaIrAEaup6dHLpdryP0p1oWiNM4GBgZ08uRJZWZmKiUlRZIUDAbl8XjU0dEhp9OZ4ApHP/rTXvSnvehPe9GfQ7MsSz09PcrPz1dq6tDfRCbdiDI1NVUFBQWD7nM6nbzRNqI/7UV/2ov+tBf9OTjTSPJHXMwDAIABQQkAgMGoCEqHw6Enn3xSDocj0aWMCfSnvehPe9Gf9qI/Ry7pLuYBACCZjIoRJQAAiUJQAgBgQFACAGBAUAIAYEBQAgBgkPRBWVtbq5/85CcaP368SkpK9Ne//jXRJY0K+/fv18qVK5Wfn6+UlBTt3LkzYr9lWXriiSeUl5enCRMmqLS0VF988UViih0FampqtHDhQmVmZionJ0erV69We3t7xDF9fX3y+XzKzs5WRkaGKioq1NXVlaCKk1tdXZ2KiorCq8V4vV6999574f305fBt3rxZKSkp2rBhQ3gb/TkySR2Ub775pqqqqvTkk0/qk08+0YIFC1RWVqbTp08nurSk19vbqwULFqi2tnbQ/c8884y2bt2ql156SQcOHNCkSZNUVlamvr6+OFc6Ovj9fvl8PrW0tGjv3r3q7+/XihUr1NvbGz5m48aN2rVrl3bs2CG/36+TJ09qzZo1Caw6eRUUFGjz5s1qbW3VoUOHtGzZMq1atUqfffaZJPpyuA4ePKiXX35ZRUVFEdvpzxGyktiiRYssn88Xfnzu3DkrPz/fqqmpSWBVo48kq7GxMfx4YGDAcrvd1h/+8Ifwtu7ubsvhcFhvvPFGAiocfU6fPm1Jsvx+v2VZP/TfuHHjrB07doSP+cc//mFJspqbmxNV5qgyZcoU689//jN9OUw9PT3W7Nmzrb1791o/+9nPrIcfftiyLH437ZC0I8qzZ8+qtbVVpaWl4W2pqakqLS1Vc3NzAisb/Y4fP67Ozs6IvnW5XCopKaFvL1IgEJAkZWVlSZJaW1vV398f0adz585VYWEhfXoB586dU0NDg3p7e+X1eunLYfL5fLr11lsj+k3id9MOSXf3kB998803OnfunHJzcyO25+bm6vPPP09QVWNDZ2enJA3atz/uw9AGBga0YcMGXX/99Zo/f76kH/o0PT1dkydPjjiWPh3akSNH5PV61dfXp4yMDDU2NmrevHlqa2ujL6PU0NCgTz75RAcPHjxvH7+bI5e0QQkkK5/Pp08//VQfffRRoksZ1ebMmaO2tjYFAgG99dZbqqyslN/vT3RZo05HR4cefvhh7d27V+PHj090OWNS0n70OnXqVF122WXnXZnV1dUlt9udoKrGhh/7j76N3rp16/Tuu+/qww8/jLhvqtvt1tmzZ9Xd3R1xPH06tPT0dM2aNUvFxcWqqanRggUL9Pzzz9OXUWptbdXp06d17bXXKi0tTWlpafL7/dq6davS0tKUm5tLf45Q0gZlenq6iouL1dTUFN42MDCgpqYmeb3eBFY2+s2YMUNutzuib4PBoA4cOEDfDsGyLK1bt06NjY364IMPNGPGjIj9xcXFGjduXESftre368SJE/TpRRoYGFAoFKIvo7R8+XIdOXJEbW1t4Xbdddfp7rvvDv+b/hyZpP7otaqqSpWVlbruuuu0aNEibdmyRb29vbrvvvsSXVrSO3PmjI4ePRp+fPz4cbW1tSkrK0uFhYXasGGDnnrqKc2ePVszZszQ448/rvz8fK1evTpxRScxn8+n+vp6vfPOO8rMzAx/t+NyuTRhwgS5XC6tXbtWVVVVysrKktPp1Pr16+X1erV48eIEV598qqurVV5ersLCQvX09Ki+vl779u3Tnj176MsoZWZmhr8r/9GkSZOUnZ0d3k5/jlCiL7u9kD/+8Y9WYWGhlZ6ebi1atMhqaWlJdEmjwocffmhJOq9VVlZalvXDFJHHH3/cys3NtRwOh7V8+XKrvb09sUUnscH6UpK1ffv28DH//ve/rV/+8pfWlClTrIkTJ1q33XabderUqcQVncR+8YtfWNOnT7fS09OtadOmWcuXL7f+8pe/hPfTlyPzn9NDLIv+HCnuRwkAgEHSfkcJAEAyICgBADAgKAEAMCAoAQAwICgBADAgKAEAMCAoAQAwICgBADAgKAEAMCAoAQAwICgBADD4P/FVWrRWO1EyAAAAAElFTkSuQmCC",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Reshape the image into 2d array\n",
    "image_2d = top_half_image.reshape(-1, 3)\n",
    "\n",
    "# perform k-means clustering with 2 clusters\n",
    "kmeans = KMeans(n_clusters=2, random_state=0)\n",
    "kmeans.fit(image_2d)\n",
    "\n",
    "# get the cluster labels\n",
    "labels = kmeans.labels_\n",
    "\n",
    "# reshape the labels into the orginal image shape\n",
    "clustered_image = labels.reshape(top_half_image.shape[0], top_half_image.shape[1])\n",
    "\n",
    "# Display the clustered image\n",
    "plt.imshow(clustered_image)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n"
     ]
    }
   ],
   "source": [
    "corner_clusters = [clustered_image[0, 0], clustered_image[0, -1], clustered_image[-1, 0], clustered_image[-1, -1]]\n",
    "non_player_cluster = max(set(corner_clusters), key=corner_clusters.count)\n",
    "print(non_player_cluster)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n"
     ]
    }
   ],
   "source": [
    "player_cluster = 1-non_player_cluster\n",
    "print(player_cluster)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([171.38378378, 235.65405405, 142.8472973 ])"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "kmeans.cluster_centers_[player_cluster]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "cv_env",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
</file>

<file path="python/extract_positions.py">
#!/usr/bin/env python3
"""
Extract player positions from soccer match video using YOLO object detection.
Outputs position data as JSON for heatmap generation.
"""

import cv2
import json
import argparse
import sys
from pathlib import Path
import numpy as np

try:
    from ultralytics import YOLO
except ImportError:
    print("ERROR: ultralytics not installed. Run: pip install ultralytics", file=sys.stderr)
    sys.exit(1)


def estimate_team(x, y, frame_width, frame_height):
    """
    Estimate team based on field position.
    Simple heuristic: left half = Team A, right half = Team B
    
    Args:
        x, y: Player position in pixels
        frame_width, frame_height: Video dimensions
    
    Returns:
        'A' or 'B'
    """
    # Normalize x position (0-100)
    x_normalized = (x / frame_width) * 100
    
    # Simple split: left half vs right half
    return 'A' if x_normalized < 50 else 'B'


def extract_positions(video_path, output_path, frame_skip=5, confidence_threshold=0.5, start_time=0, end_time=None):
    """
    Extract player positions from video using YOLO detection.
    
    Args:
        video_path: Path to input video file
        output_path: Path to output JSON file
        frame_skip: Process every Nth frame (default: 5 for speed)
        confidence_threshold: Minimum detection confidence (default: 0.5)
        start_time: Start time in seconds (default: 0)
        end_time: End time in seconds (default: None, meaning end of video)
    
    Returns:
        List of position dictionaries
    """
    print(f"Loading video: {video_path}")
    cap = cv2.VideoCapture(str(video_path))
    
    if not cap.isOpened():
        print(f"ERROR: Could not open video file: {video_path}", file=sys.stderr)
        sys.exit(1)
    
    # Get video properties
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    fps = cap.get(cv2.CAP_PROP_FPS)
    frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    duration = total_frames / fps
    
    print(f"Video info: {total_frames} frames, {fps:.2f} FPS, {frame_width}x{frame_height}")
    print(f"Duration: {duration:.2f}s")
    
    # Calculate start and end frames
    start_frame = int(start_time * fps)
    end_frame = int(end_time * fps) if end_time is not None else total_frames
    
    # Validate range
    if start_frame >= total_frames:
        print(f"WARNING: Start time {start_time}s is beyond video duration {duration:.2f}s", file=sys.stderr)
        start_frame = 0
    
    if end_frame > total_frames:
        end_frame = total_frames
        
    # Handle single timestamp case (start_time == end_time)
    if start_frame == end_frame:
        end_frame = start_frame + 1
        print(f"Single timestamp requested. Processing frame {start_frame}")
    elif start_frame > end_frame:
        print(f"ERROR: Start time {start_time}s must be less than end time {end_time}s", file=sys.stderr)
        sys.exit(1)
    
    # Auto-adjust frame skip for short durations
    requested_duration = (end_frame - start_frame) / fps
    if requested_duration < 1.0:
        print(f"Short duration ({requested_duration:.2f}s) detected. Disabling frame skip.")
        frame_skip = 1
        
    print(f"Processing range: {start_time}s to {end_time if end_time else duration:.2f}s (Frames {start_frame}-{end_frame})")
    print(f"Processing every {frame_skip} frames...")
    
    # Set starting position
    cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
    frame_count = start_frame
    
    # Load YOLO model (using YOLOv8n for speed)
    print("Loading YOLO model...")
    model = YOLO('yolov8n.pt')  # Nano model for speed
    
    positions = []
    processed_count = 0
    
    while frame_count < end_frame:
        ret, frame = cap.read()
        if not ret:
            break
        
        # Only process every Nth frame
        if frame_count % frame_skip != 0:
            frame_count += 1
            continue
        
        # Calculate timestamp
        timestamp = frame_count / fps
        
        # Run YOLO detection
        results = model(frame, classes=[0], verbose=False)  # class 0 = person
        
        # Extract detections
        for result in results:
            boxes = result.boxes
            for box in boxes:
                # Get confidence
                conf = float(box.conf[0])
                if conf < confidence_threshold:
                    continue
                
                # Get bounding box center
                x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                center_x = (x1 + x2) / 2
                center_y = (y1 + y2) / 2
                
                # Normalize to 0-100 scale
                x_norm = float((center_x / frame_width) * 100)
                y_norm = float((center_y / frame_height) * 100)
                
                # Estimate team
                team = estimate_team(center_x, center_y, frame_width, frame_height)
                
                # Add position data
                positions.append({
                    'frame': frame_count,
                    'timestamp': round(timestamp, 2),
                    'x': round(x_norm, 2),
                    'y': round(y_norm, 2),
                    'team': team,
                    'confidence': round(conf, 2)
                })
        
        processed_count += 1
        
        # Progress update every 100 processed frames
        if processed_count % 100 == 0:
            progress = ((frame_count - start_frame) / (end_frame - start_frame)) * 100
            print(f"Progress: {progress:.1f}% ({frame_count}/{end_frame} frames)", file=sys.stderr)
        
        frame_count += 1
    
    cap.release()
    
    print(f"\nExtracted {len(positions)} player positions from {processed_count} frames")
    
    # Save to JSON
    output_data = {
        'video_info': {
            'total_frames': total_frames,
            'fps': fps,
            'width': frame_width,
            'height': frame_height,
            'duration': duration,
            'analysis_start': start_time,
            'analysis_end': end_time if end_time else duration
        },
        'positions': positions
    }
    
    with open(output_path, 'w') as f:
        json.dump(output_data, f, indent=2)
    
    print(f"Saved position data to: {output_path}")
    
    return positions


def main():
    parser = argparse.ArgumentParser(description='Extract player positions from soccer video')
    parser.add_argument('--video', required=True, help='Path to input video file')
    parser.add_argument('--output', required=True, help='Path to output JSON file')
    parser.add_argument('--frame-skip', type=int, default=5, help='Process every Nth frame (default: 5)')
    parser.add_argument('--confidence', type=float, default=0.5, help='Minimum detection confidence (default: 0.5)')
    parser.add_argument('--start-time', type=float, default=0, help='Start time in seconds (default: 0)')
    parser.add_argument('--end-time', type=float, default=None, help='End time in seconds (default: end of video)')
    
    args = parser.parse_args()
    
    # Validate input file
    video_path = Path(args.video)
    if not video_path.exists():
        print(f"ERROR: Video file not found: {video_path}", file=sys.stderr)
        sys.exit(1)
    
    # Extract positions
    try:
        extract_positions(
            video_path=video_path,
            output_path=args.output,
            frame_skip=args.frame_skip,
            confidence_threshold=args.confidence,
            start_time=args.start_time,
            end_time=args.end_time
        )
    except Exception as e:
        print(f"ERROR: {str(e)}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
</file>

<file path="python/generate_clips.py">
import json
import os
import subprocess
import random
import sqlite3
import logging

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Paths
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
ANALYSIS_FILE = os.path.join(BASE_DIR, 'analysis_results.json')
CLIPS_DIR = os.path.join(BASE_DIR, 'public', 'clips')
DB_PATH = os.path.join(os.path.dirname(__file__), 'tactabot.db')

import cv2

def generate_clips():
    # 1. Load Analysis Results
    if not os.path.exists(ANALYSIS_FILE):
        logging.error(f"Analysis file not found: {ANALYSIS_FILE}")
        return

    with open(ANALYSIS_FILE, 'r') as f:
        data = json.load(f)

    video_path = data.get('metadata', {}).get('video_path')
    if not video_path or not os.path.exists(video_path):
        logging.warning(f"Video path from analysis not found: {video_path}")
        # Find latest mp4 in public/uploads
        uploads_dir = os.path.join(BASE_DIR, 'public', 'uploads')
        if os.path.exists(uploads_dir):
            files = [os.path.join(uploads_dir, f) for f in os.listdir(uploads_dir) if f.endswith('.mp4')]
            if files:
                video_path = max(files, key=os.path.getctime)
                logging.info(f"Using latest video found: {video_path}")
            else:
                logging.error("No .mp4 files found in public/uploads")
                return
        else:
            logging.error(f"Uploads directory not found: {uploads_dir}")
            return

    # 2. Create Clips Directory
    os.makedirs(CLIPS_DIR, exist_ok=True)

    # 3. Generate Random Clips using OpenCV
    duration = data.get('metadata', {}).get('duration', 60)
    num_clips = 5
    clip_duration = 4 # seconds
    
    generated_clips = []

    logging.info(f"Generating {num_clips} clips from {video_path} using OpenCV...")

    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        logging.error("Could not open video.")
        return

    fps = cap.get(cv2.CAP_PROP_FPS)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    
    if fps == 0: fps = 30.0

    for i in range(num_clips):
        start_time = random.uniform(0, (total_frames / fps) - clip_duration - 1)
        start_frame = int(start_time * fps)
        end_frame = int((start_time + clip_duration) * fps)
        
        clip_name = f"clip_{int(start_time)}.mp4"
        output_path = os.path.join(CLIPS_DIR, clip_name)
        
        # Setup VideoWriter
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
        
        cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
        
        current_frame = start_frame
        while current_frame < end_frame and cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break
            out.write(frame)
            current_frame += 1
            
        out.release()
        logging.info(f"Generated: {clip_name}")
        generated_clips.append(output_path)

    cap.release()

    # 4. Update Database
    if generated_clips:
        update_db(generated_clips)

def update_db(clip_paths):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    # Ensure match exists
    c.execute("SELECT match_id FROM matches WHERE name = ?", ("Production Match",))
    match = c.fetchone()
    if not match:
        c.execute("INSERT INTO matches (name, status) VALUES (?, ?)", ("Production Match", "live"))
        match_id = c.lastrowid
    else:
        match_id = match[0]

    # Insert clips
    for path in clip_paths:
        # We store the absolute path for the bot to send
        c.execute("INSERT INTO clips (match_id, video_path, correct_event) VALUES (?, ?, ?)", 
                  (match_id, path, "Unknown"))
    
    conn.commit()
    conn.close()
    logging.info(f"Inserted {len(clip_paths)} clips into database.")

if __name__ == "__main__":
    generate_clips()
</file>

<file path="python/generate_heatmap.py">
#!/usr/bin/env python3
"""
Generate player heatmap from position data.
Creates a visual heatmap overlaid on a soccer field.
"""

import json
import argparse
import sys
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle, Arc, Circle
from scipy.ndimage import gaussian_filter


def draw_soccer_field(ax, field_color='#2d5016', line_color='white'):
    """
    Draw a soccer field on the given matplotlib axis.
    
    Args:
        ax: Matplotlib axis
        field_color: Background color of the field
        line_color: Color of field markings
    """
    # Set field color
    ax.set_facecolor(field_color)
    
    # Field dimensions (normalized 0-100)
    field_length = 100
    field_width = 100
    
    # Outer boundary
    ax.plot([0, 0], [0, field_width], color=line_color, linewidth=2)
    ax.plot([0, field_length], [field_width, field_width], color=line_color, linewidth=2)
    ax.plot([field_length, field_length], [field_width, 0], color=line_color, linewidth=2)
    ax.plot([field_length, 0], [0, 0], color=line_color, linewidth=2)
    
    # Halfway line
    ax.plot([field_length/2, field_length/2], [0, field_width], color=line_color, linewidth=2)
    
    # Center circle
    center_circle = Circle((field_length/2, field_width/2), 9.15, fill=False, 
                           edgecolor=line_color, linewidth=2)
    ax.add_patch(center_circle)
    
    # Center spot
    ax.plot(field_length/2, field_width/2, 'o', color=line_color, markersize=3)
    
    # Penalty areas
    penalty_area_length = 16.5
    penalty_area_width = 40.3
    
    # Left penalty area
    left_penalty = Rectangle((0, (field_width - penalty_area_width)/2), 
                             penalty_area_length, penalty_area_width,
                             fill=False, edgecolor=line_color, linewidth=2)
    ax.add_patch(left_penalty)
    
    # Right penalty area
    right_penalty = Rectangle((field_length - penalty_area_length, 
                               (field_width - penalty_area_width)/2),
                              penalty_area_length, penalty_area_width,
                              fill=False, edgecolor=line_color, linewidth=2)
    ax.add_patch(right_penalty)
    
    # Goal areas
    goal_area_length = 5.5
    goal_area_width = 18.32
    
    # Left goal area
    left_goal = Rectangle((0, (field_width - goal_area_width)/2),
                          goal_area_length, goal_area_width,
                          fill=False, edgecolor=line_color, linewidth=2)
    ax.add_patch(left_goal)
    
    # Right goal area
    right_goal = Rectangle((field_length - goal_area_length,
                            (field_width - goal_area_width)/2),
                           goal_area_length, goal_area_width,
                           fill=False, edgecolor=line_color, linewidth=2)
    ax.add_patch(right_goal)
    
    # Penalty spots
    ax.plot(11, field_width/2, 'o', color=line_color, markersize=3)
    ax.plot(field_length - 11, field_width/2, 'o', color=line_color, markersize=3)
    
    # Set axis limits and aspect
    ax.set_xlim(-5, field_length + 5)
    ax.set_ylim(-5, field_width + 5)
    ax.set_aspect('equal')
    ax.axis('off')


def generate_heatmap(positions_file, output_file, team_filter=None, sigma=3.0, scatter=False):
    """
    Generate heatmap from position data.
    
    Args:
        positions_file: Path to JSON file with position data
        output_file: Path to save heatmap image
        team_filter: Filter by team ('A', 'B', or None for both)
        sigma: Gaussian smoothing factor (higher = smoother)
        scatter: If True, plot individual points instead of heatmap
    """
    print(f"Loading position data from: {positions_file}")
    
    with open(positions_file, 'r') as f:
        data = json.load(f)
    
    positions = data['positions']
    
    # Filter by team if specified
    if team_filter:
        positions = [p for p in positions if p['team'] == team_filter]
        print(f"Filtered to Team {team_filter}: {len(positions)} positions")
    else:
        print(f"Using all positions: {len(positions)}")
    
    if len(positions) == 0:
        print("ERROR: No positions found after filtering", file=sys.stderr)
        sys.exit(1)
    
    # Create figure
    fig, ax = plt.subplots(figsize=(12, 8), facecolor='white')
    
    # Draw soccer field
    draw_soccer_field(ax)
    
    if scatter:
        print("Generating scatter plot...")
        # Extract coordinates and teams
        x_coords = [p['x'] for p in positions]
        y_coords = [p['y'] for p in positions]
        teams = [p['team'] for p in positions]
        
        # Define colors
        colors = ['red' if t == 'A' else 'blue' for t in teams]
        
        # Plot scatter points
        ax.scatter(x_coords, y_coords, c=colors, s=50, alpha=0.7, edgecolors='white')
        
        # Add legend
        from matplotlib.lines import Line2D
        legend_elements = [
            Line2D([0], [0], marker='o', color='w', label='Team A',
                   markerfacecolor='red', markersize=10),
            Line2D([0], [0], marker='o', color='w', label='Team B',
                   markerfacecolor='blue', markersize=10)
        ]
        ax.legend(handles=legend_elements, loc='upper right')
        
    else:
        print("Generating density heatmap...")
        
        # If showing both teams, create separate heatmaps for each
        if not team_filter:
            # Separate positions by team
            team_a_positions = [p for p in positions if p['team'] == 'A']
            team_b_positions = [p for p in positions if p['team'] == 'B']
            
            print(f"Team A: {len(team_a_positions)} positions")
            print(f"Team B: {len(team_b_positions)} positions")
            
            bins = 50
            
            # Create custom dark colormaps
            from matplotlib.colors import LinearSegmentedColormap
            
            # Dark Red colormap (much more saturated)
            colors_red = ['#ffffff', '#ff6666', '#ff0000', '#cc0000', '#990000', '#660000']
            n_bins_red = 100
            cmap_red = LinearSegmentedColormap.from_list('dark_red', colors_red, N=n_bins_red)
            
            # Dark Blue colormap (much more saturated)
            colors_blue = ['#ffffff', '#6666ff', '#0000ff', '#0000cc', '#000099', '#000066']
            n_bins_blue = 100
            cmap_blue = LinearSegmentedColormap.from_list('dark_blue', colors_blue, N=n_bins_blue)
            
            # Create heatmap for Team A (Dark Red)
            if len(team_a_positions) > 0:
                x_a = np.array([p['x'] for p in team_a_positions])
                y_a = np.array([p['y'] for p in team_a_positions])
                heatmap_a, _, _ = np.histogram2d(x_a, y_a, bins=bins, range=[[0, 100], [0, 100]])
                heatmap_a = gaussian_filter(heatmap_a, sigma=sigma).T
                
                # Don't normalize - keep raw intensity for darker colors
                # Just scale to reasonable range
                if heatmap_a.max() > 0:
                    heatmap_a = heatmap_a / heatmap_a.max() * 2  # Boost intensity
                
                # Overlay Team A heatmap (Dark Red) with higher opacity
                extent = [0, 100, 0, 100]
                ax.imshow(heatmap_a, extent=extent, origin='lower', cmap=cmap_red,
                         alpha=0.95, interpolation='bilinear', aspect='auto', vmin=0, vmax=2)
            
            # Create heatmap for Team B (Dark Blue)
            if len(team_b_positions) > 0:
                x_b = np.array([p['x'] for p in team_b_positions])
                y_b = np.array([p['y'] for p in team_b_positions])
                heatmap_b, _, _ = np.histogram2d(x_b, y_b, bins=bins, range=[[0, 100], [0, 100]])
                heatmap_b = gaussian_filter(heatmap_b, sigma=sigma).T
                
                # Don't normalize - keep raw intensity for darker colors
                # Just scale to reasonable range
                if heatmap_b.max() > 0:
                    heatmap_b = heatmap_b / heatmap_b.max() * 2  # Boost intensity
                
                # Overlay Team B heatmap (Dark Blue) with higher opacity
                ax.imshow(heatmap_b, extent=extent, origin='lower', cmap=cmap_blue,
                         alpha=0.95, interpolation='bilinear', aspect='auto', vmin=0, vmax=2)
            
            # Add legend for both teams with darker colors
            from matplotlib.patches import Patch
            legend_elements = [
                Patch(facecolor='#cc0000', alpha=0.9, label=f'Team A ({len(team_a_positions)} pos)'),
                Patch(facecolor='#0000cc', alpha=0.9, label=f'Team B ({len(team_b_positions)} pos)')
            ]
            ax.legend(handles=legend_elements, loc='upper right', fontsize=10, 
                     framealpha=0.9, edgecolor='white')
        else:
            # Single team heatmap
            from matplotlib.colors import LinearSegmentedColormap
            
            # Create custom dark colormap based on team
            if team_filter == 'A':
                colors = ['#ffffff', '#ff6666', '#ff0000', '#cc0000', '#990000', '#660000']
            else:
                colors = ['#ffffff', '#6666ff', '#0000ff', '#0000cc', '#000099', '#000066']
            
            cmap_custom = LinearSegmentedColormap.from_list('dark_team', colors, N=100)
            
            x_coords = np.array([p['x'] for p in positions])
            y_coords = np.array([p['y'] for p in positions])
            
            # Create 2D histogram (density map)
            bins = 50
            heatmap, xedges, yedges = np.histogram2d(x_coords, y_coords, bins=bins,
                                                      range=[[0, 100], [0, 100]])
            
            # Apply Gaussian smoothing
            heatmap = gaussian_filter(heatmap, sigma=sigma)
            
            # Transpose for correct orientation
            heatmap = heatmap.T
            
            # Overlay heatmap
            extent = [0, 100, 0, 100]
            
            im = ax.imshow(heatmap, extent=extent, origin='lower', cmap=cmap_custom,
                           alpha=0.85, interpolation='bilinear', aspect='auto', vmin=0)
            
            # Add colorbar
            cbar = plt.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
            cbar.set_label('Activity Density', rotation=270, labelpad=20, fontsize=12)
    
    # Add title
    team_text = f"Team {team_filter}" if team_filter else "Both Teams"
    plot_type = "Player Positions" if scatter else "Player Heatmap"
    plt.title(f'{plot_type} - {team_text}\n({len(positions)} positions)',
              fontsize=16, fontweight='bold', pad=20)
    
    # Save figure
    plt.tight_layout()
    plt.savefig(output_file, dpi=150, bbox_inches='tight', facecolor='white')
    print(f"Heatmap saved to: {output_file}")
    
    plt.close()


def main():
    parser = argparse.ArgumentParser(description='Generate player heatmap from position data')
    parser.add_argument('--positions', required=True, help='Path to positions JSON file')
    parser.add_argument('--output', required=True, help='Path to output PNG file')
    parser.add_argument('--team', choices=['A', 'B'], help='Filter by team (A or B)')
    parser.add_argument('--sigma', type=float, default=3.0, help='Gaussian smoothing factor (default: 3.0)')
    parser.add_argument('--scatter', action='store_true', help='Generate scatter plot instead of heatmap')
    
    args = parser.parse_args()
    
    # Validate input file
    positions_file = Path(args.positions)
    if not positions_file.exists():
        print(f"ERROR: Positions file not found: {positions_file}", file=sys.stderr)
        sys.exit(1)
    
    # Generate heatmap
    try:
        generate_heatmap(
            positions_file=positions_file,
            output_file=args.output,
            team_filter=args.team,
            sigma=args.sigma,
            scatter=args.scatter
        )
    except Exception as e:
        print(f"ERROR: {str(e)}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
</file>

<file path="python/kaggle_notebook.py">
# ==========================================
# KAGGLE NOTEBOOK SCRIPT
# Copy and paste this entire script into a code cell in a Kaggle Notebook.
# ==========================================

# 1. Setup Environment
import os
import subprocess
import sys
import time

def run_command(command):
    print(f"Running: {command}")
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    if process.returncode != 0:
        print(f"Error: {stderr.decode()}")
        raise Exception(f"Command failed: {command}")
    print(stdout.decode())

print("üöÄ Setting up Soccer Analysis Environment...")

# 2. Clone Repository (or download code)
# NOTE: In a real scenario, you might want to clone your specific repo.
# For now, we assume the user might upload the 'python' folder as a dataset or we clone the main repo.
# Replace this URL with your actual repo if needed, or upload the code manually.
# 2. Find and Setup Code
print("üîç Searching for code...")

def setup_workspace():
    # Case 1: Zip file exists in input (User uploaded zip as dataset)
    for root, dirs, files in os.walk("/kaggle/input"):
        for file in files:
            if file.endswith(".zip") and "python" in file:
                zip_path = os.path.join(root, file)
                print(f"Found zip: {zip_path}")
                run_command(f"cp '{zip_path}' .")
                run_command(f"unzip -o '{file}'")
                return True

    # Case 2: Files are already unzipped in input (Kaggle auto-unzipped)
    for root, dirs, files in os.walk("/kaggle/input"):
        if "requirements.txt" in files:
            print(f"Found source code in: {root}")
            # Copy everything to working directory
            if "python" in root:
                # If we found .../python/requirements.txt, copy the parent folder content
                src = os.path.dirname(root)
                run_command(f"cp -r '{src}/.' .")
            else:
                # If we found .../requirements.txt (root), copy that folder
                run_command(f"cp -r '{root}/.' .")
            return True
            
    return False

if not setup_workspace():
    print("‚ö†Ô∏è Could not automatically find code. Checking current directory...")

# 3. Install System Dependencies
print("Installing system dependencies...")
run_command("apt-get update && apt-get install -y libgl1 libglib2.0-0")

# 4. Install Python Dependencies
print("Installing Python libraries...")
if os.path.exists("python"):
    os.chdir("python")
elif os.path.exists("requirements.txt"):
    pass # Already in the right folder
else:
    print("‚ùå Error: Could not find 'python' folder or 'requirements.txt'")
    print("Current directory content:", os.listdir("."))
    raise Exception("Setup failed: Code not found")

run_command("pip install 'numpy<2.0.0' -r requirements.txt")
run_command("pip install pyngrok nest_asyncio")

# 5. Setup Ngrok
from pyngrok import ngrok
import nest_asyncio

# Get Ngrok Token from user
print("\n" + "="*50)
print("NGROK SETUP")
print("1. Go to https://dashboard.ngrok.com/get-started/your-authtoken")
print("2. Copy your Authtoken")
print("="*50 + "\n")

# You can hardcode your token here if you want, or paste it when running
NGROK_TOKEN = input("Enter your Ngrok Authtoken: ")
ngrok.set_auth_token(NGROK_TOKEN)

# 6. Start Server
print("\nüöÄ Starting Server...")

# Apply nest_asyncio to allow nested event loops (needed for uvicorn in notebook)
nest_asyncio.apply()

# Start ngrok tunnel
public_url = ngrok.connect(8000).public_url
print("\n" + "="*50)
print(f"‚úÖ PUBLIC URL: {public_url}")
print("Copy this URL into your Video Player 'Remote Server URL' settings.")
print("="*50 + "\n")

# Run Uvicorn
import uvicorn
from api import app

# Run the server
uvicorn.run(app, host="0.0.0.0", port=8000)
</file>

<file path="python/keypoint_detection/__init__.py">
from .homography import HomographyTransformer
from .keypoint_constants import KEYPOINT_NAMES
</file>

<file path="python/keypoint_detection/homography.py">
import sys
from pathlib import Path
import numpy as np

# Adjust project path to allow imports from keypoint_detection
PROJECT_DIR = Path(__file__).resolve().parent.parent
if str(PROJECT_DIR) not in sys.path:
    sys.path.append(str(PROJECT_DIR))

try:
    import supervision as sv
    from sports.common.view import ViewTransformer
    from sports.annotators.soccer import draw_pitch
    from sports.configs.soccer import SoccerPitchConfiguration
except ImportError:
    # Fallback or dummy classes if libraries are not installed
    # Note: These are necessary to prevent the script from crashing during import
    # but the functionality will require these libraries to be installed eventually.
    class ViewTransformer:
        def __init__(self, source, target): pass
        def transform_points(self, points): return points
    class SoccerPitchConfiguration:
        def __init__(self): self.vertices = [[0,0]] * 32

from keypoint_detection.keypoint_constants import KEYPOINT_NAMES


class HomographyTransformer:
    """
    Class for handling homography transformations between frame and pitch coordinates.
    """
    
    def __init__(self, confidence_threshold=0.5):
        """
        Initialize the transformer.
        
        Args:
            confidence_threshold: Minimum confidence to consider a keypoint valid
        """
        self.confidence_threshold = confidence_threshold
        try:
            self.CONFIG = SoccerPitchConfiguration()
        except:
            self.CONFIG = type('obj', (object,), {'vertices': [[0,0]]*32})()
            
        self.all_pitch_points = self._get_all_pitch_points()
        self.our_to_sports_mapping = self._get_keypoint_mapping()
    
    def _get_all_pitch_points(self):
        """Get all pitch reference points including extra points."""
        try:
            all_pitch_points = np.array(self.CONFIG.vertices)
            extra_pitch_points = np.array([
                [2932, 3500],  # Left Semicircle rightmost point
                [6000, 3500],  # Center Point
                [9069, 3500],  # Right semicircle rightmost point
            ])
            return np.concatenate((all_pitch_points, extra_pitch_points))
        except:
            return np.zeros((35, 2))
    
    def _get_keypoint_mapping(self):
        """Get mapping from our 29 keypoints to sports library's points."""
        return np.array([
            0,   # 0: sideline_top_left -> corner
            1,   # 1: big_rect_left_top_pt1 -> left penalty  
            9,   # 2: big_rect_left_top_pt2 -> left goal
            4,   # 3: big_rect_left_bottom_pt1 -> left goal
            12,  # 4: big_rect_left_bottom_pt2 -> left penalty
            2,   # 5: small_rect_left_top_pt1 -> left goal
            6,   # 6: small_rect_left_top_pt2 -> left goal
            3,   # 7: small_rect_left_bottom_pt1 -> left goal  
            7,   # 8: small_rect_left_bottom_pt2 -> left goal
            5,   # 9: sideline_bottom_left -> corner
            32,  # 10: left_semicircle_right -> penalty arc
            13,  # 11: center_line_top -> center
            16,  # 12: center_line_bottom -> center
            14,  # 13: center_circle_top -> center circle
            15,  # 14: center_circle_bottom -> center circle
            33,  # 15: field_center -> center circle
            24,  # 16: sideline_top_right -> corner
            25,  # 17: big_rect_right_top_pt1 -> right penalty
            17,  # 18: big_rect_right_top_pt2 -> right penalty
            28,  # 19: big_rect_right_bottom_pt1 -> right penalty
            20,  # 20: big_rect_right_bottom_pt2 -> right penalty
            26,  # 21: small_rect_right_top_pt1 -> right goal
            22,  # 22: small_rect_right_top_pt2 -> right goal
            27,  # 23: small_rect_right_bottom_pt1 -> right goal
            23,  # 24: small_rect_right_bottom_pt2 -> right goal
            29,  # 25: sideline_bottom_right -> corner
            34,  # 26: right_semicircle_left -> penalty arc
            30,  # 27: center_circle_left -> center_circle_left
            31,  # 28: center_circle_right -> center_circle_right
        ])
    
    def _filter_keypoints(self, detected_keypoints):
        """
        Filter keypoints based on confidence threshold.
        
        Args:
            detected_keypoints: Array of shape (1, 29, 3) with [x, y, confidence]
            
        Returns:
            Tuple of (frame_reference_points, pitch_reference_points, filter_mask)
        """
        if detected_keypoints.shape[0] == 0:
            return None, None, None
        
        keypoints = detected_keypoints[0]  # Take first detection
        
        # Create confidence filter
        filter_mask = keypoints[:, 2] > self.confidence_threshold
        
        if np.sum(filter_mask) < 4:
            print(f"Insufficient valid keypoints: {np.sum(filter_mask)} < 4")
            return None, None, None
        
        # Apply filter to get frame reference points
        frame_reference_points = keypoints[filter_mask, :2]  # Only x, y coordinates
        
        # Apply the same filter to get corresponding pitch points
        pitch_indices = self.our_to_sports_mapping[filter_mask]
        pitch_reference_points = self.all_pitch_points[pitch_indices]
        
        return frame_reference_points, pitch_reference_points, filter_mask
    
    def _create_view_transformer(self, source_points, target_points):
        """
        Create ViewTransformer from source to target points.
        
        Args:
            source_points: Source coordinate points
            target_points: Target coordinate points
            
        Returns:
            ViewTransformer object or None if creation fails
        """
        try:
            view_transformer = ViewTransformer(
                source=source_points,
                target=target_points
            )
            return view_transformer
        except ValueError as e:
            print(f"Error creating ViewTransformer: {e}")
            return None

    def transform_to_frame_keypoints(self, detected_keypoints):
        """
        Transform pitch keypoints to frame coordinates (for visualization).
        
        Args:
            detected_keypoints: Array of shape (1, 29, 3) with [x, y, confidence]
            
        Returns:
            Tuple of (transformed_points, view_transformer) or (None, None)
        """
        frame_ref_points, pitch_ref_points, filter_mask = self._filter_keypoints(detected_keypoints)
        
        if frame_ref_points is None:
            return None, None
        
        # Create ViewTransformer (source=pitch, target=frame)
        view_transformer = self._create_view_transformer(pitch_ref_points, frame_ref_points)
        
        if view_transformer is None:
            return None, None
        
        # Transform all pitch points to frame coordinates
        transformed_points = view_transformer.transform_points(points=self.all_pitch_points.copy())
        transformed_points = np.concatenate((transformed_points, np.ones((len(transformed_points), 1), dtype=np.float32)), axis=1)
        transformed_points = np.expand_dims(transformed_points, axis=0)
        
        return transformed_points, view_transformer
    
    def transform_to_pitch_keypoints(self, detected_keypoints):
        """
        Create ViewTransformer to transform frame coordinates to pitch coordinates.
        
        Args:
            detected_keypoints: Array of shape (1, 29, 3) with [x, y, confidence]
            
        Returns:
            ViewTransformer object or None if insufficient points
        """
        frame_ref_points, pitch_ref_points, filter_mask = self._filter_keypoints(detected_keypoints)
        
        if frame_ref_points is None:
            return None
        
        # Create ViewTransformer (source=frame, target=pitch)
        view_transformer = self._create_view_transformer(frame_ref_points, pitch_ref_points)
        
        return view_transformer
    
    def transform_points_to_pitch(self, points, view_transformer):
        """
        Transform points from frame coordinates to pitch coordinates.
        
        Args:
            points: Array of points in frame coordinates (N, 2)
            view_transformer: ViewTransformer object from transform_to_pitch_keypoints
            
        Returns:
            Transformed points in pitch coordinates or None if transformer is invalid
        """
        if view_transformer is None:
            return None
        
        try:
            transformed_points = view_transformer.transform_points(points=points)
            return transformed_points
        except Exception as e:
            print(f"Error transforming points: {e}")
            return None
</file>

<file path="python/keypoint_detection/keypoint_constants.py">
KEYPOINT_NAMES = [
    "sideline_top_left",
    "big_rect_left_top_pt1",
    "big_rect_left_top_pt2",
    "big_rect_left_bottom_pt1",
    "big_rect_left_bottom_pt2",
    "small_rect_left_top_pt1",
    "small_rect_left_top_pt2",
    "small_rect_left_bottom_pt1",
    "small_rect_left_bottom_pt2",
    "sideline_bottom_left",
    "left_semicircle_right",
    "center_line_top",
    "center_line_bottom",
    "center_circle_top",
    "center_circle_bottom",
    "field_center",
    "sideline_top_right",
    "big_rect_right_top_pt1",
    "big_rect_right_top_pt2",
    "big_rect_right_bottom_pt1",
    "big_rect_right_bottom_pt2",
    "small_rect_right_top_pt1",
    "small_rect_right_top_pt2",
    "small_rect_right_bottom_pt1",
    "small_rect_right_bottom_pt2",
    "sideline_bottom_right",
    "right_semicircle_left",
    "center_circle_left",
    "center_circle_right"
]
</file>

<file path="python/main.py">
from utils import read_video, save_video
from trackers import Tracker
import cv2
import numpy as np
from team_assigner import TeamAssigner
from player_ball_assigner import PlayerBallAssigner
from camera_movement_estimator import CameraMovementEstimator
from view_transformer import ViewTransformer
from speed_and_distance_estimator import SpeedAndDistance_Estimator


def main():
    # Read Video
    video_frames = read_video('input_videos/08fd33_4.mp4')

    # Initialize Tracker
    tracker = Tracker('models/best.pt')

    tracks = tracker.get_object_tracks(video_frames,
                                       read_from_stub=True,
                                       stub_path='stubs/track_stubs.pkl')
    # Get object positions 
    tracker.add_position_to_tracks(tracks)

    # camera movement estimator
    camera_movement_estimator = CameraMovementEstimator(video_frames[0])
    camera_movement_per_frame = camera_movement_estimator.get_camera_movement(video_frames,
                                                                                read_from_stub=True,
                                                                                stub_path='stubs/camera_movement_stub.pkl')
    camera_movement_estimator.add_adjust_positions_to_tracks(tracks,camera_movement_per_frame)


    # View Trasnformer
    view_transformer = ViewTransformer()
    view_transformer.add_transformed_position_to_tracks(tracks)

    # Interpolate Ball Positions
    tracks["ball"] = tracker.interpolate_ball_positions(tracks["ball"])

    # Speed and distance estimator
    speed_and_distance_estimator = SpeedAndDistance_Estimator()
    speed_and_distance_estimator.add_speed_and_distance_to_tracks(tracks)

    # Assign Player Teams
    team_assigner = TeamAssigner()
    team_assigner.assign_team_color(video_frames[0], 
                                    tracks['players'][0])
    
    for frame_num, player_track in enumerate(tracks['players']):
        for player_id, track in player_track.items():
            team = team_assigner.get_player_team(video_frames[frame_num],   
                                                 track['bbox'],
                                                 player_id)
            tracks['players'][frame_num][player_id]['team'] = team 
            tracks['players'][frame_num][player_id]['team_color'] = team_assigner.team_colors[team]

    
    # Assign Ball Aquisition
    player_assigner =PlayerBallAssigner()
    team_ball_control= []
    for frame_num, player_track in enumerate(tracks['players']):
        ball_bbox = tracks['ball'][frame_num][1]['bbox']
        assigned_player = player_assigner.assign_ball_to_player(player_track, ball_bbox)

        if assigned_player != -1:
            tracks['players'][frame_num][assigned_player]['has_ball'] = True
            team_ball_control.append(tracks['players'][frame_num][assigned_player]['team'])
        else:
            team_ball_control.append(team_ball_control[-1])
    team_ball_control= np.array(team_ball_control)


    # Draw output 
    ## Draw object Tracks
    output_video_frames = tracker.draw_annotations(video_frames, tracks,team_ball_control)

    ## Draw Camera movement
    output_video_frames = camera_movement_estimator.draw_camera_movement(output_video_frames,camera_movement_per_frame)

    ## Draw Speed and Distance
    speed_and_distance_estimator.draw_speed_and_distance(output_video_frames,tracks)

    # Save video
    save_video(output_video_frames, 'output_videos/output_video.avi')

if __name__ == '__main__':
    main()
</file>

<file path="python/migrate_db.py">
import sqlite3
import os
import logging

logging.basicConfig(level=logging.INFO)

DB_PATH = os.path.join(os.path.dirname(__file__), 'tactabot.db')

def migrate_database():
    """Add new fields and tables for majority vote, reputation, badges, and streak systems"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    try:
        # Add new columns to users table
        logging.info("Adding new columns to users table...")
        c.execute("ALTER TABLE users ADD COLUMN reputation INTEGER DEFAULT 100")
        c.execute("ALTER TABLE users ADD COLUMN accuracy REAL DEFAULT 0.0")
        c.execute("ALTER TABLE users ADD COLUMN last_tag_date DATE")
        c.execute("ALTER TABLE users ADD COLUMN streak_days INTEGER DEFAULT 0")
        c.execute("ALTER TABLE users ADD COLUMN tags_today INTEGER DEFAULT 0")
        
        # Create badges table
        logging.info("Creating badges table...")
        c.execute('''CREATE TABLE IF NOT EXISTS badges (
            badge_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            badge_type TEXT,
            awarded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        )''')
        
        # Create clip_assignments table
        logging.info("Creating clip_assignments table...")
        c.execute('''CREATE TABLE IF NOT EXISTS clip_assignments (
            assignment_id INTEGER PRIMARY KEY AUTOINCREMENT,
            clip_id INTEGER,
            user_id INTEGER,
            assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            completed BOOLEAN DEFAULT 0,
            FOREIGN KEY(clip_id) REFERENCES clips(clip_id),
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        )''')
        
        # Add new columns to clips table
        logging.info("Adding new columns to clips table...")
        c.execute("ALTER TABLE clips ADD COLUMN required_tags INTEGER DEFAULT 5")
        c.execute("ALTER TABLE clips ADD COLUMN consensus_event TEXT")
        c.execute("ALTER TABLE clips ADD COLUMN consensus_count INTEGER DEFAULT 0")
        c.execute("ALTER TABLE clips ADD COLUMN status TEXT DEFAULT 'pending'")
        
        conn.commit()
        logging.info("‚úÖ Migration completed successfully!")
        
    except sqlite3.OperationalError as e:
        if "duplicate column name" in str(e).lower():
            logging.info("‚ö†Ô∏è Columns already exist, skipping...")
        else:
            logging.error(f"‚ùå Migration error: {e}")
            raise
    finally:
        conn.close()

if __name__ == '__main__':
    migrate_database()
</file>

<file path="python/migrate_filename.py">
import sqlite3
import os

DB_PATH = os.path.join(os.path.dirname(__file__), 'tactabot.db')

conn = sqlite3.connect(DB_PATH)
c = conn.cursor()

try:
    # Add filename column
    c.execute("ALTER TABLE clips ADD COLUMN filename TEXT")
    print("‚úÖ Added 'filename' column")
except sqlite3.OperationalError as e:
    if "duplicate column" in str(e).lower():
        print("‚ö†Ô∏è Column 'filename' already exists")
    else:
        raise

# Migrate existing video_path to filename (extract basename)
try:
    c.execute("SELECT clip_id, video_path FROM clips WHERE video_path IS NOT NULL AND filename IS NULL")
    rows = c.fetchall()
    
    for clip_id, video_path in rows:
        filename = os.path.basename(video_path)
        c.execute("UPDATE clips SET filename = ? WHERE clip_id = ?", (filename, clip_id))
    
    print(f"‚úÖ Migrated {len(rows)} clips from video_path to filename")
except Exception as e:
    print(f"‚ö†Ô∏è Migration error: {e}")

conn.commit()
conn.close()
print("‚úÖ Migration complete!")
</file>

<file path="python/migrate_pretag.py">
import sqlite3
import os

DB_PATH = 'python/tactabot.db'

def migrate():
    if not os.path.exists(DB_PATH):
        print(f"Database {DB_PATH} not found.")
        return

    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    try:
        c.execute("ALTER TABLE clips ADD COLUMN pre_tag TEXT")
        conn.commit()
        print("Successfully added pre_tag column to clips table.")
    except sqlite3.OperationalError as e:
        if "duplicate column name" in str(e).lower():
            print("Column pre_tag already exists.")
        else:
            print(f"Error: {e}")
    finally:
        conn.close()

if __name__ == "__main__":
    migrate()
</file>

<file path="python/migrate_qc.py">
import sqlite3
import os
import logging

logging.basicConfig(level=logging.INFO)

DB_PATH = os.path.join(os.path.dirname(__file__), 'tactabot.db')

def migrate_database_qc():
    """Add new fields for Full QC System"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    try:
        logging.info("Starting QC System Migration...")

        # 1. Users Table Updates
        logging.info("Updating users table...")
        try:
            c.execute("ALTER TABLE users ADD COLUMN trust_score REAL DEFAULT 50.0")
        except sqlite3.OperationalError: pass
        
        try:
            c.execute("ALTER TABLE users ADD COLUMN noise_score REAL DEFAULT 0.0")
        except sqlite3.OperationalError: pass
        
        try:
            c.execute("ALTER TABLE users ADD COLUMN is_elite BOOLEAN DEFAULT 0")
        except sqlite3.OperationalError: pass

        # 2. Clips Table Updates
        logging.info("Updating clips table...")
        try:
            c.execute("ALTER TABLE clips ADD COLUMN qc_stage TEXT DEFAULT 'crowd_voting'")
        except sqlite3.OperationalError: pass
        
        try:
            c.execute("ALTER TABLE clips ADD COLUMN quality_tag TEXT")
        except sqlite3.OperationalError: pass
        
        try:
            c.execute("ALTER TABLE clips ADD COLUMN final_event_type TEXT")
        except sqlite3.OperationalError: pass

        # 3. Tags Table Updates
        logging.info("Updating tags table...")
        try:
            c.execute("ALTER TABLE tags ADD COLUMN vote_weight REAL DEFAULT 1.0")
        except sqlite3.OperationalError: pass

        conn.commit()
        logging.info("‚úÖ QC System Migration completed successfully!")
        
    except Exception as e:
        logging.error(f"‚ùå Migration error: {e}")
        raise
    finally:
        conn.close()

if __name__ == '__main__':
    migrate_database_qc()
</file>

<file path="python/pipelines.py">
import cv2
import numpy as np
import torch
from ultralytics import YOLO
import supervision as sv
from soccer_analysis_processor import SoccerMatchAnalyzer, AnalysisConfig
from keypoint_detection.homography import HomographyTransformer

class TacticalPipeline:
    def __init__(self, keypoint_model_path, detection_model_path):
        self.keypoint_model_path = keypoint_model_path
        self.detection_model_path = detection_model_path
        self.analyzer = SoccerMatchAnalyzer(AnalysisConfig())
        self.transformer = HomographyTransformer()
        
    def initialize_models(self):
        self.analyzer.load_model()
        self.analyzer.load_roboflow_model()
        
    def detect_frame_objects(self, frame):
        # detection_model_path is likely yolov8m.pt
        results = self.analyzer.model.predict(frame, conf=0.3, verbose=False)[0]
        
        # Filter players (0) and ball (32)
        # Referees are also class 0 in many datasets, or 32 is ball
        # In this project, 0=person, 32=ball
        
        detections = sv.Detections.from_ultralytics(results)
        player_mask = detections.class_id == 0
        ball_mask = detections.class_id == 32
        
        # We don't have a separate referee class, so we might treat some persons as referees
        # For now, let's just return players and ball
        player_dets = detections[player_mask]
        ball_dets = detections[ball_mask]
        ref_dets = sv.Detections.empty() # Placeholder
        
        return player_dets, ball_dets, ref_dets

    def detect_frame_keypoints(self, frame):
        if self.analyzer.roboflow_model:
            _, keypoints = self.analyzer.roboflow_model.get_keypoints_detections(frame)
            return keypoints
        return None

    def process_detections_for_tactical_analysis(self, player_dets, ball_dets, ref_dets, keypoints, **kwargs):
        # Create a blank tactical pitch
        pitch_w, pitch_h = 1050, 680
        tactical_frame = np.zeros((pitch_h, pitch_w, 3), dtype=np.uint8)
        tactical_frame[:, :, 1] = 150 # Green
        
        # Draw pitch lines if we have keypoints/homography
        if keypoints is not None:
             vt = self.transformer.transform_to_pitch_keypoints(keypoints)
             # Draw players on tactical frame
             if vt and hasattr(vt, 'transform'):
                 def transform_point(p):
                     # vt.transform expects (x, y)
                     # Returns (xm, ym) in meters
                     return vt.transform(p)
                 
                 for i, bbox in enumerate(player_dets.xyxy):
                     # Use bottom center
                     x, y = (bbox[0] + bbox[2]) / 2, bbox[3]
                     xm, ym = transform_point((x, y))
                     # Map to tactical pixels (10px per meter)
                     px, py = int(xm * 10), int(ym * 10)
                     if 0 <= px < pitch_w and 0 <= py < pitch_h:
                         color = kwargs.get('team1_color') if player_dets.class_id[i] == 0 else kwargs.get('team2_color')
                         cv2.circle(tactical_frame, (px, py), 8, color, -1)
        
        return tactical_frame, {"success": True}

    def create_side_by_side_frame(self, annotated_frame, tactical_frame, metadata, frame_height=480):
        # Resize both to same height
        h1, w1 = annotated_frame.shape[:2]
        h2, w2 = tactical_frame.shape[:2]
        
        annotated_small = cv2.resize(annotated_frame, (int(w1 * (frame_height / h1)), frame_height))
        tactical_small = cv2.resize(tactical_frame, (int(w2 * (frame_height / h2)), frame_height))
        
        combined = np.hstack((annotated_small, tactical_small))
        return combined

class DepthPipeline:
    def initialize_model(self):
        pass
    def estimate_depth(self, frame):
        return np.zeros(frame.shape[:2], dtype=np.float32)
    def visualize_depth(self, depth_map):
        return np.zeros((depth_map.shape[0], depth_map.shape[1], 3), dtype=np.uint8)
</file>

<file path="python/player_ball_assigner/__init__.py">
from .player_ball_assigner import PlayerBallAssigner
</file>

<file path="python/player_ball_assigner/player_ball_assigner.py">
import sys 
sys.path.append('../')
from utils import get_center_of_bbox, measure_distance

class PlayerBallAssigner():
    def __init__(self):
        self.max_player_ball_distance = 70
    
    def assign_ball_to_player(self,players,ball_bbox):
        ball_position = get_center_of_bbox(ball_bbox)

        miniumum_distance = 99999
        assigned_player=-1

        for player_id, player in players.items():
            player_bbox = player['bbox']

            distance_left = measure_distance((player_bbox[0],player_bbox[-1]),ball_position)
            distance_right = measure_distance((player_bbox[2],player_bbox[-1]),ball_position)
            distance = min(distance_left,distance_right)

            if distance < self.max_player_ball_distance:
                if distance < miniumum_distance:
                    miniumum_distance = distance
                    assigned_player = player_id

        return assigned_player
</file>

<file path="python/player_clustering.py">
import numpy as np
from sklearn.cluster import KMeans
from models.reid_model import ReIDModel

class EmbeddingExtractor:
    def __init__(self):
        self.model = ReIDModel()
        
    def get_player_crops(self, frame, detections):
        crops = []
        h, w = frame.shape[:2]
        for box in detections.xyxy:
            x1, y1, x2, y2 = map(int, box)
            x1, y1 = max(0, x1), max(0, y1)
            x2, y2 = min(w, x2), min(h, y2)
            if x2 > x1 and y2 > y1:
                crops.append(frame[y1:y2, x1:x2])
            else:
                crops.append(np.zeros((10, 10, 3), dtype=np.uint8))
        return crops

    def extract(self, crops):
        # ReIDModel works on boxes. We can mock a list of boxes for the crops
        # Or just use the model directly on crops.
        # But ReIDModel.extract_features takes boxes and the WHOLE frame.
        # Let's simplify and just use color histogram if we don't want to overcomplicate.
        # Actually, let's use the ReIDModel logic.
        features = []
        for crop in crops:
            if crop.size == 0:
                features.append(np.zeros(2048))
                continue
            # Use ReIDModel transformations
            t_crop = self.model.transforms(crop).unsqueeze(0).to(self.model.device)
            import torch
            with torch.no_grad():
                f = self.model.model(t_crop).view(-1).cpu().numpy()
                # Normalize
                f = f / (np.linalg.norm(f) + 1e-6)
                features.append(f)
        return np.array(features)

class ClusteringManager:
    def __init__(self, n_clusters=2):
        self.n_clusters = n_clusters
        self.embedding_extractor = EmbeddingExtractor()
        self.kmeans = KMeans(n_clusters=n_clusters, n_init=10)
        
    def train_clustering_models(self, crops):
        features = self.embedding_extractor.extract(crops)
        labels = self.kmeans.fit_predict(features)
        return labels, None, None
</file>

<file path="python/README (2).md">
# Football Analysis Project

## Introduction
The goal of this project is to detect and track players, referees, and footballs in a video using YOLO, one of the best AI object detection models available. We will also train the model to improve its performance. Additionally, we will assign players to teams based on the colors of their t-shirts using Kmeans for pixel segmentation and clustering. With this information, we can measure a team's ball acquisition percentage in a match. We will also use optical flow to measure camera movement between frames, enabling us to accurately measure a player's movement. Furthermore, we will implement perspective transformation to represent the scene's depth and perspective, allowing us to measure a player's movement in meters rather than pixels. Finally, we will calculate a player's speed and the distance covered. This project covers various concepts and addresses real-world problems, making it suitable for both beginners and experienced machine learning engineers.

![Screenshot](output_videos/screenshot.png)

## Modules Used
The following modules are used in this project:
- YOLO: AI object detection model
- Kmeans: Pixel segmentation and clustering to detect t-shirt color
- Optical Flow: Measure camera movement
- Perspective Transformation: Represent scene depth and perspective
- Speed and distance calculation per player

## Trained Models
- [Trained Yolo v5](https://drive.google.com/file/d/1DC2kCygbBWUKheQ_9cFziCsYVSRw6axK/view?usp=sharing)

## Sample video
-  [Sample input video](https://drive.google.com/file/d/1t6agoqggZKx6thamUuPAIdN_1zR9v9S_/view?usp=sharing)

## Requirements
To run this project, you need to have the following requirements installed:
- Python 3.x
- ultralytics
- supervision
- OpenCV
- NumPy
- Matplotlib
- Pandas
</file>

<file path="python/README.md">
# Soccer Player Heatmap Generator

Python scripts for extracting player positions from match videos and generating heatmaps.

## Installation

Install required Python packages:

```bash
pip install -r requirements.txt
```

This will install:
- `opencv-python` - Video processing
- `ultralytics` - YOLO v8 for player detection
- `numpy` - Numerical operations
- `matplotlib` - Heatmap visualization
- `scipy` - Gaussian smoothing
- `Pillow` - Image processing

## Usage

### 1. Extract Player Positions from Video

```bash
python extract_positions.py --video path/to/match.mp4 --output positions.json
```

Options:
- `--video`: Path to input video file (required)
- `--output`: Path to output JSON file (required)
- `--frame-skip`: Process every Nth frame (default: 5, higher = faster but less accurate)
- `--confidence`: Minimum detection confidence 0-1 (default: 0.5)

Example:
```bash
python extract_positions.py --video ../match.mp4 --output positions.json --frame-skip 10
```

### 2. Generate Heatmap

```bash
python generate_heatmap.py --positions positions.json --output heatmap.png --team A
```

Options:
- `--positions`: Path to positions JSON file (required)
- `--output`: Path to output PNG file (required)
- `--team`: Filter by team - 'A' or 'B' (optional, omit for both teams)
- `--sigma`: Gaussian smoothing factor (default: 3.0, higher = smoother)

Examples:
```bash
# Team A heatmap
python generate_heatmap.py --positions positions.json --output team_a.png --team A

# Team B heatmap
python generate_heatmap.py --positions positions.json --output team_b.png --team B

# Both teams
python generate_heatmap.py --positions positions.json --output both_teams.png
```

## How It Works

### Position Extraction

1. Loads video using OpenCV
2. Uses YOLO v8 to detect people in each frame
3. Estimates team based on field position (left half = Team A, right half = Team B)
4. Outputs normalized coordinates (0-100 scale) with timestamps

### Heatmap Generation

1. Loads position data from JSON
2. Creates 2D density map using histogram
3. Applies Gaussian smoothing for visual appeal
4. Overlays on professional soccer field visualization
5. Uses color gradient (yellow ‚Üí orange ‚Üí red) to show activity intensity

## Output Format

### positions.json
```json
{
  "video_info": {
    "total_frames": 3000,
    "fps": 30.0,
    "width": 1920,
    "height": 1080,
    "duration": 100.0
  },
  "positions": [
    {
      "frame": 0,
      "timestamp": 0.0,
      "x": 45.5,
      "y": 52.3,
      "team": "A",
      "confidence": 0.85
    }
  ]
}
```

## Performance

- Processing speed depends on video length and hardware
- Frame skipping significantly improves speed (10x faster with `--frame-skip 10`)
- GPU acceleration automatic if CUDA available
- Typical processing time: ~1-2 minutes per minute of video (with frame-skip 5)

## Troubleshooting

**"ultralytics not installed"**
- Run: `pip install ultralytics`

**"Could not open video file"**
- Check video path is correct
- Ensure video codec is supported by OpenCV

**"No positions found"**
- Try lowering `--confidence` threshold
- Check if video actually contains people
- Verify video is not corrupted

**Slow processing**
- Increase `--frame-skip` value
- Use smaller video resolution
- Ensure GPU drivers are installed for CUDA acceleration
</file>

<file path="python/remote_server.py">
import uvicorn
from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import shutil
import os
import json
import subprocess
from pathlib import Path
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

UPLOAD_DIR = Path("uploads")
UPLOAD_DIR.mkdir(exist_ok=True)

@app.get("/")
def health_check():
    return {"status": "online", "provider": "Vast.ai"}

@app.post("/analyze")
async def analyze_match(
    video: UploadFile = File(...),
    clips: str = Form(None)
):
    try:
        # Save uploaded video
        video_path = UPLOAD_DIR / f"video_{video.filename}"
        with open(video_path, "wb") as buffer:
            shutil.copyfileobj(video.file, buffer)
        
        logger.info(f"Video received: {video_path}")

        # Save clips config if provided
        clips_path = None
        if clips:
            clips_path = UPLOAD_DIR / f"clips_{video.filename}.json"
            with open(clips_path, "w") as f:
                f.write(clips)
            logger.info(f"Clips config received: {clips_path}")

        # Output path
        output_path = UPLOAD_DIR / f"results_{video.filename}.json"

        # Construct command
        cmd = [
            "python", "analyze_match.py",
            "--video", str(video_path),
            "--output", str(output_path)
        ]
        
        if clips_path:
            cmd.extend(["--clips", str(clips_path)])

        # Run analysis
        logger.info(f"Running analysis: {' '.join(cmd)}")
        process = subprocess.run(
            cmd,
            capture_output=True,
            text=True
        )

        # Cleanup input files
        if video_path.exists():
            os.remove(video_path)
        if clips_path and clips_path.exists():
            os.remove(clips_path)

        if process.returncode != 0:
            logger.error(f"Analysis failed: {process.stderr}")
            return HTTPException(status_code=500, detail=f"Analysis failed: {process.stderr}")

        # Read results
        if not output_path.exists():
            return HTTPException(status_code=500, detail="Analysis output file not found")

        with open(output_path, "r") as f:
            results = json.load(f)

        # Cleanup output
        os.remove(output_path)

        return {"success": True, "results": results}

    except Exception as e:
        logger.error(f"Server error: {str(e)}")
        return HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
</file>

<file path="python/soccer_analysis_core.py">
#!/usr/bin/env python3
"""
Production-Grade Soccer Match Analysis System
Core module with proper error handling, logging, and architecture
"""

import os
import cv2
import json
import logging
import numpy as np
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from collections import defaultdict
from enum import Enum
import time

try:
    from ultralytics import YOLO
    from scipy.signal import savgol_filter
    from sklearn.cluster import KMeans
except ImportError as e:
    raise ImportError(f"Missing required dependency: {e}. Install with: pip install ultralytics scipy scikit-learn roboflow supervision")

from utils.roboflow_utils import RoboflowInference


# === Configuration ===
@dataclass
class AnalysisConfig:
    """Configuration for analysis with validation"""
    confidence_threshold: float = 0.3
    min_track_length_seconds: float = 1.0
    max_speed_ms: float = 12.5  # Usain Bolt's top speed
    sprint_threshold_ms: float = 7.0  # 25.2 km/h
    pressing_distance_m: float = 3.5
    pressing_speed_threshold_ms: float = 2.5
    smoothing_window: int = 15
    max_frame_gap_seconds: float = 0.5
    max_distance_jump_m: float = 10.0
    field_length_m: float = 105.0
    field_width_m: float = 68.0
    max_video_size_mb: int = 2000
    frame_skip: int = 1  # Process every Nth frame
    
    # Pass Detection
    enable_pass_detection: bool = True
    pass_proximity_threshold_m: float = 3.0  # Max distance for pass
    pass_min_distance_m: float = 2.0  # Min distance to count as pass
    pass_max_distance_m: float = 40.0  # Max realistic pass distance
    pass_max_duration_s: float = 3.0  # Max time for pass completion
    pass_velocity_threshold_ms: float = 1.5  # Min receiver velocity
    
    # Roboflow Configuration
    roboflow_api_key: Optional[str] = None
    roboflow_workspace: str = "hacenbarb"
    roboflow_project: str = "pitch-keypoints-detection"
    roboflow_version: int = 2
    
    # High Contrast Mode
    use_high_contrast_colors: bool = False
    
    def __post_init__(self):
        """Validate configuration"""
        if not 0 < self.confidence_threshold <= 1:
            raise ValueError("confidence_threshold must be between 0 and 1")
        if self.max_speed_ms <= 0:
            raise ValueError("max_speed_ms must be positive")
        if self.min_track_length_seconds <= 0:
            raise ValueError("min_track_length_seconds must be positive")


class TeamColor(Enum):
    """Team identification"""
    TEAM_A = "A"
    TEAM_B = "B"
    UNKNOWN = "Unknown"


class AnalysisError(Exception):
    """Base exception for analysis errors"""
    pass


class VideoError(AnalysisError):
    """Video-related errors"""
    pass


class ProcessingError(AnalysisError):
    """Processing-related errors"""
    pass


# === Logger Setup ===
def setup_logger(name: str, level: int = logging.INFO) -> logging.Logger:
    """Setup structured logger"""
    logger = logging.getLogger(name)
    logger.setLevel(level)
    
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    
    return logger


logger = setup_logger(__name__)


# === Data Classes ===
@dataclass
class VideoMetadata:
    """Video file metadata"""
    path: str
    width: int
    height: int
    fps: float
    total_frames: int
    duration_seconds: float
    size_mb: float
    
    @classmethod
    def from_video(cls, video_path: Path, cap: cv2.VideoCapture) -> 'VideoMetadata':
        """Extract metadata from video capture"""
        return cls(
            path=str(video_path),
            width=int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)),
            height=int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)),
            fps=cap.get(cv2.CAP_PROP_FPS) or 30.0,
            total_frames=int(cap.get(cv2.CAP_PROP_FRAME_COUNT)),
            duration_seconds=int(cap.get(cv2.CAP_PROP_FRAME_COUNT)) / (cap.get(cv2.CAP_PROP_FPS) or 30.0),
            size_mb=video_path.stat().st_size / (1024 * 1024)
        )


@dataclass
class TrackPoint:
    """Single tracking point"""
    frame: int
    timestamp: float
    x: float  # Pixel coordinates
    y: float
    xm: Optional[float] = None  # Meter coordinates
    ym: Optional[float] = None
    xm_smooth: Optional[float] = None
    ym_smooth: Optional[float] = None
    velocity: float = 0.0
    acceleration: float = 0.0
    is_sprinting: bool = False
    xthreat: float = 0.0
    team: str = TeamColor.UNKNOWN.value
    confidence: float = 0.0
    bbox: Optional[Tuple[float, float, float, float]] = None  # x1, y1, x2, y2
    has_ball: bool = False


@dataclass
class PlayerStats:
    """Aggregated player statistics"""
    player_id: int
    total_distance: float
    max_speed: float
    avg_speed: float
    sprints: int
    team: str
    track_duration: float
    frames_tracked: int


@dataclass
class PressingEvent:
    """Pressing event detection"""
    frame: int
    timestamp: float
    defender_id: int
    attacker_id: int
    distance: float
    defender_speed: float


@dataclass
class PassEvent:
    """Detected pass between players"""
    frame: int
    timestamp: float
    passer_id: int
    receiver_id: int
    team: str
    distance: float  # meters
    duration: float  # seconds
    pass_type: str  # 'short', 'medium', 'long'
    success: bool  # Did receiver control the ball?
    start_position: Tuple[float, float]  # (x, y) in meters
    end_position: Tuple[float, float]
    xthreat_delta: float  # Change in xThreat


@dataclass
class PassingNetworkMetrics:
    """Network analysis metrics for a team"""
    team: str
    total_passes: int
    successful_passes: int
    pass_completion_rate: float
    avg_pass_distance: float
    key_passers: List[Tuple[int, int]]  # [(player_id, pass_count), ...]
    key_receivers: List[Tuple[int, int]]
    passing_triangles: List[Tuple[int, int, int]]  # Groups of 3 players
    network_centrality: Dict[int, float]  # Player centrality scores


# === Homography Transform ===
class HomographyTransform:
    """Handles coordinate transformation from pixels to meters"""
    
    def __init__(self, matrix: Optional[np.ndarray] = None):
        self.matrix = matrix
        self.enabled = matrix is not None
        
        if self.enabled:
            self._validate_matrix()
    
    def _validate_matrix(self):
        """Validate homography matrix"""
        if self.matrix.shape != (3, 3):
            raise ValueError("Homography matrix must be 3x3")
        if np.allclose(self.matrix, 0):
            raise ValueError("Homography matrix is all zeros")
    
    @classmethod
    def from_string(cls, matrix_str: str) -> 'HomographyTransform':
        """Parse matrix from comma-separated string"""
        try:
            values = [float(x.strip()) for x in matrix_str.split(',')]
            if len(values) != 9:
                raise ValueError(f"Expected 9 values, got {len(values)}")
            matrix = np.array(values).reshape(3, 3)
            return cls(matrix)
        except Exception as e:
            logger.error(f"Failed to parse homography matrix: {e}")
            return cls(None)
    
    def transform(self, x: float, y: float) -> Tuple[float, float]:
        """Transform point from pixels to meters"""
        if not self.enabled:
            return x, y
        
        try:
            v = np.array([x, y, 1.0])
            v_prime = np.dot(self.matrix, v)
            
            if abs(v_prime[2]) < 1e-10:
                logger.warning(f"Near-zero denominator in homography transform")
                return x, y
            
            return float(v_prime[0] / v_prime[2]), float(v_prime[1] / v_prime[2])
        except Exception as e:
            logger.error(f"Transform error: {e}")
            return x, y


# === Team Classification ===
class TeamClassifier:
    """Improved team classification using jersey colors"""
    
    def __init__(self, method: str = "position"):
        """
        Initialize classifier
        method: 'position' (simple L/R split) or 'color' (jersey color clustering)
        """
        self.method = method
        self.team_colors = None
    
    def classify_by_position(self, x: float, y: float, width: int, height: int) -> str:
        """Simple position-based classification"""
        return TeamColor.TEAM_A.value if x < width / 2 else TeamColor.TEAM_B.value
    
    def classify_by_color(self, frame: np.ndarray, bbox: Tuple[int, int, int, int]) -> str:
        """Color-based classification using jersey region"""
        try:
            x1, y1, x2, y2 = bbox
            
            # Extract jersey region (upper 40% of bbox)
            height = y2 - y1
            jersey_region = frame[y1:int(y1 + height * 0.4), x1:x2]
            
            if jersey_region.size == 0:
                return TeamColor.UNKNOWN.value
            
            # Get dominant color
            pixels = jersey_region.reshape(-1, 3)
            dominant_color = np.median(pixels, axis=0)
            
            # Initialize team colors on first detection
            if self.team_colors is None:
                self.team_colors = {TeamColor.TEAM_A.value: dominant_color}
                return TeamColor.TEAM_A.value
            
            # Compare with known team colors
            min_dist = float('inf')
            closest_team = TeamColor.UNKNOWN.value
            
            for team, color in self.team_colors.items():
                dist = np.linalg.norm(dominant_color - color)
                if dist < min_dist:
                    min_dist = dist
                    closest_team = team
            
            # If color is very different, assign to team B
            if min_dist > 100 and len(self.team_colors) == 1:
                self.team_colors[TeamColor.TEAM_B.value] = dominant_color
                return TeamColor.TEAM_B.value
            
            return closest_team
            
        except Exception as e:
            logger.warning(f"Color classification failed: {e}")
            return TeamColor.UNKNOWN.value
    
    def classify(self, frame: np.ndarray, x: float, y: float, 
                 bbox: Optional[Tuple[int, int, int, int]] = None,
                 width: int = 0, height: int = 0) -> str:
        """Classify player team"""
        if self.method == "color" and bbox is not None:
            return self.classify_by_color(frame, bbox)
        return self.classify_by_position(x, y, width, height)


# === xThreat Grid ===
class XThreatGrid:
    """Expected Threat grid implementation"""
    
    def __init__(self, field_length: float = 105.0, field_width: float = 68.0):
        self.field_length = field_length
        self.field_width = field_width
        
        # Simplified 12x8 grid (more granular)
        # Values increase towards goal (attacking left->right)
        self.grid = np.array([
            [0.005, 0.01, 0.015, 0.02, 0.03, 0.04, 0.06, 0.08, 0.12, 0.18, 0.25, 0.35],
            [0.008, 0.015, 0.02, 0.03, 0.05, 0.07, 0.10, 0.15, 0.22, 0.30, 0.40, 0.50],
            [0.010, 0.02, 0.03, 0.05, 0.08, 0.12, 0.18, 0.25, 0.35, 0.45, 0.55, 0.65],
            [0.012, 0.025, 0.04, 0.07, 0.12, 0.18, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75],
            [0.012, 0.025, 0.04, 0.07, 0.12, 0.18, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75],
            [0.010, 0.02, 0.03, 0.05, 0.08, 0.12, 0.18, 0.25, 0.35, 0.45, 0.55, 0.65],
            [0.008, 0.015, 0.02, 0.03, 0.05, 0.07, 0.10, 0.15, 0.22, 0.30, 0.40, 0.50],
            [0.005, 0.01, 0.015, 0.02, 0.03, 0.04, 0.06, 0.08, 0.12, 0.18, 0.25, 0.35]
        ])
    
    def get_value(self, x: float, y: float) -> float:
        """Get xThreat value for field coordinates (meters)"""
        try:
            # Map to grid indices
            col = int(np.clip(x / (self.field_length / 12), 0, 11))
            row = int(np.clip(y / (self.field_width / 8), 0, 7))
            return float(self.grid[row, col])
        except Exception as e:
            logger.warning(f"xThreat calculation failed: {e}")
            return 0.0


# === Main Analyzer (Part 1) ===
class SoccerMatchAnalyzer:
    """Production-grade soccer match analyzer"""
    
    def __init__(self, config: Optional[AnalysisConfig] = None):
        self.config = config or AnalysisConfig()
        self.model = None
        self.roboflow_model = None
        self.homography = None
        self.team_classifier = TeamClassifier(method="position")
        self.xthreat_grid = XThreatGrid(
            self.config.field_length_m,
            self.config.field_width_m
        )
        self.progress_callback = None
        
    def set_progress_callback(self, callback):
        """Set callback for progress updates"""
        self.progress_callback = callback
    
    def _report_progress(self, current: int, total: int, message: str = ""):
        """Report progress to callback"""
        if self.progress_callback:
            self.progress_callback(current, total, message)
    
    def load_model(self, model_path: str = 'yolov8n.pt'):
        """Load YOLO model with error handling"""
        try:
            logger.info(f"Loading YOLO model: {model_path}")
            
            # Fix for PyTorch 2.6+ security changes
            # Option 2: Force weights_only=False since we trust the standard YOLO model
            import torch
            original_load = torch.load
            try:
                # Monkey patch torch.load to force weights_only=False
                torch.load = lambda *args, **kwargs: original_load(*args, **{**kwargs, 'weights_only': False})
                self.model = YOLO(model_path)
            finally:
                # Restore original torch.load
                torch.load = original_load
                
            logger.info("Model loaded successfully")
        except Exception as e:
            raise ProcessingError(f"Failed to load YOLO model: {e}")
            
    def load_roboflow_model(self, api_key: Optional[str] = None):
        """Load Roboflow model for inference"""
        api_key = api_key or self.config.roboflow_api_key or os.getenv("ROBOFLOW_API_KEY")
        
        if not api_key:
            logger.warning("No Roboflow API key provided. Roboflow inference will be unavailable.")
            return

        try:
            logger.info(f"Connecting to Roboflow: {self.config.roboflow_workspace}/{self.config.roboflow_project} v{self.config.roboflow_version}")
            self.roboflow_model = RoboflowInference(
                api_key=api_key,
                workspace_id=self.config.roboflow_workspace,
                project_id=self.config.roboflow_project,
                version=self.config.roboflow_version
            )
            logger.info("Roboflow model initialized successfully")
        except Exception as e:
            logger.error(f"Failed to load Roboflow model: {e}")
            # Don't raise error, just keep as None
    
    def validate_video(self, video_path: Path) -> VideoMetadata:
        """Validate video file and extract metadata"""
        if not video_path.exists():
            raise VideoError(f"Video file not found: {video_path}")
        
        if not video_path.is_file():
            raise VideoError(f"Path is not a file: {video_path}")
        
        cap = cv2.VideoCapture(str(video_path))
        if not cap.isOpened():
            raise VideoError(f"Cannot open video file: {video_path}")
        
        metadata = VideoMetadata.from_video(video_path, cap)
        cap.release()
        
        # Validate constraints
        if metadata.size_mb > self.config.max_video_size_mb:
            raise VideoError(
                f"Video size ({metadata.size_mb:.1f}MB) exceeds limit "
                f"({self.config.max_video_size_mb}MB)"
            )
        
        if metadata.fps <= 0 or metadata.total_frames <= 0:
            raise VideoError("Invalid video metadata")
        
        logger.info(
            f"Video validated: {metadata.width}x{metadata.height}, "
            f"{metadata.fps:.1f}fps, {metadata.duration_seconds:.1f}s"
        )
        
        return metadata
    
    def parse_clips(self, clips_data: Any, fps: float, total_frames: int) -> List[Tuple[int, int]]:
        """Parse and validate clip ranges"""
        if not clips_data:
            return [(0, total_frames)]
        
        ranges = []
        for clip in clips_data:
            try:
                start = max(0, int(clip['start'] * fps))
                end = min(total_frames, int(clip['end'] * fps))
                
                if start >= end:
                    logger.warning(f"Invalid clip range: {start}-{end}, skipping")
                    continue
                
                ranges.append((start, end))
                logger.info(f"Added clip: frames {start}-{end} ({(end-start)/fps:.1f}s)")
            except (KeyError, TypeError, ValueError) as e:
                logger.error(f"Invalid clip format: {e}")
                continue
        
        return ranges if ranges else [(0, total_frames)]
</file>

<file path="python/soccer_analysis_processor.py">
#!/usr/bin/env python3
"""
Production Soccer Analysis - Processing Methods
Part 2: Core analysis algorithms
"""

import cv2
import numpy as np
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional
from collections import defaultdict
import time
from dataclasses import asdict
import supervision as sv

from soccer_analysis_core import (
    SoccerMatchAnalyzer as BaseSoccerMatchAnalyzer,
    TrackPoint, PlayerStats, PressingEvent, PassEvent, PassingNetworkMetrics,
    VideoMetadata, TeamColor, VideoError, ProcessingError, logger,
    AnalysisConfig, TeamClassifier
)

# Import new modules
try:
    from camera_movement_estimator.camera_movement_estimator import CameraMovementEstimator
    from view_transformer.view_transformer import ViewTransformer
    from team_assigner.team_assigner import TeamAssigner
    from player_ball_assigner.player_ball_assigner import PlayerBallAssigner
    from speed_and_distance_estimator.speed_and_distance_estimator import SpeedAndDistance_Estimator
except ImportError as e:
    logger.warning(f"Could not import advanced modules: {e}")
    CameraMovementEstimator = None
    ViewTransformer = None
    TeamAssigner = None
    PlayerBallAssigner = None
    SpeedAndDistance_Estimator = None


# === Pass Detection ===
class PassDetector:
    """Detects passes from player tracking data using proximity heuristics"""
    
    def __init__(self, config):
        self.config = config
        self.potential_passes = []  # Track ongoing pass attempts
    
    def detect_passes(self, tracks: Dict[int, List[TrackPoint]], 
                     fps: float) -> List[PassEvent]:
        """
        Detect passes using proximity and movement heuristics
        
        Algorithm:
        1. For each frame, find same-team players within proximity
        2. Track when players separate (potential pass)
        3. Validate pass based on distance, receiver movement, duration
        """
        if not tracks:
            return []
        
        passes = []
        frames_data = self._index_by_frame(tracks)
        
        for frame in sorted(frames_data.keys()):
            players = frames_data[frame]
            
            # Detect potential pass starts (players in proximity)
            self._detect_pass_starts(players, frame)
            
            # Update ongoing passes and complete validated ones
            completed = self._update_and_complete_passes(players, frame, fps)
            passes.extend(completed)
        
        # Clean up any remaining potential passes
        self.potential_passes.clear()
        
        logger.info(f"Pass detection complete: {len(passes)} passes found")
        return passes
    
    def _index_by_frame(self, tracks: Dict[int, List[TrackPoint]]) -> Dict[int, List[Tuple[int, TrackPoint]]]:
        """Index tracks by frame for efficient lookup"""
        frames_data = defaultdict(list)
        for player_id, track in tracks.items():
            for point in track:
                if point.xm_smooth is not None:  # Only use smoothed coordinates
                    frames_data[point.frame].append((player_id, point))
        return frames_data
    
    def _detect_pass_starts(self, players: List[Tuple[int, TrackPoint]], frame: int):
        """Find same-team players in proximity (potential pass start)"""
        for i, (pid1, p1) in enumerate(players):
            for pid2, p2 in players[i+1:]:
                # Same team check
                if p1.team != p2.team or p1.team == TeamColor.UNKNOWN.value:
                    continue
                
                # Calculate distance
                dist = np.sqrt(
                    (p1.xm_smooth - p2.xm_smooth)**2 +
                    (p1.ym_smooth - p2.ym_smooth)**2
                )
                
                # Check if within proximity threshold
                if dist < self.config.pass_proximity_threshold_m:
                    # Check if this is a new potential pass
                    existing = any(
                        pp['passer'] == pid1 and pp['receiver'] == pid2 and pp['active']
                        for pp in self.potential_passes
                    )
                    
                    if not existing:
                        self.potential_passes.append({
                            'passer': pid1,
                            'receiver': pid2,
                            'team': p1.team,
                            'start_frame': frame,
                            'start_time': p1.timestamp,
                            'start_pos': (p1.xm_smooth, p1.ym_smooth),
                            'start_xthreat': p1.xthreat,
                            'active': True,
                            'min_distance': dist
                        })
    
    def _update_and_complete_passes(self, players: List[Tuple[int, TrackPoint]], 
                                   frame: int, fps: float) -> List[PassEvent]:
        """Update ongoing passes and complete validated ones"""
        completed_passes = []
        players_dict = {pid: p for pid, p in players}
        
        for potential in self.potential_passes:
            if not potential['active']:
                continue
            
            passer_id = potential['passer']
            receiver_id = potential['receiver']
            
            # Check if both players still in frame
            if passer_id not in players_dict or receiver_id not in players_dict:
                potential['active'] = False
                continue
            
            passer = players_dict[passer_id]
            receiver = players_dict[receiver_id]
            
            # Calculate current distance
            dist = np.sqrt(
                (passer.xm_smooth - receiver.xm_smooth)**2 +
                (passer.ym_smooth - receiver.ym_smooth)**2
            )
            
            # Update minimum distance
            potential['min_distance'] = min(potential['min_distance'], dist)
            
            # Check if players have separated (pass completed)
            if dist > self.config.pass_proximity_threshold_m:
                duration = passer.timestamp - potential['start_time']
                
                # Validate pass
                if self._validate_pass(potential, receiver, dist, duration):
                    # Calculate pass distance (from start to receiver current position)
                    pass_distance = np.sqrt(
                        (receiver.xm_smooth - potential['start_pos'][0])**2 +
                        (receiver.ym_smooth - potential['start_pos'][1])**2
                    )
                    
                    # Create pass event
                    pass_event = PassEvent(
                        frame=frame,
                        timestamp=round(receiver.timestamp, 3),
                        passer_id=passer_id,
                        receiver_id=receiver_id,
                        team=potential['team'],
                        distance=round(pass_distance, 2),
                        duration=round(duration, 2),
                        pass_type=self._classify_pass_type(pass_distance),
                        success=receiver.velocity > self.config.pass_velocity_threshold_ms,
                        start_position=potential['start_pos'],
                        end_position=(receiver.xm_smooth, receiver.ym_smooth),
                        xthreat_delta=round(receiver.xthreat - potential['start_xthreat'], 3)
                    )
                    
                    completed_passes.append(pass_event)
                
                # Mark as inactive
                potential['active'] = False
            
            # Timeout check
            elif (passer.timestamp - potential['start_time']) > self.config.pass_max_duration_s:
                potential['active'] = False
        
        return completed_passes
    
    def _validate_pass(self, potential: Dict, receiver: TrackPoint, 
                      dist: float, duration: float) -> bool:
        """Validate if this is a real pass"""
        # Check minimum distance traveled
        pass_distance = np.sqrt(
            (receiver.xm_smooth - potential['start_pos'][0])**2 +
            (receiver.ym_smooth - potential['start_pos'][1])**2
        )
        
        if pass_distance < self.config.pass_min_distance_m:
            return False
        
        # Check maximum distance
        if pass_distance > self.config.pass_max_distance_m:
            return False
        
        # Check duration
        if duration <= 0 or duration > self.config.pass_max_duration_s:
            return False
        
        # Check receiver movement (should be moving away)
        if receiver.velocity < 0.5:  # Receiver should be moving
            return False
        
        return True
    
    def _classify_pass_type(self, distance: float) -> str:
        """Classify pass as short/medium/long"""
        if distance < 10:
            return 'short'
        elif distance < 25:
            return 'medium'
        else:
            return 'long'


# === Network Analysis ===
class PassingNetworkAnalyzer:
    """Analyzes passing networks and team connectivity"""
    
    def __init__(self, config):
        self.config = config
    
    def analyze_network(self, passes: List[PassEvent], 
                       team: str) -> PassingNetworkMetrics:
        """Build passing network and calculate metrics"""
        team_passes = [p for p in passes if p.team == team]
        
        if not team_passes:
            return self._empty_metrics(team)
        
        # Build passing graph
        graph = self._build_graph(team_passes)
        
        # Calculate metrics
        total = len(team_passes)
        successful = sum(1 for p in team_passes if p.success)
        completion_rate = (successful / total) if total > 0 else 0.0
        
        metrics = PassingNetworkMetrics(
            team=team,
            total_passes=total,
            successful_passes=successful,
            pass_completion_rate=round(completion_rate, 3),
            avg_pass_distance=round(np.mean([p.distance for p in team_passes]), 2),
            key_passers=self._find_key_players(team_passes, 'passer'),
            key_receivers=self._find_key_players(team_passes, 'receiver'),
            passing_triangles=self._find_triangles(graph),
            network_centrality=self._calculate_centrality(graph)
        )
        
        return metrics
    
    def _empty_metrics(self, team: str) -> PassingNetworkMetrics:
        """Return empty metrics for team with no passes"""
        return PassingNetworkMetrics(
            team=team,
            total_passes=0,
            successful_passes=0,
            pass_completion_rate=0.0,
            avg_pass_distance=0.0,
            key_passers=[],
            key_receivers=[],
            passing_triangles=[],
            network_centrality={}
        )
    
    def _build_graph(self, passes: List[PassEvent]) -> Dict[int, Dict[int, int]]:
        """Build directed graph from passes (adjacency list with counts)"""
        graph = defaultdict(lambda: defaultdict(int))
        
        for pass_event in passes:
            graph[pass_event.passer_id][pass_event.receiver_id] += 1
        
        return dict(graph)
    
    def _find_key_players(self, passes: List[PassEvent], 
                         role: str) -> List[Tuple[int, int]]:
        """Find top passers or receivers by volume"""
        counts = defaultdict(int)
        
        for pass_event in passes:
            player_id = pass_event.passer_id if role == 'passer' else pass_event.receiver_id
            counts[player_id] += 1
        
        # Sort by count and return top 5
        sorted_players = sorted(counts.items(), key=lambda x: x[1], reverse=True)
        return sorted_players[:5]
    
    def _find_triangles(self, graph: Dict[int, Dict[int, int]]) -> List[Tuple[int, int, int]]:
        """Find passing triangles (3-player combinations)"""
        triangles = []
        players = list(graph.keys())
        
        # Check all combinations of 3 players
        for i, p1 in enumerate(players):
            for j, p2 in enumerate(players[i+1:], i+1):
                for p3 in players[j+1:]:
                    # Check if triangle exists (all 3 connections)
                    if (p2 in graph.get(p1, {}) and 
                        p3 in graph.get(p2, {}) and 
                        p1 in graph.get(p3, {})):
                        triangles.append((p1, p2, p3))
        
        return triangles[:10]  # Return top 10 triangles
    
    def _calculate_centrality(self, graph: Dict[int, Dict[int, int]]) -> Dict[int, float]:
        """Calculate degree centrality for each player"""
        centrality = {}
        all_players = set(graph.keys())
        
        # Add receivers to player set
        for receivers in graph.values():
            all_players.update(receivers.keys())
        
        # Calculate degree centrality (normalized)
        max_degree = len(all_players) - 1 if len(all_players) > 1 else 1
        
        for player in all_players:
            # Out-degree (passes made)
            out_degree = len(graph.get(player, {}))
            
            # In-degree (passes received)
            in_degree = sum(1 for passers in graph.values() if player in passers)
            
            # Total degree
            total_degree = out_degree + in_degree
            
            # Normalize
            centrality[player] = round(total_degree / max_degree, 3) if max_degree > 0 else 0.0
        
        return centrality



    @staticmethod
    def get_team_brightness(crops):
        """Calculate average brightness of team crops."""
        if not crops:
            return 128
        brightnesses = [np.mean(crop) for crop in crops]
        return np.mean(brightnesses)

    @staticmethod
    def assign_high_contrast_colors(team0_crops, team1_crops):
        """
        Assign guaranteed high-contrast colors based on brightness.
        WHITE team ‚Üí Light gray
        COLORED team ‚Üí Bright red
        """
        team0_bright = SoccerMatchAnalyzer.get_team_brightness(team0_crops)
        team1_bright = SoccerMatchAnalyzer.get_team_brightness(team1_crops)
        
        logger.info(f"High-contrast color assignment: Team 0 bright={team0_bright:.1f}, Team 1 bright={team1_bright:.1f}")
        
        if team0_bright > team1_bright:
            return (230, 230, 230), (50, 50, 220)  # Light gray, Bright red
        else:
            return (50, 50, 220), (230, 230, 230)  # Bright red, Light gray


class SoccerMatchAnalyzer(BaseSoccerMatchAnalyzer):
    """Extended analyzer with processing methods"""
    
    def track_players(self, video_path: Path, processing_ranges: List[Tuple[int, int]], 
                     metadata: VideoMetadata,
                     camera_estimator=None,
                     view_transformer=None,
                     team_assigner=None) -> Dict[int, List[TrackPoint]]:
        """
        Track players across video frames
        Returns: Dict mapping player_id -> list of TrackPoints
        """
        cap = cv2.VideoCapture(str(video_path))
        if not cap.isOpened():
            raise VideoError(f"Failed to reopen video: {video_path}")
        
        tracks = defaultdict(list)
        total_frames_to_process = sum(end - start for start, end in processing_ranges)
        processed = 0
        
        try:
            for range_idx, (start_frame, end_frame) in enumerate(processing_ranges):
                logger.info(f"Processing range {range_idx + 1}/{len(processing_ranges)}: "
                          f"frames {start_frame}-{end_frame}")
                
                cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
                frame_idx = start_frame
                
                while frame_idx < end_frame:
                    ret, frame = cap.read()
                    if not ret:
                        logger.warning(f"Failed to read frame {frame_idx}")
                        break
                    
                    # Skip frames if configured
                    if (frame_idx - start_frame) % self.config.frame_skip != 0:
                        frame_idx += 1
                        continue
                    
                    timestamp = frame_idx / metadata.fps
                    
                    # Camera movement
                    camera_movement = [0, 0]
                    if camera_estimator:
                        camera_movement = camera_estimator.step(frame)
                    
                    # Run tracking
                    try:
                        if self.roboflow_model:
                            # Use Roboflow for detection + manual ByteTrack
                            detections = self.roboflow_model.get_detections(frame, confidence=self.config.confidence_threshold)
                            
                            if not hasattr(self, 'sv_tracker'):
                                self.sv_tracker = sv.ByteTrack()
                            
                            # Update tracker
                            tracked_detections = self.sv_tracker.update_with_detections(detections)
                            
                            boxes = tracked_detections.xyxy
                            ids = tracked_detections.tracker_id
                            confs = tracked_detections.confidence
                            cls_ids = tracked_detections.class_id
                            
                            # For the ball
                            ball_mask = detections.class_id == 32
                            ball_boxes = detections.xyxy[ball_mask]
                            ball_confs = detections.confidence[ball_mask]
                            ball_cls_ids = detections.class_id[ball_mask]
                            
                            final_results = []
                            for i in range(len(tracked_detections)):
                                final_results.append({
                                    'bbox': boxes[i],
                                    'id': ids[i],
                                    'conf': confs[i],
                                    'cls': cls_ids[i]
                                })
                            for i in range(len(ball_boxes)):
                                final_results.append({
                                    'bbox': ball_boxes[i],
                                    'id': None,
                                    'conf': ball_confs[i],
                                    'cls': ball_cls_ids[i]
                                })
                        else:
                            yolo_results = self.model.track(
                                frame,
                                persist=True,
                                verbose=False,
                                classes=[0, 32],
                                conf=self.config.confidence_threshold,
                                tracker="bytetrack.yaml"
                            )
                            
                            final_results = []
                            for result in yolo_results:
                                if result.boxes.id is None:
                                    ball_indices = result.boxes.cls == 32
                                    bboxes = result.boxes.xyxy[ball_indices].cpu().numpy()
                                    confs = result.boxes.conf[ball_indices].cpu().numpy()
                                    for i in range(len(bboxes)):
                                        final_results.append({
                                            'bbox': bboxes[i],
                                            'id': None,
                                            'conf': confs[i],
                                            'cls': 32
                                        })
                                    continue
                                
                                boxes_xyxy = result.boxes.xyxy.cpu().numpy()
                                ids = result.boxes.id.cpu().numpy().astype(int)
                                confs = result.boxes.conf.cpu().numpy()
                                cls_ids = result.boxes.cls.cpu().numpy().astype(int)
                                
                                for bbox, track_id, conf, cls_id in zip(boxes_xyxy, ids, confs, cls_ids):
                                    final_results.append({
                                        'bbox': bbox,
                                        'id': track_id,
                                        'conf': conf,
                                        'cls': cls_id
                                    })

                    except Exception as e:
                        logger.error(f"Tracking failed at frame {frame_idx}: {e}")
                        import traceback
                        logger.error(traceback.format_exc())
                        frame_idx += 1
                        continue
                    
                    # Process detections
                    current_frame_players = {} # For team assignment
                    
                    # High-contrast color buffers
                    team0_color = (230, 230, 230) # Light gray (white team)
                    team1_color = (50, 50, 220)   # Bright red (colored team)
                    colors_assigned = False

                    for detection in final_results:
                        bbox = detection['bbox']
                        track_id = detection['id']
                        conf = detection['conf']
                        cls_id = detection['cls']
                        
                        x1, y1, x2, y2 = bbox
                        w, h = x2 - x1, y2 - y1
                        x, y = (x1 + x2) / 2, (y1 + y2) / 2
                        
                        # Use bottom-center for ground plane
                        foot_x, foot_y = float(x), float(y + h/2)
                        
                        # Adjust for camera movement (simplified accumulation)
                        x_adj = foot_x - camera_movement[0]
                        y_adj = foot_y - camera_movement[1]
                        
                        # Transform to meters
                        xm, ym = None, None
                        if view_transformer:
                            # ViewTransformer expects point as list/array
                            pt = np.array([x_adj, y_adj])
                            transformed = view_transformer.transform_point(pt)
                            if transformed is not None:
                                xm, ym = float(transformed[0][0]), float(transformed[0][1])
                        elif self.homography:
                            xm, ym = self.homography.transform(foot_x, foot_y)
                        
                        # Classify team or ball
                        team = "Unknown"
                        if cls_id == 32:
                            team = "BALL"
                        elif team_assigner:
                            # Use TeamAssigner if initialized
                            if hasattr(team_assigner, 'kmeans') and team_assigner.kmeans:
                                team_id = team_assigner.get_player_team(frame, bbox, track_id)
                                team = "A" if team_id == 1 else "B"
                            else:
                                # Will be assigned retroactively for first frame
                                team = "Unknown"
                        else:
                            team = self.team_classifier.classify(
                                frame, x, y,
                                bbox=tuple(bbox.astype(int)) if isinstance(bbox, np.ndarray) else tuple(map(int, bbox)),
                                width=metadata.width,
                                height=metadata.height
                            )
                        
                        # Create track point
                        point = TrackPoint(
                            frame=frame_idx,
                            timestamp=round(timestamp, 3),
                            x=float(x),
                            y=float(y),
                            xm=xm,
                            ym=ym,
                            team=team,
                            confidence=float(conf),
                            bbox=tuple(map(float, bbox))
                        )
                        
                        # Use track_id if available, otherwise use a temporary id for ball
                        obj_id = track_id if track_id is not None else f"ball_{frame_idx}"
                        tracks[obj_id].append(point)
                        
                        if cls_id != 32:
                            current_frame_players[track_id] = {'bbox': bbox}

                    # Update team assigner colors if needed (first frame)
                    if team_assigner and frame_idx == start_frame and current_frame_players:
                        if self.config.use_high_contrast_colors:
                            # Extract crops to determine brightness
                            from player_clustering import EmbeddingExtractor
                            extractor = EmbeddingExtractor()
                            
                            player_crops = []
                            for track_id, info in current_frame_players.items():
                                bbox = info['bbox']
                                x1, y1, x2, y2 = map(int, bbox)
                                crop = frame[max(0, y1):min(frame.shape[0], y2), 
                                             max(0, x1):min(frame.shape[1], x2)]
                                if crop.size > 0:
                                    player_crops.append(crop)
                            
                            if player_crops:
                                # We need to cluster them into two teams first to assign colors
                                from sklearn.cluster import KMeans
                                features = extractor.extract(player_crops)
                                labels = KMeans(n_clusters=2, n_init=10).fit_predict(features)
                                
                                team0_crops = [player_crops[i] for i, l in enumerate(labels) if l == 0]
                                team1_crops = [player_crops[i] for i, l in enumerate(labels) if l == 1]
                                
                                c1, c2 = self.assign_high_contrast_colors(team0_crops, team1_crops)
                                team_assigner.set_fixed_team_colors(c1, c2)
                                logger.info(f"High-contrast colors applied: Team 0={c1}, Team 1={c2}")
                        else:
                            team_assigner.assign_team_color(frame, current_frame_players)
                        
                        # Retroactively assign teams for this first frame
                        for track_id, points in tracks.items():
                            if points and points[-1].frame == start_frame and points[-1].team == "Unknown":
                                # Get the point we just added
                                point = points[-1]
                                if point.bbox:
                                    team_id = team_assigner.get_player_team(frame, point.bbox, track_id)
                                    point.team = "A" if team_id == 1 else "B"
                    
                    frame_idx += 1
                    processed += 1
                    
                    # Progress reporting
                    if processed % 30 == 0:  # Every ~1 second at 30fps
                        self._report_progress(
                            processed,
                            total_frames_to_process,
                            f"Tracking frame {frame_idx}/{end_frame}"
                        )
        
        finally:
            cap.release()
        
        logger.info(f"Tracking complete. Found {len(tracks)} players")
        return dict(tracks)
    
    def compute_metrics(self, tracks: Dict[int, List[TrackPoint]], 
                       fps: float) -> Dict[int, List[TrackPoint]]:
        """
        Compute physical metrics (velocity, acceleration, sprints)
        Modifies track points in-place and returns updated tracks
        """
        min_track_length = int(self.config.min_track_length_seconds * fps)
        
        for player_id, track in list(tracks.items()):
            # Filter short tracks
            if len(track) < min_track_length:
                logger.debug(f"Removing short track {player_id}: {len(track)} points")
                del tracks[player_id]
                continue
            
            # Check if we have meter coordinates
            if track[0].xm is None:
                logger.warning(f"Player {player_id}: No meter coordinates, skipping metrics")
                continue
            
            # Extract coordinates
            coords = np.array([[p.xm, p.ym] for p in track])
            timestamps = np.array([p.timestamp for p in track])
            
            # Smooth coordinates
            coords_smooth = self._smooth_trajectory(coords)
            
            # Compute velocity
            velocity = self._compute_velocity(coords_smooth, timestamps, fps)
            
            # Compute acceleration
            acceleration = self._compute_acceleration(velocity, timestamps)
            
            # Detect sprints
            is_sprinting = velocity > self.config.sprint_threshold_ms
            
            # Update track points
            for i, point in enumerate(track):
                point.xm_smooth = float(coords_smooth[i, 0])
                point.ym_smooth = float(coords_smooth[i, 1])
                point.velocity = float(velocity[i])
                point.acceleration = float(acceleration[i])
                point.is_sprinting = bool(is_sprinting[i])
                
                # Compute xThreat
                point.xthreat = self.xthreat_grid.get_value(
                    point.xm_smooth,
                    point.ym_smooth
                )
        
        logger.info(f"Metrics computed for {len(tracks)} players")
        return tracks
    
    def _smooth_trajectory(self, coords: np.ndarray) -> np.ndarray:
        """Apply Savitzky-Golay smoothing"""
        from scipy.signal import savgol_filter
        
        window = min(len(coords), self.config.smoothing_window)
        if window % 2 == 0:
            window -= 1
        
        if window < 3:
            return coords
        
        try:
            return savgol_filter(coords, window, 2, axis=0)
        except Exception as e:
            logger.warning(f"Smoothing failed: {e}")
            return coords
    
    def _compute_velocity(self, coords: np.ndarray, timestamps: np.ndarray, 
                         fps: float) -> np.ndarray:
        """Compute velocity with outlier filtering"""
        dt = np.diff(timestamps)
        dt[dt == 0] = 1.0 / fps  # Avoid division by zero
        
        dist = np.linalg.norm(np.diff(coords, axis=0), axis=1)
        
        # Filter impossible movements
        valid_moves = (dist < self.config.max_distance_jump_m) & \
                     (dt < self.config.max_frame_gap_seconds)
        
        velocity = np.zeros(len(dist))
        velocity[valid_moves] = dist[valid_moves] / dt[valid_moves]
        
        # Cap at maximum human speed
        velocity = np.clip(velocity, 0, self.config.max_speed_ms)
        
        # Pad to match original length
        return np.insert(velocity, 0, 0.0)
    
    def _compute_acceleration(self, velocity: np.ndarray, 
                            timestamps: np.ndarray) -> np.ndarray:
        """Compute acceleration"""
        dt = np.diff(timestamps)
        dt[dt == 0] = 0.033  # ~30fps
        
        accel = np.diff(velocity) / dt
        
        # Cap extreme accelerations (¬±10 m/s¬≤)
        accel = np.clip(accel, -10.0, 10.0)
        
        return np.insert(accel, 0, 0.0)
    
    def compute_player_stats(self, tracks: Dict[int, List[TrackPoint]], 
                           fps: float) -> Dict[int, PlayerStats]:
        """Aggregate player statistics"""
        stats = {}
        
        for player_id, track in tracks.items():
            if not track or track[0].xm is None:
                continue
            
            # Total distance (using smoothed coordinates)
            coords = np.array([[p.xm_smooth or p.xm, p.ym_smooth or p.ym] 
                             for p in track])
            distances = np.linalg.norm(np.diff(coords, axis=0), axis=1)
            
            # Filter valid movements
            valid = distances < self.config.max_distance_jump_m
            total_dist = float(np.sum(distances[valid]))
            
            # Velocity stats
            velocities = np.array([p.velocity for p in track])
            max_speed = float(np.max(velocities))
            avg_speed = float(np.mean(velocities[velocities > 0])) if np.any(velocities > 0) else 0.0
            
            # Count sprint events
            sprint_count = 0
            in_sprint = False
            for p in track:
                if p.is_sprinting and not in_sprint:
                    sprint_count += 1
                    in_sprint = True
                elif not p.is_sprinting:
                    in_sprint = False
            
            # Track duration
            duration = (track[-1].timestamp - track[0].timestamp)
            
            stats[player_id] = PlayerStats(
                player_id=player_id,
                total_distance=round(total_dist, 2),
                max_speed=round(max_speed, 2),
                avg_speed=round(avg_speed, 2),
                sprints=sprint_count,
                team=track[0].team,
                track_duration=round(duration, 2),
                frames_tracked=len(track)
            )
        
        logger.info(f"Stats computed for {len(stats)} players")
        return stats
    
    def detect_pressing_events(self, tracks: Dict[int, List[TrackPoint]]) -> List[PressingEvent]:
        """Detect pressing events between players"""
        # Index tracks by frame
        frames_data = defaultdict(list)
        for pid, track in tracks.items():
            for point in track:
                if point.xm_smooth is not None:
                    frames_data[point.frame].append((pid, point))
        
        events = []
        
        for frame in sorted(frames_data.keys()):
            players = frames_data[frame]
            
            # Separate by team
            team_a = [(pid, p) for pid, p in players if p.team == TeamColor.TEAM_A.value]
            team_b = [(pid, p) for pid, p in players if p.team == TeamColor.TEAM_B.value]
            
            # Check A pressing B
            for def_id, def_p in team_a:
                for att_id, att_p in team_b:
                    dist = np.sqrt(
                        (def_p.xm_smooth - att_p.xm_smooth)**2 +
                        (def_p.ym_smooth - att_p.ym_smooth)**2
                    )
                    
                    if dist < self.config.pressing_distance_m and \
                       def_p.velocity > self.config.pressing_speed_threshold_ms:
                        events.append(PressingEvent(
                            frame=frame,
                            timestamp=round(def_p.timestamp, 3),
                            defender_id=def_id,
                            attacker_id=att_id,
                            distance=round(dist, 2),
                            defender_speed=round(def_p.velocity, 2)
                        ))
            
            # Check B pressing A (symmetric)
            for def_id, def_p in team_b:
                for att_id, att_p in team_a:
                    dist = np.sqrt(
                        (def_p.xm_smooth - att_p.xm_smooth)**2 +
                        (def_p.ym_smooth - att_p.ym_smooth)**2
                    )
                    
                    if dist < self.config.pressing_distance_m and \
                       def_p.velocity > self.config.pressing_speed_threshold_ms:
                        events.append(PressingEvent(
                            frame=frame,
                            timestamp=round(def_p.timestamp, 3),
                            defender_id=def_id,
                            attacker_id=att_id,
                            distance=round(dist, 2),
                            defender_speed=round(def_p.velocity, 2)
                        ))
        
        # Deduplicate events (same players within 1 second)
        events = self._deduplicate_events(events)
        
        logger.info(f"Detected {len(events)} pressing events")
        return events
    
    def _deduplicate_events(self, events: List[PressingEvent], 
                          time_window: float = 1.0) -> List[PressingEvent]:
        """Remove duplicate events within time window"""
        if not events:
            return events
        
        events.sort(key=lambda e: e.timestamp)
        unique = [events[0]]
        
        for event in events[1:]:
            last = unique[-1]
            
            # Same players within time window
            if (event.defender_id == last.defender_id and
                event.attacker_id == last.attacker_id and
                event.timestamp - last.timestamp < time_window):
                continue
            
            unique.append(event)
        
        return unique
    
    def analyze(self, video_path: str, clips: Optional[List[Dict]] = None,
               homography_matrix: Optional[str] = None,
               generate_annotated_video: bool = False) -> Dict[str, Any]:
        """
        Main analysis pipeline
        
        Args:
            video_path: Path to video file
            clips: Optional list of {start, end} time ranges in seconds
            homography_matrix: Optional comma-separated 3x3 matrix string
            generate_annotated_video: If True, generate MP4 with annotations
        
        Returns:
            Complete analysis results dictionary
        """
        start_time = time.time()
        video_path = Path(video_path)
        
        try:
            # Initialize
            if self.model is None:
                self.load_model()
            
            if self.roboflow_model is None:
                self.load_roboflow_model()

            # Initialize modules
            camera_estimator = CameraMovementEstimator(None) if CameraMovementEstimator else None
            view_transformer = ViewTransformer() if ViewTransformer else None
            team_assigner = TeamAssigner() if TeamAssigner else None
            player_assigner = PlayerBallAssigner() if PlayerBallAssigner else None
            
            # Setup homography
            if homography_matrix:
                from soccer_analysis_core import HomographyTransform
                self.homography = HomographyTransform.from_string(homography_matrix)
                if self.homography.enabled:
                    logger.info("Homography transform enabled")
                else:
                    logger.warning("Homography parsing failed, using pixel coordinates")
            elif self.roboflow_model:
                # Attempt auto-calibration on the first frame of the first clip
                try:
                    cap = cv2.VideoCapture(str(video_path))
                    if cap.isOpened():
                        ret, first_frame = cap.read()
                        cap.release()
                        
                        if ret:
                            logger.info("Running auto-calibration on first frame...")
                            detections, keypoints = self.roboflow_model.get_keypoints_detections(first_frame)
                            
                            if keypoints is not None:
                                from keypoint_detection.homography import HomographyTransformer
                                transformer = HomographyTransformer()
                                view_transformer = transformer.transform_to_pitch_keypoints(keypoints)
                                
                                if view_transformer:
                                    from soccer_analysis_core import HomographyTransform
                                    # Convert sports.ViewTransformer to our HomographyTransform
                                    # sports.ViewTransformer has .m attribute for homography matrix
                                    if hasattr(view_transformer, 'm'):
                                        self.homography = HomographyTransform(view_transformer.m)
                                        logger.info("Auto-calibration successful")
                                    else:
                                        logger.warning("Auto-calibration failed: ViewTransformer missing matrix")
                                else:
                                    logger.warning("Auto-calibration failed: Insufficient keypoints")
                    else:
                        logger.warning("Could not open video for auto-calibration")
                except Exception as e:
                    logger.error(f"Auto-calibration error: {e}")
            
            # Validate video
            metadata = self.validate_video(video_path)
            
            # Parse clips
            processing_ranges = self.parse_clips(clips, metadata.fps, metadata.total_frames)
            
            # Track players
            self._report_progress(0, 100, "Starting player tracking...")
            tracks = self.track_players(video_path, processing_ranges, metadata,
                                      camera_estimator, view_transformer, team_assigner)
            
            if not tracks:
                raise ProcessingError("No players detected in video")
            
            # Compute metrics
            self._report_progress(50, 100, "Computing metrics...")
            tracks = self.compute_metrics(tracks, metadata.fps)
            
            # Player stats
            stats = self.compute_player_stats(tracks, metadata.fps)
            
            # Detect events
            self._report_progress(80, 100, "Detecting events...")
            events = self.detect_pressing_events(tracks)

            # Assign ball possession
            if player_assigner:
                self._report_progress(82, 100, "Assigning ball possession...")
                # Index tracks by frame
                frames_data = defaultdict(dict) # frame -> {player_id: track_point}
                ball_data = {} # frame -> track_point
                
                for pid, track in tracks.items():
                    for point in track:
                        if point.team == "BALL":
                            ball_data[point.frame] = point
                        else:
                            frames_data[point.frame][pid] = point
                
                for frame, players in frames_data.items():
                    if frame in ball_data:
                        ball_point = ball_data[frame]
                        if ball_point.bbox:
                            # Construct players dict for assigner
                            players_dict = {}
                            for pid, p in players.items():
                                if p.bbox:
                                    players_dict[pid] = {'bbox': p.bbox}
                            
                            if players_dict:
                                assigned_id = player_assigner.assign_ball_to_player(players_dict, ball_point.bbox)
                                if assigned_id != -1:
                                    # Update track point
                                    frames_data[frame][assigned_id].has_ball = True
            
            # Detect passes
            passes = []
            network_metrics = {}
            
            if self.config.enable_pass_detection:
                self._report_progress(85, 100, "Detecting passes...")
                
                pass_detector = PassDetector(self.config)
                passes = pass_detector.detect_passes(tracks, metadata.fps)
                
                logger.info(f"Detected {len(passes)} passes")
                
                # Network analysis
                self._report_progress(90, 100, "Analyzing passing networks...")
                network_analyzer = PassingNetworkAnalyzer(self.config)
                network_metrics['A'] = network_analyzer.analyze_network(passes, 'A')
                network_metrics['B'] = network_analyzer.analyze_network(passes, 'B')
            
            # Advanced analysis (NEW)
            passing_predictions = []
            tactical_alerts = []
            
            try:
                from advanced_engines import PassingEngine, TacticalEngine
                
                self._report_progress(92, 100, "Computing passing predictions...")
                
                # Index tracks by frame
                frames_data = defaultdict(list)
                ball_track = []
                for pid, track in tracks.items():
                    for point in track:
                        if point.xm_smooth is not None:
                            if point.team == "BALL":
                                ball_track.append(point)
                            else:
                                frames_data[point.frame].append((pid, point))
                
                # Passing predictions
                passing_engine = PassingEngine(self.config)
                passing_predictions = passing_engine.predict_passes(frames_data, ball_track)
                logger.info(f"Generated {len(passing_predictions)} passing predictions")
                
                # Tactical alerts
                self._report_progress(94, 100, "Detecting tactical events...")
                tactical_engine = TacticalEngine(self.config)
                tactical_alerts = tactical_engine.detect_events(frames_data)
                logger.info(f"Detected {len(tactical_alerts)} tactical alerts")
                
            except ImportError as e:
                logger.warning(f"Advanced engines not available: {e}")
            
            # Video generation (NEW)
            annotated_video_path = None
            if generate_annotated_video:
                self._report_progress(96, 100, "Generating annotated video...")
                try:
                    annotated_video_path = self._generate_annotated_video(
                        video_path, tracks, metadata, processing_ranges
                    )
                    logger.info(f"Annotated video saved: {annotated_video_path}")
                except Exception as e:
                    logger.error(f"Video generation failed: {e}")
            
            # Flatten positions for compatibility
            positions = self._flatten_tracks(tracks)
            
            # Build output
            result = {
                'success': True,
                'metadata': {
                    'video_path': str(video_path),
                    'duration': round(metadata.duration_seconds, 2),
                    'fps': metadata.fps,
                    'resolution': f"{metadata.width}x{metadata.height}",
                    'processing_time': round(time.time() - start_time, 2),
                    'annotated_video': annotated_video_path
                },
                'stats': {str(k): asdict(v) for k, v in stats.items()},
                'tracks': {str(k): [asdict(p) for p in v] for k, v in tracks.items()},
                'events': [asdict(e) for e in events],
                'passes': [asdict(p) for p in passes],
                'network_metrics': {k: asdict(v) for k, v in network_metrics.items()},
                'passing_predictions': [asdict(p) for p in passing_predictions],  # NEW
                'tactical_alerts': [asdict(a) for a in tactical_alerts],  # NEW
                'positions': positions
            }
            
            self._report_progress(100, 100, "Analysis complete")
            logger.info(f"Analysis completed in {result['metadata']['processing_time']:.1f}s")
            
            return result
            
        except Exception as e:
            logger.error(f"Analysis failed: {e}", exc_info=True)
            return {
                'success': False,
                'error': str(e),
                'error_type': type(e).__name__
            }
    
    
    def _generate_annotated_video(self, video_path: Path, tracks: Dict[int, List[TrackPoint]],
                                  metadata: VideoMetadata, processing_ranges: List[Tuple[int, int]]) -> str:
        """Generate annotated video with tracking overlays"""
        output_path = str(video_path.parent / f"{video_path.stem}_annotated.mp4")
        
        cap = cv2.VideoCapture(str(video_path))
        if not cap.isOpened():
            raise VideoError(f"Failed to open video for annotation: {video_path}")
        
        # Video writer
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        out = cv2.VideoWriter(output_path, fourcc, metadata.fps, 
                             (metadata.width, metadata.height))
        
        try:
            # Index tracks by frame for fast lookup
            frames_data = defaultdict(list)
            for pid, track in tracks.items():
                for point in track:
                    frames_data[point.frame].append((pid, point))
            
            # Process frames
            for start_frame, end_frame in processing_ranges:
                cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
                frame_idx = start_frame
                
                while frame_idx < end_frame:
                    ret, frame = cap.read()
                    if not ret:
                        break
                    
                    # Draw annotations
                    if frame_idx in frames_data:
                        for pid, point in frames_data[frame_idx]:
                            # Skip ball for now
                            if point.team == "BALL":
                                # Draw ball as yellow circle
                                cv2.circle(frame, (int(point.x), int(point.y)), 8, (0, 255, 255), -1)
                                continue
                            
                            # Player marker
                            color = (0, 0, 255) if point.team == "A" else (255, 0, 0)  # Red=A, Blue=B
                            cv2.circle(frame, (int(point.x), int(point.y)), 10, color, 2)
                            
                            # Player ID
                            cv2.putText(frame, str(pid), (int(point.x) - 10, int(point.y) - 15),
                                      cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
                            
                            # Speed label
                            if point.velocity > 2.0:
                                speed_kmh = point.velocity * 3.6
                                cv2.putText(frame, f"{speed_kmh:.1f} km/h", 
                                          (int(point.x) - 20, int(point.y) + 25),
                                          cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 255), 1)
                            
                            # Sprint indicator
                            if point.is_sprinting:
                                cv2.circle(frame, (int(point.x), int(point.y)), 15, (0, 255, 0), 2)
                    
                    out.write(frame)
                    frame_idx += 1
        
        finally:
            cap.release()
            out.release()
        
        return output_path
    
    def _flatten_tracks(self, tracks: Dict[int, List[TrackPoint]]) -> List[Dict]:
        """Flatten tracks for backward compatibility"""
        positions = []
        for player_id, track in tracks.items():
            for point in track:
                positions.append({
                    'frame': point.frame,
                    'timestamp': point.timestamp,
                    'x': point.x,
                    'y': point.y,
                    'team': point.team,
                    'confidence': point.confidence,
                    'id': player_id,
                    'speed': point.velocity,
                    'sprinting': point.is_sprinting
                })
        return positions


# Export main class
__all__ = ['SoccerMatchAnalyzer', 'AnalysisConfig', 'HomographyTransform']
</file>

<file path="python/speed_and_distance_estimator/__init__.py">
from .speed_and_distance_estimator import SpeedAndDistance_Estimator
</file>

<file path="python/speed_and_distance_estimator/speed_and_distance_estimator.py">
import cv2
import sys 
sys.path.append('../')
from utils import measure_distance ,get_foot_position

class SpeedAndDistance_Estimator():
    def __init__(self):
        self.frame_window=5
        self.frame_rate=24
    
    def add_speed_and_distance_to_tracks(self,tracks):
        total_distance= {}

        for object, object_tracks in tracks.items():
            if object == "ball" or object == "referees":
                continue 
            number_of_frames = len(object_tracks)
            for frame_num in range(0,number_of_frames, self.frame_window):
                last_frame = min(frame_num+self.frame_window,number_of_frames-1 )

                for track_id,_ in object_tracks[frame_num].items():
                    if track_id not in object_tracks[last_frame]:
                        continue

                    start_position = object_tracks[frame_num][track_id]['position_transformed']
                    end_position = object_tracks[last_frame][track_id]['position_transformed']

                    if start_position is None or end_position is None:
                        continue
                    
                    distance_covered = measure_distance(start_position,end_position)
                    time_elapsed = (last_frame-frame_num)/self.frame_rate
                    speed_meteres_per_second = distance_covered/time_elapsed
                    speed_km_per_hour = speed_meteres_per_second*3.6

                    if object not in total_distance:
                        total_distance[object]= {}
                    
                    if track_id not in total_distance[object]:
                        total_distance[object][track_id] = 0
                    
                    total_distance[object][track_id] += distance_covered

                    for frame_num_batch in range(frame_num,last_frame):
                        if track_id not in tracks[object][frame_num_batch]:
                            continue
                        tracks[object][frame_num_batch][track_id]['speed'] = speed_km_per_hour
                        tracks[object][frame_num_batch][track_id]['distance'] = total_distance[object][track_id]
    
    def draw_speed_and_distance(self,frames,tracks):
        output_frames = []
        for frame_num, frame in enumerate(frames):
            for object, object_tracks in tracks.items():
                if object == "ball" or object == "referees":
                    continue 
                for _, track_info in object_tracks[frame_num].items():
                   if "speed" in track_info:
                       speed = track_info.get('speed',None)
                       distance = track_info.get('distance',None)
                       if speed is None or distance is None:
                           continue
                       
                       bbox = track_info['bbox']
                       position = get_foot_position(bbox)
                       position = list(position)
                       position[1]+=40

                       position = tuple(map(int,position))
                       cv2.putText(frame, f"{speed:.2f} km/h",position,cv2.FONT_HERSHEY_SIMPLEX,0.5,(0,0,0),2)
                       cv2.putText(frame, f"{distance:.2f} m",(position[0],position[1]+20),cv2.FONT_HERSHEY_SIMPLEX,0.5,(0,0,0),2)
            output_frames.append(frame)
        
        return output_frames
</file>

<file path="python/start_runpod.sh">
#!/bin/bash

# Update and install system dependencies
echo "Installing system dependencies..."
apt-get update && apt-get install -y libgl1 libglib2.0-0

# Install Python dependencies
echo "Installing Python dependencies..."
pip install -r requirements.txt

# Start the server
echo "Starting server..."
python api.py
</file>

<file path="python/tactabot.py">
import os
import logging
import sqlite3
import asyncio
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler, MessageHandler, filters, CallbackQueryHandler
from contextlib import contextmanager

# --- CONFIGURATION & SETUP ---
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass

# Logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Constants
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
ADMIN_IDS = [x.strip() for x in os.getenv("ADMIN_IDS", "").split(",") if x.strip()]
ANNOUNCEMENT_CHAT_ID = os.getenv("ANNOUNCEMENT_CHAT_ID")

# DYNAMIC PATHS (Fixes 'File Not Found' errors)
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(BASE_DIR, 'tactabot.db')
UPLOADS_DIR = os.path.join(BASE_DIR, '..', 'public', 'uploads')
CLIPS_DIR = os.path.join(BASE_DIR, '..', 'public', 'clips')

# Ensure directories exist
os.makedirs(UPLOADS_DIR, exist_ok=True)
os.makedirs(CLIPS_DIR, exist_ok=True)

# Import Clip Generator (Graceful Fallback)
try:
    from clip_generator import generate_clips_from_video
except ImportError:
    logger.warning("‚ö†Ô∏è clip_generator.py NOT FOUND. Video processing will not work.")
    def generate_clips_from_video(p, o, n=-1): return []

# --- DATABASE INITIALIZATION ---
@contextmanager
def get_db():
    conn = sqlite3.connect(DB_PATH)
    try:
        yield conn
    finally:
        conn.close()

def init_db():
    with get_db() as conn:
        c = conn.cursor()
        
        # Users
        c.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            nickname TEXT,
            club TEXT,
            xp INTEGER DEFAULT 0,
            monthly_xp INTEGER DEFAULT 0,
            trust_score INTEGER DEFAULT 50,
            noise_score INTEGER DEFAULT 0,
            is_elite BOOLEAN DEFAULT 0,
            streak_days INTEGER DEFAULT 0,
            tags_today INTEGER DEFAULT 0,
            last_tag_date TEXT,
            joined_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')

        # Migration: Add club and monthly_xp if not exists
        try:
            c.execute("ALTER TABLE users ADD COLUMN club TEXT")
        except sqlite3.OperationalError: pass
        try:
            c.execute("ALTER TABLE users ADD COLUMN monthly_xp INTEGER DEFAULT 0")
        except sqlite3.OperationalError: pass

        # Matches
        c.execute('''CREATE TABLE IF NOT EXISTS matches (
            match_id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            status TEXT DEFAULT 'live'
        )''')

        # Clips (Added missing columns from your original code + filename fix)
        c.execute('''CREATE TABLE IF NOT EXISTS clips (
            clip_id INTEGER PRIMARY KEY AUTOINCREMENT,
            match_id INTEGER,
            filename TEXT, 
            qc_stage TEXT DEFAULT 'crowd_voting',
            required_tags INTEGER DEFAULT 3,
            consensus_event TEXT,
            status TEXT DEFAULT 'pending', 
            quality_tag TEXT,
            final_event_type TEXT,
            is_announced BOOLEAN DEFAULT 0,
            is_priority BOOLEAN DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY(match_id) REFERENCES matches(match_id)
        )''')

        # Migration: Add is_announced and is_priority if not exists
        try:
            c.execute("ALTER TABLE clips ADD COLUMN is_announced BOOLEAN DEFAULT 0")
        except sqlite3.OperationalError: pass
        try:
            c.execute("ALTER TABLE clips ADD COLUMN pre_tag TEXT")
        except sqlite3.OperationalError: pass

        # Tags
        c.execute('''CREATE TABLE IF NOT EXISTS tags (
            tag_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            clip_id INTEGER,
            event_type TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            vote_weight REAL DEFAULT 1.0,
            FOREIGN KEY(user_id) REFERENCES users(user_id),
            FOREIGN KEY(clip_id) REFERENCES clips(clip_id)
        )''')

        # Assignments
        c.execute('''CREATE TABLE IF NOT EXISTS clip_assignments (
            assignment_id INTEGER PRIMARY KEY AUTOINCREMENT,
            clip_id INTEGER,
            user_id INTEGER,
            completed BOOLEAN DEFAULT 0,
            assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')

        # Badges
        c.execute('''CREATE TABLE IF NOT EXISTS badges (
            badge_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            badge_type TEXT,
            awarded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')

        conn.commit()
    logger.info("Database initialized successfully.")

# --- HELPER FUNCTIONS ---

def is_admin(user_id: int) -> bool:
    return str(user_id) in ADMIN_IDS

# Stage 1: Rule Validation
def validate_tag_rules(user_id: int, clip_id: int, event_type: str) -> tuple[bool, str]:
    with get_db() as conn:
        c = conn.cursor()
        
        # Spam Check
        c.execute("SELECT timestamp FROM tags WHERE user_id = ? ORDER BY timestamp DESC LIMIT 1", (user_id,))
        last_tag = c.fetchone()

    if last_tag:
        last_time = datetime.strptime(last_tag[0], '%Y-%m-%d %H:%M:%S')
        if (datetime.now() - last_time).total_seconds() < 2:
            return False, "Spam detected: Too fast!"

    # Extended event types for tactical annotation
    valid_events = [
        'Goal', 'KeyPass', 'Pass', 'Defense', 'Press', 'Foul', 'Card', 'Offside', 'None',
        # New tactical events
        'HighPress', 'DefensiveRetreat', 'PositioningError', 'TacticalFoul',
        # Decision quality
        'DecisionCorrect', 'DecisionLate', 'DecisionWrong',
        # Subtypes (Dynamic)
        'Goal_Foot', 'Goal_Head', 'Goal_Penalty', 'Goal_LongShot',
        'Shot_OnTarget', 'Shot_OffTarget', 'Shot_Blocked',
        'Foul_Yellow', 'Foul_Red', 'Foul_None',
        'Pass_Key', 'Pass_Assist', 'Pass_PreAssist',
        'Dribble_1v1', 'Dribble_Progression', 'Dribble_Speed',
        'Duel_Ground', 'Duel_Aerial', 'Duel_50/50',
        'Press_Success', 'Press_ForcedError', 'Press_Passive'
    ]
    if event_type not in valid_events:
        return False, "Invalid event type"
        
    return True, "Valid"

# Stage 2: Crowd Validation (Wisdom of the Crowd)
# Uses 70% agreement threshold among 50-100 fans
CONSENSUS_THRESHOLD = 0.70  # 70% agreement required
MIN_VOTES_FOR_CONSENSUS = 10  # Minimum votes before checking consensus
MAX_VOTES_BEFORE_EXPERT = 50  # Send to experts if no consensus after this many votes

def calculate_crowd_consensus(clip_id: int):
    """
    Calculate consensus using percentage-based agreement.
    - 70%+ agreement ‚Üí confirmed
    - High variance after 50 votes ‚Üí ambiguous, send to experts
    """
    with get_db() as conn:
        conn.execute("BEGIN IMMEDIATE")
        c = conn.cursor()
        
        # Get tags with user trust scores (weighted voting)
        c.execute('''
            SELECT t.event_type, u.trust_score 
            FROM tags t 
            JOIN users u ON t.user_id = u.user_id 
            WHERE t.clip_id = ?
        ''', (clip_id,))
        tags = c.fetchall()
        conn.commit()
    
    if not tags:
        return None, "pending"

    # Weighted vote counting (trust score as weight)
    vote_weights = {}
    total_weight = 0
    total_votes = len(tags)
    
    for event, trust in tags:
        trust = trust if trust else 50
        if trust > 20:  # Filter spammers
            weight = trust / 100  # Normalize to 0-1
            vote_weights[event] = vote_weights.get(event, 0) + weight
            total_weight += weight
    
    if total_weight == 0:
        return None, "pending"
    
    # Check for consensus at 70% threshold
    for event, weight in vote_weights.items():
        percentage = weight / total_weight
        if percentage >= CONSENSUS_THRESHOLD and total_votes >= MIN_VOTES_FOR_CONSENSUS:
            if event == 'None':
                return event, "rejected"
            return event, "confirmed"
    
    # Too much variance after enough votes ‚Üí send to experts
    if total_votes >= MAX_VOTES_BEFORE_EXPERT:
        # Find the top event even if below threshold
        top_event = max(vote_weights.items(), key=lambda x: x[1], default=(None, 0))
        return top_event[0], "ambiguous"  # Marked for expert review
    
    # Still collecting votes
    return None, "crowd_voting"

# Stage 3: Reputation System
def update_trust_score(user_id: int, was_correct: bool, is_spam: bool = False):
    with get_db() as conn:
        c = conn.cursor()
        
        if is_spam:
            c.execute("UPDATE users SET noise_score = noise_score + 10, trust_score = max(0, trust_score - 5) WHERE user_id = ?", (user_id,))
        elif was_correct:
            c.execute("UPDATE users SET trust_score = min(100, trust_score + 1) WHERE user_id = ?", (user_id,))
        else:
            c.execute("UPDATE users SET trust_score = max(0, trust_score - 2) WHERE user_id = ?", (user_id,))
            
        conn.commit()

# Stage 5: Timeline Consistency
def check_timeline_consistency(match_id: int, event_type: str) -> bool:
    with get_db() as conn:
        c = conn.cursor()
        
        c.execute('''
            SELECT final_event_type, created_at 
            FROM clips 
            WHERE match_id = ? AND status = 'confirmed' 
            ORDER BY created_at DESC LIMIT 1
        ''', (match_id,))
        last_event = c.fetchone()
    
    if last_event:
        last_type, _ = last_event
        # Logic: Prevent duplicate goals immediately (Simplified)
        if last_type == 'Goal' and event_type == 'Goal':
            return False 
            
    return True

# Assignment Logic (Fixed SQL Bug)
def ensure_user_exists(user_id: int, username: str = None):
    """Create user if doesn't exist"""
    with get_db() as conn:
        c = conn.cursor()
        c.execute("SELECT user_id FROM users WHERE user_id = ?", (user_id,))
        if not c.fetchone():
            c.execute('''
                INSERT INTO users (user_id, username, trust_score, xp, monthly_xp)
                VALUES (?, ?, 50, 0, 0)
            ''', (user_id, username))
            conn.commit()

def assign_clip_to_user(user_id: int):
    ensure_user_exists(user_id)
    with get_db() as conn:
        c = conn.cursor()
        
        c.execute("SELECT is_elite, trust_score FROM users WHERE user_id = ?", (user_id,))
        user_data = c.fetchone()
        is_elite = user_data[0] if user_data else 0
        trust_score = user_data[1] if user_data else 50
        
        clip = None

        # 1. Elite Review Queue
        if is_elite or trust_score > 80:
            c.execute('''
                SELECT clip_id, filename FROM clips 
                WHERE qc_stage = 'elite_review' 
                AND clip_id NOT IN (SELECT clip_id FROM clip_assignments WHERE user_id = ?)
                LIMIT 1
            ''', (user_id,))
            clip = c.fetchone()

        # 2. Regular Queue
        if not clip:
            # Fixed the SQL Binding Error here (Removed extra user_id)
            c.execute('''
                SELECT c.clip_id, c.filename 
                FROM clips c
                WHERE c.qc_stage = 'crowd_voting'
                AND (SELECT COUNT(*) FROM tags WHERE clip_id = c.clip_id) < c.required_tags
                AND c.clip_id NOT IN (SELECT clip_id FROM clip_assignments WHERE user_id = ?)
                ORDER BY RANDOM()
                LIMIT 1
            ''', (user_id,)) 
            clip = c.fetchone()
        
        if clip:
            c.execute("INSERT INTO clip_assignments (clip_id, user_id) VALUES (?, ?)", (clip[0], user_id))
            conn.commit()
        
        return clip

# Badge System
BADGE_THRESHOLDS = {'Bronze': 100, 'Silver': 500, 'Gold': 2000}

def check_and_award_badges(user_id: int, new_xp: int):
    with get_db() as conn:
        c = conn.cursor()
        
        c.execute("SELECT badge_type FROM badges WHERE user_id = ?", (user_id,))
        existing_badges = {row[0] for row in c.fetchall()}
        
        awarded_badges = []
        for badge_type, threshold in BADGE_THRESHOLDS.items():
            if new_xp >= threshold and badge_type not in existing_badges:
                c.execute("INSERT INTO badges (user_id, badge_type) VALUES (?, ?)", (user_id, badge_type))
                awarded_badges.append(badge_type)
        
        conn.commit()
    return awarded_badges

# Streak System
def update_streak(user_id: int):
    with get_db() as conn:
        c = conn.cursor()
        
        today = datetime.now().date().isoformat()
        yesterday = (datetime.now() - timedelta(days=1)).date().isoformat()
        
        c.execute("SELECT last_tag_date, streak_days, tags_today FROM users WHERE user_id = ?", (user_id,))
        result = c.fetchone()
        
        streak_days = 0
        tags_today = 0
        bonus_xp = 0

        if result:
            last_date, streak_days, tags_today = result
            
            if last_date == today:
                tags_today += 1
            elif last_date == yesterday:
                streak_days += 1
                tags_today = 1
            else:
                streak_days = 1
                tags_today = 1
            
            c.execute('''
                UPDATE users SET last_tag_date = ?, streak_days = ?, tags_today = ? WHERE user_id = ?
            ''', (today, streak_days, tags_today, user_id))
            
            if tags_today == 10:
                bonus_points = 20
                c.execute("UPDATE users SET xp = xp + ?, monthly_xp = monthly_xp + ? WHERE user_id = ?", (bonus_points, bonus_points, user_id))
            
            if streak_days == 7:
                streak_bonus = 50
                c.execute("UPDATE users SET xp = xp + ?, monthly_xp = monthly_xp + ? WHERE user_id = ?", (streak_bonus, streak_bonus, user_id))
                bonus_xp += streak_bonus
                
        conn.commit()
    return streak_days, tags_today, bonus_xp

# --- TELEGRAM HANDLERS ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    context.user_data.clear() # Reset state

    with get_db() as conn:
        c = conn.cursor()
        c.execute("SELECT nickname FROM users WHERE user_id=?", (user.id,))
        result = c.fetchone()

    if result and result[0]:
        # Check for deep link parameters
        if context.args and context.args[0].startswith('tag_'):
            clip_id = int(context.args[0].split('_')[1])
            context.user_data['current_clip_id'] = clip_id
            await start_tagging_specific_clip(update, context, clip_id)
            return

        await update.message.reply_text(f"ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ ŸÖÿ¨ÿØÿØÿßŸãÿå {result[0]}! üëã")
        await show_main_menu(update, context)
    else:
        # Check for deep link parameters even for new users (registration first)
        if context.args and context.args[0].startswith('tag_'):
            context.user_data['pending_tag_clip_id'] = int(context.args[0].split('_')[1])
            
        kb = [[InlineKeyboardButton("ŸÜÿπŸÖÿå ŸÜÿ¨ÿ±ÿ®!", callback_data='join_confirm')]]
        await update.message.reply_text(
            "ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ ŸÅŸä **TactaBot**! üëã\nÿ≠ÿßÿ® ÿ™ÿ¥ÿßÿ±ŸÉ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿßÿ™ÿ¥ÿßÿ™ÿü", 
            reply_markup=InlineKeyboardMarkup(kb), 
            parse_mode='Markdown'
        )

async def get_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Command to get the current chat ID."""
    chat_id = update.effective_chat.id
    logger.info(f"üÜî /get_id called in chat: {chat_id}")
    await update.message.reply_text(f"Current Chat ID: `{chat_id}`", parse_mode='Markdown')

async def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    text = update.message.text
    
    # 1. Nickname Registration
    if context.user_data.get('awaiting_nickname'):
        nickname = text.strip()
        with get_db() as conn:
            c = conn.cursor()
            c.execute("INSERT OR REPLACE INTO users (user_id, username, nickname) VALUES (?, ?, ?)", 
                      (user.id, user.username, nickname))
            conn.commit()
        context.user_data['awaiting_nickname'] = False
        await update.message.reply_text(f"ÿ™ŸÖÿßŸÖ Ÿäÿß **{nickname}**! üõ°Ô∏è")
        
        # Resume pending tag if any
        if context.user_data.get('pending_tag_clip_id'):
            clip_id = context.user_data.pop('pending_tag_clip_id')
            context.user_data['current_clip_id'] = clip_id
            await start_tagging_specific_clip(update, context, clip_id)
            return

        await show_main_menu(update, context)
        return

    # 2. Main Menu
    if text == "‚öΩ ÿßÿ®ÿØÿ£ ÿßŸÑÿ™ÿßÿ∫ŸäŸÜÿ∫":
        await send_clip(update, context)
    elif text == "üèÜ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä":
        await show_leaderboard(update, context)
    elif text == "üìä ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™Ÿä":
        await show_stats(update, context)
    elif text == "üìπ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™":
        if is_admin(user.id): await show_admin_menu(update, context)

# --- BUTTON SETS ---

SPECIFIC_EVENT_BUTTONS = {
    'Goal': [
        [InlineKeyboardButton("ü¶∂ ÿ®ÿßŸÑÿ±ÿ¨ŸÑ", callback_data='tag_Goal_Foot'), 
         InlineKeyboardButton("üë§ ÿ®ÿßŸÑÿ±ÿ£ÿ≥", callback_data='tag_Goal_Head')],
        [InlineKeyboardButton("üéØ ÿ∂ÿ±ÿ®ÿ© ÿ¨ÿ≤ÿßÿ°", callback_data='tag_Goal_Penalty'), 
         InlineKeyboardButton("üöÄ ÿ™ÿ≥ÿØŸäÿØÿ© ÿ®ÿπŸäÿØÿ©", callback_data='tag_Goal_LongShot')]
    ],
    'Shot': [
        [InlineKeyboardButton("‚úÖ ŸÖÿ§ÿ∑ÿ±ÿ©", callback_data='tag_Shot_OnTarget'), 
         InlineKeyboardButton("‚ùå ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÖÿ±ŸÖŸâ", callback_data='tag_Shot_OffTarget')],
        [InlineKeyboardButton("üõ°Ô∏è ŸÖÿ≠ÿ¨Ÿàÿ®ÿ©", callback_data='tag_Shot_Blocked')]
    ],
    'Foul': [
        [InlineKeyboardButton("üü® ÿ®ÿ∑ÿßŸÇÿ© ÿµŸÅÿ±ÿßÿ°", callback_data='tag_Foul_Yellow'), 
         InlineKeyboardButton("üü• ÿ®ÿ∑ÿßŸÇÿ© ÿ≠ŸÖÿ±ÿßÿ°", callback_data='tag_Foul_Red')],
        [InlineKeyboardButton("üö´ ÿ®ÿØŸàŸÜ ÿ®ÿ∑ÿßŸÇÿ©", callback_data='tag_Foul_None')]
    ],
    'Offside': [
        [InlineKeyboardButton("üö© ÿ™ÿ≥ŸÑŸÑ", callback_data='tag_Offside_Yes'), 
         InlineKeyboardButton("üö´ ŸÑÿß ŸäŸàÿ¨ÿØ ÿ™ÿ≥ŸÑŸÑ", callback_data='tag_Offside_No')]
    ],
    'Pass': [
        [InlineKeyboardButton("üéØ ÿ™ŸÖÿ±Ÿäÿ±ÿ© ŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©", callback_data='tag_KeyPass'), 
         InlineKeyboardButton("üöÄ ŸÉÿßÿ≥ÿ±ÿ© ŸÑŸÑÿÆÿ∑Ÿàÿ∑", callback_data='tag_LineBreaker')],
        [InlineKeyboardButton("‚öΩ ÿ™ŸÖÿ±Ÿäÿ±ÿ© ÿπÿßÿØŸäÿ©", callback_data='tag_Pass_Normal')]
    ]
}

DEFAULT_TACTICAL_BUTTONS = [
    [InlineKeyboardButton("üéØ ÿ™ŸÖÿ±Ÿäÿ±ÿ© ŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©", callback_data='tag_KeyPass'), 
     InlineKeyboardButton("üî• ÿ∂ÿ∫ÿ∑ ÿπÿßŸÑŸä", callback_data='tag_HighPress')],
    [InlineKeyboardButton("üõ°Ô∏è ÿ™ÿ±ÿßÿ¨ÿπ ÿØŸÅÿßÿπŸä", callback_data='tag_DefensiveRetreat'), 
     InlineKeyboardButton("‚ö†Ô∏è ÿ∂Ÿäÿßÿπ ÿ™ŸÖÿ±ŸÉÿ≤", callback_data='tag_PositioningError')],
    [InlineKeyboardButton("‚öΩ ŸáÿØŸÅ", callback_data='tag_Goal'), 
     InlineKeyboardButton("üö´ ÿÆÿ∑ÿ£ ÿ™ŸÉÿ™ŸäŸÉŸä", callback_data='tag_TacticalFoul')],
    [InlineKeyboardButton("‚ùå ŸÑÿß ÿ¥Ÿäÿ° Ÿàÿßÿ∂ÿ≠", callback_data='tag_None')]
]

def get_keyboard_for_tag(pre_tag):
    if not pre_tag:
        return DEFAULT_TACTICAL_BUTTONS
    
    keyboard = SPECIFIC_EVENT_BUTTONS.get(pre_tag)
    if keyboard:
        return keyboard
        
    for key in SPECIFIC_EVENT_BUTTONS:
        if key.lower() in pre_tag.lower():
            return SPECIFIC_EVENT_BUTTONS[key]
            
    return DEFAULT_TACTICAL_BUTTONS

async def start_tagging_specific_clip(update: Update, context: ContextTypes.DEFAULT_TYPE, clip_id: int):
    """Start tagging for a specific clip, usually from a broadcast link."""
    user_id = update.effective_user.id
    ensure_user_exists(user_id)
    
    with get_db() as conn:
        c = conn.cursor()
        c.execute("SELECT filename, pre_tag FROM clips WHERE clip_id = ?", (clip_id,))
        clip_data = c.fetchone()
        
        if not clip_data:
            await update.message.reply_text("‚ùå ÿßŸÑŸÑŸÇÿ∑ÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©")
            return
            
        filename, pre_tag = clip_data
        # Record assignment if not exists
        c.execute("INSERT OR IGNORE INTO clip_assignments (clip_id, user_id) VALUES (?, ?)", (clip_id, user_id))
        conn.commit()

    video_path = os.path.join(CLIPS_DIR, filename)
    
    keyboard = get_keyboard_for_tag(pre_tag)
    
    caption = f"üé¨ ŸÑŸÇÿ∑ÿ© ŸÖŸÜ ŸÖÿ®ÿßÿ±ÿßÿ© {filename[:20]}...\n\n"
    if pre_tag:
        caption += f"üîé ÿßŸÑŸÖÿ≠ŸÑŸÑ ÿ¥ÿßŸÅŸáÿß **{pre_tag}**.\n**ÿ≠ÿØŸëÿØ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ:**"
    else:
        caption += "**Ÿàÿ¥ ÿ¥ŸÅÿ™ÿü**"
    
    if os.path.exists(video_path):
        try:
            with open(video_path, 'rb') as v:
                # If we have a callback query, we can't reply_video directly to the channel message easily
                # but we can send a NEW message to the user/group
                await update.effective_message.reply_video(
                    video=v, 
                    caption=caption, 
                    reply_markup=InlineKeyboardMarkup(keyboard), 
                    parse_mode='Markdown'
                )
        except Exception as e:
            logger.error(f"Error sending specific video: {e}")
            await update.effective_message.reply_text("ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅŸäÿØŸäŸà.")
    else:
        await update.effective_message.reply_text(f"‚ùå ÿßŸÑŸÅŸäÿØŸäŸà ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ.")

async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    kb = [["‚öΩ ÿßÿ®ÿØÿ£ ÿßŸÑÿ™ÿßÿ∫ŸäŸÜÿ∫", "üèÜ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä"], ["üìä ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™Ÿä"]]
    if is_admin(update.effective_user.id):
        kb.append(["üìπ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™"])
    await update.message.reply_text("ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©:", reply_markup=ReplyKeyboardMarkup(kb, resize_keyboard=True))

async def send_clip(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    clip = assign_clip_to_user(user_id)
    
    msg = update.callback_query.message if update.callback_query else update.message

    if not clip:
        await msg.reply_text("üéâ ŸÖÿ®ÿ±ŸàŸÉ! ŸÉŸÖŸÑÿ™ ŸÉŸÑ ÿßŸÑŸÑŸÇÿ∑ÿßÿ™ ÿßŸÑŸÖÿ™ŸàŸÅÿ±ÿ©.")
        return

    clip_id, filename, pre_tag = clip # Fixed: Uses filename and pre_tag
    context.user_data['current_clip_id'] = clip_id
    
    # Path construction fix
    video_path = os.path.join(CLIPS_DIR, filename)
    
    keyboard = get_keyboard_for_tag(pre_tag)
    
    caption = "üé¨ ÿ¥ŸàŸÅ ÿßŸÑŸÑŸÇÿ∑ÿ©\n\n"
    if pre_tag:
        caption += f"üîé ÿßŸÑŸÖÿ≠ŸÑŸÑ ÿ¥ÿßŸÅŸáÿß **{pre_tag}**.\n**ÿ≠ÿØŸëÿØ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ:**"
    else:
        caption += "**Ÿàÿ¥ ÿ¥ŸÅÿ™ÿü**"
    
    if os.path.exists(video_path):
        try:
            with open(video_path, 'rb') as v:
                await msg.reply_video(video=v, caption=caption, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
        except Exception as e:
            logger.error(f"Error sending video: {e}")
            await msg.reply_text("ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅŸäÿØŸäŸà.")
    else:
        # Fallback if file missing
        await msg.reply_text(f"‚ùå ÿßŸÑŸÅŸäÿØŸäŸà ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ: {filename}")
        with get_db() as conn:
            conn.execute("UPDATE clip_assignments SET completed=1 WHERE clip_id=? AND user_id=?", (clip_id, user_id))
            conn.commit()
        await send_clip(update, context)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == 'join_confirm':
        context.user_data['awaiting_nickname'] = True
        await query.edit_message_text("ŸÖŸÑŸäÿ≠! ÿßÿπÿ∑ŸäŸÜŸä **ÿßÿ≥ŸÖ ÿßŸÑÿπÿ±ÿ∂** (Nickname).", parse_mode='Markdown')
        
    elif query.data.startswith('tag_'):
        event = query.data.split('_', 1)[1]  # Handle multi-word events like DefensiveRetreat
        await handle_tag_logic(update, context, event)
        
    elif query.data.startswith('start_tag_'):
        clip_id = int(query.data.split('_')[-1])
        context.user_data['current_clip_id'] = clip_id
        await start_tagging_specific_clip(update, context, clip_id)
        
    elif query.data.startswith('decision_'):
        # Step 2: Decision quality response
        decision = query.data.split('_', 1)[1]
        await handle_decision_quality(update, context, decision)
        
    elif query.data == 'skip_decision':
        # Skip decision quality question
        context.user_data.pop('pending_decision_clip', None)
        await query.message.edit_caption(caption="‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ≠ÿØÿ´!")
        await send_clip(update, context)
        
    elif query.data == 'admin_scan':
        await scan_local_files(update, context)
        
    elif query.data == 'admin_upload_prompt':         await query.edit_message_text("üì§ ÿ£ÿ±ÿ≥ŸÑ ŸÖŸÑŸÅ ÿßŸÑŸÅŸäÿØŸäŸà ÿßŸÑÿ¢ŸÜ.")
        
    elif query.data.startswith('club_'):
        club = query.data.split('_')[1]
        user_id = query.effective_user.id
        with get_db() as conn:
            c = conn.cursor()
            c.execute("UPDATE users SET club = ? WHERE user_id = ?", (club, user_id))
            conn.commit()
        
        group_id = CLUB_GROUPS.get(club)
        msg = f"ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ŸÜÿßÿØŸä **{club}**! üõ°Ô∏è"
        if group_id:
            # Try to get invite link or just mention the group
            msg += f"\n\nŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ŸÖÿ¨ŸÖŸàÿπÿ© ÿßŸÑŸÖÿ≠ŸÑŸÑŸäŸÜ ÿßŸÑÿÆÿßÿµÿ© ÿ®ŸÜÿßÿØŸäŸÉ ŸáŸÜÿß: [ŸÖÿ¨ŸÖŸàÿπÿ© {club}](https://t.me/{group_id})"
        
        await query.edit_message_text(msg, parse_mode='Markdown', disable_web_page_preview=True)

    elif query.data.startswith('process_video_'):
        idx = int(query.data.split('_')[-1])
        files = context.user_data.get('video_files', [])
        if idx < len(files):
            file_path = os.path.join(UPLOADS_DIR, files[idx])
            await query.edit_message_text(f"ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©: {files[idx]}...")


# Events that trigger the decision quality question
DECISION_EVENTS = ['KeyPass', 'HighPress', 'DefensiveRetreat', 'TacticalFoul', 'PositioningError']

async def handle_decision_quality(update: Update, context: ContextTypes.DEFAULT_TYPE, decision: str):
    """Handle the second step - decision quality assessment."""
    user_id = update.effective_user.id
    clip_id = context.user_data.get('pending_decision_clip')
    
    if not clip_id:
        await update.callback_query.answer("‚ö†Ô∏è ŸÑÿß ŸäŸàÿ¨ÿØ ÿ≠ÿØÿ´ ŸÖÿπŸÑŸÇ", show_alert=True)
        return
    
    # Save decision quality as a separate tag
    with get_db() as conn:
        c = conn.cursor()
        c.execute("INSERT INTO tags (user_id, clip_id, event_type) VALUES (?, ?, ?)", 
                  (user_id, clip_id, f"Decision{decision}"))
        c.execute("UPDATE users SET xp = xp + 1, monthly_xp = monthly_xp + 1 WHERE user_id = ?", (user_id,))
        conn.commit()
    
    context.user_data.pop('pending_decision_clip', None)
    
    await update.callback_query.answer("ÿ¥ŸÉÿ±ÿßŸã! +1 XP üéØ")
    await update.callback_query.message.edit_caption(caption=f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ: ÿßŸÑŸÇÿ±ÿßÿ± ŸÉÿßŸÜ {decision}")
    await send_clip(update, context)

async def handle_tag_logic(update: Update, context: ContextTypes.DEFAULT_TYPE, event: str):
    user_id = update.effective_user.id
    username = update.effective_user.username
    clip_id = context.user_data.get('current_clip_id')
    
    # Ensure user exists in DB before processing
    ensure_user_exists(user_id, username)
    
    # 1. Rules
    is_valid, reason = validate_tag_rules(user_id, clip_id, event)
    if not is_valid:
        await update.callback_query.answer(f"‚ùå {reason}", show_alert=True)
        if "Spam" in reason: update_trust_score(user_id, False, True)
        return

    # 2. Save & 3. Base XP (Atomic Transaction)
    with get_db() as conn:
        c = conn.cursor()
        # All updates in ONE transaction
        c.execute("INSERT INTO tags (user_id, clip_id, event_type) VALUES (?, ?, ?)", (user_id, clip_id, event))
        c.execute("UPDATE clip_assignments SET completed=1 WHERE clip_id=? AND user_id=?", (clip_id, user_id))
        
        xp_gain = 10  # Supporter analyse 1 clip ‚Üí +10 points
        c.execute("UPDATE users SET xp = xp + ?, monthly_xp = monthly_xp + ? WHERE user_id = ?", (xp_gain, xp_gain, user_id))
        
        c.execute("SELECT xp FROM users WHERE user_id = ?", (user_id,))
        row = c.fetchone()
        new_xp = row[0] if row else 0
        conn.commit()

    # 4. Streak & Badges
    streak, _, bonus = update_streak(user_id)
    new_badges = check_and_award_badges(user_id, new_xp)
    if bonus: xp_gain += bonus
    
    msg = f"ÿ™ŸÖ! +{xp_gain} XP"
    if new_badges: msg += f"\nüéâ ÿ¥ÿßÿ±ÿ© ÿ¨ÿØŸäÿØÿ©: {', '.join(new_badges)}"
    await update.callback_query.answer(msg)
    
    # Check if this event needs a follow-up decision quality question
    if event in DECISION_EVENTS:
        # Step 2: Ask about decision quality
        context.user_data['pending_decision_clip'] = clip_id
        decision_keyboard = [
            [InlineKeyboardButton("‚úÖ ÿµÿ≠Ÿäÿ≠", callback_data='decision_Correct'),
             InlineKeyboardButton("‚è∞ ŸÖÿ™ÿ£ÿÆÿ±", callback_data='decision_Late'),
             InlineKeyboardButton("‚ùå ÿÆÿßÿ∑ÿ¶", callback_data='decision_Wrong')],
            [InlineKeyboardButton("‚è≠Ô∏è ÿ™ÿÆÿ∑Ÿä", callback_data='skip_decision')]
        ]
        await update.callback_query.message.edit_caption(
            caption=f"ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ: **{event}**\n\n**ÿßŸÑŸÇÿ±ÿßÿ± ŸÉÿßŸÜÿü**",
            reply_markup=InlineKeyboardMarkup(decision_keyboard),
            parse_mode='Markdown'
        )
        return  # Don't send next clip yet
    
    try:
        # Display localized message for the selected event
        display_event = event.replace('_', ' ')
        await update.callback_query.message.edit_caption(caption=f"‚úÖ ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ: {display_event}")
    except Exception as e:
        # Ignore "Message is not modified" errors (e.g. clicking same button twice)
        if "Message is not modified" not in str(e):
            logger.error(f"Error editing caption: {e}")

    # 5. Consensus
    cons_event, status = calculate_crowd_consensus(clip_id)
    if status in ['confirmed', 'rejected']:
        with get_db() as conn:
            c = conn.cursor()
            
            # Timeline Check
            c.execute("SELECT match_id FROM clips WHERE clip_id=?", (clip_id,))
            match_id = c.fetchone()[0]
            consistent = check_timeline_consistency(match_id, cons_event)
            
            if not consistent: status = 'ambiguous'
            
            c.execute("UPDATE clips SET consensus_event=?, status=?, qc_stage='finalized' WHERE clip_id=?", (cons_event, status, clip_id))
            
            # Trust Update (Retroactive)
            c.execute("SELECT user_id, event_type FROM tags WHERE clip_id=?", (clip_id,))
            for uid, etype in c.fetchall():
                correct = (etype == cons_event)
                update_trust_score(uid, correct)
                
                if correct:
                    # Vote = majorit√© ‚Üí +5 points bonus
                    bonus = 5
                    c.execute("UPDATE users SET xp = xp + ?, monthly_xp = monthly_xp + ? WHERE user_id = ?", (bonus, bonus, uid))
                
            conn.commit()

    await send_clip(update, context)

# --- ADMIN VIDEO LOGIC ---

async def show_admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    kb = [
        [InlineKeyboardButton("üìÇ Scan Files", callback_data='admin_scan')],
        [InlineKeyboardButton("üì§ Upload Video", callback_data='admin_upload_prompt')]
    ]
    await update.message.reply_text("ŸÑŸàÿ≠ÿ© ÿßŸÑÿ£ÿØŸÖŸÜ:", reply_markup=InlineKeyboardMarkup(kb))

async def handle_video_upload(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id): return
    
    video = update.message.video or update.message.document
    if not video: return

    # Validate file size (Telegram limit is 50MB for bots, but check anyway)
    if video.file_size > 50 * 1024 * 1024:  # 50MB
        await update.message.reply_text("‚ùå ÿßŸÑŸÖŸÑŸÅ ŸÉÿ®Ÿäÿ± ÿ¨ÿØÿßŸã (ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ 50MB)")
        return
    
    # Validate file type
    if video.mime_type and not video.mime_type.startswith('video/'):
        await update.message.reply_text("‚ùå Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ŸÖŸÑŸÅ ŸÅŸäÿØŸäŸà")
        return

    progress_msg = await update.message.reply_text("üì• ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ... 0%")
    
    try:
        file_id = video.file_id
        new_file = await context.bot.get_file(file_id)
        
        save_path = os.path.join(UPLOADS_DIR, f"video_{file_id}.mp4")
        
        # Download with timeout
        await asyncio.wait_for(
            new_file.download_to_drive(save_path),
            timeout=300  # 5 minutes max
        )
        
        await progress_msg.edit_text("‚úÖ ÿ™ŸÖ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ! ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©...")
        await process_video_async(update, save_path)
        
    except asyncio.TimeoutError:
        await progress_msg.edit_text("‚ùå ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÖŸáŸÑÿ© - ÿßŸÑŸÖŸÑŸÅ ŸÉÿ®Ÿäÿ± ÿ¨ÿØÿßŸã")
    except Exception as e:
        logger.error(f"Upload error: {e}")
        await progress_msg.edit_text("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ")

async def scan_local_files(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update.effective_user.id): return
    files = [f for f in os.listdir(UPLOADS_DIR) if f.endswith('.mp4')]
    
    if not files:
        await update.effective_message.reply_text("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖŸÑŸÅÿßÿ™.")
        return
        
    context.user_data['video_files'] = files
    kb = []
    for i, f in enumerate(files):
        kb.append([InlineKeyboardButton(f[:30], callback_data=f'process_video_{i}')])
    await update.effective_message.reply_text("ÿßÿÆÿ™ÿ± ŸÖŸÑŸÅ:", reply_markup=InlineKeyboardMarkup(kb))

async def process_video_async(update: Update, file_path: str):
    msg = update.effective_message or update.callback_query.message
    await msg.reply_text("‚öôÔ∏è ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ŸÇÿ∑Ÿäÿπ (ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©)...")
    
    loop = asyncio.get_running_loop()
    try:
    # Non-blocking Execution
        clips = await loop.run_in_executor(None, generate_clips_from_video, file_path, CLIPS_DIR, -1)
        
        if clips:
            with get_db() as conn:
                c = conn.cursor()
                match_name = f"Match {os.path.basename(file_path)[:10]}"
                c.execute("INSERT INTO matches (name) VALUES (?)", (match_name,))
                match_id = c.lastrowid
                
                count = 0
                for cp in clips:
                    fname = os.path.basename(cp) # Store filename only
                    c.execute("INSERT INTO clips (match_id, filename) VALUES (?, ?)", (match_id, fname))
                    count += 1
                conn.commit()
            await msg.reply_text(f"‚úÖ ÿ™ŸÖ! {count} ŸÑŸÇÿ∑ÿ©.")
        else:
            await msg.reply_text("‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ£Ÿä ŸÑŸÇÿ∑ÿßÿ™.")
    except Exception as e:
        logger.error(f"Process error: {e}")
        await msg.reply_text("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©.")

# --- STATS DISPLAY ---

async def show_leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    with get_db() as conn:
        c = conn.cursor()
        # Overall
        c.execute("SELECT nickname, xp FROM users ORDER BY xp DESC LIMIT 10")
        rows_all = c.fetchall()
        
        # Monthly
        c.execute("SELECT nickname, monthly_xp FROM users ORDER BY monthly_xp DESC LIMIT 10")
        rows_month = c.fetchall()
    
    txt = "üèÜ **ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿπÿßŸÖ (Top 10):**\n" + "\n".join([f"{i+1}. {r[0]} ({r[1]} XP)" for i,r in enumerate(rows_all)])
    txt += "\n\nüìÖ **ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿ¥Ÿáÿ±Ÿä (Top 10):**\n" + "\n".join([f"{i+1}. {r[0]} ({r[1]} XP)" for i,r in enumerate(rows_month)])
    
    await update.message.reply_text(txt, parse_mode='Markdown')

def award_monthly_badges():
    """Awads 'Analyste Or' to Top 10 monthly contributors and resets monthly_xp."""
    with get_db() as conn:
        c = conn.cursor()
        # Get Top 10
        c.execute("SELECT user_id FROM users ORDER BY monthly_xp DESC LIMIT 10")
        top_users = c.fetchall()
        
        for (uid,) in top_users:
            # Check if already has it for this month (simplified, just award it)
            c.execute("INSERT INTO badges (user_id, badge_type) VALUES (?, ?)", (uid, "Analyste Or"))
        
        # Reset monthly XP
        c.execute("UPDATE users SET monthly_xp = 0")
        conn.commit()

async def show_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    with get_db() as conn:
        c = conn.cursor()
        c.execute("SELECT nickname, xp, streak_days, trust_score, accuracy, club, monthly_xp FROM users LEFT JOIN (SELECT user_id, 0 as accuracy FROM users) USING(user_id) WHERE user_id=?", (uid,))
        data = c.fetchone()
        c.execute("SELECT badge_type FROM badges WHERE user_id=?", (uid,))
        badges = [b[0] for b in c.fetchall()]
    
        if data:
            reward_status = "‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖŸÉÿßŸÅÿ¢ÿ™ ÿ®ÿπÿØ"
            if data[1] >= 10000: reward_status = "üéÅ ÿØÿπŸàÿ© VIP ŸÑŸÖÿ®ÿßÿ±ÿßÿ© (ÿ™ŸÖ ÿßŸÑŸÅŸàÿ≤!)"
            elif data[1] >= 5000: reward_status = "üîì Early Access (ÿ™ŸÖ ÿßŸÑŸÅŸàÿ≤!)"
            elif data[1] >= 1000: reward_status = "üìú ÿ¥ŸáÿßÿØÿ© ÿ±ŸÇŸÖŸäÿ© FAF (ÿ™ŸÖ ÿßŸÑŸÅŸàÿ≤!)"
            
            txt = (f"üë§ **{data[0]}**\n"
                   f"üèÅ ÿßŸÑŸÜÿßÿØŸä: {data[5] if data[5] else 'ŸÑŸÖ ŸäÿÆÿ™ÿ± ÿ®ÿπÿØ'}\n"
                   f"‚≠ê XP ÿßŸÑŸÉŸÑŸä: {data[1]}\n"
                   f"üóìÔ∏è XP ÿßŸÑÿ¥Ÿáÿ±: {data[6]}\n"
                   f"üî• Streak: {data[2]}\n"
                   f"üõ°Ô∏è Trust: {data[3]}\n"
                   f"üèÖ Badges: {', '.join(badges) if badges else 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ'}\n"
                   f"üéÅ ÿßŸÑŸÖŸÉÿßŸÅÿ£ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©: {reward_status}")
            await update.message.reply_text(txt, parse_mode='Markdown')

# --- PHASE 3: CLUBS & GROUPS ---

CLUB_GROUPS = {
    "MCA": os.getenv("MCA_GROUP_ID"),
    "CRB": os.getenv("CRB_GROUP_ID"),
    "ESS": os.getenv("ESS_GROUP_ID")
}

async def choisir_club(update: Update, context: ContextTypes.DEFAULT_TYPE):
    kb = [
        [InlineKeyboardButton("MCA (Mouloudia d'Alger)", callback_data='club_MCA')],
        [InlineKeyboardButton("CRB (CR Belouizdad)", callback_data='club_CRB')],
        [InlineKeyboardButton("ESS (ES S√©tif)", callback_data='club_ESS')]
    ]
    await update.message.reply_text("ÿßÿÆÿ™ÿ± ŸÜÿßÿØŸäŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑ ŸÑŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ŸÖÿ¨ŸÖŸàÿπÿ™Ÿá ÿßŸÑÿÆÿßÿµÿ©:", reply_markup=InlineKeyboardMarkup(kb))

async def show_club_competition(update: Update, context: ContextTypes.DEFAULT_TYPE):
    with get_db() as conn:
        c = conn.cursor()
        c.execute('''
            SELECT club, SUM(xp) as total_xp, COUNT(user_id) as members 
            FROM users 
            WHERE club IS NOT NULL 
            GROUP BY club 
            ORDER BY total_xp DESC
        ''')
        rows = c.fetchall()
    
    if not rows:
        await update.message.reply_text("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖŸÜÿßŸÅÿ≥ÿßÿ™ ÿ≠ÿßŸÑŸäÿßŸã. ÿßÿÆÿ™ÿ± ŸÜÿßÿØŸäŸÉ Ÿàÿßÿ®ÿØÿ£ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ!")
        return
        
    txt = "üèÅ **ŸÖŸÜÿßŸÅÿ≥ÿ© ÿßŸÑÿ£ŸÜÿØŸäÿ© (Ranking):**\n\n"
    for i, (club, xp, members) in enumerate(rows):
        txt += f"{i+1}. {club}: {xp} XP ({members} ÿπÿ∂Ÿà) üë§\n"
    
    await update.message.reply_text(txt, parse_mode='Markdown')

# --- BACKGROUND JOBS ---

async def check_for_new_clips(context: ContextTypes.DEFAULT_TYPE):
    """Periodically check for clips that haven't been announced yet."""
    if not ANNOUNCEMENT_CHAT_ID:
        logger.warning("üö´ ANNOUNCEMENT_CHAT_ID not set. Skipping proactive notifications.")
        return

    logger.info(f"üîç Checking for new clips to announce (Chat ID: {ANNOUNCEMENT_CHAT_ID})")
    try:
        with get_db() as conn:
            c = conn.cursor()
            # 1. Check for PRIORITY clips first
            c.execute('''
                SELECT c.clip_id, c.filename, m.name, c.pre_tag 
                FROM clips c
                JOIN matches m ON c.match_id = m.match_id
                WHERE c.is_announced = 0 AND c.status = 'pending' AND c.is_priority = 1
                ORDER BY c.clip_id ASC
            ''')
            priority_clips = c.fetchall()
            
            if priority_clips:
                logger.info(f"üî• PRIORITY clips found: {len(priority_clips)}. Suspending regular queue.")
                new_clips = priority_clips[:1] # ONLY send the first priority one to satisfy "Only it" requirement
            else:
                # 2. Otherwise send regular clips
                c.execute('''
                    SELECT c.clip_id, c.filename, m.name, c.pre_tag 
                    FROM clips c
                    JOIN matches m ON c.match_id = m.match_id
                    WHERE c.is_announced = 0 AND c.status = 'pending'
                    ORDER BY c.clip_id ASC
                    LIMIT 2
                ''')
                new_clips = c.fetchall()
            
            if not new_clips:
                logger.info("‚ÑπÔ∏è No new clips to announce.")
                return
            announced_count = 0
            for clip_id, filename, match_name, pre_tag in new_clips:
                if announced_count >= 5: # Limit announcements per cycle to avoid spamming
                    break

                video_path = os.path.join(CLIPS_DIR, filename)
                if not os.path.exists(video_path):
                    # Don't log individual missing files if there are many, just keep track
                    c.execute("UPDATE clips SET is_announced = 1 WHERE clip_id = ?", (clip_id,))
                    continue

                # Deep link to bot for private tagging
                bot_info = await context.bot.get_me()
                deep_link = f"https://t.me/{bot_info.username}?start=tag_{clip_id}"
                
                keyboard = [
                    [InlineKeyboardButton("üéØ ÿ≠ŸÑŸÑ Ÿáÿ∞Ÿá ÿßŸÑŸÑŸÇÿ∑ÿ©", url=deep_link)]
                ]
                
                logger.info(f"üì§ Sending clip {clip_id} ({filename}) to {ANNOUNCEMENT_CHAT_ID}...")
                try:
                    caption_text = f"‚öΩ **ŸÑŸÇÿ∑ÿ© ÿ¨ÿØŸäÿØÿ© ŸÑŸÑÿ™ÿ≠ŸÑŸäŸÑ!**\nüèüÔ∏è ÿßŸÑŸÖÿ®ÿßÿ±ÿßÿ©: {match_name}\n"
                    if pre_tag:
                        caption_text = f"‚öΩ **ÿ™ÿ≠ŸÑŸäŸÑ {pre_tag}!**\nüèüÔ∏è ÿßŸÑŸÖÿ®ÿßÿ±ÿßÿ©: {match_name}\n"
                    
                    caption_text += "\nÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑÿ≤ÿ± ÿ™ÿ≠ÿ™ ÿ®ÿßÿ¥ ÿ™ÿ®ÿØÿ£ ÿßŸÑÿ™ÿßÿ∫ŸäŸÜÿ∫ üëá"

                    await context.bot.send_video(
                        chat_id=ANNOUNCEMENT_CHAT_ID,
                        video=open(video_path, 'rb'),
                        caption=caption_text,
                        reply_markup=InlineKeyboardMarkup(keyboard),
                        parse_mode='Markdown'
                    )
                    c.execute("UPDATE clips SET is_announced = 1 WHERE clip_id = ?", (clip_id,))
                    logger.info(f"‚úÖ Successfully broadcasted clip {clip_id}")
                    announced_count += 1
                except Exception as e:
                    logger.error(f"‚ùå Error broadcasting clip {clip_id}: {e}")
            
            conn.commit()
    except Exception as e:
        logger.error(f"‚ùå Database error in check_for_new_clips: {e}")

# --- MAIN ---
if __name__ == '__main__':
    if not TOKEN:
        print("‚ùå TELEGRAM_BOT_TOKEN missing!")
        exit(1)
        
    init_db()
    
    # Fix for TimedOut/RuntimeError
    from telegram.request import HTTPXRequest
    request = HTTPXRequest(connect_timeout=20, read_timeout=20)
    app = ApplicationBuilder().token(TOKEN).request(request).build()
    
    # Register background jobs
    if app.job_queue:
        app.job_queue.run_repeating(check_for_new_clips, interval=30, first=10)
        logger.info("‚è∞ JobQueue started: checking for new clips every 30s")
    else:
        logger.warning("‚ö†Ô∏è JobQueue not available. Proactive notifications disabled.")

    app.add_handler(CommandHandler('start', start))
    app.add_handler(CommandHandler('get_id', get_id))
    app.add_handler(CommandHandler('scan', scan_local_files))
    app.add_handler(CommandHandler('choisir_club', choisir_club))
    app.add_handler(CommandHandler('competition_clubs', show_club_competition))
    app.add_handler(CommandHandler('reset_mois', lambda u, c: award_monthly_badges() if is_admin(u.effective_user.id) else None))
    app.add_handler(CallbackQueryHandler(button_handler))
    app.add_handler(MessageHandler(filters.VIDEO | filters.Document.VIDEO, handle_video_upload))
    app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), message_handler))
    
    print("üöÄ TactaBot Full Version Running...")
    app.run_polling()
</file>

<file path="python/team_assigner/__init__.py">
from .team_assigner import TeamAssigner
</file>

<file path="python/team_assigner/team_assigner.py">
from sklearn.cluster import KMeans
import numpy as np

class TeamAssigner:
    def __init__(self):
        self.team_colors = {}
        self.player_team_dict = {}
    
    def get_clustering_model(self,image):
        # Reshape the image to 2D array
        image_2d = image.reshape(-1,3)

        # Preform K-means with 2 clusters
        kmeans = KMeans(n_clusters=2, init="k-means++",n_init=1)
        kmeans.fit(image_2d)

        return kmeans

    def get_player_color(self,frame,bbox):
        image = frame[int(bbox[1]):int(bbox[3]),int(bbox[0]):int(bbox[2])]

        top_half_image = image[0:int(image.shape[0]/2),:]

        # Get Clustering model
        kmeans = self.get_clustering_model(top_half_image)

        # Get the cluster labels forr each pixel
        labels = kmeans.labels_

        # Reshape the labels to the image shape
        clustered_image = labels.reshape(top_half_image.shape[0],top_half_image.shape[1])

        # Get the player cluster
        corner_clusters = [clustered_image[0,0],clustered_image[0,-1],clustered_image[-1,0],clustered_image[-1,-1]]
        non_player_cluster = max(set(corner_clusters),key=corner_clusters.count)
        player_cluster = 1 - non_player_cluster

        player_color = kmeans.cluster_centers_[player_cluster]

        return player_color


    def assign_team_color(self,frame, player_detections):
        
        player_colors = []
        for _, player_detection in player_detections.items():
            bbox = player_detection["bbox"]
            player_color =  self.get_player_color(frame,bbox)
            player_colors.append(player_color)
        
        kmeans = KMeans(n_clusters=2, init="k-means++",n_init=10)
        kmeans.fit(player_colors)

        self.kmeans = kmeans

        self.team_colors[1] = kmeans.cluster_centers_[0]
        self.team_colors[2] = kmeans.cluster_centers_[1]

    def set_fixed_team_colors(self, color1, color2):
        """Set fixed colors and initialize a dummy kmeans to allow prediction."""
        self.team_colors[1] = np.array(color1)
        self.team_colors[2] = np.array(color2)
        
        # Create a dummy KMeans to satisfy predictability
        self.kmeans = KMeans(n_clusters=2, init=np.array([color1, color2]), n_init=1)
        self.kmeans.fit(np.array([color1, color2]))


    def get_player_team(self,frame,player_bbox,player_id):
        if player_id in self.player_team_dict:
            return self.player_team_dict[player_id]

        player_color = self.get_player_color(frame,player_bbox)

        team_id = self.kmeans.predict(player_color.reshape(1,-1))[0]
        team_id+=1

        if player_id ==91:
            team_id=1

        self.player_team_dict[player_id] = team_id

        return team_id
</file>

<file path="python/test_pass_detection.py">
import os
import logging
import sqlite3
import asyncio
from datetime import datetime, timedelta
from typing import Optional, Tuple, List, Dict, Any
from contextlib import contextmanager

# Third-party imports
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder, 
    ContextTypes, 
    CommandHandler, 
    MessageHandler, 
    filters, 
    CallbackQueryHandler
)

# --- CONFIGURATION & ENVIRONMENT ---
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass

# --- LOGGING SETUP ---
# Detailed logging configuration for debugging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('tactabot.log'), # Save logs to file
        logging.StreamHandler()              # Print logs to console
    ]
)
logger = logging.getLogger(__name__)

# --- CONSTANTS & SETTINGS ---
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
# Parse Admin IDs from .env string (e.g., "123,456")
ADMIN_IDS = [x.strip() for x in os.getenv("ADMIN_IDS", "").split(",") if x.strip()]

# XP & Gamification Settings
XP_TAG_BASE = 1
XP_TAG_CORRECT = 5
XP_DAILY_BONUS = 20
DAILY_TAG_THRESHOLD = 10
SPAM_COOLDOWN_SECONDS = 2.0
CONSENSUS_THRESHOLD = 3
TRUST_THRESHOLD_VOTE = 20

# Valid Event Types
VALID_EVENTS = [
    'Goal', 'KeyPass', 'Pass', 'Defense', 
    'Press', 'Foul', 'Card', 'Offside', 'None'
]

# Badge Thresholds
BADGE_THRESHOLDS = {
    'Bronze': 100,
    'Silver': 500,
    'Gold': 2000,
    'Platinum': 5000,
    'Diamond': 10000
}

# --- DYNAMIC PATHS (Fixes FileNotFound Errors) ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(BASE_DIR, 'tactabot.db')
UPLOADS_DIR = os.path.join(BASE_DIR, '..', 'public', 'uploads')
CLIPS_DIR = os.path.join(BASE_DIR, '..', 'public', 'clips')

# Ensure required directories exist
for directory in [UPLOADS_DIR, CLIPS_DIR]:
    os.makedirs(directory, exist_ok=True)

# --- CLIP GENERATOR IMPORT ---
try:
    from clip_generator import generate_clips_from_video
    CLIP_GENERATOR_AVAILABLE = True
except ImportError:
    logger.warning("‚ö†Ô∏è clip_generator.py NOT FOUND. Video processing will be disabled.")
    CLIP_GENERATOR_AVAILABLE = False
    def generate_clips_from_video(p, o, n=-1): return []

# --- DATABASE MANAGEMENT ---

@contextmanager
def get_db_connection():
    """Context manager for safe database connections."""
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row  # Allows accessing columns by name
    try:
        yield conn
        conn.commit()
    except Exception as e:
        conn.rollback()
        logger.error(f"‚ùå Database Transaction Error: {e}")
        raise
    finally:
        conn.close()

def init_db():
    """Initialize the database with the complete schema."""
    with get_db_connection() as conn:
        c = conn.cursor()
        
        # 1. Users Table
        c.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            nickname TEXT,
            xp INTEGER DEFAULT 0,
            trust_score INTEGER DEFAULT 50,
            noise_score INTEGER DEFAULT 0,
            is_elite BOOLEAN DEFAULT 0,
            streak_days INTEGER DEFAULT 0,
            tags_today INTEGER DEFAULT 0,
            last_tag_date TEXT,
            total_tags INTEGER DEFAULT 0,
            correct_tags INTEGER DEFAULT 0,
            joined_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')

        # 2. Matches Table
        c.execute('''CREATE TABLE IF NOT EXISTS matches (
            match_id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            status TEXT DEFAULT 'live',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')

        # 3. Clips Table (Using 'filename' instead of 'video_path')
        c.execute('''CREATE TABLE IF NOT EXISTS clips (
            clip_id INTEGER PRIMARY KEY AUTOINCREMENT,
            match_id INTEGER NOT NULL,
            filename TEXT NOT NULL,
            qc_stage TEXT DEFAULT 'crowd_voting',
            required_tags INTEGER DEFAULT 3,
            consensus_event TEXT,
            status TEXT DEFAULT 'pending',
            quality_tag TEXT,
            final_event_type TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            finalized_at TIMESTAMP,
            FOREIGN KEY(match_id) REFERENCES matches(match_id) ON DELETE CASCADE
        )''')

        # 4. Tags Table
        c.execute('''CREATE TABLE IF NOT EXISTS tags (
            tag_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            clip_id INTEGER NOT NULL,
            event_type TEXT NOT NULL,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            vote_weight REAL DEFAULT 1.0,
            is_correct BOOLEAN DEFAULT NULL,
            FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE,
            FOREIGN KEY(clip_id) REFERENCES clips(clip_id) ON DELETE CASCADE
        )''')

        # 5. Clip Assignments Table
        c.execute('''CREATE TABLE IF NOT EXISTS clip_assignments (
            assignment_id INTEGER PRIMARY KEY AUTOINCREMENT,
            clip_id INTEGER NOT NULL,
            user_id INTEGER NOT NULL,
            completed BOOLEAN DEFAULT 0,
            assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY(clip_id) REFERENCES clips(clip_id) ON DELETE CASCADE,
            FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE,
            UNIQUE(clip_id, user_id)
        )''')

        # 6. Badges Table
        c.execute('''CREATE TABLE IF NOT EXISTS badges (
            badge_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            badge_type TEXT NOT NULL,
            awarded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE,
            UNIQUE(user_id, badge_type)
        )''')

        # Create Indexes for Performance
        c.execute('CREATE INDEX IF NOT EXISTS idx_tags_clip ON tags(clip_id)')
        c.execute('CREATE INDEX IF NOT EXISTS idx_clips_status ON clips(status)')
        
        logger.info("‚úÖ Database initialized successfully with correct schema.")

# --- CORE LOGIC & ALGORITHMS ---

def is_admin(user_id: int) -> bool:
    """Check if a user is in the ADMIN_IDS list."""
    return str(user_id) in ADMIN_IDS

def validate_tag_rules(user_id: int, clip_id: int, event_type: str) -> Tuple[bool, str]:
    """
    QC Stage 1: Rule Validation
    - Checks for spam (too fast).
    - Checks for valid event type.
    """
    with get_db_connection() as conn:
        c = conn.cursor()
        # Spam Check
        c.execute("""
            SELECT timestamp FROM tags 
            WHERE user_id = ? 
            ORDER BY timestamp DESC LIMIT 1
        """, (user_id,))
        last_tag = c.fetchone()
        
        if last_tag:
            last_time = datetime.strptime(last_tag['timestamp'], '%Y-%m-%d %H:%M:%S')
            diff = (datetime.now() - last_time).total_seconds()
            if diff < SPAM_COOLDOWN_SECONDS:
                return False, f"‚è±Ô∏è ŸÖŸáŸÑÿßŸã! ÿßŸÜÿ™ÿ∏ÿ± {SPAM_COOLDOWN_SECONDS} ÿ´ÿßŸÜŸäÿ© ÿ®ŸäŸÜ ÿßŸÑÿ™ÿßÿ∫ÿßÿ™."

    if event_type not in VALID_EVENTS:
        return False, "‚ùå ŸÜŸàÿπ ÿßŸÑÿ≠ÿØÿ´ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠."
        
    return True, "Valid"

def calculate_crowd_consensus(clip_id: int) -> Tuple[Optional[str], str]:
    """
    QC Stage 2: Crowd Consensus
    - Requires at least 3 votes from trusted users to confirm.
    - If 5 votes and no consensus -> Elite Review.
    """
    with get_db_connection() as conn:
        c = conn.cursor()
        c.execute("""
            SELECT t.event_type, u.trust_score 
            FROM tags t 
            JOIN users u ON t.user_id = u.user_id 
            WHERE t.clip_id = ?
        """, (clip_id,))
        tags = c.fetchall()
        
    if not tags:
        return None, "pending"

    vote_counts = {}
    total_trusted_votes = 0
    
    for tag in tags:
        event = tag['event_type']
        trust = tag['trust_score'] or 50
        
        # Only count votes from users with some trust
        if trust > TRUST_THRESHOLD_VOTE:
            vote_counts[event] = vote_counts.get(event, 0) + 1
            total_trusted_votes += 1
    
    # Check for Majority (3 Votes)
    for event, count in vote_counts.items():
        if count >= CONSENSUS_THRESHOLD:
            if event == 'None':
                return event, "rejected"
            return event, "confirmed"
    
    # If too many votes without consensus, escalate
    if total_trusted_votes >= 5:
        return None, "elite_review"
        
    return None, "crowd_voting"

def update_trust_score(user_id: int, was_correct: bool, is_spam: bool = False):
    """
    QC Stage 3: Reputation System
    - Correct: +Trust, +CorrectTags
    - Incorrect: -Trust
    - Spam: -Trust (Heavy), +NoiseScore
    """
    with get_db_connection() as conn:
        c = conn.cursor()
        
        if is_spam:
            c.execute("""
                UPDATE users 
                SET noise_score = noise_score + 10, 
                    trust_score = MAX(0, trust_score - 5) 
                WHERE user_id = ?
            """, (user_id,))
        elif was_correct:
            c.execute("""
                UPDATE users 
                SET trust_score = MIN(100, trust_score + 1),
                    correct_tags = correct_tags + 1
                WHERE user_id = ?
            """, (user_id,))
        else:
            c.execute("""
                UPDATE users 
                SET trust_score = MAX(0, trust_score - 2) 
                WHERE user_id = ?
            """, (user_id,))
            
        # Always increment total tags
        c.execute("UPDATE users SET total_tags = total_tags + 1 WHERE user_id = ?", (user_id,))

def check_timeline_consistency(match_id: int, event_type: str) -> bool:
    """
    QC Stage 5: Timeline Consistency
    - Prevents impossible sequences (e.g. 2 Goals in 10 seconds).
    """
    with get_db_connection() as conn:
        c = conn.cursor()
        c.execute("""
            SELECT final_event_type, created_at 
            FROM clips 
            WHERE match_id = ? AND status = 'confirmed' 
            ORDER BY created_at DESC LIMIT 1
        """, (match_id,))
        last_event = c.fetchone()
        
    if last_event:
        last_type = last_event['final_event_type']
        last_time = datetime.strptime(last_event['created_at'], '%Y-%m-%d %H:%M:%S')
        diff = (datetime.now() - last_time).total_seconds()
        
        # Rule: No duplicate Goals within 30 seconds
        if last_type == 'Goal' and event_type == 'Goal' and diff < 30:
            return False
            
    return True

def assign_clip_to_user(user_id: int) -> Optional[Tuple[int, str]]:
    """
    Intelligent Assignment Logic.
    Returns (clip_id, filename) or None.
    """
    with get_db_connection() as conn:
        c = conn.cursor()
        
        # Get User Rank
        c.execute("SELECT is_elite, trust_score FROM users WHERE user_id = ?", (user_id,))
        user_data = c.fetchone()
        is_elite = user_data['is_elite'] if user_data else 0
        trust_score = user_data['trust_score'] if user_data else 50
        
        clip = None

        # 1. Elite Queue (For High Trust Users)
        if is_elite or trust_score > 80:
            c.execute("""
                SELECT clip_id, filename FROM clips 
                WHERE qc_stage = 'elite_review' 
                AND clip_id NOT IN (SELECT clip_id FROM clip_assignments WHERE user_id = ?)
                LIMIT 1
            """, (user_id,))
            clip = c.fetchone()

        # 2. General Crowd Queue
        if not clip:
            c.execute("""
                SELECT c.clip_id, c.filename 
                FROM clips c
                WHERE c.qc_stage = 'crowd_voting'
                AND (SELECT COUNT(*) FROM tags WHERE clip_id = c.clip_id) < c.required_tags
                AND c.clip_id NOT IN (SELECT clip_id FROM clip_assignments WHERE user_id = ?)
                ORDER BY RANDOM()
                LIMIT 1
            """, (user_id,))
            clip = c.fetchone()
        
        # Assign if found
        if clip:
            try:
                c.execute("""
                    INSERT INTO clip_assignments (clip_id, user_id) 
                    VALUES (?, ?)
                """, (clip['clip_id'], user_id))
                return (clip['clip_id'], clip['filename'])
            except sqlite3.IntegrityError:
                # Race condition handled silently
                pass
                
    return None

def update_streak(user_id: int) -> Tuple[int, int, int]:
    """Updates daily streak and calculates daily bonus."""
    with get_db_connection() as conn:
        c = conn.cursor()
        
        today = datetime.now().date().isoformat()
        yesterday = (datetime.now() - timedelta(days=1)).date().isoformat()
        
        c.execute("SELECT last_tag_date, streak_days, tags_today FROM users WHERE user_id = ?", (user_id,))
        result = c.fetchone()
        
        streak_days, tags_today, bonus_xp = 1, 1, 0

        if result:
            last_date = result['last_tag_date']
            streak_days = result['streak_days'] or 1
            tags_today = result['tags_today'] or 0
            
            if last_date == today:
                tags_today += 1
            elif last_date == yesterday:
                streak_days += 1
                tags_today = 1
            else:
                streak_days = 1
                tags_today = 1
            
            c.execute("""
                UPDATE users 
                SET last_tag_date = ?, streak_days = ?, tags_today = ? 
                WHERE user_id = ?
            """, (today, streak_days, tags_today, user_id))
            
            if tags_today == DAILY_TAG_THRESHOLD:
                bonus_xp = XP_DAILY_BONUS
                c.execute("UPDATE users SET xp = xp + ? WHERE user_id = ?", (bonus_xp, user_id))
        
    return streak_days, tags_today, bonus_xp

def check_and_award_badges(user_id: int, new_xp: int) -> List[str]:
    """Checks XP against thresholds and awards new badges."""
    with get_db_connection() as conn:
        c = conn.cursor()
        c.execute("SELECT badge_type FROM badges WHERE user_id = ?", (user_id,))
        existing = {row['badge_type'] for row in c.fetchall()}
        
        awarded = []
        for badge, threshold in BADGE_THRESHOLDS.items():
            if new_xp >= threshold and badge not in existing:
                try:
                    c.execute("INSERT INTO badges (user_id, badge_type) VALUES (?, ?)", (user_id, badge))
                    awarded.append(badge)
                except sqlite3.IntegrityError:
                    pass
    return awarded

# --- TELEGRAM BOT HANDLERS ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /start command."""
    user = update.effective_user
    context.user_data.clear()

    with get_db_connection() as conn:
        c = conn.cursor()
        c.execute("SELECT nickname FROM users WHERE user_id = ?", (user.id,))
        result = c.fetchone()

    if result and result['nickname']:
        await update.message.reply_text(
            f"üëã ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ ŸÖÿ¨ÿØÿØÿßŸãÿå **{result['nickname']}**!",
            parse_mode='Markdown'
        )
        await show_main_menu(update, context)
    else:
        keyboard = [[InlineKeyboardButton("üöÄ ÿßŸÜÿ∂ŸÖ ÿßŸÑÿ¢ŸÜ!", callback_data='join_confirm')]]
        await update.message.reply_text(
            "üéØ **ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ ŸÅŸä TactaBot!**\n\n"
            "ŸÖŸÜÿµÿ© ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸà ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿ¨ŸÖÿßÿπŸä.\n"
            "ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ≥ÿ™ÿπÿØ ŸÑŸÑÿßŸÜÿ∂ŸÖÿßŸÖÿü",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )

async def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Router for all text messages."""
    user = update.effective_user
    text = update.message.text
    
    # 1. Registration Flow
    if context.user_data.get('awaiting_nickname'):
        nickname = text.strip()
        if len(nickname) < 2 or len(nickname) > 20:
            await update.message.reply_text("‚ùå ÿßŸÑÿßÿ≥ŸÖ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ®ŸäŸÜ 2 Ÿà 20 ÿ≠ÿ±ŸÅ.")
            return
        
        with get_db_connection() as conn:
            c = conn.cursor()
            c.execute("""
                INSERT OR REPLACE INTO users (user_id, username, nickname) 
                VALUES (?, ?, ?)
            """, (user.id, user.username, nickname))
        
        context.user_data['awaiting_nickname'] = False
        await update.message.reply_text(f"‚úÖ ÿ™ŸÖ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ! ÿ£ŸáŸÑÿßŸã Ÿäÿß **{nickname}**.", parse_mode='Markdown')
        await show_main_menu(update, context)
        return

    # 2. Main Menu Commands
    if text == "‚öΩ ÿßÿ®ÿØÿ£ ÿßŸÑÿ™ÿßÿ∫ŸäŸÜÿ∫":
        await send_clip(update, context)
    elif text == "üèÜ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä":
        await show_leaderboard(update, context)
    elif text == "üìä ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™Ÿä":
        await show_stats(update, context)
    elif text == "üìπ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™":
        if is_admin(user.id):
            await show_admin_menu(update, context)
        else:
            await update.message.reply_text("‚õî Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸÅŸÇÿ∑.")
    elif text == "‚ÑπÔ∏è ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©":
        await show_help(update, context)

async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays the main keyboard menu."""
    kb = [
        ["‚öΩ ÿßÿ®ÿØÿ£ ÿßŸÑÿ™ÿßÿ∫ŸäŸÜÿ∫", "üèÜ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä"],
        ["üìä ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™Ÿä", "‚ÑπÔ∏è ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©"]
    ]
    if is_admin(update.effective_user.id):
        kb.append(["üìπ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™"])
    
    await update.message.reply_text(
        "ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©:",
        reply_markup=ReplyKeyboardMarkup(kb, resize_keyboard=True)
    )

async def send_clip(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fetches a clip assignment and sends the video."""
    user_id = update.effective_user.id
    clip = assign_clip_to_user(user_id)
    
    msg = update.callback_query.message if update.callback_query else update.message

    if not clip:
        await msg.reply_text(
            "üéâ **ÿπŸÖŸÑ ÿ±ÿßÿ¶ÿπ!**\n"
            "ŸÑŸÇÿØ ŸÇŸÖÿ™ ÿ®ÿ™ÿ≠ŸÑŸäŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÑŸÇÿ∑ÿßÿ™ ÿßŸÑŸÖÿ™ŸàŸÅÿ±ÿ© ÿ≠ÿßŸÑŸäÿßŸã.\n"
            "ÿπÿØ ŸÑÿßÿ≠ŸÇÿßŸã ŸÑŸÑŸÖÿ≤ŸäÿØ!",
            parse_mode='Markdown'
        )
        return

    clip_id, filename = clip
    context.user_data['current_clip_id'] = clip_id
    
    # Construct absolute path safely
    video_path = os.path.join(CLIPS_DIR, filename)
    
    # Tagging Keyboard
    keyboard = [
        [InlineKeyboardButton("‚öΩ ŸáÿØŸÅ", callback_data='tag_Goal'), InlineKeyboardButton("üéØ ÿ™ŸÖÿ±Ÿäÿ±ÿ© ÿ≠ÿßÿ≥ŸÖÿ©", callback_data='tag_KeyPass')],
        [InlineKeyboardButton("üîÅ ÿ™ŸÖÿ±Ÿäÿ±ÿ©", callback_data='tag_Pass'), InlineKeyboardButton("üõ°Ô∏è ÿØŸÅÿßÿπ", callback_data='tag_Defense')],
        [InlineKeyboardButton("üî• ÿ∂ÿ∫ÿ∑", callback_data='tag_Press'), InlineKeyboardButton("‚ö†Ô∏è ŸÅÿßŸàŸÑ", callback_data='tag_Foul')],
        [InlineKeyboardButton("üü® ŸÉÿßÿ±ÿ™", callback_data='tag_Card'), InlineKeyboardButton("üö© ÿ£ŸàŸÅÿ≥ÿßŸäÿØ", callback_data='tag_Offside')],
        [InlineKeyboardButton("‚ùå ŸÑÿß ÿ¥Ÿäÿ°/ÿ∫Ÿäÿ± Ÿàÿßÿ∂ÿ≠", callback_data='tag_None')]
    ]
    
    if os.path.exists(video_path):
        try:
            with open(video_path, 'rb') as video_file:
                await msg.reply_video(
                    video=video_file,
                    caption=f"üé¨ **Clip #{clip_id}**\nŸÖÿß ŸáŸà ÿßŸÑÿ≠ÿØÿ´ ÿßŸÑÿ£ÿ®ÿ±ÿ≤ÿü",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode='Markdown'
                )
        except Exception as e:
            logger.error(f"Failed to send video {filename}: {e}")
            await msg.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅŸäÿØŸäŸà.")
    else:
        # Handle Missing File gracefully
        logger.warning(f"File missing on disk: {video_path}")
        await msg.reply_text(f"‚ö†Ô∏è ÿßŸÑŸÖŸÑŸÅ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ: {filename}. ÿ¨ÿßÿ±Ÿä ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ŸÑŸÑÿ™ÿßŸÑŸä...")
        
        # Mark as completed so user doesn't get stuck loop
        with get_db_connection() as conn:
            conn.execute("UPDATE clip_assignments SET completed=1 WHERE clip_id=? AND user_id=?", (clip_id, user_id))
        
        # Recursive call to get next clip
        await send_clip(update, context)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Callback query handler for inline buttons."""
    query = update.callback_query
    await query.answer()
    
    if query.data == 'join_confirm':
        context.user_data['awaiting_nickname'] = True
        await query.edit_message_text("üìù ŸÖŸÖÿ™ÿßÿ≤! ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖŸÉ ÿßŸÑŸÖÿ≥ÿ™ÿπÿßÿ± (Nickname) ÿßŸÑÿ¢ŸÜ:")
        
    elif query.data.startswith('tag_'):
        event = query.data.split('_')[1]
        await handle_tag_logic(update, context, event)
        
    elif query.data == 'admin_scan':
        await scan_local_files(update, context)
        
    elif query.data == 'admin_upload_prompt':
        await query.edit_message_text("üì§ ŸÇŸÖ ÿ®ÿ•ÿ±ÿ≥ÿßŸÑ ŸÖŸÑŸÅ ÿßŸÑŸÅŸäÿØŸäŸà ÿßŸÑÿ¢ŸÜ (MP4).")
        
    elif query.data.startswith('process_video_'):
        # Extract index from callback data
        try:
            idx = int(query.data.split('_')[-1])
            files = context.user_data.get('video_files', [])
            if idx < len(files):
                file_path = os.path.join(UPLOADS_DIR, files[idx])
                await query.edit_message_text(f"‚öôÔ∏è ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ©: {files[idx]}...")
                await process_video_async(update, file_path)
            else:
                await query.edit_message_text("‚ùå ÿßŸÑŸÖŸÑŸÅ ŸÑŸÖ ŸäÿπÿØ ŸÖÿ™ÿßÿ≠ÿßŸã.")
        except ValueError:
            pass

async def handle_tag_logic(update: Update, context: ContextTypes.DEFAULT_TYPE, event: str):
    """
    The Core Engine: Handles tagging, scoring, and consensus logic.
    """
    user_id = update.effective_user.id
    clip_id = context.user_data.get('current_clip_id')
    
    if not clip_id:
        await update.callback_query.answer("‚ö†Ô∏è ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÖŸÜÿ™ŸáŸäÿ©.", show_alert=True)
        return

    # 1. Rule Validation
    is_valid, reason = validate_tag_rules(user_id, clip_id, event)
    if not is_valid:
        await update.callback_query.answer(f"‚ùå {reason}", show_alert=True)
        if "Spam" in reason:
            update_trust_score(user_id, False, is_spam=True)
        return

    # 2. Save Tag & Update User
    with get_db_connection() as conn:
        c = conn.cursor()
        # Insert Tag
        c.execute("INSERT INTO tags (user_id, clip_id, event_type) VALUES (?, ?, ?)", 
                  (user_id, clip_id, event))
        
        # Mark Assignment Complete
        c.execute("UPDATE clip_assignments SET completed=1 WHERE clip_id=? AND user_id=?", 
                  (clip_id, user_id))
        
        # Award Base XP
        c.execute("UPDATE users SET xp = xp + ? WHERE user_id=?", (XP_TAG_BASE, user_id))
        
        # Fetch new XP for badge check
        c.execute("SELECT xp FROM users WHERE user_id=?", (user_id,))
        new_xp = c.fetchone()['xp']

    # 3. Process Streaks & Badges
    streak, tags_today, bonus = update_streak(user_id)
    new_badges = check_and_award_badges(user_id, new_xp)
    
    # 4. User Feedback
    msg = f"‚úÖ ÿ™ŸÖ! +{XP_TAG_BASE} XP"
    if bonus: msg += f"\nüéÅ ÿ®ŸàŸÜÿµ ŸäŸàŸÖŸä: +{bonus} XP"
    if streak > 1: msg += f"\nüî• Streak: {streak} ŸäŸàŸÖ"
    if new_badges: msg += f"\nüèÖ ÿ¥ÿßÿ±ÿ© ÿ¨ÿØŸäÿØÿ©: {', '.join(new_badges)}"
    
    await update.callback_query.answer(msg, show_alert=True)
    await update.callback_query.edit_message_caption(
        caption=f"‚úÖ ÿ™ŸÖ ÿßŸÑÿ™ÿµŸàŸäÿ™: **{event}**",
        parse_mode='Markdown'
    )

    # 5. Consensus & QC Logic
    consensus_event, status = calculate_crowd_consensus(clip_id)
    
    if status in ['confirmed', 'rejected']:
        with get_db_connection() as conn:
            c = conn.cursor()
            
            # Get Match ID for Timeline Logic
            c.execute("SELECT match_id FROM clips WHERE clip_id=?", (clip_id,))
            match_row = c.fetchone()
            match_id = match_row['match_id'] if match_row else 0
            
            final_status = status
            
            # Timeline Check (Only for confirmed events)
            if status == 'confirmed' and not check_timeline_consistency(match_id, consensus_event):
                final_status = 'ambiguous'
                logger.info(f"Clip {clip_id} marked ambiguous due to timeline inconsistency.")
            
            # Determine Quality Tag
            quality_tag = 'high_confidence' if final_status == 'confirmed' else 'ambiguous'
            if final_status == 'rejected': quality_tag = 'rejected'
            
            # Finalize Clip in DB
            c.execute("""
                UPDATE clips 
                SET consensus_event=?, status=?, qc_stage='finalized', 
                    quality_tag=?, final_event_type=?, finalized_at=CURRENT_TIMESTAMP 
                WHERE clip_id=?
            """, (consensus_event, final_status, quality_tag, consensus_event, clip_id))
            
            # 6. Retroactive Reputation Update
            c.execute("SELECT user_id, event_type FROM tags WHERE clip_id=?", (clip_id,))
            tags = c.fetchall()
            
            for tag in tags:
                uid = tag['user_id']
                u_event = tag['event_type']
                
                # Determine correctness
                is_correct = False
                if final_status == 'confirmed':
                    is_correct = (u_event == consensus_event)
                elif final_status == 'rejected':
                    is_correct = (u_event == 'None')
                
                # Update Trust
                update_trust_score(uid, is_correct)
                
                # Mark tag as correct/incorrect in DB
                c.execute("UPDATE tags SET is_correct=? WHERE clip_id=? AND user_id=?", 
                          (is_correct, clip_id, uid))
                
                # Award Accuracy XP Bonus
                if is_correct:
                    c.execute("UPDATE users SET xp = xp + ? WHERE user_id=?", 
                              (XP_TAG_CORRECT, uid))

    # 7. Move to next clip
    await send_clip(update, context)

# --- ADMIN FUNCTIONS ---

async def show_admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin Control Panel."""
    kb = [
        [InlineKeyboardButton("üìÇ ŸÅÿ≠ÿµ ÿßŸÑŸÖŸÑŸÅÿßÿ™ (Scan)", callback_data='admin_scan')],
        [InlineKeyboardButton("üì§ ÿ±ŸÅÿπ ŸÅŸäÿØŸäŸà ÿ¨ÿØŸäÿØ", callback_data='admin_upload_prompt')]
    ]
    await update.message.reply_text(
        "üõ†Ô∏è **ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿßŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ**",
        reply_markup=InlineKeyboardMarkup(kb),
        parse_mode='Markdown'
    )

async def handle_video_upload(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle direct file uploads by admin."""
    if not is_admin(update.effective_user.id): return

    video = update.message.video or update.message.document
    if not video: return

    await update.message.reply_text("‚è≥ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...")
    
    try:
        f = await context.bot.get_file(video.file_id)
        # Generate clean filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        clean_name = f"upload_{timestamp}.mp4"
        save_path = os.path.join(UPLOADS_DIR, clean_name)
        
        await f.download_to_drive(save_path)
        await update.message.reply_text(f"‚úÖ ÿ™ŸÖ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ: `{clean_name}`\n‚öôÔ∏è ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ŸÇÿ∑Ÿäÿπ...")
        
        # Trigger processing
        await process_video_async(update, save_path)
        
    except Exception as e:
        logger.error(f"Upload Error: {e}")
        await update.message.reply_text(f"‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")

async def scan_local_files(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Scan the uploads folder for unprocessed videos."""
    if not is_admin(update.effective_user.id): return
    
    # Filter for video files
    files = [f for f in os.listdir(UPLOADS_DIR) if f.lower().endswith(('.mp4', '.avi', '.mov'))]
    
    if not files:
        await update.effective_message.reply_text("üìÇ ÿßŸÑŸÖÿ¨ŸÑÿØ `public/uploads` ŸÅÿßÿ±ÿ∫.")
        return
        
    context.user_data['video_files'] = files
    
    # Create buttons for files (Limit to first 10 to avoid size limits)
    kb = []
    for i, f in enumerate(files[:10]):
        # Truncate name for button
        display_name = (f[:25] + '..') if len(f) > 25 else f
        kb.append([InlineKeyboardButton(f"üé¨ {display_name}", callback_data=f'process_video_{i}')])
        
    await update.effective_message.reply_text(
        f"üìÇ Ÿàÿ¨ÿØŸÜÿß {len(files)} ŸÖŸÑŸÅÿßÿ™. ÿßÿÆÿ™ÿ± ŸÖŸÑŸÅÿßŸã ŸÑŸÑŸÖÿπÿßŸÑÿ¨ÿ©:",
        reply_markup=InlineKeyboardMarkup(kb)
    )

async def process_video_async(update: Update, file_path: str):
    """
    Runs the video processing logic in a separate thread (Executor)
    to prevent blocking the Telegram bot main loop.
    """
    msg = update.effective_message or update.callback_query.message
    
    if not CLIP_GENERATOR_AVAILABLE:
        await msg.reply_text("‚ùå ŸÖŸÉÿ™ÿ®ÿ© `clip_generator.py` ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©.")
        return

    await msg.reply_text("‚öôÔ∏è ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ŸàÿßŸÑÿ™ŸÇÿ∑Ÿäÿπ (ŸÇÿØ Ÿäÿ≥ÿ™ÿ∫ÿ±ŸÇ ŸàŸÇÿ™ÿßŸã)...")
    
    loop = asyncio.get_running_loop()
    
    try:
        # EXECUTE BLOCKING CODE IN THREAD
        clips = await loop.run_in_executor(
            None, 
            generate_clips_from_video, 
            file_path, 
            CLIPS_DIR, 
            -1 # Auto-detect number of clips
        )
        
        if clips:
            with get_db_connection() as conn:
                c = conn.cursor()
                
                # Create Match Entry
                match_name = f"Match {os.path.basename(file_path)[:15]}"
                c.execute("INSERT INTO matches (name, status) VALUES (?, 'live')", (match_name,))
                match_id = c.lastrowid
                
                # Insert Clips
                count = 0
                for clip_path in clips:
                    # IMPORTANT: Store only filename!
                    filename = os.path.basename(clip_path)
                    c.execute("""
                        INSERT INTO clips (match_id, filename, qc_stage) 
                        VALUES (?, ?, 'crowd_voting')
                    """, (match_id, filename))
                    count += 1
            
            await msg.reply_text(f"‚úÖ **ÿ™ŸÖÿ™ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ®ŸÜÿ¨ÿßÿ≠!**\nüíæ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© {count} ŸÑŸÇÿ∑ÿ© ŸÑŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™.", parse_mode='Markdown')
        else:
            await msg.reply_text("‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ£Ÿä ŸÑŸÇÿ∑ÿßÿ™. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÅŸäÿØŸäŸà.")
            
    except Exception as e:
        logger.error(f"Processing Failed: {e}")
        await msg.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿØÿßÿÆŸÑŸä ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©.")

# --- STATS & LEADERBOARD ---

async def show_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays detailed user statistics."""
    user_id = update.effective_user.id
    
    with get_db_connection() as conn:
        c = conn.cursor()
        
        # 1. Fetch User Data (Simple Select)
        c.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
        user = c.fetchone()
        
        # 2. Fetch Badges
        c.execute("SELECT badge_type FROM badges WHERE user_id = ?", (user_id,))
        badges = [b['badge_type'] for b in c.fetchall()]
        
        # 3. Calculate Rank
        if user:
            c.execute("SELECT COUNT(*) as rank FROM users WHERE xp > ?", (user['xp'],))
            rank = c.fetchone()['rank'] + 1
            
    if not user:
        await update.message.reply_text("‚ùå ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿ≠ÿ≥ÿßÿ® ÿ®ÿπÿØ.")
        return

    # Calculate Accuracy in Python to avoid SQL errors
    total = user['total_tags'] or 0
    correct = user['correct_tags'] or 0
    accuracy = (correct / total * 100) if total > 0 else 0.0
    
    # Format Badges
    badge_icons = {"Bronze": "ü•â", "Silver": "ü•à", "Gold": "ü•á", "Platinum": "üíé", "Diamond": "üëë"}
    badges_str = ", ".join([f"{badge_icons.get(b, 'üèÖ')} {b}" for b in badges]) if badges else "ŸÑÿß ŸäŸàÿ¨ÿØ"
    
    text = (
        f"üë§ **ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä: {user['nickname']}**\n\n"
        f"üìä **ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿπÿßŸÑŸÖŸä:** #{rank}\n"
        f"‚≠ê **ŸÜŸÇÿßÿ∑ ÿßŸÑÿÆÿ®ÿ±ÿ© (XP):** {user['xp']}\n"
        f"üõ°Ô∏è **ŸÖÿπÿØŸÑ ÿßŸÑÿ´ŸÇÿ©:** {user['trust_score']}/100\n"
        f"üéØ **ÿßŸÑÿØŸÇÿ©:** {accuracy:.1f}%\n"
        f"üî• **ÿ≥ŸÑÿ≥ŸÑÿ© ÿßŸÑÿ™ŸÅÿßÿπŸÑ:** {user['streak_days']} ŸäŸàŸÖ\n"
        f"üè∑Ô∏è **ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ™ÿßÿ∫ÿßÿ™:** {total}\n"
        f"üèÖ **ÿßŸÑÿ¥ÿßÿ±ÿßÿ™:** {badges_str}"
    )
    
    await update.message.reply_text(text, parse_mode='Markdown')

async def show_leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Displays top 10 users."""
    with get_db_connection() as conn:
        c = conn.cursor()
        c.execute("SELECT nickname, xp FROM users ORDER BY xp DESC LIMIT 10")
        rows = c.fetchall()
    
    if not rows:
        await update.message.reply_text("üì≠ ŸÑÿß ŸäŸàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÉÿßŸÅŸäÿ©.")
        return

    text = "üèÜ **ŸÑŸàÿ≠ÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ (Top 10)**\n\n"
    for i, row in enumerate(rows, 1):
        medal = "ü•á" if i==1 else "ü•à" if i==2 else "ü•â" if i==3 else f"{i}."
        text += f"{medal} **{row['nickname']}** ‚Äî {row['xp']} XP\n"
        
    await update.message.reply_text(text, parse_mode='Markdown')

async def show_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Help message."""
    text = (
        "‚ÑπÔ∏è **ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© - TactaBot**\n\n"
        "üéÆ **ŸÉŸäŸÅ ÿ™ŸÑÿπÿ®ÿü**\n"
        "1. ÿßÿ∂ÿ∫ÿ∑ 'ÿ®ÿØÿ° ÿßŸÑÿ™ÿßÿ∫ŸäŸÜÿ∫'.\n"
        "2. ÿ¥ÿßŸáÿØ ÿßŸÑŸÅŸäÿØŸäŸà.\n"
        "3. ÿßÿÆÿ™ÿ± ÿßŸÑÿ≠ÿØÿ´ ÿßŸÑÿµÿ≠Ÿäÿ≠.\n\n"
        "‚≠ê **ÿßŸÑŸÜŸÇÿßÿ∑:**\n"
        "+1 XP ŸÑŸÑŸÖÿ¥ÿßÿ±ŸÉÿ©\n"
        "+5 XP ŸÑŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©\n"
        "+20 XP ÿ®ŸàŸÜÿµ ŸäŸàŸÖŸä (10 ÿ™ÿßÿ∫ÿßÿ™)\n\n"
        "‚ö†Ô∏è ÿßŸÑÿ™ÿµŸàŸäÿ™ ÿßŸÑÿπÿ¥Ÿàÿßÿ¶Ÿä ŸäŸÇŸÑŸÑ ŸÖŸÜ ŸÜŸÇÿßÿ∑ ÿ´ŸÇÿ™ŸÉ!"
    )
    await update.message.reply_text(text, parse_mode='Markdown')

# --- MAIN EXECUTION ---

if __name__ == '__main__':
    # 1. Validation
    if not TOKEN:
        print("‚ùå Error: TELEGRAM_BOT_TOKEN is missing in .env file.")
        exit(1)
        
    if not ADMIN_IDS:
        print("‚ö†Ô∏è Warning: ADMIN_IDS not set. Admin features will be hidden.")

    # 2. Initialization
    init_db()
    
    # 3. Application Builder
    app = ApplicationBuilder().token(TOKEN).build()
    
    # 4. Handler Registration
    # Commands
    app.add_handler(CommandHandler('start', start))
    app.add_handler(CommandHandler('scan', scan_local_files))
    app.add_handler(CommandHandler('help', show_help))
    
    # Admin Uploads (Video/Document)
    app.add_handler(MessageHandler(filters.VIDEO | filters.Document.VIDEO, handle_video_upload))
    
    # Callbacks (Inline Buttons)
    app.add_handler(CallbackQueryHandler(button_handler))
    
    # Text Messages (Menu & Registration)
    app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), message_handler))
    
    # 5. Run
    print(f"üöÄ TactaBot is running... (Admin IDs: {len(ADMIN_IDS)})")
    app.run_polling()
</file>

<file path="python/test_roboflow.py">
import os
import cv2
import numpy as np
from dotenv import load_dotenv
from soccer_analysis_processor import SoccerMatchAnalyzer, AnalysisConfig

def test_inference():
    # Load environment variables
    load_dotenv()
    
    # Initialize analyzer
    config = AnalysisConfig(confidence_threshold=0.3)
    analyzer = SoccerMatchAnalyzer(config)
    
    # Load Roboflow model
    print("Loading Roboflow model...")
    analyzer.load_roboflow_model()
    
    if analyzer.roboflow_model is None:
        print("FAILED: Roboflow model not loaded. Check ROBOFLOW_API_KEY in .env")
        return

    # Create a dummy frame (green pitch)
    frame = np.zeros((720, 1280, 3), dtype=np.uint8)
    frame[:, :, 1] = 120 # Dark green
    
    # Draw some "players" (white circles)
    cv2.circle(frame, (640, 360), 10, (255, 255, 255), -1)
    cv2.circle(frame, (100, 100), 10, (255, 255, 255), -1)
    
    # Draw a "ball" (orange circle)
    cv2.circle(frame, (600, 400), 5, (0, 165, 255), -1)

    print("Running inference...")
    detections = analyzer.roboflow_model.get_detections(frame)
    
    print(f"Detected {len(detections)} objects.")
    for i in range(len(detections)):
        print(f"Object {i}: Class={detections.class_id[i]}, Conf={detections.confidence[i]:.2f}, BBox={detections.xyxy[i]}")

    print("Running keypoints inference...")
    k_detections, keypoints = analyzer.roboflow_model.get_keypoints_detections(frame)
    if keypoints is not None:
        print(f"Detected {keypoints.shape[1]} keypoints.")
    else:
        print("No keypoints detected.")

if __name__ == "__main__":
    test_inference()
</file>

<file path="python/trackers/__init__.py">
from .tracker import Tracker
from .tracker_manager import TrackerManager
</file>

<file path="python/trackers/hybrid_tracker.py">
import numpy as np
from python.models.reid_model import ReIDModel
# We'll use a simplified ByteTrack implementation or wrapper
# For this "Elite" system, we assume we have a ByteTrack implementation available
# or we implement the core logic here.
# Since we can't easily pip install bytetrack in this environment without potential issues,
# I'll implement a robust Kalman Filter + IoU/ReID association tracker (Hybrid) directly.

from filterpy.kalman import KalmanFilter
from scipy.optimize import linear_sum_assignment

class Track:
    def __init__(self, track_id, box, score, feature=None):
        self.track_id = track_id
        self.box = box # [x1, y1, x2, y2]
        self.score = score
        self.features = [feature] if feature is not None else []
        self.max_features = 100
        self.hits = 1
        self.age = 1
        self.time_since_update = 0
        self.state = 'active' # active, lost
        
        # Initialize Kalman Filter
        self.kf = KalmanFilter(dim_x=7, dim_z=4)
        self.kf.F = np.array([[1,0,0,0,1,0,0],
                              [0,1,0,0,0,1,0],
                              [0,0,1,0,0,0,1],
                              [0,0,0,1,0,0,0],
                              [0,0,0,0,1,0,0],
                              [0,0,0,0,0,1,0],
                              [0,0,0,0,0,0,1]])
        self.kf.H = np.array([[1,0,0,0,0,0,0],
                              [0,1,0,0,0,0,0],
                              [0,0,1,0,0,0,0],
                              [0,0,0,1,0,0,0]])
        self.kf.R[2:,2:] *= 10.
        self.kf.P[4:,4:] *= 1000.
        self.kf.P *= 10.
        self.kf.Q[-1,-1] *= 0.01
        self.kf.Q[4:,4:] *= 0.01
        
        # Initialize state
        self.update_kf(box)

    def update_kf(self, box):
        # Convert [x1,y1,x2,y2] to [cx,cy,s,r]
        w = box[2] - box[0]
        h = box[3] - box[1]
        x = box[0] + w/2.
        y = box[1] + h/2.
        s = w * h
        r = w / float(h)
        
        self.kf.x[:4] = np.array([x, y, s, r]).reshape((4, 1))

    def predict(self):
        if((self.kf.x[6]+self.kf.x[2])<=0):
            self.kf.x[6] *= 0.0
        self.kf.predict()
        self.age += 1
        self.time_since_update += 1
        return self.get_box()

    def update(self, box, score, feature=None):
        self.hits += 1
        self.time_since_update = 0
        self.score = score
        self.box = box
        
        # Update KF
        w = box[2] - box[0]
        h = box[3] - box[1]
        x = box[0] + w/2.
        y = box[1] + h/2.
        s = w * h
        r = w / float(h)
        
        self.kf.update(np.array([x, y, s, r]).reshape((4, 1)))
        
        if feature is not None:
            self.features.append(feature)
            if len(self.features) > self.max_features:
                self.features.pop(0)

    def get_box(self):
        """
        Get current bounding box estimate from Kalman Filter
        """
        x = self.kf.x[0]
        y = self.kf.x[1]
        s = self.kf.x[2]
        r = self.kf.x[3]
        
        w = np.sqrt(s * r)
        h = s / w
        
        return np.array([x-w/2., y-h/2., x+w/2., y+h/2.]).reshape((4,))

class HybridTracker:
    def __init__(self, frame_rate=30):
        self.reid = ReIDModel()
        self.tracks = []
        self.next_id = 1
        self.frame_rate = frame_rate
        self.max_age = frame_rate * 2 # Keep lost tracks for 2 seconds
        
        # Thresholds
        self.conf_thresh = 0.5
        self.iou_thresh = 0.3
        self.reid_thresh = 0.4 # Cosine distance threshold

    def update(self, detections, frame):
        """
        detections: list of [x1, y1, x2, y2, score, class_id]
        frame: current video frame
        """
        # 1. Filter low confidence detections
        dets = [d for d in detections if d[4] >= self.conf_thresh]
        dets = np.array(dets)
        
        # 2. Extract ReID features for all detections
        features = []
        if len(dets) > 0:
            features = self.reid.extract_features(frame, dets[:, :4])
            
        # 3. Predict new locations of existing tracks
        for track in self.tracks:
            track.predict()
            
        # 4. Association: First by ReID (DeepSORT style)
        # Separate tracks into active and lost
        active_tracks = [t for t in self.tracks if t.time_since_update <= 1]
        lost_tracks = [t for t in self.tracks if t.time_since_update > 1]
        
        unmatched_dets_idx = list(range(len(dets)))
        unmatched_tracks_idx = list(range(len(self.tracks)))
        
        matches = []
        
        # --- Stage 1: ReID Association for all tracks ---
        if len(dets) > 0 and len(self.tracks) > 0:
            dists = np.zeros((len(self.tracks), len(dets)))
            
            for i, track in enumerate(self.tracks):
                if len(track.features) > 0:
                    # Compute min distance to any of the track's past features
                    # (Simplified: use mean feature or last feature for speed)
                    track_feat = np.mean(track.features, axis=0).reshape(1, -1)
                    dists[i] = self.reid.compute_distance(track_feat, features)[0]
                else:
                    dists[i] = 1.0 # Max distance if no features
            
            # Solve assignment
            row_idxs, col_idxs = linear_sum_assignment(dists)
            
            for r, c in zip(row_idxs, col_idxs):
                if dists[r, c] < self.reid_thresh:
                    matches.append((r, c))
                    if c in unmatched_dets_idx: unmatched_dets_idx.remove(c)
                    if r in unmatched_tracks_idx: unmatched_tracks_idx.remove(r)

        # --- Stage 2: IoU Association for remaining (ByteTrack style) ---
        # (Simplified: Standard IoU matching for now)
        if len(unmatched_dets_idx) > 0 and len(unmatched_tracks_idx) > 0:
            iou_dists = np.zeros((len(unmatched_tracks_idx), len(unmatched_dets_idx)))
            
            for i, t_idx in enumerate(unmatched_tracks_idx):
                track = self.tracks[t_idx]
                track_box = track.get_box()
                
                for j, d_idx in enumerate(unmatched_dets_idx):
                    det_box = dets[d_idx][:4]
                    iou_dists[i, j] = 1.0 - self._iou(track_box, det_box)
            
            row_idxs, col_idxs = linear_sum_assignment(iou_dists)
            
            for r, c in zip(row_idxs, col_idxs):
                if iou_dists[r, c] < (1.0 - self.iou_thresh):
                    t_idx = unmatched_tracks_idx[r]
                    d_idx = unmatched_dets_idx[c]
                    matches.append((t_idx, d_idx))
                    
                    # Remove from unmatched lists (careful with indices)
                    # We rebuild unmatched lists at end of loop or use sets, 
                    # but here we just track what's matched in 'matches'
                    pass

        # 5. Update Tracks
        matched_track_indices = set(m[0] for m in matches)
        matched_det_indices = set(m[1] for m in matches)
        
        # Update matched tracks
        for t_idx, d_idx in matches:
            track = self.tracks[t_idx]
            det = dets[d_idx]
            feat = features[d_idx] if len(features) > 0 else None
            track.update(det[:4], det[4], feat)
            
        # Create new tracks for unmatched detections
        for i in range(len(dets)):
            if i not in matched_det_indices:
                feat = features[i] if len(features) > 0 else None
                new_track = Track(self.next_id, dets[i][:4], dets[i][4], feat)
                self.tracks.append(new_track)
                self.next_id += 1
                
        # Remove dead tracks
        self.tracks = [t for t in self.tracks if t.time_since_update < self.max_age]
        
        # Return active tracks
        ret_tracks = []
        for t in self.tracks:
            if t.time_since_update < 1 and t.hits >= 3: # Min hits to confirm
                box = t.get_box()
                ret_tracks.append([*box, t.track_id, t.score, 0]) # Class 0 for player
                
        return np.array(ret_tracks)

    def _iou(self, box1, box2):
        xx1 = max(box1[0], box2[0])
        yy1 = max(box1[1], box2[1])
        xx2 = min(box1[2], box2[2])
        yy2 = min(box1[3], box2[3])
        
        w = max(0, xx2 - xx1)
        h = max(0, yy2 - yy1)
        inter = w * h
        
        area1 = (box1[2]-box1[0]) * (box1[3]-box1[1])
        area2 = (box2[2]-box2[0]) * (box2[3]-box2[1])
        
        return inter / (area1 + area2 - inter + 1e-6)
</file>

<file path="python/trackers/tracker_manager.py">
import sys
from pathlib import Path
import numpy as np

# Adjust project path to allow imports from other packages
PROJECT_DIR = Path(__file__).resolve().parent.parent
if str(PROJECT_DIR) not in sys.path:
    sys.path.append(str(PROJECT_DIR))

try:
    import supervision as sv
except ImportError:
    # Fallback/Mock for ByteTrack if supervision is not installed
    class MockByteTrack:
        def __init__(self):
            self.match_thresh = 0.5
            self.track_buffer = 120
        def update_with_detections(self, detections):
            if hasattr(detections, 'xyxy'):
                # Simple pass-through if no tracker is available
                if not hasattr(detections, 'tracker_id') or detections.tracker_id is None:
                    detections.tracker_id = np.arange(len(detections.xyxy))
            return detections
            
    class sv:
        ByteTrack = MockByteTrack


class TrackerManager:
    """
    Manager class for player tracking functionality.
    Handles initialization and configuration of tracking models.
    """
    
    def __init__(self, match_thresh=0.5, track_buffer=120):
        """
        Initialize the tracker with configurable parameters.
        
        Args:
            match_thresh (float): Matching threshold for tracking
            track_buffer (int): Number of frames to keep tracking buffer
        """
        self.tracker = sv.ByteTrack()
        self.tracker.match_thresh = match_thresh
        self.tracker.track_buffer = track_buffer
    
    def get_tracker(self):
        """Get the configured tracker instance."""
        return self.tracker
    
    def update_player_detections(self, player_detections):
        """
        Update the player detections with the tracker.
        
        Args:
            player_detections: Detection results from YOLO
            
        Returns:
            Updated detections with tracker IDs
        """
        # Note: In supervision, update_with_detections is the standard way to advance the tracker
        player_detections = self.tracker.update_with_detections(player_detections)
        return player_detections
    
    def process_tracking_for_frame(self, player_detections):
        """
        Process tracking for a single frame.
        
        Args:
            player_detections: Player detections for the frame
            
        Returns:
            Updated player detections with tracking information
        """
        if player_detections is not None and len(player_detections.xyxy) > 0:
            player_detections = self.update_player_detections(player_detections)
        return player_detections
</file>

<file path="python/trackers/tracker.py">
from ultralytics import YOLO
import supervision as sv
import pickle
import os
import numpy as np
import pandas as pd
import cv2
import sys 
sys.path.append('../')
from utils import get_center_of_bbox, get_bbox_width, get_foot_position

class Tracker:
    def __init__(self, model_path):
        self.model = YOLO(model_path) 
        self.tracker = sv.ByteTrack()

    def add_position_to_tracks(sekf,tracks):
        for object, object_tracks in tracks.items():
            for frame_num, track in enumerate(object_tracks):
                for track_id, track_info in track.items():
                    bbox = track_info['bbox']
                    if object == 'ball':
                        position= get_center_of_bbox(bbox)
                    else:
                        position = get_foot_position(bbox)
                    tracks[object][frame_num][track_id]['position'] = position

    def interpolate_ball_positions(self,ball_positions):
        ball_positions = [x.get(1,{}).get('bbox',[]) for x in ball_positions]
        df_ball_positions = pd.DataFrame(ball_positions,columns=['x1','y1','x2','y2'])

        # Interpolate missing values
        df_ball_positions = df_ball_positions.interpolate()
        df_ball_positions = df_ball_positions.bfill()

        ball_positions = [{1: {"bbox":x}} for x in df_ball_positions.to_numpy().tolist()]

        return ball_positions

    def detect_frames(self, frames):
        batch_size=20 
        detections = [] 
        for i in range(0,len(frames),batch_size):
            detections_batch = self.model.predict(frames[i:i+batch_size],conf=0.1)
            detections += detections_batch
        return detections

    def get_object_tracks(self, frames, read_from_stub=False, stub_path=None):
        
        if read_from_stub and stub_path is not None and os.path.exists(stub_path):
            with open(stub_path,'rb') as f:
                tracks = pickle.load(f)
            return tracks

        detections = self.detect_frames(frames)

        tracks={
            "players":[],
            "referees":[],
            "ball":[]
        }

        for frame_num, detection in enumerate(detections):
            cls_names = detection.names
            cls_names_inv = {v:k for k,v in cls_names.items()}

            # Covert to supervision Detection format
            detection_supervision = sv.Detections.from_ultralytics(detection)

            # Convert GoalKeeper to player object
            for object_ind , class_id in enumerate(detection_supervision.class_id):
                if cls_names[class_id] == "goalkeeper":
                    detection_supervision.class_id[object_ind] = cls_names_inv["player"]

            # Track Objects
            detection_with_tracks = self.tracker.update_with_detections(detection_supervision)

            tracks["players"].append({})
            tracks["referees"].append({})
            tracks["ball"].append({})

            for frame_detection in detection_with_tracks:
                bbox = frame_detection[0].tolist()
                cls_id = frame_detection[3]
                track_id = frame_detection[4]

                if cls_id == cls_names_inv['player']:
                    tracks["players"][frame_num][track_id] = {"bbox":bbox}
                
                if cls_id == cls_names_inv['referee']:
                    tracks["referees"][frame_num][track_id] = {"bbox":bbox}
            
            for frame_detection in detection_supervision:
                bbox = frame_detection[0].tolist()
                cls_id = frame_detection[3]

                if cls_id == cls_names_inv['ball']:
                    tracks["ball"][frame_num][1] = {"bbox":bbox}

        if stub_path is not None:
            with open(stub_path,'wb') as f:
                pickle.dump(tracks,f)

        return tracks
    
    def draw_ellipse(self,frame,bbox,color,track_id=None):
        y2 = int(bbox[3])
        x_center, _ = get_center_of_bbox(bbox)
        width = get_bbox_width(bbox)

        cv2.ellipse(
            frame,
            center=(x_center,y2),
            axes=(int(width), int(0.35*width)),
            angle=0.0,
            startAngle=-45,
            endAngle=235,
            color = color,
            thickness=2,
            lineType=cv2.LINE_4
        )

        rectangle_width = 40
        rectangle_height=20
        x1_rect = x_center - rectangle_width//2
        x2_rect = x_center + rectangle_width//2
        y1_rect = (y2- rectangle_height//2) +15
        y2_rect = (y2+ rectangle_height//2) +15

        if track_id is not None:
            cv2.rectangle(frame,
                          (int(x1_rect),int(y1_rect) ),
                          (int(x2_rect),int(y2_rect)),
                          color,
                          cv2.FILLED)
            
            x1_text = x1_rect+12
            if track_id > 99:
                x1_text -=10
            
            cv2.putText(
                frame,
                f"{track_id}",
                (int(x1_text),int(y1_rect+15)),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.6,
                (0,0,0),
                2
            )

        return frame

    def draw_traingle(self,frame,bbox,color):
        y= int(bbox[1])
        x,_ = get_center_of_bbox(bbox)

        triangle_points = np.array([
            [x,y],
            [x-10,y-20],
            [x+10,y-20],
        ])
        cv2.drawContours(frame, [triangle_points],0,color, cv2.FILLED)
        cv2.drawContours(frame, [triangle_points],0,(0,0,0), 2)

        return frame

    def draw_team_ball_control(self,frame,frame_num,team_ball_control):
        # Draw a semi-transparent rectaggle 
        overlay = frame.copy()
        cv2.rectangle(overlay, (1350, 850), (1900,970), (255,255,255), -1 )
        alpha = 0.4
        cv2.addWeighted(overlay, alpha, frame, 1 - alpha, 0, frame)

        team_ball_control_till_frame = team_ball_control[:frame_num+1]
        # Get the number of time each team had ball control
        team_1_num_frames = team_ball_control_till_frame[team_ball_control_till_frame==1].shape[0]
        team_2_num_frames = team_ball_control_till_frame[team_ball_control_till_frame==2].shape[0]
        team_1 = team_1_num_frames/(team_1_num_frames+team_2_num_frames)
        team_2 = team_2_num_frames/(team_1_num_frames+team_2_num_frames)

        cv2.putText(frame, f"Team 1 Ball Control: {team_1*100:.2f}%",(1400,900), cv2.FONT_HERSHEY_SIMPLEX, 1, (0,0,0), 3)
        cv2.putText(frame, f"Team 2 Ball Control: {team_2*100:.2f}%",(1400,950), cv2.FONT_HERSHEY_SIMPLEX, 1, (0,0,0), 3)

        return frame

    def draw_annotations(self,video_frames, tracks,team_ball_control):
        output_video_frames= []
        for frame_num, frame in enumerate(video_frames):
            frame = frame.copy()

            player_dict = tracks["players"][frame_num]
            ball_dict = tracks["ball"][frame_num]
            referee_dict = tracks["referees"][frame_num]

            # Draw Players
            for track_id, player in player_dict.items():
                color = player.get("team_color",(0,0,255))
                frame = self.draw_ellipse(frame, player["bbox"],color, track_id)

                if player.get('has_ball',False):
                    frame = self.draw_traingle(frame, player["bbox"],(0,0,255))

            # Draw Referee
            for _, referee in referee_dict.items():
                frame = self.draw_ellipse(frame, referee["bbox"],(0,255,255))
            
            # Draw ball 
            for track_id, ball in ball_dict.items():
                frame = self.draw_traingle(frame, ball["bbox"],(0,255,0))


            # Draw Team Ball Control
            frame = self.draw_team_ball_control(frame, frame_num, team_ball_control)

            output_video_frames.append(frame)

        return output_video_frames
</file>

<file path="python/training/football_training_yolo_v5.ipynb">
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install ultralytics\n",
    "!pip install roboflow"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Get Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "loading Roboflow workspace...\n",
      "loading Roboflow project...\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Downloading Dataset Version Zip in football-players-detection-1 to yolov5pytorch:: 100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 148663/148663 [00:41<00:00, 3621.65it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "Extracting Dataset Version Zip to football-players-detection-1 in yolov5pytorch:: 100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 1338/1338 [00:06<00:00, 222.41it/s]\n"
     ]
    }
   ],
   "source": [
    "from roboflow import Roboflow\n",
    "rf = Roboflow(api_key=\"3205MH29k2z3u5Ejc3HU\") # THIS API KEY IS REVOKED. PLEASE USE YOUR OWN API KEY\n",
    "project = rf.workspace(\"roboflow-jvuqo\").project(\"football-players-detection-3zvbc\")\n",
    "version = project.version(1)\n",
    "dataset = version.download(\"yolov5\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'/mnt/d/AI_youtube_channel/videos/015.football_project/football_analysis/training/football-players-detection-1'"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dataset.location"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'football-players-detection-1/football-players-detection-1/valid'"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import shutil\n",
    "\n",
    "shutil.move('football-players-detection-1/train',\n",
    "            'football-players-detection-1/football-players-detection-1/train'\n",
    "            )\n",
    "\n",
    "shutil.move('football-players-detection-1/test',\n",
    "            'football-players-detection-1/football-players-detection-1/test'\n",
    "            )\n",
    "\n",
    "shutil.move('football-players-detection-1/valid',\n",
    "            'football-players-detection-1/football-players-detection-1/valid'\n",
    "            )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Training"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "!yolo task=detect mode=train model=yolov5x.pt data={dataset.location}/data.yaml epochs=100 imgsz=640"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "cv_env",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
</file>

<file path="python/utils/__init__.py">
from .video_utils import read_video, save_video
from .bbox_utils import get_center_of_bbox, get_bbox_width, measure_distance,measure_xy_distance,get_foot_position
</file>

<file path="python/utils/bbox_utils.py">
def get_center_of_bbox(bbox):
    x1,y1,x2,y2 = bbox
    return int((x1+x2)/2),int((y1+y2)/2)

def get_bbox_width(bbox):
    return bbox[2]-bbox[0]

def measure_distance(p1,p2):
    return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**0.5

def measure_xy_distance(p1,p2):
    return p1[0]-p2[0],p1[1]-p2[1]

def get_foot_position(bbox):
    x1,y1,x2,y2 = bbox
    return int((x1+x2)/2),int(y2)
</file>

<file path="python/utils/field_calibration.py">
import cv2
import numpy as np

class FieldCalibrator:
    def __init__(self, field_dims=(105, 68)):
        self.field_width = field_dims[0] # meters
        self.field_height = field_dims[1] # meters
        self.homography = None
        
        # Standard pitch keypoints (normalized 0-1)
        # Top-Left, Top-Right, Bottom-Right, Bottom-Left
        self.src_pts = np.float32([[0, 0], [1, 0], [1, 1], [0, 1]])
        
    def calibrate_manual(self, image_points):
        """
        Compute homography from 4 manually selected points corresponding to field corners.
        image_points: list of [x, y] for TL, TR, BR, BL corners of the pitch in the image
        """
        if len(image_points) != 4:
            print("Error: Need exactly 4 points for calibration")
            return False
            
        dst_pts = np.float32([
            [0, 0],
            [self.field_width, 0],
            [self.field_width, self.field_height],
            [0, self.field_height]
        ])
        
        self.homography = cv2.getPerspectiveTransform(np.float32(image_points), dst_pts)
        return True
        
    def transform(self, tracks):
        """
        Transform tracks from pixel coordinates to field coordinates.
        tracks: list of [x1, y1, x2, y2, ...]
        Returns: list of [field_x, field_y]
        """
        if self.homography is None:
            return []
            
        field_coords = []
        for track in tracks:
            # Use bottom-center of bounding box as player position
            x1, y1, x2, y2 = track[:4]
            foot_x = (x1 + x2) / 2
            foot_y = y2
            
            # Apply homography
            pt = np.array([[[foot_x, foot_y]]], dtype=np.float32)
            dst = cv2.perspectiveTransform(pt, self.homography)
            
            field_coords.append(dst[0][0])
            
        return np.array(field_coords)
        
    def pixel_to_field(self, x, y):
        if self.homography is None:
            return None
        pt = np.array([[[x, y]]], dtype=np.float32)
        dst = cv2.perspectiveTransform(pt, self.homography)
        return dst[0][0]
</file>

<file path="python/utils/model_downloader.py">
import os
import requests
import sys

MODELS = {
    "yolov10n.pt": "https://github.com/THU-MIG/yolov10/releases/download/v1.1/yolov10n.pt",
    "yolov10s.pt": "https://github.com/THU-MIG/yolov10/releases/download/v1.1/yolov10s.pt",
    "yolov10m.pt": "https://github.com/THU-MIG/yolov10/releases/download/v1.1/yolov10m.pt",
    "yolov10b.pt": "https://github.com/THU-MIG/yolov10/releases/download/v1.1/yolov10b.pt",
    "yolov10l.pt": "https://github.com/THU-MIG/yolov10/releases/download/v1.1/yolov10l.pt",
    "yolov10x.pt": "https://github.com/THU-MIG/yolov10/releases/download/v1.1/yolov10x.pt",
}

def download_file(url, filename):
    print(f"Downloading {filename}...")
    response = requests.get(url, stream=True)
    total_size = int(response.headers.get('content-length', 0))
    block_size = 1024
    wrote = 0
    
    with open(filename, 'wb') as f:
        for data in response.iter_content(block_size):
            wrote = wrote + len(data)
            f.write(data)
            done = int(50 * wrote / total_size)
            sys.stdout.write(f"\r[{'=' * done}{' ' * (50-done)}] {wrote}/{total_size} bytes")
            sys.stdout.flush()
    print(f"\nSaved to {filename}")

def check_and_download_models(target_dir='python/models/weights'):
    if not os.path.exists(target_dir):
        os.makedirs(target_dir)
        
    # Default to YOLOv10x for best accuracy, or 's' for speed
    target_model = "yolov10x.pt" 
    
    file_path = os.path.join(target_dir, target_model)
    if not os.path.exists(file_path):
        print(f"Model {target_model} not found.")
        download_file(MODELS[target_model], file_path)
    else:
        print(f"Model {target_model} already exists.")

if __name__ == "__main__":
    check_and_download_models()
</file>

<file path="python/utils/optical_flow.py">
import cv2
import numpy as np

class OpticalFlowEngine:
    def __init__(self):
        self.prev_gray = None
        self.feature_params = dict(maxCorners=100,
                                   qualityLevel=0.3,
                                   minDistance=7,
                                   blockSize=7)
        self.lk_params = dict(winSize=(15, 15),
                              maxLevel=2,
                              criteria=(cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 0.03))
                              
    def stabilize(self, tracks, frame):
        """
        Use optical flow to adjust/predict track positions if detection was shaky or missing.
        tracks: list of [x1, y1, x2, y2, id, score, cls]
        """
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        
        if self.prev_gray is None:
            self.prev_gray = gray
            return tracks
            
        # If we have no tracks, just update prev_gray
        if len(tracks) == 0:
            self.prev_gray = gray
            return tracks
            
        # For each track, calculate optical flow of its center or features
        stabilized_tracks = []
        
        for track in tracks:
            x1, y1, x2, y2 = track[:4]
            center = np.array([[(x1+x2)/2, (y1+y2)/2]], dtype=np.float32)
            
            # Calculate flow for the center point
            p1, st, err = cv2.calcOpticalFlowPyrLK(self.prev_gray, gray, center, None, **self.lk_params)
            
            if st[0][0] == 1:
                # Flow vector
                dx = p1[0][0] - center[0][0]
                dy = p1[0][1] - center[0][1]
                
                # Apply flow to box (simple stabilization)
                # In a full implementation, we would weight this against the detection
                # Here we just return the track, but in a real scenario we'd use this 
                # to fill in gaps if detection was missing (which is handled by Kalman Filter in HybridTracker)
                # So this module is mainly for smoothing or camera motion compensation
                pass
                
            stabilized_tracks.append(track)
            
        self.prev_gray = gray
        return np.array(stabilized_tracks)
        
    def estimate_camera_motion(self, frame):
        """
        Estimate global camera motion using background features
        """
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        if self.prev_gray is None:
            return np.array([0.0, 0.0])
            
        # Detect features in previous frame
        p0 = cv2.goodFeaturesToTrack(self.prev_gray, mask=None, **self.feature_params)
        
        if p0 is not None:
            p1, st, err = cv2.calcOpticalFlowPyrLK(self.prev_gray, gray, p0, None, **self.lk_params)
            
            # Select good points
            good_new = p1[st==1]
            good_old = p0[st==1]
            
            # Average motion
            if len(good_new) > 0:
                motion = np.mean(good_new - good_old, axis=0)
                return motion
                
        return np.array([0.0, 0.0])
</file>

<file path="python/utils/roboflow_utils.py">
import os
import time
import numpy as np
from typing import List, Dict, Union, Tuple
from roboflow import Roboflow
import supervision as sv

class RoboflowInference:
    """Helper class to run inference using Roboflow API."""
    
    def __init__(self, api_key: str, workspace_id: str, project_id: str, version: int):
        """
        Initialize Roboflow client.
        
        Args:
            api_key: Roboflow Private API Key
            workspace_id: Roboflow Workspace ID
            project_id: Roboflow Project ID
            version: Project Version number
        """
        self.rf = Roboflow(api_key=api_key)
        self.project = self.rf.workspace(workspace_id).project(project_id)
        self.model = self.project.version(version).model

    def infer(self, image: Union[np.ndarray, str], confidence: float = 0.4, overlap: float = 0.3) -> dict:
        """
        Run inference on an image.
        
        Args:
            image: Numpy array (BGR) or path to image file
            confidence: Confidence threshold
            overlap: IoU threshold
            
        Returns:
            Raw JSON response from Roboflow API
        """
        import uuid
        import os
        
        # Use unique temp file to avoid race conditions in threads
        temp_path = f"temp_inference_{uuid.uuid4()}.jpg"
        
        try:
            if isinstance(image, np.ndarray):
                import cv2
                
                # Optimization: Resize image to reduce upload time
                h, w = image.shape[:2]
                target_size = 640
                scale = target_size / max(h, w)
                if scale < 1:
                    new_w, new_h = int(w * scale), int(h * scale)
                    resized_image = cv2.resize(image, (new_w, new_h), interpolation=cv2.INTER_AREA)
                else:
                    resized_image = image

                cv2.imwrite(temp_path, resized_image)
                
                # Keypoint models might not support overlap/IoU
                try:
                    prediction = self.model.predict(temp_path, confidence=confidence*100, overlap=overlap*100).json()
                except TypeError:
                    prediction = self.model.predict(temp_path, confidence=confidence*100).json()

                # Helper to scale back coordinates
                if scale < 1:
                     self._scale_predictions(prediction, 1/scale)

            else:
                # If path provided
                try:
                    prediction = self.model.predict(image, confidence=confidence*100, overlap=overlap*100).json()
                except TypeError:
                    prediction = self.model.predict(image, confidence=confidence*100).json()
        
        finally:
            # Cleanup temp file
            if os.path.exists(temp_path):
                os.remove(temp_path)

            
        return prediction

    def _scale_predictions(self, result: dict, scale_factor: float):
        """
        Scale prediction coordinates back to original image size.
        Modifies result dict in-place.
        """
        predictions = result.get('predictions', [])
        for pred in predictions:
            if 'x' in pred: pred['x'] *= scale_factor
            if 'y' in pred: pred['y'] *= scale_factor
            if 'width' in pred: pred['width'] *= scale_factor
            if 'height' in pred: pred['height'] *= scale_factor
            
            if 'keypoints' in pred:
                for kp in pred['keypoints']:
                    if 'x' in kp: kp['x'] *= scale_factor
                    if 'y' in kp: kp['y'] *= scale_factor

    def _parse_roboflow_response(self, result: dict) -> sv.Detections:
        """
        Manually parse Roboflow JSON response to sv.Detections.
        
        Args:
            result: JSON response from Roboflow model.predict().json()
            
        Returns:
            sv.Detections object
        """
        predictions = result.get('predictions', [])
        
        if not predictions:
            return sv.Detections.empty()
            
        xyxy = []
        confidence = []
        class_id = []
        
        for pred in predictions:
            # Use .get() to avoid KeyError if keys are missing
            x = pred.get('x', 0)
            y = pred.get('y', 0)
            w = pred.get('width', 0)
            h = pred.get('height', 0)
            
            # Convert center-xywh to xyxy
            x_min = x - w / 2
            y_min = y - h / 2
            x_max = x + w / 2
            y_max = y + h / 2
            
            xyxy.append([x_min, y_min, x_max, y_max])
            confidence.append(pred.get('confidence', 0))
            class_id.append(pred.get('class_id', 0)) # Default to 0 if missing
            
        return sv.Detections(
            xyxy=np.array(xyxy),
            confidence=np.array(confidence),
            class_id=np.array(class_id)
        )

    def get_detections(self, image: np.ndarray, confidence: float = 0.4) -> sv.Detections:
        """
        Get detections in Supervision format.
        
        Args:
            image: Input image (numpy array)
            confidence: Confidence threshold
            
        Returns:
            sv.Detections object
        """
        result = self.infer(image, confidence=confidence)
        
        # Convert Roboflow JSON to Supervision Detections manually
        return self._parse_roboflow_response(result)

    def get_keypoints_detections(self, image: np.ndarray, confidence: float = 0.4) -> Tuple[sv.Detections, np.ndarray]:
        """
        Get keypoint detections.
        
        Args:
            image: Input image
            confidence: Confidence threshold
            
        Returns:
             Tuple of (detections, keypoints array)
        """
        # Note: Roboflow Keypoint response structure differs slightly.
        # Check if project type is keypoint-detection.
        
        result = self.infer(image, confidence=confidence)
        detections = self._parse_roboflow_response(result)
        
        # Extract keypoints manually from the JSON response
        predictions = result.get('predictions', [])
        all_kpts = []
        
        for pred in predictions:
            kpts = []
            if 'keypoints' in pred:
                for kp in pred['keypoints']:
                    # Roboflow keypoints: list of dicts {'x':, 'y':, 'confidence':}
                    x = kp.get('x', 0)
                    y = kp.get('y', 0)
                    # confidence key might vary or be absent
                    conf = kp.get('confidence', 0) 
                    kpts.append([x, y, conf])
                all_kpts.append(kpts)
            else:
                pass
                
        if len(all_kpts) > 0:
            # Check consistency of keypoints count
            # Use max length or truncate? Assuming uniform keypoint count for valid model.
            try:
                keypoints_array = np.array(all_kpts) # Shape (N, K, 3)
                return detections, keypoints_array
            except ValueError:
                 # Ragged array if keypoint counts differ (unlikely for standard model)
                 return detections, None
        else:
            return detections, None
</file>

<file path="python/utils/scene_analyzer.py">
import cv2
import numpy as np
from dataclasses import dataclass

@dataclass
class SceneInfo:
    is_crowded: bool
    is_shaky: bool
    lighting_condition: str  # 'good', 'low', 'glare'
    occlusion_level: float  # 0.0 to 1.0
    motion_intensity: float # 0.0 to 1.0

class SceneAnalyzer:
    def __init__(self):
        self.prev_frame = None
        self.prev_gray = None
        
    def analyze(self, frame) -> SceneInfo:
        """
        Analyze the current frame to determine scene characteristics.
        """
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        height, width = frame.shape[:2]
        
        # 1. Detect Camera Motion / Shake using Optical Flow on background
        motion_intensity = 0.0
        is_shaky = False
        
        if self.prev_gray is not None:
            # Calculate dense optical flow (Farneback) on a downscaled frame for speed
            small_curr = cv2.resize(gray, (width // 4, height // 4))
            small_prev = cv2.resize(self.prev_gray, (width // 4, height // 4))
            
            flow = cv2.calcOpticalFlowFarneback(small_prev, small_curr, None, 0.5, 3, 15, 3, 5, 1.2, 0)
            mag, _ = cv2.cartToPolar(flow[..., 0], flow[..., 1])
            motion_intensity = np.mean(mag)
            
            # Threshold for shaky camera (heuristic)
            if motion_intensity > 2.0:
                is_shaky = True
                
        self.prev_gray = gray
        
        # 2. Analyze Lighting
        avg_brightness = np.mean(gray)
        if avg_brightness < 50:
            lighting = 'low'
        elif avg_brightness > 200:
            lighting = 'glare'
        else:
            lighting = 'good'
            
        # 3. Estimate Crowding / Occlusion (Simple Edge Density)
        # More edges often means more texture/objects in a soccer context (players, crowd)
        # This is a rough proxy; true crowding comes from detection count
        edges = cv2.Canny(gray, 100, 200)
        edge_density = np.count_nonzero(edges) / (width * height)
        
        is_crowded = edge_density > 0.05  # Heuristic threshold
        occlusion_level = min(edge_density * 10, 1.0) # Normalize
        
        return SceneInfo(
            is_crowded=is_crowded,
            is_shaky=is_shaky,
            lighting_condition=lighting,
            occlusion_level=occlusion_level,
            motion_intensity=motion_intensity
        )
</file>

<file path="python/utils/video_utils.py">
import cv2

def read_video(video_path):
    cap = cv2.VideoCapture(video_path)
    frames = []
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        frames.append(frame)
    return frames

def save_video(ouput_video_frames,output_video_path):
    fourcc = cv2.VideoWriter_fourcc(*'XVID')
    out = cv2.VideoWriter(output_video_path, fourcc, 24, (ouput_video_frames[0].shape[1], ouput_video_frames[0].shape[0]))
    for frame in ouput_video_frames:
        out.write(frame)
    out.release()
</file>

<file path="python/verify_db_fixes.py">
import sqlite3
import os
import sys
from tactabot import get_db, ensure_user_exists, calculate_crowd_consensus, init_db, DB_PATH

def test_get_db():
    print("Testing get_db context manager...")
    conn_obj = None
    with get_db() as conn:
        conn_obj = conn
        c = conn.cursor()
        c.execute("SELECT 1")
        print("  Query executed successfully.")
    
    # Check if connection is closed
    try:
        conn_obj.execute("SELECT 1")
        print("‚ùå Connection was NOT closed!")
    except sqlite3.ProgrammingError:
        print("‚úÖ Connection closed successfully.")

def test_ensure_user_exists():
    print("\nTesting ensure_user_exists...")
    test_user_id = 999999
    ensure_user_exists(test_user_id, "testuser")
    
    with get_db() as conn:
        c = conn.cursor()
        c.execute("SELECT username, trust_score FROM users WHERE user_id=?", (test_user_id,))
        row = c.fetchone()
        if row and row[0] == "testuser" and row[1] == 50:
            print("‚úÖ User created successfully.")
        else:
            print(f"‚ùå User creation failed: {row}")

def test_consensus_locking():
    print("\nTesting consensus locking (basic run)...")
    # Just ensure it doesn't crash with the new BEGIN IMMEDIATE
    try:
        calculate_crowd_consensus(1)
        print("‚úÖ Consensus calculation ran without error.")
    except Exception as e:
        print(f"‚ùå Consensus calculation failed: {e}")

if __name__ == "__main__":
    # Ensure DB exists
    if not os.path.exists(DB_PATH):
        init_db()
        
    test_get_db()
    test_ensure_user_exists()
    test_consensus_locking()
</file>

<file path="python/view_transformer/__init__.py">
from .view_transformer import ViewTransformer
</file>

<file path="python/view_transformer/view_transformer.py">
import numpy as np 
import cv2

class ViewTransformer():
    def __init__(self):
        court_width = 68
        court_length = 23.32

        self.pixel_vertices = np.array([[110, 1035], 
                               [265, 275], 
                               [910, 260], 
                               [1640, 915]])
        
        self.target_vertices = np.array([
            [0,court_width],
            [0, 0],
            [court_length, 0],
            [court_length, court_width]
        ])

        self.pixel_vertices = self.pixel_vertices.astype(np.float32)
        self.target_vertices = self.target_vertices.astype(np.float32)

        self.persepctive_trasnformer = cv2.getPerspectiveTransform(self.pixel_vertices, self.target_vertices)

    def transform_point(self,point):
        p = (int(point[0]),int(point[1]))
        is_inside = cv2.pointPolygonTest(self.pixel_vertices,p,False) >= 0 
        if not is_inside:
            return None

        reshaped_point = point.reshape(-1,1,2).astype(np.float32)
        tranform_point = cv2.perspectiveTransform(reshaped_point,self.persepctive_trasnformer)
        return tranform_point.reshape(-1,2)

    def add_transformed_position_to_tracks(self,tracks):
        for object, object_tracks in tracks.items():
            for frame_num, track in enumerate(object_tracks):
                for track_id, track_info in track.items():
                    position = track_info['position_adjusted']
                    position = np.array(position)
                    position_trasnformed = self.transform_point(position)
                    if position_trasnformed is not None:
                        position_trasnformed = position_trasnformed.squeeze().tolist()
                    tracks[object][frame_num][track_id]['position_transformed'] = position_trasnformed
</file>

<file path="python/yolo_inference.py">
from ultralytics import YOLO 

model = YOLO('models/best.pt')

results = model.predict('input_videos/08fd33_4.mp4',save=True)
print(results[0])
print('=====================================')
for box in results[0].boxes:
    print(box)
</file>

<file path="QUICK_START_GPU.md">
# Quick Start Guide - Replicate Integration

## Current Status
Your web app is working with local Python execution. To use GPU acceleration via Replicate:

### Option 1: Deploy to Replicate (Recommended for Production)
1. Install Cog: https://github.com/replicate/cog#install
2. Run: `cog push r8.im/YOUR_USERNAME/soccer-analysis`
3. Add to `.env`:
   ```
   REPLICATE_API_TOKEN=your_token
   REPLICATE_MODEL=YOUR_USERNAME/soccer-analysis
   ```
4. Modify `server.js` to use Replicate API (see `replicate_integration_example.js`)

### Option 2: Keep Using Local + Fix JSON Error
The JSON serialization error in Colab has been fixed in the code.  
To use locally, just run `npm run server` as you currently do.

### Option 3: Use Colab Manually (Current Workaround)
1. Upload `colab_package.zip` to Colab
2. Upload video
3. Run analysis
4. Download JSON
5. Upload JSON to your web app

## Files Created
- `cog.yaml` - Replicate deployment config
- `predict.py` - Replicate predictor
- `REPLICATE_DEPLOY.md` - Detailed deployment guide
- `replicate_integration_example.js` - Example integration code

## Next Steps
Choose one of the options above based on your needs.
</file>

<file path="read_MS_docx.py">
import zipfile
import re
import xml.etree.ElementTree as ET
import sys
import os

def read_docx(file_path):
    if not os.path.exists(file_path):
        print(f"File not found: {file_path}")
        return

    try:
        with zipfile.ZipFile(file_path) as z:
            xml_content = z.read('word/document.xml')
            tree = ET.fromstring(xml_content)
            
            # fast and loose XML parsing for text in w:t tags
            # The namespace map for docx usually includes w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
            # But finding all text nodes recursively is easier
            
            text_content = []
            for elem in tree.iter():
                if elem.tag.endswith('}t'):
                    if elem.text:
                        text_content.append(elem.text)
                elif elem.tag.endswith('}p'):
                    text_content.append('\n') 
            
            print("".join(text_content))
            
    except Exception as e:
        print(f"Error reading docx: {e}")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        read_docx(sys.argv[1])
    else:
        print("Please provide a file path")
</file>

<file path="README.md">
# Soccer Controller Log - Real-Time Match Analysis System

A comprehensive web application for real-time soccer match event logging, video analysis, and synchronized multi-device viewing with gamepad support.

## üéØ Overview

This application enables coaches, analysts, and scouts to log match events in real-time using gamepad controllers, upload and analyze match videos with AI-powered tracking, and synchronize playback across multiple devices. It features voice recognition, smart player selection, tactical analysis, and real-time audio/video broadcasting.

## ‚ú® Key Features

### üìä Real-Time Event Logging
- **Gamepad Control**: Log events using Xbox/PlayStation controllers
- **Voice Recognition**: Hands-free event logging with voice commands
- **Smart Player Selection**: AI-assisted player identification with D-pad navigation
- **Event Types**: Goals, passes, fouls, shots, possession changes, substitutions, and more
- **Live Sync**: Events broadcast instantly to all connected viewers

### üé• Video Analysis
- **Video Upload**: Upload match videos for synchronized playback
- **AI Tracking**: Automatic player detection and tracking
- **Heatmaps**: Generate team and player position heatmaps
- **Speed Analysis**: Calculate player speeds and sprint detection
- **Passing Predictions**: AI-powered passing lane analysis
- **Tactical Alerts**: Real-time tactical situation detection

### üéÆ Gamepad Features
- **Zoom & Pan**: R2/L2 for zoom, right stick for pan control
- **Event Logging**: Quick event logging with mapped buttons
- **Player Selection**: D-pad navigation for selecting players
- **Customizable Mappings**: Remap buttons to your preference

### üîÑ Multi-Device Synchronization
- **Broadcaster/Viewer Roles**: One broadcaster, multiple viewers
- **Video Sync**: Play, pause, seek synchronized across all devices
- **Event Sync**: Events appear on all connected devices instantly
- **Team Data Sync**: Roster and team information shared automatically
- **Audio Broadcasting**: Real-time audio commentary via WebRTC

### üìà Analysis & Visualization
- **Event Timeline**: Visual timeline of all match events
- **Player Statistics**: Individual player performance metrics
- **Team Analytics**: Team-level tactical analysis
- **Export Data**: Export events and analysis to JSON/CSV

## üöÄ Getting Started

### Prerequisites

- **Node.js** (v18 or higher)
- **Python** (v3.8 or higher)
- **npm** or **yarn**

### Installation

1. **Clone the repository**
```bash
git clone <repository-url>
cd soccer-controller-log-main
```

2. **Install Node.js dependencies**
```bash
npm install
```

3. **Install Python dependencies**
```bash
cd python
pip install -r requirements.txt
cd ..
```

4. **Create required directories**
```bash
mkdir -p public/uploads
mkdir -p public/heatmaps
mkdir -p public/analysis
```

### Running the Application

1. **Start the backend server**
```bash
npm run server
```
Server will run on `http://localhost:3003`

2. **Start the frontend development server**
```bash
npm run dev
```
Frontend will run on `http://localhost:5173`

3. **Access the application**
- **Broadcaster**: Open `http://localhost:5173` on the main device
- **Viewers**: Open `http://localhost:5173` on additional devices (same network)

## üéÆ Gamepad Setup

### Supported Controllers
- Xbox One/Series Controllers
- PlayStation 4/5 DualShock/DualSense
- Generic USB/Bluetooth gamepads

### Default Button Mappings

| Button | Function |
|--------|----------|
| A (Cross) | Confirm/Select |
| B (Circle) | Cancel |
| X (Square) | Pass Event |
| Y (Triangle) | Shot Event |
| LB | Previous Player |
| RB | Next Player |
| LT | Zoom Out |
| RT | Zoom In |
| D-Pad | Navigate Player Selection |
| Left Stick | Navigate UI |
| Right Stick | Pan Video (when zoomed) |
| Start | Toggle Match Timer |
| Select | Open Settings |

### Customizing Mappings
1. Click the **Settings** icon in the top-right
2. Navigate to **Gamepad Settings**
3. Click on any button to remap
4. Press the desired button on your controller
5. Click **Save Mappings**

## üìπ Video Upload & Analysis

### Uploading Videos

1. Click **Upload Video** in the video mode section
2. Select your match video file (MP4, AVI, MOV supported)
3. Video will upload to server and become available to all viewers
4. Use playback controls to navigate through the video

### Running AI Analysis

1. Upload a video first
2. Click the **Settings** icon on the video player
3. Configure analysis options:
   - **Full Video**: Analyze entire video with real-time tracking
   - **Event Clips**: Analyze only logged event clips (¬±5 seconds)
   - **Generate Video**: Create annotated video with overlays
4. Click **Run Analysis**
5. Wait for processing (may take several minutes)
6. View results with player tracking, heatmaps, and tactical insights

### Analysis Features

- **Player Tracking**: Bounding boxes around detected players
- **Speed Calculation**: Real-time speed display for each player
- **Sprint Detection**: Highlights when players are sprinting
- **Passing Predictions**: Shows likely passing targets
- **Tactical Alerts**: Notifications for offsides, pressing, counter-attacks
- **Heatmaps**: Position density visualization

## üîä Voice Commands

Enable voice recognition to log events hands-free:

### Supported Commands
- "Goal" - Log a goal
- "Pass" - Log a pass
- "Shot" - Log a shot attempt
- "Foul" - Log a foul
- "Corner" - Log a corner kick
- "Throw-in" - Log a throw-in
- "Offside" - Log an offside
- "Substitution" - Log a player substitution
- "Yellow card" - Log a yellow card
- "Red card" - Log a red card

### Enabling Voice Recognition
1. Click the **microphone icon** in the header
2. Allow microphone permissions when prompted
3. Speak commands clearly
4. Commands will be logged automatically

## üì± Multi-Device Setup

### Broadcaster Setup
1. Open the app on your main device
2. You'll automatically be assigned as **Broadcaster**
3. Upload team rosters (JSON format)
4. Upload match video (optional)
5. Start logging events

### Viewer Setup
1. Open the app on additional devices
2. Ensure devices are on the same network
3. You'll automatically be assigned as **Viewer**
4. All events and video playback will sync automatically

### Network Configuration
- Devices must be on the same local network
- Firewall may need to allow port 3003
- For remote access, configure port forwarding or use ngrok

## üìä Team Roster Format

Upload team rosters in JSON format:

```json
{
  "teamName": "Team Name",
  "players": [
    {
      "number": 10,
      "name": "Player Name",
      "position": "Forward",
      "isStarting": true
    }
  ]
}
```

### Roster Features
- **Starting Lineup**: Mark starting XI
- **Substitutes**: Track bench players
- **Player Selection**: Quick selection during events
- **Position Tracking**: Record player positions

## üõ†Ô∏è Technical Architecture

### Frontend Stack
- **React** with TypeScript
- **Vite** for build tooling
- **Tailwind CSS** for styling
- **shadcn/ui** for UI components
- **Socket.IO Client** for real-time communication
- **WebRTC** for audio/video streaming

### Backend Stack
- **Node.js** with Express
- **Socket.IO** for WebSocket communication
- **Multer** for file uploads
- **Python** for AI analysis

### AI/ML Components
- **YOLOv8** for player detection
- **ByteTrack** for player tracking
- **OpenCV** for video processing
- **NumPy/Pandas** for data analysis

## üìÅ Project Structure

```
soccer-controller-log-main/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/       # React components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VideoPlayer/  # Video player with AI overlays
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EventLog/     # Event logging interface
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dashboard/    # Analytics dashboard
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ hooks/            # Custom React hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useGamepad.ts # Gamepad integration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useVoiceRecognition.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ pages/            # Page components
‚îÇ   ‚îú‚îÄ‚îÄ types/            # TypeScript types
‚îÇ   ‚îî‚îÄ‚îÄ utils/            # Utility functions
‚îú‚îÄ‚îÄ python/               # Python analysis scripts
‚îÇ   ‚îú‚îÄ‚îÄ analyze_match.py  # Main analysis script
‚îÇ   ‚îú‚îÄ‚îÄ extract_positions.py
‚îÇ   ‚îú‚îÄ‚îÄ generate_heatmap.py
‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ public/               # Static assets
‚îÇ   ‚îú‚îÄ‚îÄ uploads/          # Uploaded videos
‚îÇ   ‚îú‚îÄ‚îÄ heatmaps/         # Generated heatmaps
‚îÇ   ‚îî‚îÄ‚îÄ analysis/         # Analysis results
‚îú‚îÄ‚îÄ server.js             # Backend server
‚îî‚îÄ‚îÄ package.json
```

## üîß Configuration

### Environment Variables

Create a `.env` file in the root directory:

```env
PORT=3003
VITE_API_BASE_URL=http://localhost:3003
```

### Server Configuration

Edit `server.js` to customize:
- Port number
- CORS settings
- Upload limits
- Static file paths

## üêõ Troubleshooting

### Gamepad Not Detected
- Ensure controller is properly connected
- Try reconnecting the controller
- Check browser gamepad support (Chrome/Edge recommended)
- Press any button to wake up the controller

### Video Not Syncing
- Check network connection
- Ensure all devices are connected to the same server
- Refresh the page on viewer devices
- Check browser console for errors

### Analysis Failing
- Verify Python dependencies are installed
- Check video file format (MP4 recommended)
- Ensure sufficient disk space
- Check Python script logs in terminal

### Audio Not Broadcasting
- Allow microphone permissions in browser
- Check audio input device settings
- Ensure WebRTC is supported (HTTPS or localhost only)
- Try refreshing both broadcaster and viewer

## üìù API Endpoints

### Video Upload
```
POST /api/upload-video
Content-Type: multipart/form-data
Body: { video: File }
Response: { success: true, videoUrl: string }
```

### Match Analysis
```
POST /api/analyze-match
Content-Type: multipart/form-data
Body: { 
  video: File,
  clips?: string,
  generate_annotated_video?: string
}
Response: { success: true, results: AnalysisResults }
```

### Position Extraction
```
POST /api/extract-positions
Content-Type: multipart/form-data
Body: {
  video: File,
  startTime?: number,
  endTime?: number
}
Response: { success: true, positions: PositionData }
```

### Heatmap Generation
```
POST /api/generate-heatmap
Content-Type: application/json
Body: {
  team?: string,
  scatter?: boolean
}
Response: { success: true, heatmap: string }
```

## üîå Socket.IO Events

### Client ‚Üí Server
- `new-event` - Log new match event
- `update-event` - Update existing event
- `sync-timer` - Sync match timer
- `sync-teams` - Sync team rosters
- `select-team` - Select active team
- `video-play` - Play video
- `video-pause` - Pause video
- `video-seek` - Seek to timestamp
- `video-loaded` - Notify video loaded

### Server ‚Üí Client
- `sync-state` - Initial state sync
- `role-assignment` - Assign broadcaster/viewer role
- `new-event` - Broadcast new event
- `update-event` - Broadcast event update
- `sync-timer` - Broadcast timer update
- `sync-teams` - Broadcast team data
- `video-play` - Broadcast play command
- `video-pause` - Broadcast pause command
- `video-seek` - Broadcast seek command
- `video-loaded` - Broadcast video URL

## ü§ù Contributing

Contributions are welcome! Please follow these guidelines:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## üìÑ License

This project is licensed under the MIT License - see the LICENSE file for details.

## üôè Acknowledgments

- **YOLOv8** by Ultralytics for object detection
- **ByteTrack** for multi-object tracking
- **shadcn/ui** for beautiful UI components
- **Socket.IO** for real-time communication

## üìß Support

For issues, questions, or feature requests, please open an issue on GitHub.

---

**Built with ‚ù§Ô∏è for soccer analysts and coaches**
#   t a c t a 
 
 
</file>

<file path="REPLICATE_DEPLOY.md">
# Replicate Deployment Guide

## Prerequisites
1. Install Cog: `curl -o /usr/local/bin/cog -L https://github.com/replicate/cog/releases/latest/download/cog_$(uname -s)_$(uname -m) && chmod +x /usr/local/bin/cog`
2. Create Replicate account: https://replicate.com/
3. Get API token: https://replicate.com/account/api-tokens

## Deploy to Replicate

### 1. Test Locally (Optional)
```bash
# From project root
cog predict -i video=@path/to/test_video.mp4
```

### 2. Push to Replicate
```bash
# Login
cog login

# Push model (replace YOUR_USERNAME)
cog push r8.im/YOUR_USERNAME/soccer-analysis
```

### 3. Get Model URL
After pushing, you'll get a URL like:
`r8.im/YOUR_USERNAME/soccer-analysis`

### 4. Update server.js
Add your Replicate API token and model URL to `.env`:
```
REPLICATE_API_TOKEN=r8_your_token_here
REPLICATE_MODEL=YOUR_USERNAME/soccer-analysis
```

## Usage from Web App
Once deployed, your web app will automatically use the Replicate API when the environment variables are set.

## Cost Estimation
- GPU: NVIDIA T4 (~$0.0002/second)
- Average analysis time: 2-3 minutes
- Cost per analysis: ~$0.02-0.04
</file>

<file path="replicate-analyzer.js">
// Replicate GPU Integration Module
import Replicate from 'replicate';
import fs from 'fs';

export class ReplicateAnalyzer {
    constructor() {
        this.apiToken = process.env.REPLICATE_API_TOKEN;
        this.model = process.env.REPLICATE_MODEL;
        this.enabled = !!(this.apiToken && this.model);

        if (this.enabled) {
            this.replicate = new Replicate({ auth: this.apiToken });
            console.log(`‚úÖ Replicate GPU enabled: ${this.model}`);
        } else {
            console.log('‚ÑπÔ∏è  Replicate not configured, using local Python');
        }
    }

    isEnabled() {
        return this.enabled;
    }

    async analyze(videoPath, options = {}) {
        if (!this.enabled) {
            throw new Error('Replicate not configured');
        }

        console.log(`üöÄ Starting Replicate analysis: ${videoPath}`);

        try {
            // Read video file and convert to base64 data URI
            const videoBuffer = fs.readFileSync(videoPath);
            const base64Video = videoBuffer.toString('base64');
            const dataUri = `data:video/mp4;base64,${base64Video}`;

            // Run prediction
            const output = await this.replicate.run(
                this.model,
                {
                    input: {
                        video: dataUri,
                        confidence_threshold: options.confidenceThreshold || 0.3,
                        generate_video: options.generateVideo || false
                    }
                }
            );

            console.log('‚úÖ Replicate analysis complete');
            return output;

        } catch (error) {
            console.error('‚ùå Replicate analysis failed:', error);
            throw error;
        }
    }

    async analyzeWithProgress(videoPath, options = {}, progressCallback) {
        if (!this.enabled) {
            throw new Error('Replicate not configured');
        }

        console.log(`üöÄ Starting Replicate analysis with progress: ${videoPath}`);

        try {
            const videoBuffer = fs.readFileSync(videoPath);
            const base64Video = videoBuffer.toString('base64');
            const dataUri = `data:video/mp4;base64,${base64Video}`;

            // Create prediction
            const prediction = await this.replicate.predictions.create({
                version: this.model,
                input: {
                    video: dataUri,
                    confidence_threshold: options.confidenceThreshold || 0.3,
                    generate_video: options.generateVideo || false
                }
            });

            // Poll for completion
            let result = prediction;
            while (result.status !== 'succeeded' && result.status !== 'failed') {
                await new Promise(resolve => setTimeout(resolve, 1000));
                result = await this.replicate.predictions.get(prediction.id);

                if (progressCallback) {
                    progressCallback({
                        status: result.status,
                        logs: result.logs
                    });
                }
            }

            if (result.status === 'failed') {
                throw new Error(result.error || 'Prediction failed');
            }

            console.log('‚úÖ Replicate analysis complete');
            return result.output;

        } catch (error) {
            console.error('‚ùå Replicate analysis failed:', error);
            throw error;
        }
    }
}
</file>

<file path="RUNPOD_GUIDE.md">
# RunPod Deployment Guide

This guide will help you deploy the soccer analysis backend to your RunPod GPU instance.

## Prerequisites
- A RunPod account with credits (which you have!)
- The local project files

## Step 1: Launch a Pod
1. Go to [RunPod Console](https://www.runpod.io/console/pods)
2. Click **Deploy** (or "Launch a GPU environment")
3. Select a GPU (e.g., RTX 3090 or 4090 are great for this)
4. Choose a Template: **RunPod PyTorch 2.1** (or similar)
   - *Note: Ensure it has Python 3.10+*
5. Click **Continue** -> **Deploy**

## Step 2: Prepare Your Code
We need to upload the `python` folder to the Pod.

1. On your local machine, zip the `python` folder inside `soccer-controller-log-main`.
   - You should have a file named `python.zip` containing `analyze_match.py`, `api.py`, etc.

## Step 3: Connect and Upload
1. Once your Pod is **Running**, click the **Connect** button.
2. Click **Start Web Terminal** (or use SSH if you prefer).
3. In the terminal, create a directory:
   ```bash
   mkdir soccer-analysis
   cd soccer-analysis
   ```
4. **Upload the Code**:
   - In the Web Terminal UI, look for an "Upload" button (usually top right or via Jupyter Lab).
   - Upload your `python.zip`.
   - Unzip it:
     ```bash
     unzip python.zip
     cd python
     ```

## Step 4: Install Dependencies
Run the following command in the terminal (inside the `python` folder):

```bash
pip install -r requirements.txt
```

*Note: If you get an error about `cv2` (OpenCV), run:*
```bash
apt-get update && apt-get install -y libgl1
```

## Step 5: Start the Server
Run the API server:

```bash
python api.py
```

You should see: `Uvicorn running on http://0.0.0.0:8000`

## Step 6: Expose the Port
1. Go back to the **RunPod Console** -> **My Pods**.
2. Click the **Connect** button on your pod.
3. Look for **TCP Port Mappings**.
4. Find the public IP and port mapping for internal port **8000**.
   - It will look like: `123.45.67.89:12345` -> `8000`
   - Or if using the Proxy feature: `https://<pod-id>-8000.proxy.runpod.net`

## Step 7: Connect Web App
1. Open your local web app (`http://localhost:5173`).
2. Go to the **Video Player**.
3. Click the **Settings** (gear icon).
4. In **Vast.ai / Remote Server URL**, enter the URL from Step 6.
   - Example: `http://123.45.67.89:12345` or `https://<pod-id>-8000.proxy.runpod.net`
   - *Do not include a trailing slash.*
5. Upload a video and click **Run Analysis**.

üöÄ The analysis will now run on the powerful RunPod GPU!
</file>

<file path="scripts/forward.js">
import ngrok from 'ngrok';
import dotenv from 'dotenv';

dotenv.config();

const PORT = 3001; // backend port

async function startForwarding() {
    try {
        console.log('üßπ Disconnecting existing ngrok tunnels...');

        // Ÿáÿ∞ÿß ŸäŸÖÿ≥ÿ≠ ŸÉŸÑ ÿßŸÑŸÄ tunnels ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ©
        await ngrok.disconnect();
        await ngrok.kill();

        console.log(`üöÄ Starting ngrok tunnel for port ${PORT}...`);

        const options = {
            addr: PORT,
            proto: 'http',
            authtoken: process.env.NGROK_AUTHTOKEN, // ÿÆŸÑŸäŸá ÿØÿßŸäŸÖŸãÿß ŸáŸÜÿß
        };

        const url = await ngrok.connect(options);

        console.log('\n=========================================');
        console.log('‚úÖ NGROK FORWARDING ACTIVE');
        console.log(`üîó Public URL: ${url}`);
        console.log('=========================================\n');

        console.log('Keep this process running to maintain the tunnel.');
        console.log('Press Ctrl+C to stop.');

    } catch (err) {
        console.error('‚ùå Error starting ngrok:', err);
        process.exit(1);
    }
}

startForwarding();
</file>

<file path="scripts/generate-pdf.js">
import puppeteer from 'puppeteer';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

(async () => {
    try {
        const browser = await puppeteer.launch();
        const page = await browser.newPage();

        // Path to your HTML file
        // Assuming this script is in 'scripts/' and 'the ask.html' is in the root
        const htmlPath = path.join(__dirname, '..', 'the ask.html');
        const fileUrl = `file://${htmlPath}`;

        console.log(`Loading: ${fileUrl}`);
        await page.goto(fileUrl, { waitUntil: 'networkidle0' });

        // Force visibility of all fade-in elements and fix gallery layout for PDF
        console.log('Injecting CSS to force visibility and fix layout...');
        await page.addStyleTag({
            content: `
        .fade-in {
          opacity: 1 !important;
          transform: none !important;
        }
        
        /* Change horizontal scroll to grid layout for PDF */
        .gallery-scroller {
          display: grid !important;
          grid-template-columns: repeat(2, 1fr) !important;
          gap: 20px !important;
          overflow: visible !important;
          padding: 0 !important;
        }
        
        /* Ensure images fit nicely */
        .gallery-item {
            width: 100% !important;
            margin-bottom: 20px !important;
            page-break-inside: avoid !important; /* Prevent cutting images across pages */
        }
        
        .gallery-img {
            width: 100% !important;
            height: auto !important;
            max-height: 250px !important;
            object-fit: cover !important; 
        }

        /* Adjust caption styling */
        .gallery-caption {
            font-size: 0.8rem !important;
            margin-top: 5px !important;
        }
      `
        });

        // Set viewport to ensure responsiveness is handled (optional but good practice)
        await page.setViewport({ width: 1200, height: 800 });

        const pdfPath = path.join(__dirname, '..', 'public', 'the ask.pdf');

        console.log('Generating PDF...');
        await page.pdf({
            path: pdfPath,
            format: 'A4',
            printBackground: true,
            margin: {
                top: '20px',
                bottom: '20px',
                left: '20px',
                right: '20px'
            }
        });

        console.log(`PDF generated successfully at: ${pdfPath}`);

        await browser.close();
    } catch (error) {
        console.error('Error generating PDF:', error);
        process.exit(1);
    }
})();
</file>

<file path="SERVER_FIX_NEEDED.md">
# IMPORTANT: Server.js Needs Manual Fix

## Problem
The `server.js` file got corrupted during an edit attempt. The imports at the top are missing.

## Quick Fix
Add these lines at the very top of `server.js` (before line 1):

```javascript
import { fileURLToPath } from 'url';
import path from 'path';
import fs from 'fs';
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { spawn } from 'child_process';
import http from 'http';
import https from 'https';
import multer from 'multer';
import dotenv from 'dotenv';
import { ReplicateAnalyzer } from './replicate-analyzer.js';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Initialize Replicate (optional GPU acceleration)
const replicateAnalyzer = new ReplicateAnalyzer();

```

Then find the line that starts with `const storage = multer.diskStorage({` and make sure it comes AFTER these imports.

## Alternative: I Can Create a New server.js
Let me know if you'd like me to create a fresh `server.js` with Replicate integration included.
</file>

<file path="server.js">
// server.js - Main application entry point
import { fileURLToPath } from 'url';
import path from 'path';
import fs from 'fs';
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { spawn } from 'child_process';
import http from 'http';
import https from 'https';
import multer from 'multer';
import dotenv from 'dotenv';
import { ReplicateAnalyzer } from './replicate-analyzer.js';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Initialize Replicate (optional GPU acceleration)
const replicateAnalyzer = new ReplicateAnalyzer();

// Routes
import uploadRoutes from './src/routes/upload.routes.js';
import heatmapRoutes from './src/routes/heatmap.routes.js';
import analysisRoutes from './src/routes/analysis.routes.js';
import proxyRoutes from './src/routes/proxy.routes.js';
import roboflowRoutes from './src/routes/roboflow.routes.js';
import authRoutes from './src/routes/auth.routes.js';
import userRoutes from './src/routes/user.routes.js';
import lfpRoutes from './src/routes/lfp.routes.js';
import exportRoutes from './src/routes/export.routes.js';

// Socket
import { setupSocketHandlers } from './src/socket/handlers.js';
import { verifyToken } from './src/services/auth.service.js';

// ===== EXPRESS APP =====
const app = express();

// ===== CORS CONFIG =====
const corsOptions = {
    origin: (origin, callback) => {
        const allowedOrigins = [
            'http://localhost:5173',
            'http://localhost:8080',
            'https://tactasports.onrender.com',
            'https://tactasports-1.onrender.com',
            process.env.CORS_ORIGIN, // Vercel Domain
            process.env.FRONTEND_URL  // Alternative name
        ].filter(Boolean);

        // Allow requests with no origin (like mobile apps or curl)
        if (!origin) return callback(null, true);

        // Allow exact matches or development
        if (allowedOrigins.includes(origin) || process.env.NODE_ENV !== 'production') {
            return callback(null, true);
        }

        console.warn(`[CORS] Blocked request from unauthorized origin: ${origin}`);
        return callback(new Error('Not allowed by CORS'));
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'ngrok-skip-browser-warning', 'Bypass-Tunnel-Reminder', 'Accept', 'Origin'],
    optionsSuccessStatus: 200
};

app.use(cors(corsOptions));

// Simple request logger
app.use((req, res, next) => {
    if (req.method !== 'OPTIONS') {
        console.log(`[HTTP] ${req.method} ${req.url} - Origin: ${req.headers.origin || 'none'}`);
    }
    next();
});
app.use(bodyParser.json({ limit: '50mb' }));

// Static
app.use('/heatmaps', express.static(path.join(__dirname, 'public/heatmaps')));
app.use('/uploads', express.static(path.join(__dirname, 'public/uploads')));
app.use('/analysis', express.static(path.join(__dirname, 'public/analysis')));
app.use('/extracted', express.static(path.join(__dirname, 'public/extracted')));

// API
app.use('/api/auth', authRoutes);
app.use('/api', uploadRoutes);
app.use('/api', heatmapRoutes);
app.use('/api', analysisRoutes);
app.use('/api', proxyRoutes);
app.use('/api', roboflowRoutes);
app.use('/api/users', userRoutes);
app.use('/api', lfpRoutes);
app.use('/api', exportRoutes);

// ===== HTTP + SOCKET.IO =====
const httpServer = createServer(app);

const io = new Server(httpServer, {
    path: '/socket.io',
    cors: {
        origin: true, // Socket.IO doesn't support callback-style, use 'true' to allow all or specify domains
        methods: ['GET', 'POST'],
        credentials: true,
    },
});

// üîê Socket Auth Middleware
io.use((socket, next) => {
    try {
        const token = socket.handshake.auth?.token;

        if (!token) {
            return next(new Error('No auth token'));
        }

        const decoded = verifyToken(token);
        if (!decoded) {
            return next(new Error('Invalid token'));
        }

        socket.user = decoded;
        next();
    } catch (err) {
        next(new Error('Socket authentication failed'));
    }
});

// üß† Handlers
io.on('connection', (socket) => {
    console.log(`üîå Client connected: ${socket.id} | user=${socket.user?.id}`);

    // Only the Admin is the authoritative broadcaster for general state sync
    const role = (socket.user?.role === 'admin') ? 'broadcaster' : 'viewer';
    socket.emit('role-assignment', role);

    socket.on('disconnect', () => {
        console.log(`‚ùå Client disconnected: ${socket.id}`);
    });
});

// Modular handlers
setupSocketHandlers(io);

// ===== OBS TEST ENDPOINT =====
app.get('/api/test-obs', async (req, res) => {
    try {
        console.log('üß™ Testing OBS connection...');
        const OBSWebSocket = (await import('obs-websocket-js')).default;
        const obs = new OBSWebSocket();

        await obs.connect('ws://localhost:4455', '', {
            rpcVersion: 1
        });

        const version = await obs.call('GetVersion');
        await obs.disconnect();

        res.json({
            success: true,
            message: 'OBS connection successful!',
            version
        });
    } catch (error) {
        console.error('üß™ OBS test failed:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            code: error.code
        });
    }
});

// ===== HEALTH CHECK ENDPOINT =====
app.get('/api/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV || 'development'
    });
});

// ===== EVENT CONFIG API =====
const EVENTS_CONFIG_FILE = path.join(__dirname, 'config', 'events.json');

app.get('/api/events-config', async (req, res) => {
    try {
        // Using fs.promises for async file operations
        const fileExists = await fs.promises.access(EVENTS_CONFIG_FILE, fs.constants.F_OK)
            .then(() => true)
            .catch(() => false);

        if (fileExists) {
            const data = await fs.promises.readFile(EVENTS_CONFIG_FILE, 'utf8');
            const events = JSON.parse(data);
            res.json(events);
        } else {
            // If no config, return the default registry (client will need to handle this fallback initially or we prime it)
            res.json([]);
        }
    } catch (err) {
        console.error('Error reading events config:', err);
        res.status(500).json({ error: 'Failed to read events config' });
    }
});

app.post('/api/events-config', async (req, res) => {
    try {
        const events = req.body;
        // Ensure directory exists
        await fs.promises.mkdir(path.dirname(EVENTS_CONFIG_FILE), { recursive: true });
        await fs.promises.writeFile(EVENTS_CONFIG_FILE, JSON.stringify(events, null, 2), 'utf8');
        console.log('‚úÖ Events configuration updated');
        res.json({ success: true });
    } catch (err) {
        console.error('Error saving events config:', err);
        res.status(500).json({ error: 'Failed to save events config' });
    }
});

// ===== SERVE REACT FRONTEND (VITE BUILD) =====
// This must come AFTER all API routes
if (process.env.NODE_ENV === 'production') {
    // Serve static files from the Vite build
    app.use(express.static(path.join(__dirname, 'dist')));

    // Handle React Router - send all non-API requests to index.html
    // Use regex to match anything that doesn't start with /api
    app.get(/^(?!\/api).*/, (req, res) => {
        res.sendFile(path.join(__dirname, 'dist', 'index.html'));
    });
}

// Global Error Handler (Must be last middleware)
app.use((err, req, res, next) => {
    console.error('[Global Error]', err);
    // Ensure we don't return HTML for API requests
    if (res.headersSent) {
        return next(err);
    }

    // Multer errors
    if (err.name === 'MulterError') {
        return res.status(400).json({ success: false, error: `Upload Error: ${err.message}` });
    }

    res.status(500).json({ success: false, error: err.message || "Internal Server Error" });
});

const PORT = process.env.PORT || 3001;
console.log(`üåç Environment: ${process.env.NODE_ENV || 'development'}`);
console.log(`üåê Allowed CORS Origin: ${process.env.CORS_ORIGIN || 'None (Dev Mode)'}`);

httpServer.listen(PORT, '0.0.0.0', () => {
    console.log(`üöÄ Server running on http://localhost:${PORT}`);
    console.log(`üì° API available at http://localhost:${PORT}/api`);
});
</file>

<file path="server.js.backup">
import { fileURLToPath } from 'url';
import path from 'path';
import fs from 'fs';
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { spawn } from 'child_process';
import http from 'http';
import https from 'https';
import multer from 'multer';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ===== CONFIGURATION =====

// Configure multer for video uploads
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        const uploadDir = path.join(__dirname, 'public', 'uploads');
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
    },
    filename: function (req, file, cb) {
        cb(null, 'video-' + Date.now() + path.extname(file.originalname));
    }
});

const upload = multer({ storage: storage });

const app = express();
app.use(cors());
// Increased limit for heavy JSON payloads (like team data)
app.use(bodyParser.json({ limit: '50mb' }));
app.use('/heatmaps', express.static(path.join(__dirname, 'public', 'heatmaps')));

const httpServer = createServer(app);
const io = new Server(httpServer, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

// ===== STATE MANAGEMENT =====

// Store current state to sync with new connections
let currentState = {
    events: [],
    matchTime: 0,
    isMatchActive: false,
    selectedTeam: "", // Holds the ID of the currently selected team
    teams: []         // Holds the array of team objects
};

let broadcasterId = null;

// ===== HEATMAP API ENDPOINTS (Unchanged) =====

app.post('/api/extract-positions', upload.single('video'), (req, res) => {
    if (!req.file) return res.status(400).json({ error: 'No video file uploaded' });

    const videoPath = req.file.path;
    const startTime = req.body.startTime || 0;
    const endTime = req.body.endTime || null;
    const outputPath = path.join(__dirname, 'public', 'heatmaps', 'positions.json');
    const pythonScript = path.join(__dirname, 'python', 'extract_positions.py');

    const args = [pythonScript, '--video', videoPath, '--output', outputPath, '--frame-skip', '5', '--start-time', startTime.toString()];
    if (endTime) args.push('--end-time', endTime.toString());

    console.log(`Extracting positions: ${videoPath}`);
    const python = spawn('python', args);
    let stderr = '';

    python.stderr.on('data', (data) => stderr += data.toString());
    python.on('close', (code) => {
        if (code !== 0) return res.status(500).json({ error: 'Position extraction failed', details: stderr });
        fs.readFile(outputPath, 'utf8', (err, data) => {
            if (err) return res.status(500).json({ error: 'Failed to read positions file' });
            try { res.json({ success: true, positions: JSON.parse(data) }); }
            catch (e) { res.status(500).json({ error: 'Failed to parse positions data' }); }
        });
    });
});

app.post('/api/generate-heatmap', (req, res) => {
    const { team } = req.body;
    const scatter = req.body.scatter === true;
    const positionsPath = path.join(__dirname, 'public', 'heatmaps', 'positions.json');
    if (!broadcasterId) {
        broadcasterId = socket.id;
        socket.emit('role-assignment', 'broadcaster');
        console.log(`Assigned BROADCASTER role to ${socket.id}`);
    } else {
        socket.emit('role-assignment', 'viewer');
        console.log(`Assigned VIEWER role to ${socket.id}`);
    }

    // 3. WEBRTC SIGNALING (Video)
    socket.on('watcher', () => {
        if (broadcasterId) io.to(broadcasterId).emit('watcher', socket.id);
    });
    socket.on('offer', (id, message) => io.to(id).emit('offer', socket.id, message));
    socket.on('answer', (id, message) => io.to(id).emit('answer', socket.id, message));
    socket.on('candidate', (id, message) => io.to(id).emit('candidate', socket.id, message));

    // 4. WEBRTC SIGNALING (Audio)
    socket.on('audio-watcher', () => {
        if (broadcasterId) io.to(broadcasterId).emit('audio-watcher', socket.id);
    });
    socket.on('audio-broadcaster-ready', () => socket.broadcast.emit('audio-broadcaster-ready'));
    socket.on('audio-offer', (data) => io.to(data.to).emit('audio-offer', { offer: data.offer, from: socket.id }));
    socket.on('audio-answer', (data) => io.to(data.to).emit('audio-answer', { answer: data.answer, from: socket.id }));
    socket.on('audio-candidate', (data) => io.to(data.to).emit('audio-candidate', { candidate: data.candidate, from: socket.id }));
    socket.on('audio-broadcast-stopped', () => socket.broadcast.emit('audio-broadcast-stopped'));

    // 5. DATA SYNCHRONIZATION EVENTS

    // Handle new event logged (e.g., Goal, Foul)
    socket.on('new-event', (event) => {
        console.log('New event received:', event.eventName);
        currentState.events.push(event);
        socket.broadcast.emit('new-event', event);
    });

    // Handle match timer updates
    socket.on('sync-timer', (data) => {
        currentState.matchTime = data.matchTime;
        currentState.isMatchActive = data.isMatchActive;
        // Optimization: Use volatile for timer to prevent backlog
        socket.broadcast.emit('sync-timer', data);
    });

    // Handle Teams Sync
    socket.on('sync-teams', (teams) => {
        console.log(`Syncing teams: Received ${teams.length} teams.`);
        // CRITICAL: Update server memory
        currentState.teams = teams;
        // CRITICAL: Broadcast to everyone else (Viewers)
        socket.broadcast.emit('sync-teams', teams);
    });

    // Handle Team Selection
    socket.on('select-team', (teamId) => {
        console.log(`Team Selected: ${teamId}`);
        // CRITICAL: Update server memory
        currentState.selectedTeam = teamId;
        // CRITICAL: Broadcast to everyone else
        socket.broadcast.emit('select-team', teamId);
    });

    // Handle Full State Update (Nuclear option)
    socket.on('update-full-state', (state) => {
        console.log('Full state update received');
        currentState = { ...currentState, ...state };
        socket.broadcast.emit('sync-state', currentState);
    });

    socket.on('disconnect', () => {
        console.log('Client disconnected:', socket.id);
        if (socket.id === broadcasterId) {
            broadcasterId = null;
            socket.broadcast.emit('stream-ended');
            console.log('Broadcaster disconnected. Role reset.');
            // Note: We do NOT wipe currentState here so viewers keep data
        }
    });
});

// ===== PROXY ENDPOINT =====
app.get(/^\/api\/proxy(\/.*)?$/, (req, res) => {
    let targetUrl = req.query.url;
    if (!targetUrl && req.params[0]) targetUrl = req.params[0].substring(1);
    if (!targetUrl) return res.status(400).send('URL required');

    const fetchUrl = (url, redirectCount = 0) => {
        if (redirectCount > 5) return res.status(500).send('Too many redirects');

        try {
            const parsedUrl = new URL(url);
            const client = parsedUrl.protocol === 'https:' ? https : http;

            client.get(url, (proxyRes) => {
                if (proxyRes.statusCode >= 300 && proxyRes.statusCode < 400 && proxyRes.headers.location) {
                    return fetchUrl(proxyRes.headers.location, redirectCount + 1);
                }

                res.status(proxyRes.statusCode);
                Object.keys(proxyRes.headers).forEach(key => {
                    if (key.toLowerCase() === 'access-control-allow-origin') return;
                    res.setHeader(key, proxyRes.headers[key]);
                });
                res.setHeader('Access-Control-Allow-Origin', '*');
                proxyRes.pipe(res);
            }).on('error', (err) => {
                if (!res.headersSent) res.status(500).send('Proxy request error');
            });
        } catch (err) {
            if (!res.headersSent) res.status(400).send('Invalid URL');
        }
    };
    fetchUrl(targetUrl);
});

const PORT = process.env.PORT || 3003;
httpServer.listen(PORT, '0.0.0.0', () => {
    console.log(`Socket.io server running on port ${PORT}`);
    console.log(`API available at http://localhost:${PORT}/api`);
});
</file>

<file path="src/App.css">
#root {
  width: 100%;
  height: 100vh;
  overflow: hidden;
  margin: 0;
  padding: 0;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="src/App.tsx">
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
import { SocketProvider } from "@/contexts/SocketContext";
import { MatchProvider } from "@/contexts/MatchContext";
import { AuthProvider } from "@/contexts/AuthContext";
import ProtectedRoute from "@/components/ProtectedRoute";
import Index from "./pages/Index";
import Analytics from "./pages/Analytics";
import { KPIProvider } from "@/contexts/KPIContext";
import KPIEngine from "./pages/KPIEngine";
import Monitoring from "./pages/Monitoring";
import NotFound from "./pages/NotFound";
import Login from "./pages/Login";
import AdminPortal from "./pages/AdminPortal";

import { IPTVAuthProvider } from "@/contexts/IPTVAuthContext";
import AnalystAudit from "./pages/AnalystAudit";

const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <TooltipProvider>
      <Toaster />
      <Sonner />
      <BrowserRouter>
        <AuthProvider>
          <IPTVAuthProvider>
            <SocketProvider>
              <MatchProvider>
                <Routes>
                  <Route path="/audit" element={<AnalystAudit />} />
                  <Route path="/login" element={<Login />} />

                  <Route path="/" element={
                    <ProtectedRoute allowedRoles={['operational_analyst', 'tactical_analyst', 'quality_controller', 'admin', 'early_tester', 'lead_analyst', 'live_tagger', 'eye_spotter', 'logger']}>
                      <Index />
                    </ProtectedRoute>
                  } />

                  <Route path="/admin" element={
                    <ProtectedRoute allowedRoles={['admin']}>
                      <AdminPortal />
                    </ProtectedRoute>
                  } />

                  <Route path="/analytics" element={
                    <ProtectedRoute allowedRoles={['tactical_analyst', 'admin']}>
                      <Analytics />
                    </ProtectedRoute>
                  } />

                  <Route path="/analysis/kpi" element={
                    <ProtectedRoute allowedRoles={['tactical_analyst', 'admin']}>
                      <KPIProvider>
                        <KPIEngine />
                      </KPIProvider>
                    </ProtectedRoute>
                  } />

                  <Route path="/monitoring" element={
                    <ProtectedRoute allowedRoles={['quality_controller', 'admin']}>
                      <Monitoring />
                    </ProtectedRoute>
                  } />

                  {/* ADD ALL CUSTOM ROUTES ABOVE THE CATCH-ALL "*" ROUTE */}
                  <Route path="*" element={<NotFound />} />
                </Routes>
              </MatchProvider>
            </SocketProvider>
          </IPTVAuthProvider>
        </AuthProvider>
      </BrowserRouter>
    </TooltipProvider>
  </QueryClientProvider>
);

export default App;
// Re-trigger HMR
</file>

<file path="src/components/Admin/EventConfigTable.tsx">
import React, { useState } from 'react';
import { useEventConfig } from '@/contexts/EventConfigContext';
import { EventDefinition, GamepadMapping, GamepadModifier } from '@/config/eventRegistry';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Checkbox } from '@/components/ui/checkbox';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import VisualGamepadConfig from './VisualGamepadConfig';
import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import {
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
    DialogTrigger,
    DialogFooter
} from "@/components/ui/dialog";
import { ScrollArea } from '@/components/ui/scroll-area';
import { Edit2, RotateCcw, Save, Plus, Trash2 } from 'lucide-react';
import { Badge } from '@/components/ui/badge';

export const EventConfigTable = () => {
    const { events, updateEvent, resetToDefaults, isLoading } = useEventConfig();
    const [editingEvent, setEditingEvent] = useState<EventDefinition | null>(null);
    const [isDialogOpen, setIsDialogOpen] = useState(false);

    // Group events/Category Filter could be added here

    // Edit Form State
    const [formData, setFormData] = useState<Partial<EventDefinition>>({});

    const handleEditClick = (event: EventDefinition) => {
        setEditingEvent(event);
        setFormData({ ...event });
        setIsDialogOpen(true);
    };

    const handleAddMapping = () => {
        const currentMappings = formData.gamepadMappings || [];
        setFormData({
            ...formData,
            gamepadMappings: [
                ...currentMappings,
                { buttonIndex: 0, mode: 'LIVE', isHold: false }
            ]
        });
    };

    const handleRemoveMapping = (index: number) => {
        const currentMappings = [...(formData.gamepadMappings || [])];
        currentMappings.splice(index, 1);
        setFormData({ ...formData, gamepadMappings: currentMappings });
    };

    const handleUpdateMapping = (index: number, field: keyof GamepadMapping, value: any) => {
        const currentMappings = [...(formData.gamepadMappings || [])];
        currentMappings[index] = { ...currentMappings[index], [field]: value };
        setFormData({ ...formData, gamepadMappings: currentMappings });
    };

    const handleSave = async () => {
        if (editingEvent && formData) {
            await updateEvent({ ...editingEvent, ...formData } as EventDefinition);
            setIsDialogOpen(false);
        }
    };

    if (isLoading) return <div>Loading configuration...</div>;

    return (
        <div className="space-y-4">
            <div className="flex justify-between items-center bg-black/40 p-4 rounded-lg border border-border/50">
                <div>
                    <h2 className="text-xl font-bold text-white">Event Configuration Registry</h2>
                    <p className="text-sm text-muted-foreground">Manage event definitions, durations, and file naming conventions.</p>
                </div>
                <Button variant="destructive" size="sm" onClick={resetToDefaults}>
                    <RotateCcw className="w-4 h-4 mr-2" />
                    Reset to Defaults
                </Button>
            </div>

            <div className="rounded-md border border-border/50 bg-black/20 backdrop-blur-sm">
                <ScrollArea className="h-[600px]">
                    <Table>
                        <TableHeader className="bg-muted/10 sticky top-0 backdrop-blur-md z-10">
                            <TableRow>
                                <TableHead className="w-[50px]">ID</TableHead>
                                <TableHead>Category</TableHead>
                                <TableHead>Event Name</TableHead>
                                <TableHead>Duration (s)</TableHead>
                                <TableHead>Modes</TableHead>
                                <TableHead>Interaction</TableHead>
                                <TableHead>Gamepad</TableHead>
                                <TableHead>Clip</TableHead>
                                <TableHead>Output Path Pattern</TableHead>
                                <TableHead className="text-right">Actions</TableHead>
                            </TableRow>
                        </TableHeader>
                        <TableBody>
                            {events.map((event) => (
                                <TableRow key={event.id} className="hover:bg-muted/5 transition-colors">
                                    <TableCell className="font-mono text-xs text-muted-foreground">{event.id}</TableCell>
                                    <TableCell><Badge variant="outline" className="bg-primary/10 border-primary/20">{event.category}</Badge></TableCell>
                                    <TableCell className="font-medium text-white">{event.label}</TableCell>
                                    <TableCell>{event.defaultDuration[0]}s - {event.defaultDuration[1]}s</TableCell>
                                    <TableCell>
                                        <div className="flex gap-1">
                                            {event.isRealTime && <Badge variant="secondary" className="text-[10px]">LIVE</Badge>}
                                            {event.isPostMatch && <Badge variant="secondary" className="text-[10px]">POST</Badge>}
                                        </div>
                                    </TableCell>
                                    <TableCell>
                                        <div className="flex gap-1">
                                            {event.requiresZone && <Badge variant="outline" className="text-[10px] border-amber-500/50 text-amber-500">ZONE</Badge>}
                                            {event.requiresDuration && <Badge variant="outline" className="text-[10px] border-blue-500/50 text-blue-500">DUR</Badge>}
                                        </div>
                                    </TableCell>
                                    <TableCell>
                                        <div className="flex flex-wrap gap-1 max-w-[150px]">
                                            {event.gamepadMappings?.map((m, idx) => (
                                                <Badge key={idx} variant="secondary" className="text-[10px] bg-blue-500/10 border-blue-500/20 text-blue-400">
                                                    {m.modifier ? `${m.modifier}+` : ''}{m.isHold ? 'Hold ' : ''}{m.buttonIndex}
                                                </Badge>
                                            ))}
                                        </div>
                                    </TableCell>
                                    <TableCell>
                                        <div className="flex gap-1">
                                            {event.clippingEnabled ? (
                                                <Badge variant="outline" className="text-[10px] border-green-500/50 text-green-500">YES</Badge>
                                            ) : (
                                                <Badge variant="outline" className="text-[10px] border-red-500/50 text-red-500 opacity-50">NO</Badge>
                                            )}
                                        </div>
                                    </TableCell>
                                    <TableCell className="font-mono text-xs text-muted-foreground truncate max-w-[200px]" title={event.folderPath + event.filenameConvention}>
                                        {event.folderPath}...{event.filenameConvention}
                                    </TableCell>
                                    <TableCell className="text-right">
                                        <Button variant="ghost" size="icon" onClick={() => handleEditClick(event)}>
                                            <Edit2 className="w-4 h-4 text-primary" />
                                        </Button>
                                    </TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                </ScrollArea>
            </div>

            <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
                <DialogContent className="sm:max-w-[600px] bg-zinc-950 border-zinc-800 text-white">
                    <DialogHeader>
                        <DialogTitle>Edit Event: {editingEvent?.label}</DialogTitle>
                    </DialogHeader>

                    <div className="grid gap-4 py-4">
                        <div className="grid grid-cols-2 gap-4">
                            <div className="space-y-2">
                                <label className="text-xs font-medium text-muted-foreground">Category</label>
                                <Input
                                    value={formData.category || ''}
                                    onChange={e => setFormData({ ...formData, category: e.target.value })}
                                    className="bg-black/50 border-white/10"
                                />
                            </div>
                            <div className="space-y-2">
                                <label className="text-xs font-medium text-muted-foreground">Display Label</label>
                                <Input
                                    value={formData.label || ''}
                                    onChange={e => setFormData({ ...formData, label: e.target.value })}
                                    className="bg-black/50 border-white/10"
                                />
                            </div>
                        </div>

                        <div className="grid grid-cols-2 gap-4">
                            <div className="space-y-2">
                                <label className="text-xs font-medium text-muted-foreground">Duration Min (s)</label>
                                <Input
                                    type="number"
                                    value={formData.defaultDuration?.[0] || 0}
                                    onChange={e => setFormData({ ...formData, defaultDuration: [parseInt(e.target.value), formData.defaultDuration?.[1] || 0] })}
                                    className="bg-black/50 border-white/10"
                                />
                            </div>
                            <div className="space-y-2">
                                <label className="text-xs font-medium text-muted-foreground">Duration Max (s)</label>
                                <Input
                                    type="number"
                                    value={formData.defaultDuration?.[1] || 0}
                                    onChange={e => setFormData({ ...formData, defaultDuration: [formData.defaultDuration?.[0] || 0, parseInt(e.target.value)] })}
                                    className="bg-black/50 border-white/10"
                                />
                            </div>
                        </div>

                        <div className="space-y-2">
                            <label className="text-xs font-medium text-muted-foreground">Folder Path</label>
                            <div className="text-[10px] text-muted-foreground mb-1">Use 'DATE' for match date placeholder.</div>
                            <Input
                                value={formData.folderPath || ''}
                                onChange={e => setFormData({ ...formData, folderPath: e.target.value })}
                                className="bg-black/50 border-white/10 font-mono text-xs"
                            />
                        </div>

                        <div className="space-y-2">
                            <label className="text-xs font-medium text-muted-foreground">Filename Convention</label>
                            <div className="text-[10px] text-muted-foreground mb-1">Use 'MIN' and 'SEC' as placeholders.</div>
                            <Input
                                value={formData.filenameConvention || ''}
                                onChange={e => setFormData({ ...formData, filenameConvention: e.target.value })}
                                className="bg-black/50 border-white/10 font-mono text-xs"
                            />
                        </div>

                        <div className="flex gap-6 pt-2">
                            <div className="flex items-center space-x-2">
                                <Checkbox
                                    id="realtime"
                                    checked={formData.isRealTime}
                                    onCheckedChange={(checked) => setFormData({ ...formData, isRealTime: !!checked })}
                                />
                                <label htmlFor="realtime" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
                                    Live
                                </label>
                            </div>
                            <div className="flex items-center space-x-2">
                                <Checkbox
                                    id="postmatch"
                                    checked={formData.isPostMatch}
                                    onCheckedChange={(checked) => setFormData({ ...formData, isPostMatch: !!checked })}
                                />
                                <label htmlFor="postmatch" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
                                    Post
                                </label>
                            </div>
                            <div className="flex items-center space-x-2">
                                <Checkbox
                                    id="requiresZone"
                                    checked={formData.requiresZone}
                                    onCheckedChange={(checked) => setFormData({ ...formData, requiresZone: !!checked })}
                                />
                                <label htmlFor="requiresZone" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
                                    Zone
                                </label>
                            </div>
                            <div className="flex items-center space-x-2">
                                <Checkbox
                                    id="requiresDuration"
                                    checked={formData.requiresDuration}
                                    onCheckedChange={(checked) => setFormData({ ...formData, requiresDuration: !!checked })}
                                />
                                <label htmlFor="requiresDuration" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
                                    Duration
                                </label>
                                <div className="flex items-center space-x-2">
                                    <Checkbox
                                        id="clippingEnabled"
                                        checked={formData.clippingEnabled}
                                        onCheckedChange={(checked) => setFormData({ ...formData, clippingEnabled: !!checked })}
                                    />
                                    <label htmlFor="clippingEnabled" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
                                        Clip
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div className="space-y-3 pt-4 border-t border-white/10">
                            <div className="flex justify-between items-center">
                                <label className="text-sm font-medium text-white">Gamepad Mappings</label>
                                <Button type="button" variant="outline" size="sm" onClick={handleAddMapping} className="h-7 text-xs">
                                    <Plus className="w-3 h-3 mr-1" /> Add Mapping
                                </Button>
                            </div>

                            <div className="space-y-2">
                                {(formData.gamepadMappings?.length === 0 || !formData.gamepadMappings) && (
                                    <div className="text-xs text-muted-foreground italic py-2 text-center bg-black/20 rounded">
                                        No mappings configured
                                    </div>
                                )}
                                {formData.gamepadMappings?.map((mapping, idx) => (
                                    <div key={idx} className="flex items-center gap-2 bg-black/40 p-2 rounded border border-white/5">
                                        <div className="flex-1">
                                            <label className="text-[10px] text-muted-foreground block mb-1">Binding (Modifier + Btn)</label>
                                            <VisualGamepadConfig
                                                showDebug={false}
                                                compact={true}
                                                value={{
                                                    buttonIndex: mapping.buttonIndex,
                                                    modifier: mapping.modifier
                                                }}
                                                onChange={(newVal) => {
                                                    // Update both fields at once to avoid race condition
                                                    const currentMappings = [...(formData.gamepadMappings || [])];
                                                    currentMappings[idx] = {
                                                        ...currentMappings[idx],
                                                        buttonIndex: newVal.buttonIndex,
                                                        modifier: newVal.modifier
                                                    };
                                                    setFormData({ ...formData, gamepadMappings: currentMappings });
                                                }}
                                            />
                                        </div>

                                        <div className="w-[80px]">
                                            <label className="text-[10px] text-muted-foreground block mb-1">Mode</label>
                                            <Select
                                                value={mapping.mode || 'LIVE'}
                                                onValueChange={(val) => handleUpdateMapping(idx, 'mode', val)}
                                            >
                                                <SelectTrigger className="h-7 text-xs bg-black/50 border-white/10">
                                                    <SelectValue />
                                                </SelectTrigger>
                                                <SelectContent>
                                                    <SelectItem value="LIVE">Live</SelectItem>
                                                    <SelectItem value="POST">Post</SelectItem>
                                                    <SelectItem value="BOTH">Both</SelectItem>
                                                </SelectContent>
                                            </Select>
                                        </div>

                                        <div className="flex items-center pt-5 px-2">
                                            <div className="flex items-center space-x-2">
                                                <Checkbox
                                                    id={`hold-${idx}`}
                                                    checked={mapping.isHold || false}
                                                    onCheckedChange={(checked) => handleUpdateMapping(idx, 'isHold', checked === true)}
                                                />
                                                <label htmlFor={`hold-${idx}`} className="text-xs cursor-pointer">Hold</label>
                                            </div>
                                        </div>

                                        <div className="ml-auto pt-4">
                                            <Button variant="ghost" size="icon" className="h-6 w-6 text-red-400 hover:text-red-300 hover:bg-red-900/20" onClick={() => handleRemoveMapping(idx)}>
                                                <Trash2 className="w-3 h-3" />
                                            </Button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    <DialogFooter>
                        <Button variant="outline" onClick={() => setIsDialogOpen(false)}>Cancel</Button>
                        <Button onClick={handleSave} className="gap-2">
                            <Save className="w-4 h-4" />
                            Save Changes
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>
        </div>
    );
};
</file>

<file path="src/components/Admin/GamepadRecorder.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Gamepad2, Loader2 } from 'lucide-react';
import { BUTTON_LABELS } from '@/hooks/useGamepad';
import { GamepadModifier } from '@/config/eventRegistry';
import { cn } from '@/lib/utils';

interface GamepadRecorderProps {
    value: {
        buttonIndex: number;
        modifier?: GamepadModifier;
    };
    onChange: (value: { buttonIndex: number; modifier?: GamepadModifier }) => void;
}

export const GamepadRecorder = ({ value, onChange }: GamepadRecorderProps) => {
    const [isListening, setIsListening] = useState(false);
    const requestRef = useRef<number>();

    // Track previous button states to detect "fresh" presses
    const prevButtonsRef = useRef<boolean[]>(new Array(16).fill(false));
    const [debugPressed, setDebugPressed] = useState<number[]>([]);

    useEffect(() => {
        if (!isListening) {
            cancelAnimationFrame(requestRef.current!);
            setDebugPressed([]);
            return;
        }

        // SYNC INITIAL STATE to avoid triggering on buttons already held down
        const initialGamepads = navigator.getGamepads();
        const initialGamepad = Array.from(initialGamepads).find(gp => gp !== null);
        if (initialGamepad) {
            initialGamepad.buttons.forEach((btn, i) => {
                prevButtonsRef.current[i] = btn.pressed || (typeof btn.value === 'number' && btn.value > 0.5);
            });
        }

        const pollGamepad = () => {
            const gamepads = navigator.getGamepads();
            const gamepad = Array.from(gamepads).find(gp => gp !== null);

            if (gamepad) {
                // Debug Helper: Show currently pressed physical buttons
                const currentPressedIndices = gamepad.buttons
                    .map((b, i) => (b.pressed || b.value > 0.5) ? i : -1)
                    .filter(i => i !== -1);

                // Only update state if changed to avoid render thrashing
                if (JSON.stringify(currentPressedIndices) !== JSON.stringify(debugPressed)) {
                    setDebugPressed(currentPressedIndices);
                }

                // Check modifiers first
                // RT: 7, LT: 6, RB: 5, LB: 4, View: 8
                const rt = gamepad.buttons[7]?.pressed || gamepad.buttons[7]?.value > 0.5;
                const lt = gamepad.buttons[6]?.pressed || gamepad.buttons[6]?.value > 0.5;
                const rb = gamepad.buttons[5]?.pressed;
                const lb = gamepad.buttons[4]?.pressed;
                const view = gamepad.buttons[8]?.pressed; // View is often used as modifier in this app

                let activeModifier: GamepadModifier | undefined;
                if (rt) activeModifier = 'RT';
                else if (lt) activeModifier = 'LT';
                else if (rb) activeModifier = 'RB';
                else if (lb) activeModifier = 'LB';
                else if (view) activeModifier = 'View';

                // Check for Face Button Press (on rising edge)
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    const btn = gamepad.buttons[i];
                    const isPressed = btn.pressed || (typeof btn.value === 'number' && btn.value > 0.5); // value check for triggers acting as buttons

                    // If pressed now but wasn't before -> RISING EDGE
                    if (isPressed && !prevButtonsRef.current[i]) {

                        // IGNORE modifier buttons themselves if they are being used *as* buttons while we are looking for a combo
                        // But if NO modifier is held, maybe we want to map the bumper itself?
                        // Let's decide: If logic is "Modifier + Button", we capture the *other* button.
                        // If I just press "A", activeModifier is undefined.
                        // If I press "RT" (held) then "A", activeModifier is RT, button is A.

                        // What if I just want to map "RT" as the button?
                        // Then activeModifier would be RT. But the rising edge is index 7.

                        // Filter out the button index if it matches the active modifier's index to avoid confusion?
                        // RT=7, LT=6, RB=5, LB=4, View=8.

                        let isModifierIndex = false;
                        if (activeModifier === 'RT' && i === 7) isModifierIndex = true;
                        if (activeModifier === 'LT' && i === 6) isModifierIndex = true;
                        if (activeModifier === 'RB' && i === 5) isModifierIndex = true;
                        if (activeModifier === 'LB' && i === 4) isModifierIndex = true;
                        if (activeModifier === 'View' && i === 8) isModifierIndex = true;

                        if (!isModifierIndex) {
                            // Valid binding found!
                            onChange({
                                buttonIndex: i,
                                modifier: activeModifier
                            });
                            setIsListening(false);
                            return; // Stop polling
                        }
                    }

                    // Update prev state
                    prevButtonsRef.current[i] = isPressed;
                }
            }

            requestRef.current = requestAnimationFrame(pollGamepad);
        };

        requestRef.current = requestAnimationFrame(pollGamepad);

        return () => cancelAnimationFrame(requestRef.current!);
    }, [isListening, onChange]);

    // Format display
    const buttonLabel = BUTTON_LABELS[value.buttonIndex] || `Btn ${value.buttonIndex}`;
    const displayLabel = value.modifier ? `${value.modifier} + ${buttonLabel}` : buttonLabel;

    return (
        <div className="w-full">
            <Button
                type="button"
                variant={isListening ? "destructive" : "outline"}
                className={cn(
                    "w-full font-mono text-xs justify-between transition-all",
                    isListening ? "animate-pulse border-red-500 bg-red-500/10 text-red-500" : "bg-black/50 border-white/10"
                )}
                onClick={() => setIsListening(!isListening)}
            >
                <span className="flex items-center gap-2">
                    {isListening ? (
                        <>
                            <Loader2 className="w-3 h-3 animate-spin" />
                            Listening...
                        </>
                    ) : (
                        <>
                            <Gamepad2 className="w-3 h-3 text-muted-foreground" />
                            {displayLabel}
                        </>
                    )}
                </span>
                {isListening && <span className="text-[9px] opacity-70">Press btn</span>}
            </Button>
            {isListening && debugPressed.length > 0 && (
                <div className="text-[9px] text-muted-foreground mt-1 text-center font-mono">
                    Raw Inputs: {debugPressed.join(', ')}
                </div>
            )}
        </div>
    );
};
</file>

<file path="src/components/Admin/VisualGamepadConfig.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { GamepadModifier } from '@/config/eventRegistry';

interface VisualGamepadConfigProps {
    value?: {
        buttonIndex: number;
        modifier?: GamepadModifier;
    };
    onChange?: (value: { buttonIndex: number; modifier?: GamepadModifier }) => void;
    showDebug?: boolean;
    compact?: boolean;
}

const VisualGamepadConfig: React.FC<VisualGamepadConfigProps> = ({
    value,
    onChange,
    showDebug = true,
    compact = false
}) => {
    const [gamepad, setGamepad] = useState<Gamepad | null>(null);
    const [buttons, setButtons] = useState<readonly GamepadButton[]>([]);
    const [axes, setAxes] = useState<readonly number[]>([]);
    const lastInteractionRef = useRef<number>(0);

    useEffect(() => {
        let animationId: number;

        const getModifierFromIndex = (index: number): GamepadModifier | undefined => {
            const map: Record<number, GamepadModifier> = {
                4: 'LB', 5: 'RB', 6: 'LT', 7: 'RT', 8: 'View', 9: 'Menu',
                12: 'D-Up', 13: 'D-Down', 14: 'D-Left', 15: 'D-Right'
            };
            return map[index];
        };

        const updateGamepad = () => {
            const gamepads = navigator.getGamepads();
            const gp = gamepads[0];

            if (gp) {
                setGamepad(gp);
                setButtons(gp.buttons);
                setAxes(gp.axes);

                // Handle binding logic if in picker mode
                if (onChange) {
                    gp.buttons.forEach((btn, i) => {
                        if (btn.pressed && Date.now() - lastInteractionRef.current > 300) {
                            // Determine modifiers
                            let modifier: GamepadModifier | undefined;
                            if (gp.buttons[4].pressed) modifier = 'LB';
                            else if (gp.buttons[5].pressed) modifier = 'RB';
                            else if (gp.buttons[6].value > 0.5) modifier = 'LT';
                            else if (gp.buttons[7].value > 0.5) modifier = 'RT';
                            else if (gp.buttons[8].pressed) modifier = 'View';
                            else if (gp.buttons[9].pressed) modifier = 'Menu';
                            else if (gp.buttons[12].pressed) modifier = 'D-Up';
                            else if (gp.buttons[13].pressed) modifier = 'D-Down';
                            else if (gp.buttons[14].pressed) modifier = 'D-Left';
                            else if (gp.buttons[15].pressed) modifier = 'D-Right';

                            // Only trigger if it's not a sole modifier press
                            const isModifier = [4, 5, 6, 7, 8, 9, 12, 13, 14, 15].includes(i);
                            if (!isModifier || (isModifier && modifier && modifier !== getModifierFromIndex(i))) {
                                onChange({ buttonIndex: i, modifier });
                                lastInteractionRef.current = Date.now();
                            }
                        }
                    });
                }
            }

            animationId = requestAnimationFrame(updateGamepad);
        };

        window.addEventListener('gamepadconnected', (e) => {
            console.log('Gamepad connected:', e.gamepad);
            updateGamepad();
        });

        window.addEventListener('gamepaddisconnected', () => {
            setGamepad(null);
            setButtons([]);
            setAxes([]);
        });

        updateGamepad();

        return () => {
            if (animationId) cancelAnimationFrame(animationId);
        };
    }, [onChange]);

    const isPressed = (index: number) => buttons[index]?.pressed || false;
    const getPressure = (index: number) => buttons[index]?.value || 0;

    const isSelected = (index: number) => value?.buttonIndex === index;
    const isModifierActive = (mod: GamepadModifier) => value?.modifier === mod;

    const getButtonClass = (index: number, activeColor: string = 'fill-blue-500 stroke-blue-400', idleColor: string = 'fill-white/10 stroke-white/20') => {
        if (isPressed(index)) return 'fill-emerald-500 stroke-emerald-400';
        if (isSelected(index)) return activeColor;
        return idleColor;
    };

    const containerClasses = compact
        ? "bg-zinc-950/30 rounded-xl p-4 border border-zinc-800/50"
        : "max-w-4xl w-full bg-zinc-950/50 rounded-2xl p-8 backdrop-blur-sm border border-zinc-800";

    return (
        <div className={compact ? "" : "min-h-screen bg-gradient-to-br from-zinc-900 via-zinc-800 to-zinc-900 flex items-center justify-center p-8"}>
            <div className={compact ? "" : "max-w-4xl w-full"}>
                {!compact && (
                    <div className="text-center mb-8">
                        <h1 className="text-4xl font-bold text-white mb-2">Gamepad Visualizer</h1>
                        <p className="text-zinc-400">
                            {gamepad ? `Connected: ${gamepad.id}` : 'No gamepad detected - Press any button to connect'}
                        </p>
                    </div>
                )}

                <div className={containerClasses}>
                    {/* Controller SVG */}
                    <div className="flex justify-center mb-6">
                        <svg width={compact ? "400" : "520"} height={compact ? "350" : "500"} viewBox="0 0 520 500" className="select-none max-w-full h-auto">
                            {/* Controller body */}
                            <path
                                d="M505.765,151.733c-16.255-10.392-4.528-16.329-21.353-29.193c-16.824-12.864-85.104-34.639-96.983-24.743 s-25.233,11.873-25.233,11.873h-72.112h-0.122h-72.118c0,0-13.36-1.977-25.233-11.873c-11.873-9.896-80.16,11.873-96.983,24.743 c-16.824,12.864-5.098,18.801-21.353,29.193C58.02,162.125,15.467,305.619,15.467,305.619s-55.417,159.824,43.544,179.12 c0,0,24.248-15.336,45.025-40.079c20.784-24.743,61.353-59.872,83.128-60.368c21.298-0.483,99.389-0.019,102.792,0l0,0 c0,0,0.024,0,0.061,0c0.043,0,0.062,0,0.062,0l0,0c3.403-0.019,81.494-0.483,102.792,0c21.769,0.496,62.345,35.625,83.128,60.368 s45.024,40.079,45.024,40.079c98.961-19.296,43.544-179.12,43.544-179.12S522.02,162.125,505.765,151.733z"
                                className="fill-zinc-900 stroke-zinc-700 stroke-2"
                            />

                            {/* LB Button */}
                            <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                <rect
                                    x="100" y="80" width="50" height="20" rx="5"
                                    className={`stroke-2 ${getButtonClass(4, isModifierActive('LB') ? 'fill-blue-500 stroke-blue-400' : undefined)}`}
                                />
                                <text x="125" y="90" textAnchor="middle" dominantBaseline="middle" className="text-[12px] fill-white pointer-events-none font-bold">LB</text>
                            </g>

                            {/* RB Button */}
                            <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                <rect
                                    x="370" y="80" width="50" height="20" rx="5"
                                    className={`stroke-2 ${getButtonClass(5, isModifierActive('RB') ? 'fill-blue-500 stroke-blue-400' : undefined)}`}
                                />
                                <text x="395" y="90" textAnchor="middle" dominantBaseline="middle" className="text-[12px] fill-white pointer-events-none font-bold">RB</text>
                            </g>

                            {/* LT Button */}
                            <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                <rect
                                    x="80" y="50" width="50" height="18" rx="5"
                                    className={`stroke-2 ${getButtonClass(6, isModifierActive('LT') ? 'fill-blue-500 stroke-blue-400' : undefined)}`}
                                    style={{ opacity: 0.3 + (getPressure(6) * 0.7) }}
                                />
                                <text x="105" y="59" textAnchor="middle" dominantBaseline="middle" className="text-[12px] fill-white pointer-events-none font-bold">LT</text>
                            </g>

                            {/* RT Button */}
                            <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                <rect
                                    x="390" y="50" width="50" height="18" rx="5"
                                    className={`stroke-2 ${getButtonClass(7, isModifierActive('RT') ? 'fill-blue-500 stroke-blue-400' : undefined)}`}
                                    style={{ opacity: 0.3 + (getPressure(7) * 0.7) }}
                                />
                                <text x="415" y="59" textAnchor="middle" dominantBaseline="middle" className="text-[12px] fill-white pointer-events-none font-bold">RT</text>
                            </g>

                            {/* Left D-pad */}
                            <g transform="translate(142, 211)">
                                <path d="M -15 -5 L -5 -5 L -5 -15 L 5 -15 L 5 -5 L 15 -5 L 15 5 L 5 5 L 5 15 L -5 15 L -5 5 L -15 5 Z" className="fill-zinc-800 stroke-zinc-700" />
                                {/* Up */}
                                <rect x="-5" y="-20" width="10" height="10" rx="4" className={`stroke-2 ${getButtonClass(12, isModifierActive('D-Up') ? 'fill-blue-500 stroke-blue-400' : 'fill-transparent stroke-transparent', 'fill-transparent stroke-transparent')}`} />
                                {/* Down */}
                                <rect x="-5" y="10" width="10" height="10" rx="4" className={`stroke-2 ${getButtonClass(13, isModifierActive('D-Down') ? 'fill-blue-500 stroke-blue-400' : 'fill-transparent stroke-transparent', 'fill-transparent stroke-transparent')}`} />
                                {/* Left */}
                                <rect x="-20" y="-5" width="10" height="10" rx="4" className={`stroke-2 ${getButtonClass(14, isModifierActive('D-Left') ? 'fill-blue-500 stroke-blue-400' : 'fill-transparent stroke-transparent', 'fill-transparent stroke-transparent')}`} />
                                {/* Right */}
                                <rect x="10" y="-5" width="10" height="10" rx="4" className={`stroke-2 ${getButtonClass(15, isModifierActive('D-Right') ? 'fill-blue-500 stroke-blue-400' : 'fill-transparent stroke-transparent', 'fill-transparent stroke-transparent')}`} />
                                <circle r="2" className="fill-zinc-600" />
                            </g>

                            {/* Right buttons (ABXY) */}
                            <g transform="translate(365, 251)">
                                {/* A Button */}
                                <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                    <circle
                                        cx="0" cy="20" r="13"
                                        className={`stroke-2 ${getButtonClass(0, 'fill-green-500 stroke-green-400', 'fill-green-900/50 stroke-green-500/50')}`}
                                    />
                                    <text x="0" y="20" textAnchor="middle" dominantBaseline="middle" className="text-[12px] fill-white pointer-events-none font-bold">A</text>
                                </g>
                                {/* B Button */}
                                <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                    <circle
                                        cx="20" cy="0" r="13"
                                        className={`stroke-2 ${getButtonClass(1, 'fill-red-500 stroke-red-400', 'fill-red-900/50 stroke-red-500/50')}`}
                                    />
                                    <text x="20" y="0" textAnchor="middle" dominantBaseline="middle" className="text-[12px] fill-white pointer-events-none font-bold">B</text>
                                </g>
                                {/* X Button */}
                                <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                    <circle
                                        cx="-20" cy="0" r="13"
                                        className={`stroke-2 ${getButtonClass(2, 'fill-blue-500 stroke-blue-400', 'fill-blue-900/50 stroke-blue-500/50')}`}
                                    />
                                    <text x="-20" y="0" textAnchor="middle" dominantBaseline="middle" className="text-[12px] fill-white pointer-events-none font-bold">X</text>
                                </g>
                                {/* Y Button */}
                                <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                    <circle
                                        cx="0" cy="-20" r="13"
                                        className={`stroke-2 ${getButtonClass(3, 'fill-yellow-500 stroke-yellow-400', 'fill-yellow-900/50 stroke-yellow-500/50')}`}
                                    />
                                    <text x="0" y="-20" textAnchor="middle" dominantBaseline="middle" className="text-[12px] fill-white pointer-events-none font-bold">Y</text>
                                </g>
                            </g>

                            {/* Select/Start buttons */}
                            <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                <circle
                                    cx="220" cy="200" r="8"
                                    className={`stroke-2 ${getButtonClass(8, isModifierActive('View') ? 'fill-blue-500 stroke-blue-400' : undefined)}`}
                                />
                                <text x="220" y="200" textAnchor="middle" dominantBaseline="middle" className="text-[10px] fill-white pointer-events-none font-bold">‚è∏</text>
                            </g>
                            <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                <circle
                                    cx="300" cy="200" r="8"
                                    className={`stroke-2 ${getButtonClass(9, isModifierActive('Menu') ? 'fill-blue-500 stroke-blue-400' : undefined)}`}
                                />
                                <text x="300" y="200" textAnchor="middle" dominantBaseline="middle" className="text-[10px] fill-white pointer-events-none font-bold">‚ò∞</text>
                            </g>

                            {/* Left Analog Stick */}
                            <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                <circle
                                    cx={142 + (axes[0] || 0) * 10}
                                    cy={170 + (axes[1] || 0) * 10}
                                    r="20"
                                    className={`stroke-2 ${getButtonClass(10, 'fill-blue-500 stroke-blue-400', 'fill-white/10 stroke-zinc-600')}`}
                                />
                                <text
                                    x={142 + (axes[0] || 0) * 10}
                                    y={170 + (axes[1] || 0) * 10}
                                    textAnchor="middle"
                                    dominantBaseline="middle"
                                    className="text-[12px] fill-white pointer-events-none font-bold"
                                >
                                    L3
                                </text>
                            </g>

                            {/* Right Analog Stick */}
                            <g className="cursor-pointer hover:opacity-80 transition-opacity">
                                <circle
                                    cx={315 + (axes[2] || 0) * 10}
                                    cy={300 + (axes[3] || 0) * 10}
                                    r="20"
                                    className={`stroke-2 ${getButtonClass(11, 'fill-blue-500 stroke-blue-400', 'fill-white/10 stroke-zinc-600')}`}
                                />
                                <text
                                    x={315 + (axes[2] || 0) * 10}
                                    y={300 + (axes[3] || 0) * 10}
                                    textAnchor="middle"
                                    dominantBaseline="middle"
                                    className="text-[12px] fill-white pointer-events-none font-bold"
                                >
                                    R3
                                </text>
                            </g>
                        </svg>
                    </div>

                    {/* Debug Info */}
                    {showDebug && gamepad && (
                        <div className="grid grid-cols-2 gap-4 text-sm mt-4">
                            <div className="bg-zinc-900/80 rounded-lg p-4 border border-zinc-800">
                                <h3 className="text-white font-semibold mb-3 border-b border-zinc-700 pb-2">Buttons</h3>
                                <div className="space-y-1 text-zinc-400 max-h-[300px] overflow-y-auto pr-2 custom-scrollbar">
                                    {buttons.map((btn, i) => (
                                        <div key={i} className="flex justify-between items-center py-0.5">
                                            <span className="font-mono text-[10px] opacity-70">
                                                {i === 4 ? 'LB' : i === 5 ? 'RB' : i === 6 ? 'LT' : i === 7 ? 'RT' :
                                                    i === 0 ? 'A' : i === 1 ? 'B' : i === 2 ? 'X' : i === 3 ? 'Y' :
                                                        i === 12 ? 'Up' : i === 13 ? 'Down' : i === 14 ? 'Left' : i === 15 ? 'Right' :
                                                            `Btn ${i}`}:
                                            </span>
                                            <span className={`${btn.pressed ? 'text-emerald-400 font-bold' : ''} transition-colors min-w-[120px] text-right`}>
                                                {btn.pressed ? 'Pressed' : 'Released'} ({btn.value.toFixed(2)})
                                            </span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                            <div className="bg-zinc-900/80 rounded-lg p-4 border border-zinc-800">
                                <h3 className="text-white font-semibold mb-3 border-b border-zinc-700 pb-2">Axes</h3>
                                <div className="space-y-1 text-zinc-400">
                                    {axes.map((axis, i) => (
                                        <div key={i} className="flex justify-between items-center py-0.5">
                                            <span className="font-mono text-[10px] opacity-70">
                                                {i === 0 ? 'LX' : i === 1 ? 'LY' : i === 2 ? 'RX' : i === 3 ? 'RY' : `Axis ${i}`}:
                                            </span>
                                            <span className={`font-mono ${Math.abs(axis) > 0.1 ? 'text-blue-400' : ''}`}>
                                                {axis.toFixed(2)}
                                            </span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default VisualGamepadConfig;
</file>

<file path="src/components/AdminWaitingRoom.tsx">
import React from 'react';
import { Users, Play, Mic, MicOff } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";

interface VoicePeer {
    id: string;
    name: string;
    role: string;
}

interface AdminWaitingRoomProps {
    connectedPeers: VoicePeer[];
    onStartSession: () => void;
}

export const AdminWaitingRoom: React.FC<AdminWaitingRoomProps> = ({ connectedPeers, onStartSession }) => {
    return (
        <div className="absolute inset-0 z-50 bg-background/60 backdrop-blur-md flex items-center justify-center p-4">
            <Card className="max-w-md w-full bg-card shadow-2xl border-primary/20 animate-in fade-in zoom-in duration-300">
                <CardHeader className="text-center border-b border-border/50 pb-6">
                    <div className="mx-auto w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center mb-4">
                        <Users className="w-6 h-6 text-primary" />
                    </div>
                    <CardTitle className="text-2xl font-bold tracking-tight">Waiting Room</CardTitle>
                    <CardDescription>
                        Waiting for testers to join the voice room.
                    </CardDescription>
                </CardHeader>

                <CardContent className="py-6">
                    <div className="space-y-4">
                        <div className="flex items-center justify-between px-2 text-xs font-semibold uppercase text-muted-foreground tracking-wider">
                            <span>Connected Users</span>
                            <span>{connectedPeers.length} Online</span>
                        </div>

                        <div className="bg-muted/30 rounded-lg border border-border/50 p-2 min-h-[120px] max-h-[200px] overflow-y-auto space-y-1">
                            {connectedPeers.length === 0 ? (
                                <div className="h-full flex flex-col items-center justify-center text-muted-foreground py-8 opacity-50">
                                    <MicOff size={24} className="mb-2" />
                                    <span className="text-xs">No users connected yet...</span>
                                </div>
                            ) : (
                                connectedPeers.map((peer, idx) => (
                                    <div key={idx} className="flex items-center gap-3 p-2 rounded-md bg-card border border-border/50 shadow-sm animate-in slide-in-from-bottom-2">
                                        <div className="w-8 h-8 rounded-full bg-indigo-500/20 text-indigo-500 flex items-center justify-center">
                                            <Mic size={14} />
                                        </div>
                                        <div className="flex-1">
                                            <div className="text-xs font-bold text-foreground">{peer.name}</div>
                                            <div className="text-[10px] text-muted-foreground uppercase">{peer.role}</div>
                                            <div className="text-[10px] text-green-500 font-medium flex items-center gap-1">
                                                <span className="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse" /> Connected
                                            </div>
                                        </div>
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </CardContent>

                <CardFooter className="pt-4 border-t border-border/50 flex flex-col gap-3">
                    <Button
                        className="w-full gap-2 font-bold tracking-wide"
                        size="lg"
                        onClick={onStartSession}
                    >
                        <Play size={16} fill="currentColor" /> START SESSION
                    </Button>
                    <p className="text-[10px] text-muted-foreground text-center">
                        You can start the session at any time. Late joiners can still connect.
                    </p>
                </CardFooter>
            </Card>
        </div>
    );
};
</file>

<file path="src/components/AnalysisDashboard.tsx">
import { LoggedEvent } from "@/hooks/useGamepad";
import { analyzeEvents, DerivedEvent } from "@/utils/analysisEngine";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { PlayCircle } from "lucide-react";

interface AnalysisDashboardProps {
    events: LoggedEvent[];
    onJumpToTime: (time: number) => void;
}

export const AnalysisDashboard = ({ events, onJumpToTime }: AnalysisDashboardProps) => {
    const derivedEvents = analyzeEvents(events);

    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    if (derivedEvents.length === 0) {
        return (
            <Card>
                <CardHeader>
                    <CardTitle>Advanced Analysis</CardTitle>
                </CardHeader>
                <CardContent>
                    <p className="text-muted-foreground text-sm">
                        No advanced patterns detected yet. Log more events with spatial data (if available) to see analysis.
                    </p>
                    <div className="mt-4 p-2 bg-muted rounded text-xs font-mono">
                        <p>Debug Info:</p>
                        <p>Total Events: {events.length}</p>
                        <p>Events with Video Time: {events.filter(e => e.videoTime !== undefined).length}</p>
                        <p>Try logging 3 consecutive "Pass" events to test.</p>
                    </div>
                </CardContent>
            </Card>
        );
    }

    return (
        <Card>
            <CardHeader>
                <CardTitle>Advanced Analysis</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
                {derivedEvents.map((event) => (
                    <div key={event.id} className="flex items-center justify-between p-3 border rounded-lg bg-muted/50">
                        <div>
                            <h4 className="font-semibold text-sm">{event.name}</h4>
                            <p className="text-xs text-muted-foreground">{event.description}</p>
                            <p className="text-xs font-mono mt-1">
                                {formatTime(event.startTime)} - {formatTime(event.endTime)}
                            </p>
                        </div>
                        <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => onJumpToTime(event.startTime)}
                            title="Play Clip"
                        >
                            <PlayCircle className="h-4 w-4 text-primary" />
                        </Button>
                    </div>
                ))}
            </CardContent>
        </Card>
    );
};
</file>

<file path="src/components/AnalysisModeSelector.tsx">
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Radio, Activity, Target, Gamepad2, Mouse, Keyboard } from 'lucide-react';

export type AnalysisMode = 'LIVE' | 'POST_MATCH';

interface AnalysisModeSelectorProps {
    mode: AnalysisMode;
    onModeChange: (mode: AnalysisMode) => void;
    disabled?: boolean;
    hasEvents?: boolean;
}

export function AnalysisModeSelector({
    mode,
    onModeChange,
    disabled = false,
    hasEvents = false
}: AnalysisModeSelectorProps) {
    const [showConfirm, setShowConfirm] = useState(false);
    const [pendingMode, setPendingMode] = useState<AnalysisMode | null>(null);

    const handleModeChange = (newMode: AnalysisMode) => {
        if (hasEvents && newMode !== mode) {
            setPendingMode(newMode);
            setShowConfirm(true);
        } else {
            onModeChange(newMode);
        }
    };

    const confirmModeChange = () => {
        if (pendingMode) {
            onModeChange(pendingMode);
            setShowConfirm(false);
            setPendingMode(null);
        }
    };

    return (
        <Card className="p-4 bg-gradient-to-br from-card to-card/50 border-2">
            <div className="space-y-3">
                {/* Header */}
                <div className="flex items-center justify-between">
                    <h3 className="text-sm font-bold flex items-center gap-2">
                        <Activity className="h-4 w-4 text-primary" />
                        Analysis Mode
                    </h3>
                    <div className={`px-2 py-1 rounded text-xs font-mono ${mode === 'LIVE'
                            ? 'bg-red-500/20 text-red-400 border border-red-500/50'
                            : 'bg-blue-500/20 text-blue-400 border border-blue-500/50'
                        }`}>
                        {mode}
                    </div>
                </div>

                {/* Mode Buttons */}
                <div className="grid grid-cols-2 gap-2">
                    {/* LIVE Mode */}
                    <button
                        onClick={() => handleModeChange('LIVE')}
                        disabled={disabled}
                        className={`
              relative p-3 rounded-lg border-2 transition-all
              ${mode === 'LIVE'
                                ? 'border-red-500 bg-red-500/10 shadow-lg shadow-red-500/20'
                                : 'border-border/50 bg-card/50 hover:border-red-500/50'
                            }
              ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
            `}
                    >
                        <div className="flex flex-col items-center gap-2">
                            <Radio className={`h-5 w-5 ${mode === 'LIVE' ? 'text-red-400' : 'text-muted-foreground'}`} />
                            <div className="text-xs font-bold">LIVE</div>
                            <div className="flex gap-1">
                                <Gamepad2 className="h-3 w-3 text-muted-foreground" />
                            </div>
                        </div>
                        {mode === 'LIVE' && (
                            <div className="absolute -top-1 -right-1 h-3 w-3 bg-red-500 rounded-full animate-pulse" />
                        )}
                    </button>

                    {/* POST-MATCH Mode */}
                    <button
                        onClick={() => handleModeChange('POST_MATCH')}
                        disabled={disabled}
                        className={`
              relative p-3 rounded-lg border-2 transition-all
              ${mode === 'POST_MATCH'
                                ? 'border-blue-500 bg-blue-500/10 shadow-lg shadow-blue-500/20'
                                : 'border-border/50 bg-card/50 hover:border-blue-500/50'
                            }
              ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
            `}
                    >
                        <div className="flex flex-col items-center gap-2">
                            <Target className={`h-5 w-5 ${mode === 'POST_MATCH' ? 'text-blue-400' : 'text-muted-foreground'}`} />
                            <div className="text-xs font-bold">POST-MATCH</div>
                            <div className="flex gap-1">
                                <Gamepad2 className="h-3 w-3 text-muted-foreground" />
                                <Mouse className="h-3 w-3 text-muted-foreground" />
                                <Keyboard className="h-3 w-3 text-muted-foreground" />
                            </div>
                        </div>
                        {mode === 'POST_MATCH' && (
                            <div className="absolute -top-1 -right-1 h-3 w-3 bg-blue-500 rounded-full animate-pulse" />
                        )}
                    </button>
                </div>

                {/* Mode Description */}
                <div className={`p-2 rounded text-xs ${mode === 'LIVE'
                        ? 'bg-red-500/5 border border-red-500/20'
                        : 'bg-blue-500/5 border border-blue-500/20'
                    }`}>
                    {mode === 'LIVE' ? (
                        <div className="space-y-1">
                            <div className="font-semibold text-red-400">‚ö° Fast Tagging</div>
                            <ul className="text-muted-foreground space-y-0.5 ml-4">
                                <li>‚Ä¢ Controller only (8-12 events)</li>
                                <li>‚Ä¢ No player/position selection</li>
                                <li>‚Ä¢ Speed over precision</li>
                            </ul>
                        </div>
                    ) : (
                        <div className="space-y-1">
                            <div className="font-semibold text-blue-400">üéØ Detailed Analysis</div>
                            <ul className="text-muted-foreground space-y-0.5 ml-4">
                                <li>‚Ä¢ Controller + Mouse + Keyboard</li>
                                <li>‚Ä¢ Full event details (30-50 events)</li>
                                <li>‚Ä¢ Player & position tracking</li>
                            </ul>
                        </div>
                    )}
                </div>

                {/* Confirmation Dialog */}
                {showConfirm && (
                    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                        <Card className="p-6 max-w-md space-y-4 border-2 border-primary">
                            <h3 className="text-lg font-bold">Switch Analysis Mode?</h3>
                            <p className="text-sm text-muted-foreground">
                                {pendingMode === 'LIVE' ? (
                                    <>
                                        Switching to <span className="text-red-400 font-semibold">LIVE mode</span> will:
                                        <ul className="mt-2 space-y-1 ml-4">
                                            <li>‚Ä¢ Remove player and position data from events</li>
                                            <li>‚Ä¢ Simplify event types to 8-12 core events</li>
                                            <li>‚Ä¢ Enable fast controller-only logging</li>
                                        </ul>
                                    </>
                                ) : (
                                    <>
                                        Switching to <span className="text-blue-400 font-semibold">POST-MATCH mode</span> will:
                                        <ul className="mt-2 space-y-1 ml-4">
                                            <li>‚Ä¢ Allow adding player and position details</li>
                                            <li>‚Ä¢ Enable all 30-50 event types</li>
                                            <li>‚Ä¢ Require mouse/keyboard for full details</li>
                                        </ul>
                                    </>
                                )}
                            </p>
                            <div className="flex gap-2">
                                <Button
                                    onClick={() => {
                                        setShowConfirm(false);
                                        setPendingMode(null);
                                    }}
                                    variant="outline"
                                    className="flex-1"
                                >
                                    Cancel
                                </Button>
                                <Button
                                    onClick={confirmModeChange}
                                    className="flex-1"
                                >
                                    Confirm Switch
                                </Button>
                            </div>
                        </Card>
                    </div>
                )}
            </div>
        </Card>
    );
}
</file>

<file path="src/components/AnalysisResultsViewer.tsx">
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import { Activity, Zap, TrendingUp, Users, MapPin, Network, Flame, Share2 } from "lucide-react";
import { useState } from "react";
import { PassingNetworkViz, buildPassingNetwork, PassingNetwork } from "./PassingNetworkViz";
import { API_BASE_URL, ANALYSIS_API_URL, API_HEADERS } from "@/utils/apiConfig";

interface PlayerStats {
    total_distance: number;
    max_speed: number;
    sprints: number;
    team: 'A' | 'B';
}

interface TrackPoint {
    frame: number;
    timestamp: number;
    x: number;
    y: number;
    xm?: number;
    ym?: number;
    xm_smooth?: number;
    ym_smooth?: number;
    v?: number;
    a?: number;
    is_sprinting?: boolean;
    xT?: number;
    team: 'A' | 'B';
    conf: number;
}

interface PassEvent {
    frame: number;
    timestamp: number;
    passer_id: number;
    receiver_id: number;
    team: string;
    distance: number;
    duration: number;
    pass_type: string;
    success: boolean;
    xthreat_delta: number;
}

interface AnalysisResults {
    metadata: {
        video_path: string;
        duration: number;
        fps: number;
    };
    stats: Record<string, PlayerStats>;
    tracks: Record<string, TrackPoint[]>;
    events: Array<{
        frame: number;
        timestamp: number;
        defender_id: number;
        attacker_id: number;
        distance: number;
        defender_speed: number;
    }>;
    passes?: PassEvent[];
    network_metrics?: Record<string, any>;
    positions: TrackPoint[];
}

interface AnalysisResultsViewerProps {
    results: AnalysisResults | null;
}

export const AnalysisResultsViewer = ({ results }: AnalysisResultsViewerProps) => {
    const [heatmapTeam, setHeatmapTeam] = useState<'A' | 'B' | null>(null);
    const [heatmapUrl, setHeatmapUrl] = useState<string | null>(null);
    const [isLoadingHeatmap, setIsLoadingHeatmap] = useState(false);

    if (!results) {
        return (
            <Card>
                <CardContent className="p-6 text-center text-muted-foreground">
                    No analysis results yet. Run analysis on a clip to see player tracking data.
                </CardContent>
            </Card>
        );
    }

    const playerIds = Object.keys(results.stats);
    const teamAPlayers = playerIds.filter(id => results.stats[id].team === 'A');
    const teamBPlayers = playerIds.filter(id => results.stats[id].team === 'B');

    const formatSpeed = (ms: number) => `${(ms * 3.6).toFixed(1)} km/h`;
    const formatDistance = (m: number) => `${m.toFixed(0)}m`;
    const formatTime = (s: number) => {
        const mins = Math.floor(s / 60);
        const secs = Math.floor(s % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    const generateHeatmap = async (team: 'A' | 'B' | null) => {
        setIsLoadingHeatmap(true);
        setHeatmapTeam(team);
        try {
            const response = await fetch(`${ANALYSIS_API_URL}/api/generate-heatmap`, {
                method: 'POST',
                headers: API_HEADERS,
                body: JSON.stringify({
                    team: team,
                    scatter: false
                })
            });
            const data = await response.json();
            if (data.success) {
                setHeatmapUrl(`${ANALYSIS_API_URL}${data.imageUrl}`);
            }
        } catch (error) {
            console.error("Failed to generate heatmap:", error);
        } finally {
            setIsLoadingHeatmap(false);
        }
    };

    // Construct Passing Networks if data exists
    const networkA = results.passes ? buildPassingNetwork(
        results.passes.map(p => ({
            id: Date.now() + Math.random(),
            eventName: "PASS",
            team: "TEAM_A",
            player: { id: p.passer_id, name: `Player ${p.passer_id}` },
            timestamp: p.timestamp.toString(),
            buttonLabel: "AI"
        })),
        "TEAM_A",
        teamAPlayers.map(id => ({ id: parseInt(id), name: `Player ${id}` }))
    ) : null;

    const networkB = results.passes ? buildPassingNetwork(
        results.passes.map(p => ({
            id: Date.now() + Math.random(),
            eventName: "PASS",
            team: "TEAM_B",
            player: { id: p.passer_id, name: `Player ${p.passer_id}` },
            timestamp: p.timestamp.toString(),
            buttonLabel: "AI"
        })),
        "TEAM_B",
        teamBPlayers.map(id => ({ id: parseInt(id), name: `Player ${id}` }))
    ) : null;

    return (
        <Card>
            <CardHeader>
                <CardTitle className="flex items-center gap-2">
                    <Activity className="w-5 h-5" />
                    AI Analysis Results
                </CardTitle>
                <CardDescription>
                    Analyzed {formatTime(results.metadata.duration)} ‚Ä¢ {playerIds.length} players tracked ‚Ä¢ {results.events.length} pressing events
                </CardDescription>
            </CardHeader>
            <CardContent>
                <Tabs defaultValue="overview" className="w-full">
                    <TabsList className="grid w-full grid-cols-6">
                        <TabsTrigger value="overview">Overview</TabsTrigger>
                        <TabsTrigger value="team-a">Team A</TabsTrigger>
                        <TabsTrigger value="team-b">Team B</TabsTrigger>
                        <TabsTrigger value="passing">Passing</TabsTrigger>
                        <TabsTrigger value="heatmaps">Heatmaps</TabsTrigger>
                        <TabsTrigger value="tactical">Tactical</TabsTrigger>
                    </TabsList>

                    {/* OVERVIEW TAB */}
                    <TabsContent value="overview" className="space-y-4">
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <Card>
                                <CardHeader className="pb-3">
                                    <CardTitle className="text-sm font-medium flex items-center gap-2">
                                        <Users className="w-4 h-4" />
                                        Players Tracked
                                    </CardTitle>
                                </CardHeader>
                                <CardContent>
                                    <div className="text-3xl font-bold">{playerIds.length}</div>
                                    <p className="text-xs text-muted-foreground mt-1">
                                        Team A: {teamAPlayers.length} ‚Ä¢ Team B: {teamBPlayers.length}
                                    </p>
                                </CardContent>
                            </Card>

                            <Card>
                                <CardHeader className="pb-3">
                                    <CardTitle className="text-sm font-medium flex items-center gap-2">
                                        <Zap className="w-4 h-4" />
                                        Total Sprints
                                    </CardTitle>
                                </CardHeader>
                                <CardContent>
                                    <div className="text-3xl font-bold">
                                        {Object.values(results.stats).reduce((sum, s) => sum + s.sprints, 0)}
                                    </div>
                                    <p className="text-xs text-muted-foreground mt-1">
                                        Speed &gt; 25 km/h
                                    </p>
                                </CardContent>
                            </Card>

                            <Card>
                                <CardHeader className="pb-3">
                                    <CardTitle className="text-sm font-medium flex items-center gap-2">
                                        <TrendingUp className="w-4 h-4" />
                                        Pressing Events
                                    </CardTitle>
                                </CardHeader>
                                <CardContent>
                                    <div className="text-3xl font-bold">{results.events.length}</div>
                                    <p className="text-xs text-muted-foreground mt-1">
                                        High-intensity duels
                                    </p>
                                </CardContent>
                            </Card>
                        </div>

                        {/* Top Performers */}
                        <div className="space-y-3">
                            <h3 className="font-semibold text-sm">Top Performers</h3>

                            {/* Fastest Player */}
                            {(() => {
                                const fastest = playerIds.reduce((max, id) =>
                                    results.stats[id].max_speed > results.stats[max].max_speed ? id : max
                                    , playerIds[0]);
                                return (
                                    <div className="flex items-center justify-between p-3 bg-muted rounded-lg">
                                        <div className="flex items-center gap-2">
                                            <Zap className="w-4 h-4 text-yellow-500" />
                                            <span className="text-sm font-medium">Fastest Player</span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <Badge variant={results.stats[fastest].team === 'A' ? 'default' : 'destructive'}>
                                                Player {fastest}
                                            </Badge>
                                            <span className="text-sm font-bold">{formatSpeed(results.stats[fastest].max_speed)}</span>
                                        </div>
                                    </div>
                                );
                            })()}

                            {/* Most Distance */}
                            {(() => {
                                const mostDistance = playerIds.reduce((max, id) =>
                                    results.stats[id].total_distance > results.stats[max].total_distance ? id : max
                                    , playerIds[0]);
                                return (
                                    <div className="flex items-center justify-between p-3 bg-muted rounded-lg">
                                        <div className="flex items-center gap-2">
                                            <Activity className="w-4 h-4 text-blue-500" />
                                            <span className="text-sm font-medium">Most Distance</span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <Badge variant={results.stats[mostDistance].team === 'A' ? 'default' : 'destructive'}>
                                                Player {mostDistance}
                                            </Badge>
                                            <span className="text-sm font-bold">{formatDistance(results.stats[mostDistance].total_distance)}</span>
                                        </div>
                                    </div>
                                );
                            })()}
                        </div>
                    </TabsContent>

                    {/* TEAM A TAB */}
                    <TabsContent value="team-a" className="space-y-3">
                        {teamAPlayers.map(playerId => {
                            const stats = results.stats[playerId];
                            return (
                                <Card key={playerId}>
                                    <CardHeader className="pb-3">
                                        <div className="flex items-center justify-between">
                                            <CardTitle className="text-base">Player {playerId}</CardTitle>
                                            <Badge>Team A</Badge>
                                        </div>
                                    </CardHeader>
                                    <CardContent className="space-y-3">
                                        <div className="grid grid-cols-3 gap-3 text-sm">
                                            <div>
                                                <p className="text-muted-foreground text-xs">Distance</p>
                                                <p className="font-bold">{formatDistance(stats.total_distance)}</p>
                                            </div>
                                            <div>
                                                <p className="text-muted-foreground text-xs">Max Speed</p>
                                                <p className="font-bold">{formatSpeed(stats.max_speed)}</p>
                                            </div>
                                            <div>
                                                <p className="text-muted-foreground text-xs">Sprints</p>
                                                <p className="font-bold">{stats.sprints}</p>
                                            </div>
                                        </div>
                                        <div>
                                            <div className="flex justify-between text-xs mb-1">
                                                <span className="text-muted-foreground">Speed Performance</span>
                                                <span>{((stats.max_speed / 10) * 100).toFixed(0)}%</span>
                                            </div>
                                            <Progress value={(stats.max_speed / 10) * 100} className="h-2" />
                                        </div>
                                    </CardContent>
                                </Card>
                            );
                        })}
                    </TabsContent>

                    {/* TEAM B TAB */}
                    <TabsContent value="team-b" className="space-y-3">
                        {teamBPlayers.map(playerId => {
                            const stats = results.stats[playerId];
                            return (
                                <Card key={playerId}>
                                    <CardHeader className="pb-3">
                                        <div className="flex items-center justify-between">
                                            <CardTitle className="text-base">Player {playerId}</CardTitle>
                                            <Badge variant="destructive">Team B</Badge>
                                        </div>
                                    </CardHeader>
                                    <CardContent className="space-y-3">
                                        <div className="grid grid-cols-3 gap-3 text-sm">
                                            <div>
                                                <p className="text-muted-foreground text-xs">Distance</p>
                                                <p className="font-bold">{formatDistance(stats.total_distance)}</p>
                                            </div>
                                            <div>
                                                <p className="text-muted-foreground text-xs">Max Speed</p>
                                                <p className="font-bold">{formatSpeed(stats.max_speed)}</p>
                                            </div>
                                            <div>
                                                <p className="text-muted-foreground text-xs">Sprints</p>
                                                <p className="font-bold">{stats.sprints}</p>
                                            </div>
                                        </div>
                                        <div>
                                            <div className="flex justify-between text-xs mb-1">
                                                <span className="text-muted-foreground">Speed Performance</span>
                                                <span>{((stats.max_speed / 10) * 100).toFixed(0)}%</span>
                                            </div>
                                            <Progress value={(stats.max_speed / 10) * 100} className="h-2" />
                                        </div>
                                    </CardContent>
                                </Card>
                            );
                        })}
                    </TabsContent>

                    {/* PASSING TAB */}
                    <TabsContent value="passing" className="space-y-6">
                        {networkA && (
                            <div className="space-y-2">
                                <h3 className="font-semibold flex items-center gap-2">
                                    <Network className="w-4 h-4 text-primary" /> Team A Network
                                </h3>
                                <PassingNetworkViz network={networkA} teamName="Team A" width={600} height={400} />
                            </div>
                        )}
                        {networkB && (
                            <div className="space-y-2">
                                <h3 className="font-semibold flex items-center gap-2">
                                    <Network className="w-4 h-4 text-destructive" /> Team B Network
                                </h3>
                                <PassingNetworkViz network={networkB} teamName="Team B" width={600} height={400} />
                            </div>
                        )}
                        {!results.passes && (
                            <div className="text-center py-8 text-muted-foreground">
                                No passing data available. Enable pass detection in analysis settings.
                            </div>
                        )}
                    </TabsContent>

                    {/* HEATMAPS TAB */}
                    <TabsContent value="heatmaps" className="space-y-4">
                        <div className="flex items-center gap-4 justify-center">
                            <Button
                                variant={heatmapTeam === 'A' ? "default" : "outline"}
                                onClick={() => generateHeatmap('A')}
                                disabled={isLoadingHeatmap}
                            >
                                <Flame className="w-4 h-4 mr-2" /> Team A Heatmap
                            </Button>
                            <Button
                                variant={heatmapTeam === 'B' ? "destructive" : "outline"}
                                onClick={() => generateHeatmap('B')}
                                disabled={isLoadingHeatmap}
                            >
                                <Flame className="w-4 h-4 mr-2" /> Team B Heatmap
                            </Button>
                        </div>

                        {isLoadingHeatmap && (
                            <div className="text-center py-12">
                                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-2"></div>
                                <p className="text-sm text-muted-foreground">Generating heatmap...</p>
                            </div>
                        )}

                        {heatmapUrl && !isLoadingHeatmap && (
                            <div className="border rounded-lg overflow-hidden bg-black/5">
                                <img src={heatmapUrl} alt="Heatmap" className="w-full h-auto object-contain" />
                            </div>
                        )}
                    </TabsContent>

                    {/* TACTICAL TAB */}
                    <TabsContent value="tactical" className="space-y-3">
                        {results.events.length === 0 ? (
                            <p className="text-center text-muted-foreground py-8">No pressing events detected in this clip.</p>
                        ) : (
                            results.events.map((event, idx) => (
                                <Card key={idx}>
                                    <CardContent className="p-4">
                                        <div className="flex items-center justify-between">
                                            <div className="flex items-center gap-3">
                                                <MapPin className="w-4 h-4 text-orange-500" />
                                                <div>
                                                    <p className="font-medium text-sm">Pressing Event</p>
                                                    <p className="text-xs text-muted-foreground">
                                                        Player {event.defender_id} pressing Player {event.attacker_id}
                                                    </p>
                                                </div>
                                            </div>
                                            <div className="text-right">
                                                <Badge variant="outline">{formatTime(event.timestamp)}</Badge>
                                                <p className="text-[10px] text-muted-foreground mt-1">
                                                    {event.distance}m separation
                                                </p>
                                            </div>
                                        </div>
                                    </CardContent>
                                </Card>
                            ))
                        )}
                    </TabsContent>
                </Tabs>
            </CardContent>
        </Card>
    );
};
</file>

<file path="src/components/analytics/LiveDashboard.tsx">
import { LoggedEvent } from "@/hooks/useGamepad";
import { ZoneGrid } from "@/components/ZoneGrid";
import { EventLog } from "@/components/EventLog";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import {
    Activity,
    Zap,
    Target,
    Shield,
    Crosshair,
    TrendingUp,
    TrendingDown,
    AlertTriangle,
    CheckCircle,
    XCircle,
    ArrowRightLeft,
    Timer,
    Users
} from "lucide-react";
import { MomentumChart } from "./MomentumChart";
import { useMemo } from "react";

interface LiveDashboardProps {
    events: LoggedEvent[];
    currentZone: number;
    onZoneClick: (zone: number) => void;
    teamNames: { teamA: string, teamB: string };
}

// Calculate comprehensive KPIs from events
const calculateKPIs = (events: LoggedEvent[], teamNames: { teamA: string, teamB: string }) => {
    const teamA = events.filter(e => e.team === "TEAM_A");
    const teamB = events.filter(e => e.team === "TEAM_B");

    // Possession Events
    const passesA = teamA.filter(e => e.eventName.includes('pass')).length;
    const passesB = teamB.filter(e => e.eventName.includes('pass')).length;
    const totalPasses = passesA + passesB;

    // Shots
    const shotsA = teamA.filter(e => e.eventName.includes('shot')).length;
    const shotsB = teamB.filter(e => e.eventName.includes('shot')).length;
    const goalsA = teamA.filter(e => e.eventName === 'goal').length;
    const goalsB = teamB.filter(e => e.eventName === 'goal').length;

    // Defensive Actions
    const tacklesA = teamA.filter(e => ['tackle', 'duel_ground', 'duel_aerial'].includes(e.eventName)).length;
    const tacklesB = teamB.filter(e => ['tackle', 'duel_ground', 'duel_aerial'].includes(e.eventName)).length;
    const interceptionsA = teamA.filter(e => e.eventName === 'interception').length;
    const interceptionsB = teamB.filter(e => e.eventName === 'interception').length;
    const clearancesA = teamA.filter(e => e.eventName === 'clearance').length;
    const clearancesB = teamB.filter(e => e.eventName === 'clearance').length;

    // Pressing
    const pressTriggersA = teamA.filter(e => ['pressing_trigger', 'press_trap', 'pressing_success'].includes(e.eventName)).length;
    const pressTriggersB = teamB.filter(e => ['pressing_trigger', 'press_trap', 'pressing_success'].includes(e.eventName)).length;

    // Transitions
    const transitionsOffA = teamA.filter(e => e.eventName === 'transition_off_start').length;
    const transitionsOffB = teamB.filter(e => e.eventName === 'transition_off_start').length;
    const transitionsDefA = teamA.filter(e => e.eventName === 'transition_def_start').length;
    const transitionsDefB = teamB.filter(e => e.eventName === 'transition_def_start').length;
    const counterAttacksA = teamA.filter(e => e.eventName === 'counter_attack').length;
    const counterAttacksB = teamB.filter(e => e.eventName === 'counter_attack').length;

    // Turnovers
    const turnoversA = teamA.filter(e => e.eventName === 'turnover').length;
    const turnoversB = teamB.filter(e => e.eventName === 'turnover').length;

    // Dribbles
    const dribblesA = teamA.filter(e => e.eventName.includes('dribble')).length;
    const dribblesB = teamB.filter(e => e.eventName.includes('dribble')).length;

    // Danger
    const dangerousAttacksA = teamA.filter(e => ['dangerous_attack', 'big_chance', 'final_third_entry'].includes(e.eventName)).length;
    const dangerousAttacksB = teamB.filter(e => ['dangerous_attack', 'big_chance', 'final_third_entry'].includes(e.eventName)).length;

    // Set Pieces
    const setPiecesA = teamA.filter(e => ['corner_start', 'free_kick', 'penalty', 'throw_in_tactical'].includes(e.eventName)).length;
    const setPiecesB = teamB.filter(e => ['corner_start', 'free_kick', 'penalty', 'throw_in_tactical'].includes(e.eventName)).length;

    // Cards
    const yellowCardsA = teamA.filter(e => e.eventName === 'card_yellow').length;
    const yellowCardsB = teamB.filter(e => e.eventName === 'card_yellow').length;
    const redCardsA = teamA.filter(e => e.eventName === 'card_red').length;
    const redCardsB = teamB.filter(e => e.eventName === 'card_red').length;

    // Possession % (based on pass events)
    const possessionA = totalPasses > 0 ? Math.round((passesA / totalPasses) * 100) : 50;
    const possessionB = 100 - possessionA;

    return {
        teamA: {
            name: teamNames.teamA,
            events: teamA.length,
            passes: passesA,
            shots: shotsA,
            goals: goalsA,
            tackles: tacklesA,
            interceptions: interceptionsA,
            clearances: clearancesA,
            pressing: pressTriggersA,
            transitionsOff: transitionsOffA,
            transitionsDef: transitionsDefA,
            counterAttacks: counterAttacksA,
            turnovers: turnoversA,
            dribbles: dribblesA,
            dangerousAttacks: dangerousAttacksA,
            setPieces: setPiecesA,
            yellowCards: yellowCardsA,
            redCards: redCardsA,
            possession: possessionA,
        },
        teamB: {
            name: teamNames.teamB,
            events: teamB.length,
            passes: passesB,
            shots: shotsB,
            goals: goalsB,
            tackles: tacklesB,
            interceptions: interceptionsB,
            clearances: clearancesB,
            pressing: pressTriggersB,
            transitionsOff: transitionsOffB,
            transitionsDef: transitionsDefB,
            counterAttacks: counterAttacksB,
            turnovers: turnoversB,
            dribbles: dribblesB,
            dangerousAttacks: dangerousAttacksB,
            setPieces: setPiecesB,
            yellowCards: yellowCardsB,
            redCards: redCardsB,
            possession: possessionB,
        },
        total: events.length,
    };
};

// Generate insights based on KPIs
const generateInsights = (kpis: ReturnType<typeof calculateKPIs>) => {
    const insights: { type: 'warning' | 'success' | 'info', title: string, description: string }[] = [];

    // Possession insight
    if (kpis.teamA.possession > 60) {
        insights.push({
            type: 'success',
            title: `${kpis.teamA.name} Dominating Possession`,
            description: `Controlling ${kpis.teamA.possession}% of possession with ${kpis.teamA.passes} passes.`
        });
    } else if (kpis.teamB.possession > 60) {
        insights.push({
            type: 'warning',
            title: `${kpis.teamB.name} Dominating Possession`,
            description: `Opponent controlling ${kpis.teamB.possession}% of possession.`
        });
    }

    // Pressing insight
    if (kpis.teamA.pressing > kpis.teamB.pressing + 3) {
        insights.push({
            type: 'info',
            title: 'High Pressing Intensity',
            description: `${kpis.teamA.name} is pressing aggressively with ${kpis.teamA.pressing} triggers.`
        });
    }

    // Counter-attack warning
    if (kpis.teamB.counterAttacks >= 2) {
        insights.push({
            type: 'warning',
            title: 'Counter-Attack Threat',
            description: `${kpis.teamB.name} has launched ${kpis.teamB.counterAttacks} counter-attacks.`
        });
    }

    // Danger zone
    if (kpis.teamB.dangerousAttacks >= 3) {
        insights.push({
            type: 'warning',
            title: 'Defensive Alert',
            description: `${kpis.teamB.name} has ${kpis.teamB.dangerousAttacks} dangerous attacks.`
        });
    }

    // Shots on target
    if (kpis.teamA.shots > 0 && kpis.teamA.goals / kpis.teamA.shots < 0.1) {
        insights.push({
            type: 'info',
            title: 'Low Shot Conversion',
            description: `${kpis.teamA.name} has ${kpis.teamA.shots} shots but only ${kpis.teamA.goals} goals.`
        });
    }

    // Turnovers warning
    if (kpis.teamA.turnovers > 5) {
        insights.push({
            type: 'warning',
            title: 'High Turnovers',
            description: `${kpis.teamA.name} has lost possession ${kpis.teamA.turnovers} times.`
        });
    }

    return insights.slice(0, 4); // Max 4 insights
};

export const LiveDashboard = ({ events, currentZone, onZoneClick, teamNames }: LiveDashboardProps) => {
    const kpis = useMemo(() => calculateKPIs(events, teamNames), [events, teamNames]);
    const insights = useMemo(() => generateInsights(kpis), [kpis]);

    return (
        <div className="grid grid-cols-12 gap-4 h-[calc(100vh-120px)]">
            {/* Left Column: Stats & Event Feed */}
            <div className="col-span-12 lg:col-span-3 flex flex-col gap-4 overflow-hidden">
                {/* Score / Events Count */}
                <div className="grid grid-cols-2 gap-2">
                    <Card className="bg-gradient-to-br from-blue-500/20 to-blue-600/10 border-blue-500/30">
                        <CardContent className="p-4 text-center">
                            <div className="text-3xl font-bold text-blue-400">{kpis.teamA.goals}</div>
                            <div className="text-xs text-muted-foreground truncate">{kpis.teamA.name}</div>
                            <div className="text-[10px] text-blue-400/70 mt-1">{kpis.teamA.events} events</div>
                        </CardContent>
                    </Card>
                    <Card className="bg-gradient-to-br from-red-500/20 to-red-600/10 border-red-500/30">
                        <CardContent className="p-4 text-center">
                            <div className="text-3xl font-bold text-red-400">{kpis.teamB.goals}</div>
                            <div className="text-xs text-muted-foreground truncate">{kpis.teamB.name}</div>
                            <div className="text-[10px] text-red-400/70 mt-1">{kpis.teamB.events} events</div>
                        </CardContent>
                    </Card>
                </div>

                {/* Possession Bar */}
                <Card className="p-3">
                    <div className="flex items-center justify-between text-xs mb-2">
                        <span className="text-blue-400 font-bold">{kpis.teamA.possession}%</span>
                        <span className="text-muted-foreground">Possession</span>
                        <span className="text-red-400 font-bold">{kpis.teamB.possession}%</span>
                    </div>
                    <div className="h-2 bg-red-500/30 rounded-full overflow-hidden">
                        <div
                            className="h-full bg-blue-500 transition-all duration-500"
                            style={{ width: `${kpis.teamA.possession}%` }}
                        />
                    </div>
                </Card>

                {/* Event Feed */}
                <div className="flex-1 min-h-0 border rounded-lg bg-card/50 overflow-hidden">
                    <EventLog events={events} teamNames={teamNames} />
                </div>
            </div>

            {/* Center Column: Visualizations & KPIs */}
            <div className="col-span-12 lg:col-span-6 flex flex-col gap-4 overflow-y-auto no-scrollbar">
                {/* Momentum Chart */}
                <Card className="shrink-0">
                    <CardHeader className="p-3 pb-1">
                        <CardTitle className="text-sm font-medium flex items-center gap-2">
                            <Activity className="w-4 h-4 text-primary" />
                            Match Momentum (Last 5 mins)
                        </CardTitle>
                    </CardHeader>
                    <CardContent className="p-3 pt-0 h-32">
                        <MomentumChart events={events} />
                    </CardContent>
                </Card>

                {/* KPI Grid */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                    <KPICard
                        label="Shots"
                        valueA={kpis.teamA.shots}
                        valueB={kpis.teamB.shots}
                        icon={<Target className="w-4 h-4" />}
                    />
                    <KPICard
                        label="Passes"
                        valueA={kpis.teamA.passes}
                        valueB={kpis.teamB.passes}
                        icon={<ArrowRightLeft className="w-4 h-4" />}
                    />
                    <KPICard
                        label="Tackles"
                        valueA={kpis.teamA.tackles}
                        valueB={kpis.teamB.tackles}
                        icon={<Shield className="w-4 h-4" />}
                    />
                    <KPICard
                        label="Pressing"
                        valueA={kpis.teamA.pressing}
                        valueB={kpis.teamB.pressing}
                        icon={<Zap className="w-4 h-4" />}
                    />
                </div>

                {/* Detailed Stats */}
                <Card>
                    <CardHeader className="p-3 pb-2">
                        <CardTitle className="text-sm">Match Statistics</CardTitle>
                    </CardHeader>
                    <CardContent className="p-3 pt-0 space-y-2">
                        <StatRow label="Goals" a={kpis.teamA.goals} b={kpis.teamB.goals} />
                        <StatRow label="Shots" a={kpis.teamA.shots} b={kpis.teamB.shots} />
                        <StatRow label="Dangerous Attacks" a={kpis.teamA.dangerousAttacks} b={kpis.teamB.dangerousAttacks} />
                        <StatRow label="Counter Attacks" a={kpis.teamA.counterAttacks} b={kpis.teamB.counterAttacks} />
                        <StatRow label="Interceptions" a={kpis.teamA.interceptions} b={kpis.teamB.interceptions} />
                        <StatRow label="Clearances" a={kpis.teamA.clearances} b={kpis.teamB.clearances} />
                        <StatRow label="Turnovers" a={kpis.teamA.turnovers} b={kpis.teamB.turnovers} />
                        <StatRow label="Dribbles" a={kpis.teamA.dribbles} b={kpis.teamB.dribbles} />
                        <StatRow label="Set Pieces" a={kpis.teamA.setPieces} b={kpis.teamB.setPieces} />
                        <StatRow label="Yellow Cards" a={kpis.teamA.yellowCards} b={kpis.teamB.yellowCards} highlight />
                        <StatRow label="Red Cards" a={kpis.teamA.redCards} b={kpis.teamB.redCards} highlight />
                    </CardContent>
                </Card>

                {/* Zone Grid - Compact */}
                <Card className="p-4">
                    <div className="text-sm font-medium mb-2 flex items-center gap-2">
                        <Crosshair className="w-4 h-4 text-primary" />
                        Pitch Zones
                    </div>
                    <div className="max-w-xs mx-auto">
                        <ZoneGrid currentZone={currentZone} onZoneClick={onZoneClick} />
                    </div>
                </Card>
            </div>

            {/* Right Column: Insights */}
            <div className="col-span-12 lg:col-span-3 flex flex-col gap-4">
                <Card className="flex-1">
                    <CardHeader className="p-4 pb-2">
                        <CardTitle className="flex items-center gap-2 text-sm">
                            <Zap className="w-4 h-4 text-yellow-500" />
                            Live Insights
                        </CardTitle>
                    </CardHeader>
                    <CardContent className="p-4 pt-0 space-y-3">
                        {insights.length === 0 ? (
                            <div className="text-center py-8 text-muted-foreground text-sm">
                                <Activity className="w-8 h-8 mx-auto mb-2 opacity-50" />
                                Log more events to generate insights
                            </div>
                        ) : (
                            insights.map((insight, idx) => (
                                <InsightCard key={idx} {...insight} />
                            ))
                        )}
                    </CardContent>
                </Card>

                {/* Quick Actions */}
                <Card className="p-4">
                    <div className="text-sm font-medium mb-3 flex items-center gap-2">
                        <Timer className="w-4 h-4 text-primary" />
                        Quick Stats
                    </div>
                    <div className="grid grid-cols-2 gap-2 text-center">
                        <div className="bg-muted/50 rounded p-2">
                            <div className="text-lg font-bold">{kpis.total}</div>
                            <div className="text-[10px] text-muted-foreground">Total Events</div>
                        </div>
                        <div className="bg-muted/50 rounded p-2">
                            <div className="text-lg font-bold">{kpis.teamA.transitionsOff + kpis.teamB.transitionsOff}</div>
                            <div className="text-[10px] text-muted-foreground">Transitions</div>
                        </div>
                    </div>
                </Card>
            </div>
        </div>
    );
};

// Sub-components
const KPICard = ({ label, valueA, valueB, icon }: { label: string, valueA: number, valueB: number, icon: React.ReactNode }) => (
    <Card className="p-3">
        <div className="flex items-center gap-2 text-muted-foreground mb-2">
            {icon}
            <span className="text-xs">{label}</span>
        </div>
        <div className="flex items-center justify-between">
            <span className="text-lg font-bold text-blue-400">{valueA}</span>
            <span className="text-xs text-muted-foreground">vs</span>
            <span className="text-lg font-bold text-red-400">{valueB}</span>
        </div>
    </Card>
);

const StatRow = ({ label, a, b, highlight = false }: { label: string, a: number, b: number, highlight?: boolean }) => {
    const total = a + b;
    const percentA = total > 0 ? (a / total) * 100 : 50;

    return (
        <div className="flex items-center gap-2">
            <span className={`text-xs w-8 text-right font-bold ${highlight ? 'text-yellow-500' : 'text-blue-400'}`}>{a}</span>
            <div className="flex-1 h-1.5 bg-muted rounded-full overflow-hidden">
                <div className="h-full bg-blue-500/70 transition-all" style={{ width: `${percentA}%` }} />
            </div>
            <span className="text-xs flex-1 text-center text-muted-foreground truncate">{label}</span>
            <div className="flex-1 h-1.5 bg-muted rounded-full overflow-hidden">
                <div className="h-full bg-red-500/70 transition-all float-right" style={{ width: `${100 - percentA}%` }} />
            </div>
            <span className={`text-xs w-8 text-left font-bold ${highlight ? 'text-yellow-500' : 'text-red-400'}`}>{b}</span>
        </div>
    );
};

const InsightCard = ({ type, title, description }: { type: 'warning' | 'success' | 'info', title: string, description: string }) => {
    const config = {
        warning: { bg: 'bg-yellow-500/10', border: 'border-yellow-500/20', icon: <AlertTriangle className="w-4 h-4 text-yellow-500" />, text: 'text-yellow-600' },
        success: { bg: 'bg-green-500/10', border: 'border-green-500/20', icon: <CheckCircle className="w-4 h-4 text-green-500" />, text: 'text-green-600' },
        info: { bg: 'bg-blue-500/10', border: 'border-blue-500/20', icon: <Activity className="w-4 h-4 text-blue-500" />, text: 'text-blue-600' },
    };
    const c = config[type];

    return (
        <div className={`p-3 ${c.bg} border ${c.border} rounded-lg flex gap-2`}>
            <div className="shrink-0 mt-0.5">{c.icon}</div>
            <div>
                <h4 className={`font-semibold text-xs ${c.text}`}>{title}</h4>
                <p className="text-[10px] text-muted-foreground leading-relaxed">{description}</p>
            </div>
        </div>
    );
};
</file>

<file path="src/components/analytics/MomentumChart.tsx">
import { useMemo } from "react";
import { LoggedEvent } from "@/hooks/useGamepad";
import { ResponsiveContainer, AreaChart, Area, XAxis, YAxis, Tooltip, ReferenceLine } from "recharts";

interface MomentumChartProps {
    events: LoggedEvent[];
}

export const MomentumChart = ({ events }: MomentumChartProps) => {
    // Weighted Event Scoring
    const getWeight = (e: LoggedEvent) => {
        const name = e.eventName.toLowerCase();
        let w = 0;
        if (name.includes('goal')) w = 10;
        else if (name.includes('shot')) w = 5;
        else if (name.includes('dangerous') || name.includes('final_third')) w = 3;
        else if (name.includes('cross')) w = 2;
        else if (name.includes('pass')) w = 1;
        else if (name.includes('interception') || name.includes('recovery')) w = 2;
        else if (name.includes('turnover') || name.includes('loss')) w = -2;
        else if (name.includes('foul')) w = -1;
        else if (name.includes('card')) w = -5;
        return e.team === "TEAM_A" ? w : -w;
    };

    const data = useMemo(() => {
        return events.map((e, i) => {
            const windowStart = Math.max(0, i - 10);
            const window = events.slice(windowStart, i + 1);
            const sum = window.reduce((acc, curr) => acc + getWeight(curr), 0);
            return {
                time: e.matchTime || i,
                momentum: sum / window.length,
                name: e.eventName
            };
        });
    }, [events]);

    // Take last 50 events for "Live" view
    const recentData = data.slice(-40);

    return (
        <div className="w-full h-full min-h-[150px]">
            <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={recentData}>
                    <defs>
                        <linearGradient id="colorMomentum" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor="#22c55e" stopOpacity={0.8} />
                            <stop offset="95%" stopColor="#ef4444" stopOpacity={0.8} />
                        </linearGradient>
                    </defs>
                    <XAxis dataKey="time" hide />
                    <YAxis domain={[-1, 1]} hide />
                    <Tooltip />
                    <ReferenceLine y={0} stroke="#666" strokeDasharray="3 3" />
                    <Area
                        type="monotone"
                        dataKey="momentum"
                        stroke="#8884d8"
                        fillOpacity={1}
                        fill="url(#colorMomentum)"
                    />
                </AreaChart>
            </ResponsiveContainer>
        </div>
    );
};
</file>

<file path="src/components/analytics/PostMatchDashboard.tsx">
import { LoggedEvent } from "@/hooks/useGamepad";
import { TacticalAnalysisDashboard } from "@/components/TacticalAnalysisDashboard";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import {
    Target,
    ArrowRightLeft,
    Shield,
    Zap,
    TrendingUp,
    Activity,
    Users,
    Timer,
    BarChart3
} from "lucide-react";
import { useMemo } from "react";

interface PostMatchDashboardProps {
    events: LoggedEvent[];
    teamNames: { teamA: string, teamB: string };
    videoFile?: File | null;
}

// Calculate comprehensive post-match stats
const calculateStats = (events: LoggedEvent[], teamNames: { teamA: string, teamB: string }) => {
    const teamA = events.filter(e => e.team === "TEAM_A");
    const teamB = events.filter(e => e.team === "TEAM_B");

    // Possession Events
    const passesA = teamA.filter(e => e.eventName.includes('pass')).length;
    const passesB = teamB.filter(e => e.eventName.includes('pass')).length;
    const totalPasses = passesA + passesB;

    // Shots & Goals
    const shotsA = teamA.filter(e => e.eventName.includes('shot')).length;
    const shotsB = teamB.filter(e => e.eventName.includes('shot')).length;
    const goalsA = teamA.filter(e => e.eventName === 'goal').length;
    const goalsB = teamB.filter(e => e.eventName === 'goal').length;

    // Key passes & assists
    const keyPassesA = teamA.filter(e => e.eventName === 'key_pass').length;
    const keyPassesB = teamB.filter(e => e.eventName === 'key_pass').length;
    const assistsA = teamA.filter(e => e.eventName === 'assist').length;
    const assistsB = teamB.filter(e => e.eventName === 'assist').length;

    // Chances
    const chancesA = teamA.filter(e => ['chance_created', 'big_chance'].includes(e.eventName)).length;
    const chancesB = teamB.filter(e => ['chance_created', 'big_chance'].includes(e.eventName)).length;

    // Defensive
    const tacklesA = teamA.filter(e => ['tackle', 'duel_ground', 'duel_aerial'].includes(e.eventName)).length;
    const tacklesB = teamB.filter(e => ['tackle', 'duel_ground', 'duel_aerial'].includes(e.eventName)).length;
    const interceptionsA = teamA.filter(e => e.eventName === 'interception').length;
    const interceptionsB = teamB.filter(e => e.eventName === 'interception').length;

    // Pressing
    const pressingSuccessA = teamA.filter(e => e.eventName === 'pressing_success').length;
    const pressingSuccessB = teamB.filter(e => e.eventName === 'pressing_success').length;
    const pressingFailA = teamA.filter(e => e.eventName === 'pressing_fail').length;
    const pressingFailB = teamB.filter(e => e.eventName === 'pressing_fail').length;

    // Dribbles
    const dribbleSuccessA = teamA.filter(e => e.eventName === 'dribble_success').length;
    const dribbleSuccessB = teamB.filter(e => e.eventName === 'dribble_success').length;
    const dribbleFailA = teamA.filter(e => e.eventName === 'dribble_fail').length;
    const dribbleFailB = teamB.filter(e => e.eventName === 'dribble_fail').length;

    // Off-ball movement
    const offBallA = teamA.filter(e => ['off_ball_run', 'overlap', 'underlap', 'third_man_run', 'dummy_run'].includes(e.eventName)).length;
    const offBallB = teamB.filter(e => ['off_ball_run', 'overlap', 'underlap', 'third_man_run', 'dummy_run'].includes(e.eventName)).length;

    // Transitions
    const transitionsA = teamA.filter(e => e.eventName.includes('transition')).length;
    const transitionsB = teamB.filter(e => e.eventName.includes('transition')).length;

    // Possession %
    const possessionA = totalPasses > 0 ? Math.round((passesA / totalPasses) * 100) : 50;

    return {
        total: events.length,
        teamA: {
            name: teamNames.teamA,
            events: teamA.length,
            goals: goalsA,
            shots: shotsA,
            passes: passesA,
            keyPasses: keyPassesA,
            assists: assistsA,
            chances: chancesA,
            tackles: tacklesA,
            interceptions: interceptionsA,
            pressingSuccess: pressingSuccessA,
            pressingFail: pressingFailA,
            dribbleSuccess: dribbleSuccessA,
            dribbleFail: dribbleFailA,
            offBall: offBallA,
            transitions: transitionsA,
            possession: possessionA,
        },
        teamB: {
            name: teamNames.teamB,
            events: teamB.length,
            goals: goalsB,
            shots: shotsB,
            passes: passesB,
            keyPasses: keyPassesB,
            assists: assistsB,
            chances: chancesB,
            tackles: tacklesB,
            interceptions: interceptionsB,
            pressingSuccess: pressingSuccessB,
            pressingFail: pressingFailB,
            dribbleSuccess: dribbleSuccessB,
            dribbleFail: dribbleFailB,
            offBall: offBallB,
            transitions: transitionsB,
            possession: 100 - possessionA,
        }
    };
};

export const PostMatchDashboard = ({ events, teamNames, videoFile }: PostMatchDashboardProps) => {
    const stats = useMemo(() => calculateStats(events, teamNames), [events, teamNames]);

    return (
        <div className="space-y-6">
            {/* Top Summary Row */}
            <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                {/* Score Card */}
                <Card className="col-span-2 bg-gradient-to-r from-blue-500/10 via-transparent to-red-500/10 border-muted">
                    <CardContent className="p-4">
                        <div className="flex items-center justify-between">
                            <div className="text-center flex-1">
                                <div className="text-4xl font-bold text-blue-400">{stats.teamA.goals}</div>
                                <div className="text-xs text-muted-foreground truncate">{stats.teamA.name}</div>
                            </div>
                            <div className="text-2xl font-light text-muted-foreground px-4">vs</div>
                            <div className="text-center flex-1">
                                <div className="text-4xl font-bold text-red-400">{stats.teamB.goals}</div>
                                <div className="text-xs text-muted-foreground truncate">{stats.teamB.name}</div>
                            </div>
                        </div>
                    </CardContent>
                </Card>

                {/* Key Stats */}
                <SummaryCard
                    icon={<Target className="w-5 h-5 text-primary" />}
                    title="Shots"
                    valueA={stats.teamA.shots}
                    valueB={stats.teamB.shots}
                />
                <SummaryCard
                    icon={<ArrowRightLeft className="w-5 h-5 text-green-500" />}
                    title="Passes"
                    valueA={stats.teamA.passes}
                    valueB={stats.teamB.passes}
                />
                <SummaryCard
                    icon={<Shield className="w-5 h-5 text-blue-500" />}
                    title="Tackles"
                    valueA={stats.teamA.tackles}
                    valueB={stats.teamB.tackles}
                />
                <SummaryCard
                    icon={<Zap className="w-5 h-5 text-yellow-500" />}
                    title="Chances"
                    valueA={stats.teamA.chances}
                    valueB={stats.teamB.chances}
                />
            </div>

            {/* Possession Bar */}
            <Card className="p-4">
                <div className="flex items-center gap-4">
                    <span className="text-sm font-medium text-blue-400 w-20 text-right">{stats.teamA.possession}%</span>
                    <div className="flex-1 h-3 bg-red-500/30 rounded-full overflow-hidden">
                        <div
                            className="h-full bg-gradient-to-r from-blue-500 to-blue-400 rounded-full transition-all duration-500"
                            style={{ width: `${stats.teamA.possession}%` }}
                        />
                    </div>
                    <span className="text-sm font-medium text-red-400 w-20">{stats.teamB.possession}%</span>
                </div>
                <div className="text-center text-xs text-muted-foreground mt-2">Ball Possession</div>
            </Card>

            {/* KPI Cards Row */}
            <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-3">
                <KPICard label="Key Passes" valueA={stats.teamA.keyPasses} valueB={stats.teamB.keyPasses} />
                <KPICard label="Assists" valueA={stats.teamA.assists} valueB={stats.teamB.assists} />
                <KPICard label="Interceptions" valueA={stats.teamA.interceptions} valueB={stats.teamB.interceptions} />
                <KPICard label="Press Success" valueA={stats.teamA.pressingSuccess} valueB={stats.teamB.pressingSuccess} />
                <KPICard label="Dribble Success" valueA={stats.teamA.dribbleSuccess} valueB={stats.teamB.dribbleSuccess} />
                <KPICard label="Off-Ball Runs" valueA={stats.teamA.offBall} valueB={stats.teamB.offBall} />
            </div>

            {/* Main Analysis Dashboard */}
            <Card className="border-muted">
                <CardHeader className="pb-2">
                    <CardTitle className="text-lg flex items-center gap-2">
                        <BarChart3 className="w-5 h-5 text-primary" />
                        Detailed Tactical Analysis
                        <Badge variant="outline" className="ml-auto text-xs">
                            {stats.total} events
                        </Badge>
                    </CardTitle>
                </CardHeader>
                <CardContent className="p-0">
                    <TacticalAnalysisDashboard
                        events={events}
                        teamNames={teamNames}
                        hasVideo={!!videoFile}
                        videoFile={videoFile}
                    />
                </CardContent>
            </Card>
        </div>
    );
};

// Sub-components
const SummaryCard = ({
    icon,
    title,
    valueA,
    valueB
}: {
    icon: React.ReactNode,
    title: string,
    valueA: number,
    valueB: number
}) => (
    <Card>
        <CardContent className="p-4">
            <div className="flex items-center gap-2 mb-2">
                {icon}
                <span className="text-xs text-muted-foreground">{title}</span>
            </div>
            <div className="flex items-center justify-between">
                <span className="text-xl font-bold text-blue-400">{valueA}</span>
                <span className="text-xs text-muted-foreground">-</span>
                <span className="text-xl font-bold text-red-400">{valueB}</span>
            </div>
        </CardContent>
    </Card>
);

const KPICard = ({ label, valueA, valueB }: { label: string, valueA: number, valueB: number }) => (
    <Card className="p-3 bg-muted/30">
        <div className="text-[10px] text-muted-foreground mb-1 truncate">{label}</div>
        <div className="flex items-center justify-between">
            <span className="text-sm font-bold text-blue-400">{valueA}</span>
            <span className="text-[10px] text-muted-foreground">vs</span>
            <span className="text-sm font-bold text-red-400">{valueB}</span>
        </div>
    </Card>
);
</file>

<file path="src/components/analytics/SemanticAnalytics.tsx">
import { Card } from "@/components/ui/card";
import { LoggedEvent } from "@/hooks/useGamepad";
import { Brain, Zap, Target, AlertTriangle, TrendingUp } from "lucide-react";
import { cn } from "@/lib/utils";

interface SemanticAnalyticsProps {
    events: LoggedEvent[];
}

export const SemanticAnalytics = ({ events }: SemanticAnalyticsProps) => {
    // 1. Calculate Psychological Profile
    const psychCounts = events.reduce((acc, e) => {
        if (e.psychology) acc[e.psychology] = (acc[e.psychology] || 0) + 1;
        return acc;
    }, {} as Record<string, number>);

    // 2. Calculate Momentum (Intensity of SPIRIT vs others)
    const spiritImpact = events.filter(e => e.psychology === 'SPIRIT').length;
    const fearImpact = events.filter(e => e.psychology === 'FEAR').length;
    const egoImpact = events.filter(e => e.psychology === 'EGO').length;

    // 3. Contextual Analysis (e.g., Post-Goal events)
    const postGoalEvents = events.filter(e => e.contextualFactor === 'Post-Goal');
    const lowBlockAfterGoal = postGoalEvents.filter(e => e.semanticIndicator === 'Defensive Block Height' && e.intensity === 'LOW').length;

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 p-4">
            {/* PSYCHOLOGICAL RADAR */}
            <Card className="p-4 bg-background/50 backdrop-blur-sm border-primary/20">
                <div className="flex items-center justify-between mb-4">
                    <span className="text-xs font-black uppercase tracking-widest text-primary flex items-center gap-2">
                        <Brain className="w-4 h-4" /> Team Psychological Radar
                    </span>
                </div>
                <div className="space-y-3">
                    <TrendBar label="Spirit" value={psychCounts.SPIRIT || 0} total={events.length} color="bg-orange-500" icon={<Zap className="w-3 h-3" />} />
                    <TrendBar label="Focus/Ego" value={psychCounts.EGO || 0} total={events.length} color="bg-blue-600" icon={<Target className="w-3 h-3" />} />
                    <TrendBar label="Fragility/Fear" value={psychCounts.FEAR || 0} total={events.length} color="bg-amber-600" icon={<AlertTriangle className="w-3 h-3" />} />
                </div>
            </Card>

            {/* MOMENTUM SIGNAL */}
            <Card className="p-4 bg-background/50 backdrop-blur-sm border-primary/20">
                <div className="flex items-center justify-between mb-2">
                    <span className="text-xs font-black uppercase tracking-widest text-primary flex items-center gap-2">
                        <TrendingUp className="w-4 h-4" /> Momentum Signal
                    </span>
                </div>
                <div className="text-center py-4">
                    <div className="text-4xl font-black italic text-primary">
                        {spiritImpact > fearImpact ? 'DOMINANT' : 'VULNERABLE'}
                    </div>
                    <p className="text-[10px] text-muted-foreground uppercase tracking-widest mt-1">
                        Based on {events.length} semantic observations
                    </p>
                </div>
            </Card>

            {/* STRATEGIC VULNERABILITY */}
            <Card className="p-4 bg-background/50 backdrop-blur-sm border-destructive/20 col-span-1 md:col-span-2">
                <div className="flex items-center justify-between mb-4">
                    <span className="text-xs font-black uppercase tracking-widest text-destructive flex items-center gap-2">
                        <AlertTriangle className="w-4 h-4" /> Strategic Vulnerability
                    </span>
                </div>
                <div className="flex gap-4">
                    <div className="flex-1 bg-destructive/5 p-3 rounded-lg border border-destructive/10 text-center">
                        <div className="text-2xl font-black text-destructive">{lowBlockAfterGoal}</div>
                        <div className="text-[9px] uppercase font-bold opacity-70">Sustained Low Block<br />Post-Goal Score</div>
                    </div>
                    <div className="flex-1 bg-primary/5 p-3 rounded-lg border border-primary/10 text-center">
                        <div className="text-2xl font-black text-primary">{egoImpact}</div>
                        <div className="text-[9px] uppercase font-bold opacity-70">Losses due to<br />Decision Inefficiency</div>
                    </div>
                </div>
            </Card>
        </div>
    );
};

interface TrendBarProps {
    label: string;
    value: number;
    total: number;
    color: string;
    icon: React.ReactNode;
}

const TrendBar = ({ label, value, total, color, icon }: TrendBarProps) => {
    const percentage = total > 0 ? (value / total) * 100 : 0;
    return (
        <div className="space-y-1">
            <div className="flex justify-between items-center text-[9px] uppercase font-bold">
                <span className="flex items-center gap-1">{icon} {label}</span>
                <span>{value} ({Math.round(percentage)}%)</span>
            </div>
            <div className="w-full h-1.5 bg-muted rounded-full overflow-hidden">
                <div className={cn("h-full transition-all duration-1000", color)} style={{ width: `${percentage}%` }} />
            </div>
        </div>
    );
};
</file>

<file path="src/components/analytics/TacticalReview.tsx">
import React, { useMemo, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Crosshair, Move, Activity, ArrowUpRight, Target, Network, TrendingUp } from "lucide-react";
import PitchMap from "../PitchMap";
import { LoggedEvent } from "@/hooks/useGamepad";
import { MomentumChart } from "./MomentumChart";
import { buildPassingNetwork, PassingNetworkViz } from "../PassingNetworkViz";

interface TacticalReviewProps {
    events: LoggedEvent[];
    teamNames: { teamA: string; teamB: string };
    teamARoster?: any[];
    teamBRoster?: any[];
}

export const TacticalReview: React.FC<TacticalReviewProps> = ({
    events,
    teamNames,
    teamARoster = [],
    teamBRoster = []
}) => {
    const [selectedTeam, setSelectedTeam] = useState<'TEAM_A' | 'TEAM_B'>('TEAM_A');

    // 1. Calculate Player Centroids (Average Positioning)
    const playerCentroids = useMemo(() => {
        const centroids: any[] = [];
        const teamEvents = events.filter(e => e.team === selectedTeam && e.x !== undefined && e.y !== undefined);

        // Group by player
        const playerGroups = teamEvents.reduce((acc: any, e) => {
            const id = e.player?.id || 0;
            if (!acc[id]) acc[id] = [];
            acc[id].push(e);
            return acc;
        }, {});

        Object.keys(playerGroups).forEach(pid => {
            const pEvents = playerGroups[pid];
            const avgX = pEvents.reduce((sum: number, e: any) => sum + e.x, 0) / pEvents.length;
            const avgY = pEvents.reduce((sum: number, e: any) => sum + e.y, 0) / pEvents.length;
            centroids.push({
                x: avgX,
                y: avgY,
                team: selectedTeam === 'TEAM_A' ? 'A' : 'B',
                id: pid,
                name: pEvents[0].player?.name || `P${pid}`
            });
        });

        return centroids;
    }, [events, selectedTeam]);

    // 1b. Formation Detection Logic
    const detectedFormation = useMemo(() => {
        if (playerCentroids.length < 5) return "Analysing...";
        const defenders = playerCentroids.filter(p => p.x < 35).length;
        const midfielders = playerCentroids.filter(p => p.x >= 35 && p.x < 70).length;
        const attackers = playerCentroids.filter(p => p.x >= 70).length;
        const hasKeeper = playerCentroids.some(p => p.x < 15);
        const adjDef = hasKeeper ? defenders - 1 : defenders;
        return adjDef > 0 ? `${adjDef}-${midfielders}-${attackers}` : "Searching...";
    }, [playerCentroids]);

    // 2. Identify Penetrative Passes
    const penetrations = useMemo(() => {
        return events.filter(e => {
            if (e.team !== selectedTeam) return false;
            if (!e.eventName.toLowerCase().includes('pass')) return false;
            if (e.x === undefined || e.endX === undefined) return false;

            // Logic for "Penetrative": Either crosses into Final Third (70m) or enters Box (88.5m)
            const enteredFinalThird = e.x < 70 && e.endX >= 70;
            const enteredBox = e.endX >= 88.5 && (e.endY! >= 13.85 && e.endY! <= 54.15);

            return enteredFinalThird || enteredBox;
        });
    }, [events, selectedTeam]);

    // 3. Passing Network
    const network = useMemo(() => {
        const roster = selectedTeam === 'TEAM_A' ? teamARoster : teamBRoster;
        return buildPassingNetwork(events, selectedTeam, roster);
    }, [events, selectedTeam, teamARoster, teamBRoster]);

    return (
        <div className="space-y-4">
            <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                    <Activity className="w-5 h-5 text-primary" />
                    <h2 className="text-xl font-bold uppercase tracking-tight">Tactical Review</h2>
                </div>
                <div className="flex gap-2">
                    <Button
                        variant={selectedTeam === 'TEAM_A' ? 'default' : 'outline'}
                        size="sm"
                        onClick={() => setSelectedTeam('TEAM_A')}
                    >
                        {teamNames.teamA}
                    </Button>
                    <Button
                        variant={selectedTeam === 'TEAM_B' ? 'destructive' : 'outline'}
                        size="sm"
                        onClick={() => setSelectedTeam('TEAM_B')}
                    >
                        {teamNames.teamB}
                    </Button>
                </div>
            </div>

            <div className="grid grid-cols-12 gap-4">
                {/* Left: Performance Pitch */}
                <div className="col-span-12 lg:col-span-8 space-y-4">
                    <Tabs defaultValue="positioning" className="w-full">
                        <TabsList className="bg-muted/50 w-full justify-start border-b rounded-none h-12 p-0 px-4">
                            <TabsTrigger value="positioning" className="data-[state=active]:bg-primary/10 data-[state=active]:text-primary border-b-2 border-transparent data-[state=active]:border-primary rounded-none h-12 px-6">
                                <Move className="w-4 h-4 mr-2" />
                                Avg. Positioning
                            </TabsTrigger>
                            <TabsTrigger value="penetration" className="data-[state=active]:bg-primary/10 data-[state=active]:text-primary border-b-2 border-transparent data-[state=active]:border-primary rounded-none h-12 px-6">
                                <ArrowUpRight className="w-4 h-4 mr-2" />
                                Penetration Map
                            </TabsTrigger>
                            <TabsTrigger value="network" className="data-[state=active]:bg-primary/10 data-[state=active]:text-primary border-b-2 border-transparent data-[state=active]:border-primary rounded-none h-12 px-6">
                                <Network className="w-4 h-4 mr-2" />
                                Pass Network
                            </TabsTrigger>
                        </TabsList>

                        <TabsContent value="positioning" className="mt-4 pt-0">
                            <Card className="border-2 border-primary/5 shadow-xl overflow-hidden bg-white/5 backdrop-blur-sm">
                                <CardHeader className="p-4 pb-0">
                                    <CardTitle className="text-sm font-medium">Centroid Clusters</CardTitle>
                                    <CardDescription className="text-xs">Average locations of all logged touches per player</CardDescription>
                                </CardHeader>
                                <CardContent className="p-4">
                                    <div className="relative">
                                        <PitchMap
                                            playerPositions={playerCentroids}
                                            className="border border-white/10"
                                        />
                                        {/* Centroid Labels Layer */}
                                        <svg viewBox="0 0 105 68" className="absolute inset-0 pointer-events-none p-4">
                                            {playerCentroids.map(p => (
                                                <text
                                                    key={p.id}
                                                    x={p.x}
                                                    y={p.y - 3}
                                                    textAnchor="middle"
                                                    className="text-[2px] font-bold fill-white drop-shadow-md"
                                                >
                                                    {p.name}
                                                </text>
                                            ))}
                                        </svg>
                                    </div>
                                </CardContent>
                            </Card>
                        </TabsContent>

                        <TabsContent value="penetration" className="mt-4 pt-0">
                            <Card className="border-2 border-primary/5 shadow-xl overflow-hidden bg-white/5 backdrop-blur-sm">
                                <CardHeader className="p-4 pb-0">
                                    <CardTitle className="text-sm font-medium">Vertical Penetration</CardTitle>
                                    <CardDescription className="text-xs">Passes entering the Final Third or the Box</CardDescription>
                                </CardHeader>
                                <CardContent className="p-4">
                                    <div className="relative">
                                        <PitchMap className="border border-white/10" />
                                        <svg viewBox="0 0 105 68" className="absolute inset-0 pointer-events-none p-4">
                                            <defs>
                                                <marker id="arrow" markerWidth="2" markerHeight="2" refX="1" refY="1" orient="auto">
                                                    <polyline points="0,0 2,1 0,2" fill="none" stroke="hsl(var(--primary))" strokeWidth="0.5" />
                                                </marker>
                                            </defs>
                                            {penetrations.map((p, i) => (
                                                <line
                                                    key={i}
                                                    x1={p.x} y1={p.y}
                                                    x2={p.endX} y2={p.endY}
                                                    stroke="hsl(var(--primary))"
                                                    strokeWidth="0.4"
                                                    opacity="0.6"
                                                    markerEnd="url(#arrow)"
                                                />
                                            ))}
                                        </svg>
                                    </div>
                                </CardContent>
                            </Card>
                        </TabsContent>

                        <TabsContent value="network" className="mt-4 pt-0">
                            <Card className="border-2 border-primary/5 shadow-xl overflow-hidden bg-white/5 backdrop-blur-sm">
                                <CardHeader className="p-4 pb-0">
                                    <CardTitle className="text-sm font-medium">Passing Dynamics</CardTitle>
                                    <CardDescription className="text-xs">Visualizing the core distribution hubs</CardDescription>
                                </CardHeader>
                                <CardContent className="p-4">
                                    <PassingNetworkViz
                                        network={network}
                                        teamName={selectedTeam === 'TEAM_A' ? teamNames.teamA : teamNames.teamB}
                                        width={700}
                                        height={450}
                                    />
                                </CardContent>
                            </Card>
                        </TabsContent>
                    </Tabs>
                </div>

                {/* Right: Insights & Momentum */}
                <div className="col-span-12 lg:col-span-4 space-y-4">
                    <Card>
                        <CardHeader className="p-4 pb-2">
                            <CardTitle className="text-sm font-bold flex items-center gap-2">
                                <TrendingUp className="w-4 h-4 text-primary" />
                                Match Momentum
                            </CardTitle>
                        </CardHeader>
                        <CardContent className="p-4 pt-0">
                            <div className="h-32">
                                <MomentumChart events={events} />
                            </div>
                        </CardContent>
                    </Card>

                    <Card>
                        <CardHeader className="p-4 pb-2">
                            <CardTitle className="text-sm font-bold flex items-center gap-2">
                                <Target className="w-4 h-4 text-primary" />
                                Efficiency Metrics
                            </CardTitle>
                        </CardHeader>
                        <CardContent className="p-4 pt-0 space-y-4">
                            <div className="flex justify-between items-center p-3 rounded-lg bg-muted/30">
                                <div className="text-xs text-muted-foreground">Detected Formation</div>
                                <div className="text-xl font-bold text-primary">{detectedFormation}</div>
                            </div>
                            <div className="flex justify-between items-center p-3 rounded-lg bg-muted/30">
                                <div className="text-xs text-muted-foreground">Line-Breaking Passes</div>
                                <div className="text-xl font-bold text-primary">{penetrations.length}</div>
                            </div>
                            <div className="flex justify-between items-center p-3 rounded-lg bg-muted/30">
                                <div className="text-xs text-muted-foreground">Network Density</div>
                                <div className="text-xl font-bold text-primary">{(network.metrics.networkDensity * 100).toFixed(0)}%</div>
                            </div>
                            <div className="flex justify-between items-center p-3 rounded-lg bg-muted/30">
                                <div className="text-xs text-muted-foreground">Transition Speed</div>
                                <div className="text-xl font-bold text-primary">High</div>
                            </div>
                        </CardContent>
                    </Card>

                    <Card className="bg-primary/5 border-primary/10">
                        <CardHeader className="p-4 pb-2">
                            <CardTitle className="text-sm font-bold text-primary">Tactical Insight</CardTitle>
                        </CardHeader>
                        <CardContent className="p-4 pt-0">
                            <p className="text-xs leading-relaxed text-muted-foreground">
                                {penetrations.length > 5
                                    ? `${teamNames[selectedTeam === 'TEAM_A' ? 'teamA' : 'teamB']} is effectively exploiting the half-spaces and finding vertical lanes into the box.`
                                    : `${teamNames[selectedTeam === 'TEAM_A' ? 'teamA' : 'teamB']} is struggling to advance the ball centrally. Consider increasing lateral circulation to stretch the block.`
                                }
                            </p>
                        </CardContent>
                    </Card>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/components/AppSidebar.tsx">
import {
    LayoutDashboard,
    BarChart3,
    ShieldCheck,
    Activity,
    Users,
    Settings,
    ChevronRight,
    LogOut,
    Monitor,
    UserCog,
    Globe,
    FileVideo
} from "lucide-react";

import {
    Sidebar,
    SidebarContent,
    SidebarGroup,
    SidebarGroupContent,
    SidebarGroupLabel,
    SidebarHeader,
    SidebarMenu,
    SidebarMenuButton,
    SidebarMenuItem,
    SidebarRail,
    SidebarFooter,
} from "@/components/ui/sidebar";
import { useAuth } from "@/contexts/AuthContext";
import { useNavigate } from "react-router-dom";

export type ViewType = "dashboard" | "analytics" | "qa" | "tactics" | "community" | "settings" | "monitoring" | "admin" | "video_manager";

interface AppSidebarProps {
    currentView: ViewType;
    onViewChange: (view: ViewType) => void;
}

const items = [
    {
        title: "Dashboard",
        view: "dashboard" as ViewType,
        icon: LayoutDashboard,
        permission: "dashboard.view",
        description: "Live & Post-Match"
    },
    {
        title: "Live Stream",
        view: "dashboard" as ViewType, // Intentionally same view, but focuses stream
        icon: Monitor,
        permission: "dashboard.live.stream.view",
        description: "Broadcast Control"
    },
    {
        title: "Stats",
        view: "analytics" as ViewType,
        icon: BarChart3,
        permission: "analytics.view",
        description: "Data Trends"
    },
    {
        title: "Tactics",
        view: "tactics" as ViewType,
        icon: Activity,
        permission: "analytics.advanced",
        description: "Strategy Board"
    },
    {
        title: "Monitoring",
        view: "monitoring" as ViewType,
        icon: Monitor,
        permission: "monitoring.view",
        description: "System Health"
    },
    {
        title: "QA Suite",
        view: "qa" as ViewType,
        icon: ShieldCheck,
        permission: "qa.view",
        description: "Validation"
    },
    {
        title: "Community",
        view: "community" as ViewType,
        icon: Globe,
        permission: "community.view",
        description: "Hub"
    },
    {
        title: "Video Manager",
        view: "video_manager" as ViewType,
        icon: FileVideo,
        permission: "admin.view", // Restricted to admin permissions
        description: "Clips Library"
    },
    {
        title: "Admin Portal",
        path: "/admin",
        icon: UserCog,
        permission: "admin.view",
        description: "Configuration"
    }
];

export function AppSidebar({ currentView, onViewChange }: AppSidebarProps) {
    const { user, logout, hasPermission } = useAuth();
    const navigate = useNavigate();

    const filteredItems = items.filter(item => {
        if ('hidden' in item && (item as any).hidden) return false;
        if (!item.permission) return true;
        return hasPermission(item.permission);
    });

    return (
        <Sidebar id="app-sidebar" collapsible="icon" className="border-r border-border/50 bg-card/50 backdrop-blur-xl">
            <SidebarHeader className="p-4">
                <div className="flex items-center gap-3">
                    <div className="flex h-8 w-8 items-center justify-center rounded-lg bg-primary font-bold text-primary-foreground shadow-lg shadow-primary/20">
                        T
                    </div>
                    <div className="flex flex-col gap-0.5 group-data-[collapsible=icon]:hidden">
                        <span className="font-bold leading-none tracking-tight">Tacta</span>
                        <span className="text-[10px] font-medium uppercase tracking-widest text-muted-foreground opacity-70">
                            {user?.role.replace('_', ' ') || 'Pro Analytics'}
                        </span>
                    </div>
                </div>
            </SidebarHeader>
            <SidebarContent>
                <SidebarGroup>
                    <SidebarGroupLabel className="px-2 text-[10px] font-bold uppercase tracking-widest text-muted-foreground/50 group-data-[collapsible=icon]:hidden">
                        Main Navigation
                    </SidebarGroupLabel>
                    <SidebarGroupContent>
                        <SidebarMenu>
                            {filteredItems.map((item) => (
                                <SidebarMenuItem key={item.title}>
                                    <SidebarMenuButton
                                        tooltip={item.title}
                                        isActive={currentView === item.view || (item.path && window.location.pathname === item.path)}
                                        onClick={() => {
                                            if (item.path) {
                                                navigate(item.path);
                                            } else if (item.view) {
                                                onViewChange(item.view);
                                                if (window.location.pathname !== '/') {
                                                    navigate('/');
                                                }
                                            }
                                        }}
                                        className={`h-10 transition-all duration-200 ${currentView === item.view
                                            ? "bg-primary/10 text-primary shadow-sm"
                                            : "text-muted-foreground hover:bg-accent hover:text-foreground"
                                            }`}
                                    >
                                        <item.icon className={`h-4.5 w-4.5 ${currentView === item.view ? "animate-pulse" : ""}`} />
                                        <div className="flex flex-col gap-0.5 group-data-[collapsible=icon]:hidden">
                                            <span className="font-medium text-xs">{item.title}</span>
                                            {item.description && (
                                                <span className="text-[9px] text-muted-foreground/60 font-normal">{item.description}</span>
                                            )}
                                        </div>
                                        {currentView === item.view && (
                                            <ChevronRight className="ml-auto h-3.5 w-3.5 opacity-50 group-data-[collapsible=icon]:hidden" />
                                        )}
                                    </SidebarMenuButton>
                                </SidebarMenuItem>
                            ))}
                        </SidebarMenu>
                    </SidebarGroupContent>
                </SidebarGroup>
            </SidebarContent>
            <SidebarFooter className="p-4 border-t border-border/20">
                <SidebarMenu>
                    <SidebarMenuItem>
                        <SidebarMenuButton
                            onClick={logout}
                            tooltip="Logout"
                            className="text-muted-foreground hover:text-destructive hover:bg-destructive/10 transition-colors"
                        >
                            <LogOut className="h-4.5 w-4.5" />
                            <span className="font-medium group-data-[collapsible=icon]:hidden">Logout</span>
                        </SidebarMenuButton>
                    </SidebarMenuItem>
                </SidebarMenu>
            </SidebarFooter>
            <SidebarRail />
        </Sidebar>
    );
}
</file>

<file path="src/components/ButtonMappingConfig.tsx">
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { GamepadButtonMapping, BUTTON_LABELS } from "@/hooks/useGamepad";
import { useEventConfig } from '@/contexts/EventConfigContext'; // New import
import { POST_MATCH_KEYBOARD_MAPPINGS } from "@/components/KeyboardShortcutsGrid";
import { Gamepad2, RotateCcw, Settings2, Keyboard, Monitor, Zap, Timer } from "lucide-react";
import { useEffect, useState, useMemo } from "react";

interface ButtonMappingConfigProps {
    mappings: GamepadButtonMapping[];
    pressedButtons: number[];
    onUpdateMapping: (index: number, eventName: string) => void;
    onResetMappings: () => void;
}

export const ButtonMappingConfig = ({ mappings, pressedButtons, onUpdateMapping, onResetMappings }: ButtonMappingConfigProps) => {
    const [listeningFor, setListeningFor] = useState<string | null>(null);
    const [isOpen, setIsOpen] = useState(false);
    const { events } = useEventConfig(); // Use Context

    // Derive static lists from dynamic registry
    const { combos, holds } = useMemo(() => {
        const c: any[] = [];
        const h: any[] = [];

        events.forEach(e => {
            if (!e.gamepadMappings) return;
            e.gamepadMappings.forEach(m => {
                if (m.modifier) {
                    c.push({
                        buttonLabel: `${m.modifier}+${BUTTON_LABELS[m.buttonIndex]}`,
                        eventName: e.eventName,
                        eventDescription: e.label
                    });
                } else if (m.isHold) {
                    h.push({
                        buttonLabel: `Hold ${BUTTON_LABELS[m.buttonIndex]}`,
                        eventName: e.eventName,
                        eventDescription: e.label
                    });
                }
            });
        });
        return { combos: c, holds: h };
    }, [events]);

    useEffect(() => {
        if (listeningFor && pressedButtons.length > 0) {
            const buttonIndex = pressedButtons[0];
            onUpdateMapping(buttonIndex, listeningFor);
            setListeningFor(null);
        }
    }, [pressedButtons, listeningFor, onUpdateMapping]);

    const renderMappingItem = (mapping: GamepadButtonMapping) => (
        <div key={mapping.eventName} className="flex flex-col p-2 border rounded-md bg-secondary/20 hover:bg-secondary/40 transition-colors">
            <div className="flex justify-between items-start mb-1 gap-2">
                <span className="font-medium text-xs truncate text-primary flex-1" title={mapping.eventName}>
                    {mapping.eventName.replace(/_/g, ' ')}
                </span>
                <span className={`text-[10px] font-mono px-1.5 py-0.5 rounded whitespace-nowrap ${listeningFor === mapping.eventName ? 'bg-primary text-primary-foreground animate-pulse' : 'bg-muted text-muted-foreground'}`}>
                    {mapping.index === -1 ? "-" : (BUTTON_LABELS[mapping.index] || `B${mapping.index}`)}
                </span>
            </div>
            <div className="text-[9px] text-muted-foreground truncate mb-2" title={mapping.eventDescription}>
                {mapping.eventDescription}
            </div>
            <Button
                variant={listeningFor === mapping.eventName ? "destructive" : "outline"}
                size="sm"
                className="h-6 text-[10px] w-full"
                onClick={() => setListeningFor(mapping.eventName)}
                disabled={listeningFor !== null && listeningFor !== mapping.eventName}
            >
                {listeningFor === mapping.eventName ? "Cancel" : "Remap"}
            </Button>
        </div>
    );

    const renderStaticItem = (label: string, eventName: string, description: string, icon?: any) => (
        <div key={eventName} className="flex flex-col p-2 border border-dashed rounded-md bg-muted/10 opacity-80">
            <div className="flex justify-between items-start mb-1 gap-2">
                <span className="font-medium text-xs truncate text-primary flex-1" title={eventName}>
                    {eventName.replace(/_/g, ' ')}
                </span>
                <span className="text-[10px] font-mono px-1.5 py-0.5 rounded bg-muted text-muted-foreground whitespace-nowrap">
                    {label}
                </span>
            </div>
            <div className="text-[9px] text-muted-foreground truncate mb-2 flex items-center gap-1">
                {icon}
                {description}
            </div>
            <Button variant="ghost" size="sm" className="h-6 text-[10px] w-full cursor-not-allowed" disabled>
                Dynamic
            </Button>
        </div>
    );

    // Group Keyboard Mappings
    const keyboardCategories = POST_MATCH_KEYBOARD_MAPPINGS.reduce((acc, curr) => {
        const cat = curr.category || 'Other';
        if (!acc[cat]) acc[cat] = [];
        acc[cat].push(curr);
        return acc;
    }, {} as Record<string, typeof POST_MATCH_KEYBOARD_MAPPINGS>);


    return (
        <Dialog open={isOpen} onOpenChange={(open) => {
            setIsOpen(open);
            if (!open) setListeningFor(null);
        }}>
            <DialogTrigger asChild>
                <Button variant="outline" size="sm" className="gap-2">
                    <Settings2 className="w-4 h-4" />
                    Controller Config
                </Button>
            </DialogTrigger>
            <DialogContent className="max-w-5xl max-h-[90vh] overflow-hidden flex flex-col p-6">
                <DialogHeader className="pb-4">
                    <DialogTitle className="flex items-center gap-2">
                        <Monitor className="w-5 h-5 text-primary" />
                        Input Configuration
                    </DialogTitle>
                    <DialogDescription>
                        Configure your bindings for Gamepad and Keyboard.
                    </DialogDescription>
                </DialogHeader>

                <Tabs defaultValue="controller" className="flex-1 flex flex-col overflow-hidden">
                    <TabsList className="grid w-full grid-cols-2 mb-4">
                        <TabsTrigger value="controller" className="gap-2">
                            <Gamepad2 className="w-4 h-4" /> Controller
                        </TabsTrigger>
                        <TabsTrigger value="keyboard" className="gap-2">
                            <Keyboard className="w-4 h-4" /> Keyboard
                        </TabsTrigger>
                    </TabsList>

                    <TabsContent value="controller" className="flex-1 overflow-y-auto pr-2">
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 pb-4">
                            {/* Face Buttons Group */}
                            <div className="space-y-2">
                                <h4 className="text-xs font-semibold uppercase text-muted-foreground flex items-center gap-2">
                                    <span className="w-1.5 h-1.5 rounded-full bg-blue-500" /> Face & Triggers
                                </h4>
                                <div className="grid gap-2">
                                    {mappings.filter(m => (m.index >= 0 && m.index <= 3) || (m.index >= 4 && m.index <= 7)).map(renderMappingItem)}
                                </div>
                            </div>

                            {/* D-Pad & System */}
                            <div className="space-y-2">
                                <h4 className="text-xs font-semibold uppercase text-muted-foreground flex items-center gap-2">
                                    <span className="w-1.5 h-1.5 rounded-full bg-green-500" /> D-Pad & System
                                </h4>
                                <div className="grid gap-2">
                                    {mappings.filter(m => (m.index >= 12 && m.index <= 15) || (m.index >= 8 && m.index <= 11)).map(renderMappingItem)}
                                </div>
                            </div>

                            {/* Combos Group */}
                            <div className="space-y-2">
                                <h4 className="text-xs font-semibold uppercase text-muted-foreground flex items-center gap-2">
                                    <Zap className="w-3 h-3 text-yellow-500" /> Combos (Dynamic)
                                </h4>
                                <div className="grid gap-2">
                                    {combos.map((combo, idx) =>
                                        renderStaticItem(
                                            combo.buttonLabel,
                                            combo.eventName,
                                            combo.eventDescription
                                        )
                                    )}
                                </div>
                            </div>

                            {/* Holds Group */}
                            <div className="space-y-2">
                                <h4 className="text-xs font-semibold uppercase text-muted-foreground flex items-center gap-2">
                                    <Timer className="w-3 h-3 text-purple-500" /> Holds (Dynamic)
                                </h4>
                                <div className="grid gap-2">
                                    {holds.map((hold, idx) =>
                                        renderStaticItem(
                                            hold.buttonLabel,
                                            hold.eventName,
                                            hold.eventDescription
                                        )
                                    )}
                                </div>
                            </div>
                        </div>
                    </TabsContent>

                    <TabsContent value="keyboard" className="flex-1 overflow-y-auto pr-2">
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 pb-4">
                            {Object.entries(keyboardCategories).map(([category, items]) => (
                                <div key={category} className="space-y-2">
                                    <h4 className="text-xs font-semibold uppercase text-muted-foreground flex items-center gap-2">
                                        <Keyboard className="w-3 h-3" /> {category}
                                    </h4>
                                    <div className="grid gap-2">
                                        {items.map((item, idx) => (
                                            <div key={`${item.eventName}-${idx}`} className="flex flex-col p-2 border rounded-md bg-secondary/10 opacity-90">
                                                <div className="flex justify-between items-start mb-1 gap-2">
                                                    <span className="font-medium text-xs truncate text-primary flex-1">
                                                        {item.description}
                                                    </span>
                                                    <span className="text-[10px] font-mono px-1.5 py-0.5 rounded bg-muted text-foreground whitespace-nowrap border border-white/5">
                                                        {item.modifier ? `${item.modifier}+` : ''}{item.key}
                                                    </span>
                                                </div>
                                                <div className="text-[9px] text-muted-foreground truncate flex items-center justify-between">
                                                    <span>{item.eventName}</span>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                        <div className="mt-4 p-3 rounded-lg border border-yellow-500/20 bg-yellow-500/5 text-yellow-500/80 text-xs text-center">
                            Keyboard bindings are currently standard and follow the TACTA Analysis Protocol. Re-binding coming soon.
                        </div>
                    </TabsContent>
                </Tabs>

                <div className="flex justify-between items-center pt-4 border-t mt-4">
                    <div className="text-xs text-muted-foreground flex items-center gap-1">
                        <Gamepad2 className="w-3 h-3" />
                        {pressedButtons.length > 0
                            ? `Pressed: ${pressedButtons.map(b => BUTTON_LABELS[b] || b).join(", ")}`
                            : "Press controller buttons to test input"}
                    </div>
                    <Button variant="ghost" size="sm" onClick={onResetMappings} className="text-destructive hover:text-destructive">
                        <RotateCcw className="w-3 h-3 mr-2" />
                        Reset Defaults
                    </Button>
                </div>
            </DialogContent>
        </Dialog>
    );
};
</file>

<file path="src/components/common/DashboardWidget.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
import { Eye, EyeOff, GripHorizontal } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface DashboardWidgetProps {
    id: string;
    label?: string; // Human readable name for the edit overlay
    children: React.ReactNode;
    isEditMode: boolean;
    isHidden?: boolean;
    onToggleVisibility?: (id: string) => void;
    className?: string;
}

export const DashboardWidget: React.FC<DashboardWidgetProps> = ({
    id,
    label,
    children,
    isEditMode,
    isHidden = false,
    onToggleVisibility,
    className
}) => {
    // If not editing and hidden, render nothing
    if (!isEditMode && isHidden) {
        return null;
    }

    return (
        <div id={id} className={cn(
            "relative transition-all duration-300",
            className,
            isEditMode && "ring-2 ring-dashed ring-slate-600 rounded-lg p-1",
            isEditMode && isHidden && "opacity-50 grayscale ring-red-900/50 bg-red-950/10"
        )}>
            {isEditMode && (
                <div className="absolute -top-3 left-3 z-[100] flex items-center gap-1">
                    <div className={cn(
                        "px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider flex items-center gap-2 shadow-sm border",
                        isHidden
                            ? "bg-red-950 text-red-400 border-red-800"
                            : "bg-slate-800 text-slate-200 border-slate-600"
                    )}>
                        {/* Drag handle placeholder for future */}
                        <GripHorizontal className="h-3 w-3 opacity-50 cursor-move" />
                        <span>{label || id}</span>

                        <div className="h-3 w-px bg-white/10 mx-1" />

                        <button
                            onClick={(e) => {
                                e.stopPropagation();
                                onToggleVisibility?.(id);
                            }}
                            className="hover:text-white transition-colors"
                        >
                            {isHidden ? <EyeOff className="h-3 w-3" /> : <Eye className="h-3 w-3" />}
                        </button>
                    </div>
                </div>
            )}

            {/* Content Overlay when hidden in edit mode to prevent interaction */}
            {isEditMode && isHidden && (
                <div className="absolute inset-0 z-[10] bg-slate-950/20 backdrop-blur-[1px] rounded-lg pointer-events-none" />
            )}

            {children}
        </div>
    );
};
</file>

<file path="src/components/common/SafetyBoundary.tsx">
import React, { Component, ErrorInfo, type ReactNode } from 'react';

export class SafetyBoundary extends Component<{ children: ReactNode; name: string }, { hasError: boolean; error: Error | null }> {
    constructor(props: { children: ReactNode; name: string }) {
        super(props);
        this.state = { hasError: false, error: null };
    }

    static getDerivedStateFromError(error: Error) {
        return { hasError: true, error };
    }

    componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.error(`[SafetyBoundary] Error in ${this.props.name}:`, error, errorInfo);
    }

    render() {
        if (this.state.hasError) {
            return (
                <div className="p-2 m-1 bg-destructive/20 border border-destructive/50 rounded text-destructive text-[10px] font-mono overflow-auto max-h-[100px]">
                    <strong>{this.props.name} Crash:</strong> {this.state.error?.message}
                </div>
            );
        }
        return this.props.children;
    }
}
</file>

<file path="src/components/CommunityHub.tsx">
import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Trophy, Medal, Users, Flame, ShieldAlert, Award } from "lucide-react";
import { API_BASE_URL, ANALYSIS_API_URL, API_HEADERS } from '@/utils/apiConfig';

interface LeaderboardUser {
    nickname: string;
    xp: number;
}

interface ClubRanking {
    name: string;
    xp: number;
    members: number;
}

export function CommunityHub() {
    const [overallLeaderboard, setOverallLeaderboard] = useState<LeaderboardUser[]>([]);
    const [monthlyLeaderboard, setMonthlyLeaderboard] = useState<LeaderboardUser[]>([]);
    const [clubs, setClubs] = useState<ClubRanking[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchData = async () => {
            try {
                const [lbRes, clubsRes] = await Promise.all([
                    fetch(`${ANALYSIS_API_URL}/api/community/leaderboard`, { headers: API_HEADERS }),
                    fetch(`${ANALYSIS_API_URL}/api/community/clubs`, { headers: API_HEADERS })
                ]);

                const lbData = await lbRes.json();
                const clubsData = await clubsRes.json();

                if (lbData.success) {
                    setOverallLeaderboard(lbData.overall);
                    setMonthlyLeaderboard(lbData.monthly);
                }
                if (clubsData.success) {
                    setClubs(clubsData.clubs);
                }
            } catch (error) {
                console.error("Failed to fetch community data:", error);
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, []);

    if (loading) {
        return <div className="p-8 text-center text-muted-foreground animate-pulse font-mono tracking-widest uppercase">Syncing Community Data...</div>;
    }

    return (
        <div className="p-6 space-y-8 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <div className="flex flex-col gap-1">
                <h2 className="text-3xl font-bold tracking-tight text-primary">Community Hub</h2>
                <p className="text-muted-foreground">Compete, rank up, and support your club in the national analyst community.</p>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 text-sm">

                {/* Monthly Top 10 */}
                <Card className="border-primary/20 bg-card/30 backdrop-blur-md shadow-xl overflow-hidden group">
                    <CardHeader className="bg-primary/5 border-b border-primary/10">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <Trophy className="h-5 w-5 text-yellow-500 group-hover:scale-110 transition-transform" />
                                <CardTitle className="text-base uppercase tracking-wider">Top Analysts Monthly</CardTitle>
                            </div>
                            <Badge variant="outline" className="animate-pulse border-yellow-500/50 text-yellow-500">Active</Badge>
                        </div>
                        <CardDescription className="text-xs">Top 10 earn the "Analyste Or" badge</CardDescription>
                    </CardHeader>
                    <CardContent className="p-0">
                        <Table>
                            <TableHeader>
                                <TableRow className="hover:bg-transparent">
                                    <TableHead className="w-12 text-center">#</TableHead>
                                    <TableHead>User</TableHead>
                                    <TableHead className="text-right">XP</TableHead>
                                </TableRow>
                            </TableHeader>
                            <TableBody>
                                {monthlyLeaderboard.map((user, idx) => (
                                    <TableRow key={idx} className="hover:bg-primary/5 transition-colors border-primary/5">
                                        <TableCell className="text-center font-mono font-bold text-muted-foreground">
                                            {idx === 0 ? "ü•á" : idx === 1 ? "ü•à" : idx === 2 ? "ü•â" : idx + 1}
                                        </TableCell>
                                        <TableCell className="font-medium">{user.nickname}</TableCell>
                                        <TableCell className="text-right font-mono text-primary">{user.xp}</TableCell>
                                    </TableRow>
                                ))}
                                {monthlyLeaderboard.length === 0 && (
                                    <TableRow><TableCell colSpan={3} className="text-center py-8 text-muted-foreground opacity-50 italic">No data this month</TableCell></TableRow>
                                )}
                            </TableBody>
                        </Table>
                    </CardContent>
                </Card>

                {/* Club Rankings */}
                <Card className="border-blue-500/20 bg-card/30 backdrop-blur-md shadow-xl overflow-hidden group">
                    <CardHeader className="bg-blue-500/5 border-b border-blue-500/10">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <Users className="h-5 w-5 text-blue-500 group-hover:scale-110 transition-transform" />
                                <CardTitle className="text-base uppercase tracking-wider">Inter-Club Rankings</CardTitle>
                            </div>
                        </div>
                        <CardDescription className="text-xs">Combined XP of all club supporters</CardDescription>
                    </CardHeader>
                    <CardContent className="p-0">
                        <Table>
                            <TableHeader>
                                <TableRow className="hover:bg-transparent">
                                    <TableHead>Club</TableHead>
                                    <TableHead className="text-center">Members</TableHead>
                                    <TableHead className="text-right">Total XP</TableHead>
                                </TableRow>
                            </TableHeader>
                            <TableBody>
                                {clubs.map((club, idx) => (
                                    <TableRow key={idx} className="hover:bg-blue-500/5 transition-colors border-blue-500/5">
                                        <TableCell className="font-bold">{club.name}</TableCell>
                                        <TableCell className="text-center">
                                            <div className="flex items-center justify-center gap-1 text-muted-foreground">
                                                <Users className="h-3 w-3" /> {club.members}
                                            </div>
                                        </TableCell>
                                        <TableCell className="text-right font-mono text-blue-500">{club.xp}</TableCell>
                                    </TableRow>
                                ))}
                                {clubs.length === 0 && (
                                    <TableRow><TableCell colSpan={3} className="text-center py-8 text-muted-foreground opacity-50 italic">No clubs recorded</TableCell></TableRow>
                                )}
                            </TableBody>
                        </Table>
                    </CardContent>
                </Card>

                {/* Global Hall of Fame */}
                <Card className="border-purple-500/20 bg-card/30 backdrop-blur-md shadow-xl overflow-hidden group">
                    <CardHeader className="bg-purple-500/5 border-b border-purple-500/10">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <Medal className="h-5 w-5 text-purple-500 group-hover:scale-110 transition-transform" />
                                <CardTitle className="text-base uppercase tracking-wider">Hall of Fame</CardTitle>
                            </div>
                        </div>
                        <CardDescription className="text-xs">Legendary analyst status across all time</CardDescription>
                    </CardHeader>
                    <CardContent className="p-0">
                        <Table>
                            <TableHeader>
                                <TableRow className="hover:bg-transparent">
                                    <TableHead>User</TableHead>
                                    <TableHead className="text-right">Total XP</TableHead>
                                </TableRow>
                            </TableHeader>
                            <TableBody>
                                {overallLeaderboard.map((user, idx) => (
                                    <TableRow key={idx} className="hover:bg-purple-500/5 transition-colors border-purple-500/5">
                                        <TableCell className="font-medium flex items-center gap-2">
                                            {user.nickname}
                                            {user.xp > 1000 && <Award className="h-3.5 w-3.5 text-purple-500" />}
                                        </TableCell>
                                        <TableCell className="text-right font-mono text-purple-500">{user.xp}</TableCell>
                                    </TableRow>
                                ))}
                            </TableBody>
                        </Table>
                    </CardContent>
                </Card>

            </div>
        </div>
    );
}
</file>

<file path="src/components/ControllerGrid.tsx">
import { Card } from "@/components/ui/card";
import { GamepadButtonMapping } from "@/hooks/useGamepad";
import { useEffect, useState } from "react";

interface ControllerGridProps {
  lastEventButtonLabel?: string;
  pressedButtons?: number[];
  onManualInput?: (event: string, button: string) => void;
  mappings: GamepadButtonMapping[];
}

export const ControllerGrid = ({ lastEventButtonLabel, pressedButtons = [], onManualInput, mappings }: ControllerGridProps) => {
  const [flashingButton, setFlashingButton] = useState<string | null>(null);

  useEffect(() => {
    if (lastEventButtonLabel) {
      setFlashingButton(lastEventButtonLabel);
      const timer = setTimeout(() => setFlashingButton(null), 300);
      return () => clearTimeout(timer);
    }
  }, [lastEventButtonLabel]);

  return (
    <div className="flex flex-wrap justify-center gap-2">
      {mappings.map((mapping: GamepadButtonMapping) => {
        // Skip unassigned mappings
        if (mapping.index === -1) return null;

        const isPressed = pressedButtons.includes(mapping.index);
        const isFlashing = flashingButton === mapping.buttonLabel;

        return (
          <Card
            key={`${mapping.buttonLabel}-${mapping.index}`}
            onClick={() => onManualInput?.(mapping.eventName, mapping.buttonLabel)}
            className={`p-2 border-2 transition-all w-28 h-24 text-center flex flex-col items-center justify-center cursor-pointer select-none ${isFlashing || isPressed
              ? "border-success bg-success/10 animate-button-flash scale-105"
              : "border-border bg-card hover:border-primary/30 hover:bg-accent/50"
              }`}
          >
            <div className="flex flex-col items-center gap-1">
              <span className="text-xl font-mono font-bold text-primary leading-none">
                {mapping.buttonLabel}
              </span>
              <div>
                <h3 className="text-sm font-bold leading-tight">{mapping.eventDescription}</h3>
                {/* <p className="text-[10px] text-muted-foreground mt-0.5 leading-tight line-clamp-1">{mapping.eventName}</p> */}
              </div>
            </div>
          </Card>
        );
      })}
    </div>
  );
};
</file>

<file path="src/components/ControllerMappingsGrid.tsx">
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Gamepad2 } from "lucide-react";
import { BUTTON_LABELS } from "@/hooks/useGamepad";
import { useEventConfig } from '@/contexts/EventConfigContext';
import { useMemo } from "react";

// Controller mapping categories for organized display
interface ControllerMapping {
    button: string;
    eventName: string;
    description: string;
    category: 'Basic' | 'Modifier' | 'Hold' | 'D-Pad';
    modifier?: string;
}

const getCategoryColor = (category: ControllerMapping['category']) => {
    switch (category) {
        case 'Basic': return 'bg-blue-500/10 border-blue-500/40 hover:border-blue-400';
        case 'Modifier': return 'bg-purple-500/10 border-purple-500/40 hover:border-purple-400';
        case 'Hold': return 'bg-amber-500/10 border-amber-500/40 hover:border-amber-400';
        case 'D-Pad': return 'bg-emerald-500/10 border-emerald-500/40 hover:border-emerald-400';
        default: return 'bg-zinc-800 border-zinc-700';
    }
};

const getCategoryBadgeVariant = (category: ControllerMapping['category']) => {
    switch (category) {
        case 'Basic': return 'bg-blue-500/20 text-blue-300 border-blue-500/30';
        case 'Modifier': return 'bg-purple-500/20 text-purple-300 border-purple-500/30';
        case 'Hold': return 'bg-amber-500/20 text-amber-300 border-amber-500/30';
        case 'D-Pad': return 'bg-emerald-500/20 text-emerald-300 border-emerald-500/30';
        default: return '';
    }
};

interface ControllerMappingsGridProps {
    onButtonPress?: (eventName: string, button: string) => void;
    pressedButtons?: number[];
}

export const ControllerMappingsGrid = ({ onButtonPress, pressedButtons = [] }: ControllerMappingsGridProps) => {
    const { events } = useEventConfig();

    const controllerMappings = useMemo(() => {
        const mappings: ControllerMapping[] = [];

        events.forEach(event => {
            if (!event.gamepadMappings) return;

            event.gamepadMappings.forEach(m => {
                // Focus on LIVE mode or generic inputs for this grid (or allow all)
                // If we want this grid to be mode-agnostic, we can include all.
                // Assuming this is primarily for reference or live input visualization.

                let category: ControllerMapping['category'] = 'Basic';
                let buttonLabel = BUTTON_LABELS[m.buttonIndex];

                if (m.modifier) {
                    category = 'Modifier';
                    buttonLabel = `${m.modifier}+${BUTTON_LABELS[m.buttonIndex]}`;
                } else if (m.isHold) {
                    category = 'Hold';
                    buttonLabel = `${BUTTON_LABELS[m.buttonIndex]} (Hold)`;
                } else if (m.buttonIndex >= 12 && m.buttonIndex <= 15) {
                    category = 'D-Pad';
                }

                mappings.push({
                    button: buttonLabel,
                    eventName: event.eventName,
                    description: event.label,
                    category: category,
                    modifier: m.modifier
                });
            });
        });

        // Deduplicate? Or maybe show overrides? 
        // For now, simple list is fine.
        return mappings;

    }, [events]);


    // Group mappings by category
    const basicMappings = controllerMappings.filter(m => m.category === 'Basic');
    const dpadMappings = controllerMappings.filter(m => m.category === 'D-Pad');
    const modifierMappings = controllerMappings.filter(m => m.category === 'Modifier');
    const holdMappings = controllerMappings.filter(m => m.category === 'Hold');

    const renderMappingCard = (mapping: ControllerMapping, idx: number) => (
        <Card
            key={`${mapping.button}-${idx}`}
            onClick={() => onButtonPress?.(mapping.eventName, mapping.button)}
            className={`p-1.5 border transition-all cursor-pointer select-none min-h-[54px] flex flex-col justify-center ${getCategoryColor(mapping.category)}`}
        >
            <div className="flex flex-col items-center gap-0.5 text-center">
                <span className="text-xs font-mono font-bold text-primary leading-none">
                    {mapping.button}
                </span>
                <span className="text-[8px] sm:text-[9px] text-muted-foreground leading-tight line-clamp-2 font-medium">
                    {mapping.description}
                </span>
            </div>
        </Card>
    );

    return (
        <div className="space-y-3">
            <div className="flex items-center justify-between">
                <h3 className="text-xs font-bold uppercase tracking-wider text-muted-foreground flex items-center gap-1.5">
                    <Gamepad2 className="w-3.5 h-3.5" />
                    Controller Mappings
                </h3>
                <Badge variant="outline" className="text-[10px]">Live Config</Badge>
            </div>

            {/* Basic Buttons */}
            {basicMappings.length > 0 && (
                <div className="space-y-1">
                    <div className="flex items-center gap-1.5">
                        <Badge variant="outline" className={`text-[9px] ${getCategoryBadgeVariant('Basic')}`}>
                            Basic
                        </Badge>
                        <span className="text-[9px] text-muted-foreground">Face, Shoulder, Triggers</span>
                    </div>
                    <div className="grid grid-cols-4 sm:grid-cols-6 gap-1">
                        {basicMappings.map((m, i) => renderMappingCard(m, i))}
                    </div>
                </div>
            )}

            {/* D-Pad */}
            {dpadMappings.length > 0 && (
                <div className="space-y-1">
                    <div className="flex items-center gap-1.5">
                        <Badge variant="outline" className={`text-[9px] ${getCategoryBadgeVariant('D-Pad')}`}>
                            D-Pad
                        </Badge>
                        <span className="text-[9px] text-muted-foreground">Tactical Phases</span>
                    </div>
                    <div className="grid grid-cols-4 gap-1">
                        {dpadMappings.map((m, i) => renderMappingCard(m, i))}
                    </div>
                </div>
            )}

            {/* Modifier Combos */}
            {modifierMappings.length > 0 && (
                <div className="space-y-1">
                    <div className="flex items-center gap-1.5">
                        <Badge variant="outline" className={`text-[9px] ${getCategoryBadgeVariant('Modifier')}`}>
                            Combos
                        </Badge>
                        <span className="text-[9px] text-muted-foreground">RT+, LT+, View+</span>
                    </div>
                    <div className="grid grid-cols-3 sm:grid-cols-5 gap-1">
                        {modifierMappings.map((m, i) => renderMappingCard(m, i))}
                    </div>
                </div>
            )}

            {/* Hold Events */}
            {holdMappings.length > 0 && (
                <div className="space-y-1">
                    <div className="flex items-center gap-1.5">
                        <Badge variant="outline" className={`text-[9px] ${getCategoryBadgeVariant('Hold')}`}>
                            Hold
                        </Badge>
                        <span className="text-[9px] text-muted-foreground">500ms+ Press</span>
                    </div>
                    <div className="grid grid-cols-2 gap-1">
                        {holdMappings.map((m, i) => renderMappingCard(m, i))}
                    </div>
                </div>
            )}

            {/* Legend */}
            <div className="flex items-center gap-3 pt-2 border-t border-zinc-800 text-[9px] text-muted-foreground">
                <div className="flex items-center gap-1">
                    <div className="w-2 h-2 rounded-sm bg-blue-500/30 border border-blue-500/50" />
                    <span>Basic</span>
                </div>
                <div className="flex items-center gap-1">
                    <div className="w-2 h-2 rounded-sm bg-emerald-500/30 border border-emerald-500/50" />
                    <span>D-Pad</span>
                </div>
                <div className="flex items-center gap-1">
                    <div className="w-2 h-2 rounded-sm bg-purple-500/30 border border-purple-500/50" />
                    <span>Combo</span>
                </div>
                <div className="flex items-center gap-1">
                    <div className="w-2 h-2 rounded-sm bg-amber-500/30 border border-amber-500/50" />
                    <span>Hold</span>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/components/CrowdReviewPanel.tsx">
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/hooks/use-toast';
import { API_BASE_URL, ANALYSIS_API_URL } from '@/utils/apiConfig';
import {
    Users,
    Send,
    Clock,
    CheckCircle2,
    AlertCircle,
    Loader2,
    MessageSquare,
    RefreshCw
} from 'lucide-react';

interface CrowdReviewPanelProps {
    videoFile: File | null;
    currentVideoTime: number;
    matchName?: string;
    preSelectedEvent?: string;
}

interface ClipStatus {
    clip_id: number;
    filename: string;
    stage: string;
    status: string;
    consensus_event: string | null;
    vote_count: number;
    required_votes: number;
    vote_breakdown: Record<string, number>;
}

export const CrowdReviewPanel: React.FC<CrowdReviewPanelProps> = ({
    videoFile,
    currentVideoTime,
    matchName = "Unknown Match",
    preSelectedEvent
}) => {
    const { toast } = useToast();
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [pendingClips, setPendingClips] = useState<ClipStatus[]>([]);
    const [customTimestamp, setCustomTimestamp] = useState<string>('');
    const eventType = preSelectedEvent || 'General';

    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };

    const parseTimeToSeconds = (timeStr: string): number | null => {
        const match = timeStr.match(/^(\d+):(\d{2})$/);
        if (match) {
            return parseInt(match[1]) * 60 + parseInt(match[2]);
        }
        const num = parseFloat(timeStr);
        return isNaN(num) ? null : num;
    };

    const handleSendToCrowd = async (timestampSeconds?: number) => {
        if (!videoFile) {
            toast({
                title: "No Video",
                description: "Please load a video file first",
                variant: "destructive"
            });
            return;
        }

        const timestamp = timestampSeconds ?? currentVideoTime;
        setIsSubmitting(true);

        try {
            // Use FormData to upload video file
            const formData = new FormData();
            formData.append('video', videoFile);
            formData.append('timestamp_seconds', timestamp.toString());
            formData.append('match_name', matchName);
            formData.append('event_type', eventType === 'General' ? '' : eventType);
            formData.append('window_seconds', '10.0');

            const response = await fetch(`${ANALYSIS_API_URL}/api/crowd/request-review-upload`, {
                method: 'POST',
                body: formData
            });

            const data = await response.json();

            if (data.success) {
                toast({
                    title: "üìπ Sent to Crowd!",
                    description: `Clip at ${formatTime(timestamp)} queued for fan annotation.`
                });

                // Add to pending clips list
                setPendingClips(prev => [...prev, {
                    clip_id: data.clip_id,
                    filename: data.clip_filename,
                    stage: 'crowd_voting',
                    status: 'pending',
                    consensus_event: null,
                    vote_count: 0,
                    required_votes: 10,
                    vote_breakdown: {}
                }]);
            } else {
                throw new Error(data.error || 'Failed to send clip');
            }
        } catch (error) {
            console.error('Crowd review error:', error);
            toast({
                title: "Error",
                description: error instanceof Error ? error.message : "Failed to send clip for review",
                variant: "destructive"
            });
        } finally {
            setIsSubmitting(false);
        }
    };

    const handleCheckStatus = async (clipId: number) => {
        try {
            const response = await fetch(`${ANALYSIS_API_URL}/api/crowd/status/${clipId}`);
            const data = await response.json();

            if (data.success) {
                setPendingClips(prev => prev.map(clip =>
                    clip.clip_id === clipId ? {
                        ...clip,
                        stage: data.stage,
                        status: data.status,
                        consensus_event: data.consensus_event,
                        vote_count: data.vote_count,
                        vote_breakdown: data.vote_breakdown
                    } : clip
                ));
            }
        } catch (error) {
            console.error('Status check error:', error);
        }
    };

    const handleSendCustomTimestamp = () => {
        const seconds = parseTimeToSeconds(customTimestamp);
        if (seconds !== null) {
            handleSendToCrowd(seconds);
            setCustomTimestamp('');
        } else {
            toast({
                title: "Invalid Format",
                description: "Use MM:SS or seconds (e.g., 45:30 or 2730)",
                variant: "destructive"
            });
        }
    };

    return (
        <Card className="p-4 bg-card/50 border-2 border-primary/20 mt-3">
            <div className="flex items-center gap-2 mb-4">
                <Users className="w-5 h-5 text-primary" />
                <h3 className="font-bold text-sm uppercase tracking-wider">Crowd Annotation</h3>
                <Badge variant="outline" className="ml-auto text-[10px]">
                    {pendingClips.length} pending
                </Badge>
            </div>

            {preSelectedEvent && (
                <div className="mb-4 p-2 bg-primary/5 rounded border border-primary/20">
                    <label className="text-[10px] text-muted-foreground uppercase font-bold block mb-1">
                        Active Event Context
                    </label>
                    <Badge variant="secondary" className="text-[11px] font-bold uppercase">
                        {preSelectedEvent}
                    </Badge>
                </div>
            )}

            {/* Quick Send - Current Timestamp */}
            <div className="space-y-3">
                <div className="flex gap-2">
                    <Button
                        onClick={() => handleSendToCrowd()}
                        disabled={isSubmitting || !videoFile}
                        className="flex-1 gap-2"
                        variant="default"
                    >
                        {isSubmitting ? (
                            <Loader2 className="w-4 h-4 animate-spin" />
                        ) : (
                            <Send className="w-4 h-4" />
                        )}
                        Send to Fans ({formatTime(currentVideoTime)})
                    </Button>
                </div>

                {/* Custom Timestamp */}
                <div className="flex gap-2">
                    <Input
                        placeholder="MM:SS or seconds"
                        value={customTimestamp}
                        onChange={(e) => setCustomTimestamp(e.target.value)}
                        className="h-9 text-xs"
                    />
                    <Button
                        onClick={handleSendCustomTimestamp}
                        disabled={!customTimestamp || isSubmitting}
                        variant="outline"
                        size="sm"
                        className="h-9"
                    >
                        <Clock className="w-4 h-4" />
                    </Button>
                </div>

                {!videoFile && (
                    <p className="text-[10px] text-muted-foreground text-center">
                        Load a video to enable crowd annotation
                    </p>
                )}
            </div>

            {/* Pending Clips */}
            {pendingClips.length > 0 && (
                <div className="mt-4 space-y-2">
                    <span className="text-[10px] text-muted-foreground uppercase font-bold">
                        Pending Reviews
                    </span>
                    <div className="space-y-2 max-h-48 overflow-y-auto">
                        {pendingClips.map(clip => (
                            <div
                                key={clip.clip_id}
                                className="p-2 bg-muted/50 rounded-lg border border-border/50 text-xs"
                            >
                                <div className="flex items-center justify-between">
                                    <span className="font-mono">#{clip.clip_id}</span>
                                    <div className="flex items-center gap-2">
                                        {clip.status === 'confirmed' ? (
                                            <Badge variant="default" className="bg-green-500 text-[10px]">
                                                <CheckCircle2 className="w-3 h-3 mr-1" />
                                                {clip.consensus_event}
                                            </Badge>
                                        ) : clip.status === 'ambiguous' ? (
                                            <Badge variant="destructive" className="text-[10px]">
                                                <AlertCircle className="w-3 h-3 mr-1" />
                                                Ambiguous
                                            </Badge>
                                        ) : (
                                            <Badge variant="secondary" className="text-[10px]">
                                                <MessageSquare className="w-3 h-3 mr-1" />
                                                {clip.vote_count}/{clip.required_votes} votes
                                            </Badge>
                                        )}
                                        <Button
                                            size="icon"
                                            variant="ghost"
                                            className="h-6 w-6"
                                            onClick={() => handleCheckStatus(clip.clip_id)}
                                            title="Refresh status"
                                        >
                                            <RefreshCw className="w-3 h-3" />
                                        </Button>
                                    </div>
                                </div>

                                {/* Vote Breakdown */}
                                {Object.keys(clip.vote_breakdown).length > 0 && (
                                    <div className="mt-2 flex gap-1 flex-wrap">
                                        {Object.entries(clip.vote_breakdown).map(([event, count]) => (
                                            <Badge key={event} variant="outline" className="text-[9px]">
                                                {event}: {count}
                                            </Badge>
                                        ))}
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            )}
        </Card>
    );
};
</file>

<file path="src/components/Dashboard.tsx">
import { LoggedEvent } from "@/hooks/useGamepad";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Activity, Shield, Trophy, XCircle } from "lucide-react";

interface DashboardProps {
    events: LoggedEvent[];
    teamNames?: { teamA: string, teamB: string };
}

export const Dashboard = ({ events, teamNames = { teamA: "Team A", teamB: "Team B" } }: DashboardProps) => {
    // Calculate Stats
    const totalPasses = events.filter(e => e.eventName === "PASS").length;
    const successfulPasses = events.filter(e => e.eventName === "Successful Pass").length;
    const failedPasses = events.filter(e => e.eventName === "Failed Pass").length;

    const duelsWon = events.filter(e => e.eventName === "Duel Won").length; // Note: Logic for Duel Won/Lost needs to be precise in useGamepad
    // Based on current logic in useGamepad, we log "Duel" then "Possession Won/Lost". 
    // We might need to refine useGamepad to explicitly log "Duel Won" if that's the requirement, 
    // or infer it here. For now, let's count "Possession Won" as a positive defensive action if no pass preceded it.

    const possessionWon = events.filter(e => e.eventName === "Possession Won").length;
    const possessionLost = events.filter(e => e.eventName === "Possession Lost").length;

    // Simple Possession % Estimate (based on event counts for now, or time if we had it easily)
    // Let's use event count ratio for Team A vs Team B for a rough "Activity" metric
    const teamAEvents = events.filter(e => e.team === "TEAM_A").length;
    const teamBEvents = events.filter(e => e.team === "TEAM_B").length;
    const totalEvents = teamAEvents + teamBEvents;
    const teamAPercentage = totalEvents > 0 ? Math.round((teamAEvents / totalEvents) * 100) : 50;

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            {/* Possession / Activity */}
            <Card className="p-4 border-2 border-primary/20 bg-card col-span-1 md:col-span-2">
                <div className="flex items-center justify-between mb-2">
                    <h3 className="font-semibold flex items-center gap-2">
                        <Activity className="w-5 h-5 text-primary" />
                        Match Activity ({teamNames.teamA} vs {teamNames.teamB})
                    </h3>
                    <span className="text-sm font-mono">{teamAPercentage}% - {100 - teamAPercentage}%</span>
                </div>
                <Progress value={teamAPercentage} className="h-3" />
            </Card>

            {/* Passing Stats */}
            <Card className="p-4 border-2 border-border bg-card">
                <h3 className="font-semibold mb-4 flex items-center gap-2">
                    <Trophy className="w-5 h-5 text-yellow-500" />
                    Passing
                </h3>
                <div className="space-y-3">
                    <div className="flex justify-between text-sm">
                        <span className="text-muted-foreground">Total Passes</span>
                        <span className="font-bold">{totalPasses}</span>
                    </div>
                    <div className="flex justify-between text-sm">
                        <span className="text-muted-foreground">Successful</span>
                        <span className="font-bold text-success">{successfulPasses}</span>
                    </div>
                    <div className="flex justify-between text-sm">
                        <span className="text-muted-foreground">Failed</span>
                        <span className="font-bold text-destructive">{failedPasses}</span>
                    </div>
                </div>
            </Card>

            {/* Defensive Stats */}
            <Card className="p-4 border-2 border-border bg-card">
                <h3 className="font-semibold mb-4 flex items-center gap-2">
                    <Shield className="w-5 h-5 text-blue-500" />
                    Possession
                </h3>
                <div className="space-y-3">
                    <div className="flex justify-between text-sm">
                        <span className="text-muted-foreground">Possession Won</span>
                        <span className="font-bold text-success">{possessionWon}</span>
                    </div>
                    <div className="flex justify-between text-sm">
                        <span className="text-muted-foreground">Possession Lost</span>
                        <span className="font-bold text-destructive">{possessionLost}</span>
                    </div>
                </div>
            </Card>
        </div>
    );
};
</file>

<file path="src/components/dashboard/DashboardHeader.tsx">
import React from 'react';
import { Button } from '@/components/ui/button';
import {
    Mic, MicOff, Play, Pause,
    ChevronDown, X, Settings,
    Save, RotateCcw, Layout, HelpCircle
} from 'lucide-react';
import { SidebarTrigger } from '@/components/ui/sidebar';
import { SequenceAssistantCompact } from '@/components/SequenceAssistant';
import { ViewType } from '@/components/AppSidebar';
import { cn } from '@/lib/utils';
import type { AnalysisMode } from '@/components/AnalysisModeSelector';

interface DashboardHeaderProps {
    userRole?: string;
    activeView: ViewType;
    setActiveView: (view: ViewType) => void;
    hasPermission: (permission: string) => boolean;
    trackingMode: AnalysisMode;
    setTrackingMode: (mode: AnalysisMode) => void;
    isMatchActive: boolean;
    toggleMatch: () => void;
    matchTime: number;
    formatTime: (seconds: number) => string;
    voiceLanguage: 'en' | 'fr' | 'ar';
    setVoiceLanguage: (lang: 'en' | 'fr' | 'ar') => void;
    isListening: boolean;
    toggleListening: () => void;
    isInRoom: boolean;
    joinVoiceRoom: () => void;
    leaveVoiceRoom: () => void;
    toggleMute: () => void;
    isMuted: boolean;
    peersCount: number;
    isEditMode: boolean;
    setIsEditMode: (mode: boolean) => void;
    saveLayout: () => void;
    resetLayout: () => void;
    onStartGuide?: () => void;
}

export const DashboardHeader: React.FC<DashboardHeaderProps> = ({
    userRole,
    activeView,
    setActiveView,
    hasPermission,
    trackingMode,
    setTrackingMode,
    isMatchActive,
    toggleMatch,
    matchTime,
    formatTime,
    voiceLanguage,
    setVoiceLanguage,
    isListening,
    toggleListening,
    isInRoom,
    joinVoiceRoom,
    leaveVoiceRoom,
    toggleMute,
    isMuted,
    peersCount,
    isEditMode,
    setIsEditMode,
    saveLayout,
    resetLayout,
    onStartGuide
}) => {
    return (
        <div id="dashboard-header" className="h-12 border-b bg-card/95 backdrop-blur-md flex items-center px-4 select-none z-50 shrink-0 gap-4 justify-between shadow-sm">
            <div className="flex items-center gap-3">
                {userRole !== 'eye_spotter' && <SidebarTrigger className="h-8 w-8" />}
                <div className="h-4 w-px bg-border/60" />
                <div className="flex flex-col">
                    <h1 className="font-bold text-sm tracking-tight uppercase text-primary">
                        {activeView}
                    </h1>
                    <span className="text-[9px] text-muted-foreground uppercase tracking-widest leading-none font-medium">Session Live</span>
                </div>
            </div>

            {/* Match Control */}
            <div className="flex items-center gap-2">
                <div className="flex items-center bg-muted/50 rounded-md p-0.5 border border-border/50 shadow-inner">
                    {hasPermission('dashboard.live.view') && (
                        <Button
                            variant={trackingMode === 'LIVE' ? 'default' : 'ghost'}
                            size="sm"
                            className="h-6 text-[10px] px-2.5 rounded transition-all"
                            onClick={() => setTrackingMode('LIVE')}
                        >
                            LIVE
                        </Button>
                    )}
                    {hasPermission('dashboard.post.view') && (
                        <Button
                            variant={trackingMode === 'POST_MATCH' ? 'default' : 'ghost'}
                            size="sm"
                            className="h-6 text-[10px] px-2.5 rounded transition-all"
                            onClick={() => setTrackingMode('POST_MATCH')}
                        >
                            POST-MATCH
                        </Button>
                    )}
                </div>

                <div className="flex items-center gap-2 bg-card px-3 py-0.5 rounded-md border border-border shadow-sm">
                    <span className={`font-mono font-bold text-base min-w-[70px] text-center ${isMatchActive ? 'text-primary' : 'text-muted-foreground'}`}>
                        {formatTime(matchTime)}
                    </span>
                    <Button
                        size="icon"
                        className={`h-6 w-6 rounded-full shadow-sm transition-colors ${isMatchActive ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-green-500 hover:bg-green-600 text-white'}`}
                        onClick={toggleMatch}
                    >
                        {isMatchActive ? <Pause size={12} fill="currentColor" /> : <Play size={12} fill="currentColor" />}
                    </Button>
                </div>
            </div>

            <div className="flex items-center gap-3">
                <SequenceAssistantCompact className="hidden md:flex" />

                {/* Language & Voice */}
                <div className="flex items-center gap-1.5">
                    <div className="relative group">
                        <select
                            className="h-7 pl-2 pr-6 bg-muted/50 border border-border rounded text-[11px] font-medium focus:outline-none appearance-none cursor-pointer hover:bg-muted transition-colors"
                            value={voiceLanguage}
                            onChange={(e) => setVoiceLanguage(e.target.value as any)}
                        >
                            <option value="en">EN</option>
                            <option value="fr">FR</option>
                            <option value="ar">AR</option>
                        </select>
                        <ChevronDown className="h-3 w-3 text-muted-foreground absolute right-1.5 top-2 pointer-events-none group-hover:text-foreground" />
                    </div>

                    {hasPermission('dashboard.live.voice') && (
                        <Button
                            variant={isListening ? "default" : "outline"}
                            size="sm"
                            className={`h-7 gap-1.5 px-2 transition-all text-[11px] ${isListening ? 'bg-red-500 hover:bg-red-600 border-red-500 text-white shadow-md animate-pulse' : 'text-muted-foreground'}`}
                            onClick={toggleListening}
                        >
                            {isListening ? <Mic size={12} /> : <MicOff size={12} />}
                            <span className="hidden lg:inline">Voice Cmd</span>
                        </Button>
                    )}

                    {/* Voice Room Controls */}
                    <div className="flex items-center gap-1 bg-muted/30 rounded-md p-0.5 border border-border/50">
                        {!isInRoom ? (
                            <Button
                                variant="ghost"
                                size="sm"
                                className="h-6 text-[10px] px-2 gap-1.5 text-muted-foreground hover:text-primary hover:bg-primary/10"
                                onClick={joinVoiceRoom}
                            >
                                <MicOff size={12} /> Join Room
                            </Button>
                        ) : (
                            <>
                                <Button
                                    variant={isMuted ? "destructive" : "secondary"}
                                    size="icon"
                                    className="h-6 w-6 rounded-full"
                                    onClick={toggleMute}
                                >
                                    {isMuted ? <MicOff size={11} /> : <Mic size={11} />}
                                </Button>
                                <div className="px-2 text-[9px] font-mono text-primary flex items-center gap-1">
                                    <span className="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse" />
                                    {peersCount + 1} User{peersCount !== 0 && 's'}
                                </div>
                                <Button
                                    variant="ghost"
                                    size="icon"
                                    className="h-6 w-6 text-muted-foreground hover:text-destructive"
                                    onClick={leaveVoiceRoom}
                                >
                                    <X size={12} />
                                </Button>
                            </>
                        )}
                    </div>
                </div>

                <div className="h-4 w-px bg-border/60" />

                {/* Layout Controls */}
                <div className="flex items-center gap-1">
                    {isEditMode ? (
                        <>
                            <Button variant="ghost" size="sm" className="h-8 gap-2 text-green-400 hover:text-green-300 hover:bg-green-400/10" onClick={saveLayout}>
                                <Save className="h-4 w-4" /> <span className="hidden xl:inline">Save</span>
                            </Button>
                            <Button variant="ghost" size="icon" className="h-8 w-8 text-muted-foreground hover:text-white" onClick={resetLayout}>
                                <RotateCcw className="h-4 w-4" />
                            </Button>
                            <Button variant="ghost" size="sm" className="h-8 gap-2 text-muted-foreground hover:text-white" onClick={() => setIsEditMode(false)}>
                                <X className="h-4 w-4" />
                            </Button>
                        </>
                    ) : (
                        <Button variant="ghost" size="icon" className={cn("h-8 w-8 text-muted-foreground hover:text-foreground", isEditMode && "text-primary bg-primary/10")} onClick={() => setIsEditMode(true)}>
                            <Layout className="h-4 w-4" />
                        </Button>
                    )}
                </div>

                <div className="h-4 w-px bg-border/60" />

                <Button variant="ghost" size="icon" className="h-8 w-8 text-muted-foreground hover:text-foreground" onClick={() => setActiveView('settings')}>
                    <Settings className="h-4 w-4" />
                </Button>

                {onStartGuide && (
                    <Button
                        id="help-button"
                        variant="ghost"
                        size="icon"
                        className="h-8 w-8 text-muted-foreground hover:text-primary transition-colors"
                        onClick={onStartGuide}
                        title="Start Visual Guide"
                    >
                        <HelpCircle className="h-4 w-4" />
                    </Button>
                )}
            </div>
        </div>
    );
};
</file>

<file path="src/components/dashboard/DashboardLeftPanel.tsx">
import React from 'react';
import { Radio } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { DashboardWidget } from '@/components/common/DashboardWidget';
import { SpotterPingPanel } from '@/components/SpotterPingPanel';
import { PlayerUpload } from '@/components/PlayerUpload';
import { TeamGrid } from '@/components/TeamGrid';
import { ButtonMappingConfig } from '@/components/ButtonMappingConfig';
import { ControllerMappingsGrid } from '@/components/ControllerMappingsGrid';
import { KeyboardShortcutsGrid } from '@/components/KeyboardShortcutsGrid';
import { GamepadButtonMapping } from '@/hooks/useGamepad';
import { TeamRoster } from '@/types/player';
import type { AnalysisMode } from '@/components/AnalysisModeSelector';
import { LayoutConfig } from '@/hooks/useDashboardLayout';

interface DashboardLeftPanelProps {
    userRole?: string;
    isEditMode: boolean;
    layoutConfig: LayoutConfig;
    toggleComponentVisibility: (id: string) => void;
    // Team Props
    teams: Map<string, TeamRoster>;
    selectedTeam: string;
    onTeamUpload: (teams: Map<string, TeamRoster>) => void;
    onSelectTeam: (teamId: string) => void;
    // Tagger Props
    trackingMode: AnalysisMode;
    keyboardBuffer: string;
    showMappings: boolean;
    mappings: GamepadButtonMapping[];
    pressedButtons: number[];
    onUpdateMapping: (index: number, eventName: string) => void;
    onResetMappings: () => void;
    handleGameEvent: (eventName: string, source?: string) => void;
    // Local Edit Mode for mappings
    isEditingMode: boolean;
    setIsEditingMode: (mode: boolean) => void;
    hasPermission: (permission: string) => boolean;
}

export const DashboardLeftPanel: React.FC<DashboardLeftPanelProps> = ({
    userRole,
    isEditMode,
    layoutConfig,
    toggleComponentVisibility,
    teams,
    selectedTeam,
    onTeamUpload,
    onSelectTeam,
    trackingMode,
    keyboardBuffer,
    showMappings,
    mappings,
    pressedButtons,
    onUpdateMapping,
    onResetMappings,
    handleGameEvent,
    isEditingMode,
    setIsEditingMode,
    hasPermission
}) => {
    return (
        <div className="col-span-12 md:col-span-3 lg:col-span-2 flex flex-col gap-3 h-full min-h-0">
            {userRole === 'eye_spotter' ? (
                <DashboardWidget
                    id="spotter-panel"
                    label="Spotter Panel"
                    isEditMode={isEditMode}
                    isHidden={layoutConfig['spotter-panel']?.hidden}
                    onToggleVisibility={toggleComponentVisibility}
                    className="h-full"
                >
                    <SpotterPingPanel />
                </DashboardWidget>
            ) : (
                <DashboardWidget
                    id="left-tools"
                    label="Team Tools"
                    isEditMode={isEditMode}
                    isHidden={layoutConfig['left-tools']?.hidden}
                    onToggleVisibility={toggleComponentVisibility}
                    className="flex-1 min-h-0 overflow-y-auto pr-1 space-y-2 no-scrollbar"
                >
                    {userRole !== 'live_tagger' && <PlayerUpload onUpload={onTeamUpload} />}
                    {teams.size > 0 && <TeamGrid teams={Array.from(teams.keys())} selectedTeam={selectedTeam} onSelectTeam={onSelectTeam} />}

                    {trackingMode === 'LIVE' && keyboardBuffer && (
                        <div className="bg-black/90 border border-primary p-2 rounded-lg text-center shadow-lg">
                            <span className="text-[9px] text-muted-foreground uppercase tracking-widest font-semibold">Voice Buffer</span>
                            <div className="text-2xl font-mono font-bold text-primary mt-0.5">#{keyboardBuffer}</div>
                        </div>
                    )}

                    {showMappings && (trackingMode === 'LIVE' || trackingMode === 'POST_MATCH') && (
                        <div className="space-y-2 animate-in fade-in slide-in-from-left-4 duration-300">
                            {trackingMode === 'POST_MATCH' && hasPermission('dashboard.post.edit') && (
                                <Button variant={isEditingMode ? "secondary" : "outline"} size="sm" className="w-full h-7 text-[11px]" onClick={() => setIsEditingMode(!isEditingMode)}>
                                    {isEditingMode ? "Exit Edit" : "Edit Events"}
                                </Button>
                            )}
                            {trackingMode === 'LIVE' ? (
                                <div className="space-y-3">
                                    <div className="flex items-center justify-between px-1">
                                        <div className="flex flex-col gap-1">
                                            <span className="text-[10px] font-bold text-slate-500 uppercase tracking-tighter">Overlays</span>
                                            <Button
                                                variant="ghost"
                                                size="sm"
                                                className={cn(
                                                    "h-7 px-2 gap-2 text-[10px] font-bold uppercase transition-all",
                                                    layoutConfig['live-stats']?.hidden ? "text-slate-500" : "text-cyan-400 bg-cyan-400/10"
                                                )}
                                                onClick={() => toggleComponentVisibility('live-stats')}
                                            >
                                                <Radio className="h-3 w-3" />
                                                Live Stats
                                            </Button>
                                        </div>
                                        <ButtonMappingConfig
                                            mappings={mappings}
                                            pressedButtons={pressedButtons}
                                            onUpdateMapping={onUpdateMapping}
                                            onResetMappings={onResetMappings}
                                        />
                                    </div>
                                    <ControllerMappingsGrid
                                        onButtonPress={(eventName, button) => handleGameEvent(eventName, button)}
                                        pressedButtons={pressedButtons}
                                    />
                                </div>
                            ) : (
                                <div className="space-y-3">
                                    <div className="px-1 flex flex-col gap-1">
                                        <span className="text-[10px] font-bold text-slate-500 uppercase tracking-tighter">Overlays</span>
                                        <Button
                                            variant="ghost"
                                            size="sm"
                                            className={cn(
                                                "h-7 px-2 gap-2 text-[10px] font-bold uppercase transition-all",
                                                layoutConfig['live-stats']?.hidden ? "text-slate-500" : "text-cyan-400 bg-cyan-400/10"
                                            )}
                                            onClick={() => toggleComponentVisibility('live-stats')}
                                        >
                                            <Radio className="h-3 w-3" />
                                            Live Stats
                                        </Button>
                                    </div>
                                    <KeyboardShortcutsGrid onKeyPress={(eventName, key) => handleGameEvent(eventName, `Key:${key}`)} />
                                </div>
                            )}
                        </div>
                    )}
                </DashboardWidget>
            )}
        </div>
    );
};
</file>

<file path="src/components/dashboard/DashboardRightPanel.tsx">
import React from 'react';
import { toast } from 'sonner';
import { LayoutTemplate } from 'lucide-react';
import { DashboardWidget } from '@/components/common/DashboardWidget';
import { LoggerAuditPanel } from '@/components/LoggerAuditPanel';
import { PredictorStats } from '@/components/SequenceAssistant';
import { EventLog } from '@/components/EventLog';
import { PlayerSelectionSidebar } from '@/components/PlayerSelectionSidebar';
import { CrowdReviewPanel } from '@/components/CrowdReviewPanel';
import { SafetyBoundary } from '@/components/common/SafetyBoundary';
import { LoggedEvent } from '@/hooks/useGamepad';
import { LayoutConfig } from '@/hooks/useDashboardLayout';
import { TeamRoster } from '@/types/player';
import type { AnalysisMode } from '@/components/AnalysisModeSelector';

interface DashboardRightPanelProps {
    userRole?: string;
    isEditMode: boolean;
    layoutConfig: LayoutConfig;
    toggleComponentVisibility: (id: string) => void;
    // Data
    events: LoggedEvent[];
    setEvents: React.Dispatch<React.SetStateAction<LoggedEvent[]>>;
    teams: Map<string, TeamRoster>;
    selectedTeam: string;
    teamNames: { teamA: string; teamB: string };
    // Actions
    onPlayerSelect: (playerId: number) => void;
    // State
    trackingMode: AnalysisMode;
    useVideoMode: boolean;
    videoFile: File | null;
    videoTime: number;
    lastEventButtonLabel?: string | null;
}

export const DashboardRightPanel: React.FC<DashboardRightPanelProps> = ({
    userRole,
    isEditMode,
    layoutConfig,
    toggleComponentVisibility,
    events,
    setEvents,
    teams,
    selectedTeam,
    teamNames,
    onPlayerSelect,
    trackingMode,
    useVideoMode,
    videoFile,
    videoTime,
    lastEventButtonLabel
}) => {
    // Only show for non-eyespotters (logic from Index.tsx)
    if (userRole === 'eye_spotter') return null;

    return (
        <div className="hidden lg:flex lg:col-span-3 flex-col gap-3 h-full min-h-0">
            {userRole === 'logger' ? (
                <DashboardWidget
                    id="logger-audit"
                    label="Logger Audit"
                    isEditMode={isEditMode}
                    isHidden={layoutConfig['logger-audit']?.hidden}
                    onToggleVisibility={toggleComponentVisibility}
                    className="flex-1"
                >
                    <LoggerAuditPanel
                        systemEvents={events}
                        onExport={() => toast.success("Audit Report Exported")}
                    />
                </DashboardWidget>
            ) : (
                <>
                    <DashboardWidget
                        id="predictor-stats"
                        label="Prediction Engine"
                        isEditMode={isEditMode}
                        isHidden={layoutConfig['predictor-stats']?.hidden}
                        onToggleVisibility={toggleComponentVisibility}
                        className="shrink-0"
                    >
                        <PredictorStats className="shrink-0" />
                    </DashboardWidget>

                    <DashboardWidget
                        id="event-log"
                        label="Event Log"
                        isEditMode={isEditMode}
                        isHidden={layoutConfig['event-log']?.hidden}
                        onToggleVisibility={toggleComponentVisibility}
                        className="flex-1 min-h-0"
                    >
                        <SafetyBoundary name="EventLog">
                            <EventLog
                                events={events}
                                onUndoEvent={(id) => {
                                    setEvents(prev => prev.filter(e => e.id !== id));
                                    toast.success("Event removed from log");
                                }}
                                onMissedEvent={() => {
                                    const newEvent: LoggedEvent = {
                                        id: Number(`${Date.now()}${Math.floor(Math.random() * 1000)}`),
                                        timestamp: new Date().toISOString(),
                                        eventName: "missed_event",
                                        team: selectedTeam as any || "TEAM_A",
                                        buttonLabel: "LOGGER",
                                        isMissed: true,
                                        mode: trackingMode as any
                                    };
                                    setEvents(prev => [...prev, newEvent]);
                                    toast.warning("Missed event recorded in audit log");
                                }}
                                onToggleDelay={(eventId: number) => {
                                    setEvents(prev => prev.map(e =>
                                        e.id === eventId ? { ...e, isDelayed: !e.isDelayed } : e
                                    ));
                                    toast.info("Event delay flag toggled");
                                }}
                                teamNames={teamNames}
                            />
                        </SafetyBoundary>
                    </DashboardWidget>

                    <DashboardWidget
                        id="right-panel-bottom"
                        label="Context & Review"
                        isEditMode={isEditMode}
                        isHidden={layoutConfig['right-panel-bottom']?.hidden}
                        onToggleVisibility={toggleComponentVisibility}
                        className="flex-1 min-h-0 overflow-y-auto pl-1 no-scrollbar"
                    >
                        {teams.get(selectedTeam) ? (
                            <SafetyBoundary name="PlayerSelectionSidebar">
                                <PlayerSelectionSidebar
                                    players={teams.get(selectedTeam)!.PlayerData}
                                    selectedPlayerId={null}
                                    onSelectPlayer={onPlayerSelect}
                                    teamName={selectedTeam}
                                />
                            </SafetyBoundary>
                        ) : (
                            <div className="h-full flex flex-col items-center justify-center text-muted-foreground opacity-30 border border-dashed rounded-lg bg-card/30">
                                <LayoutTemplate className="w-8 h-8 mb-2" />
                                <span className="text-[10px] font-medium text-center">Select a team<br />to view roster</span>
                            </div>
                        )}

                        {useVideoMode && trackingMode === 'POST_MATCH' && (
                            <CrowdReviewPanel
                                videoFile={videoFile}
                                currentVideoTime={videoTime}
                                matchName={Array.from(teams.keys()).join(' vs ') || 'Unknown Match'}
                                preSelectedEvent={lastEventButtonLabel}
                            />
                        )}
                    </DashboardWidget>
                </>
            )}
        </div>
    );
};
</file>

<file path="src/components/dashboard/views/AnalyticsView.tsx">
import React from 'react';
import { SemanticAnalytics } from '@/components/analytics/SemanticAnalytics';
import { StatisticsDashboard } from '@/components/StatisticsDashboard';
import { LoggedEvent } from '@/hooks/useGamepad';

interface AnalyticsViewProps {
    events: LoggedEvent[];
}

export const AnalyticsView: React.FC<AnalyticsViewProps> = ({ events }) => {
    return (
        <div className="flex-1 p-0 overflow-y-auto custom-scrollbar bg-background/50 backdrop-blur-3xl">
            <SemanticAnalytics events={events} />
            <div className="p-6 pt-0">
                <StatisticsDashboard events={events} isFullPage />
            </div>
        </div>
    );
};
</file>

<file path="src/components/dashboard/views/DashboardView.tsx">
import React, { RefObject } from 'react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Monitor, Trophy, Upload, X } from 'lucide-react';
import { LiveStreamPlayer, LiveStreamPlayerRef } from '@/components/LiveStreamPlayer';
import { IPTVChannelBrowser } from '@/components/IPTV';
import { FIFAPlusBrowser } from '@/components/FIFAPlus/FIFAPlusBrowser';
import { AnnotatedVideoPlayer } from '@/components/VideoPlayer/AnnotatedVideoPlayer';
import { VideoUpload } from '@/components/VideoUpload';
import { ZoneIndicator } from '@/components/ZoneIndicator';
import { DashboardWidget } from '@/components/common/DashboardWidget';
import { DashboardLeftPanel } from '@/components/dashboard/DashboardLeftPanel';
import { DashboardRightPanel } from '@/components/dashboard/DashboardRightPanel';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Activity, Radio, Loader2 } from 'lucide-react';
import { LayoutConfig } from '@/hooks/useDashboardLayout';
import { TeamRoster } from '@/types/player';
import { LoggedEvent, GamepadButtonMapping } from '@/hooks/useGamepad';
import type { AnalysisMode } from '@/components/AnalysisModeSelector';
import { API_BASE_URL } from '@/utils/apiConfig';
import { useAuth } from '@/contexts/AuthContext';
import { toast } from 'sonner';

interface DashboardViewProps {
    userRole?: string;
    isEditMode: boolean;
    layoutConfig: LayoutConfig;
    toggleComponentVisibility: (id: string) => void;
    // State
    teams: Map<string, TeamRoster>;
    selectedTeam: string;
    handleTeamUpload: (teams: Map<string, TeamRoster>) => void;
    handleTeamSelect: (teamId: string) => void;
    trackingMode: AnalysisMode;
    keyboardBuffer: string;
    showMappings: boolean;
    mappings: GamepadButtonMapping[];
    pressedButtons: number[];
    updateMapping: (index: number, eventName: string) => void;
    resetMappings: () => void;
    handleGameEvent: (eventName: string, source?: string) => void;
    isEditingMode: boolean;
    setIsEditingMode: (mode: boolean) => void;
    hasPermission: (permission: string) => boolean;
    // Video & Analytics State
    showAnalysisView: boolean;
    videoMode: 'upload' | 'live' | 'fifaplus';
    useVideoMode: boolean;
    isIPTVConfigured: boolean;
    livePlayerRef: RefObject<LiveStreamPlayerRef>;
    events: LoggedEvent[];
    showFeed: boolean;
    setUseVideoMode: (use: boolean) => void;
    setVideoMode: (mode: 'upload' | 'live' | 'fifaplus') => void;
    showIPTVBrowser: boolean;
    setShowIPTVBrowser: (show: boolean) => void;
    showFIFAPlusBrowser: boolean;
    setShowFIFAPlusBrowser: (show: boolean) => void;
    videoFile: File | null;
    remoteVideoUrl: string | null;
    videoTime: number;
    setVideoTime: (time: number) => void;
    seekTime: number | null;
    setSeekTime: (time: number | null) => void;
    isVideoPlaying: boolean;
    setIsVideoPlaying: (playing: boolean) => void;
    socket: any;
    axes: any;
    buttons: any;
    teamNames: { teamA: string; teamB: string };
    handlePlayerSelect: (playerId: number) => void;
    analysisResults: any;
    quickSelectorState: any;
    thirdsZone: any;
    setVideoFile: (file: File | null) => void;
    setServerVideoPath: (path: string | null) => void;
    sessionMode: 'collab' | 'individual' | null;
    setShowAdminWaitingRoom: (show: boolean) => void;
    togglePiP: () => void;
    toggleWatchMatch: () => void;
    setEvents: React.Dispatch<React.SetStateAction<LoggedEvent[]>>;
    lastEventButtonLabel?: string | null;
}

export const DashboardView: React.FC<DashboardViewProps> = ({
    userRole,
    isEditMode,
    layoutConfig,
    toggleComponentVisibility,
    teams,
    selectedTeam,
    handleTeamUpload,
    handleTeamSelect,
    trackingMode,
    keyboardBuffer,
    showMappings,
    mappings,
    pressedButtons,
    updateMapping,
    resetMappings,
    handleGameEvent,
    isEditingMode,
    setIsEditingMode,
    hasPermission,
    showAnalysisView,
    videoMode,
    useVideoMode,
    isIPTVConfigured,
    livePlayerRef,
    events,
    showFeed,
    setUseVideoMode,
    setVideoMode,
    showIPTVBrowser,
    setShowIPTVBrowser,
    showFIFAPlusBrowser,
    setShowFIFAPlusBrowser,
    videoFile,
    remoteVideoUrl,
    videoTime,
    setVideoTime,
    seekTime,
    setSeekTime,
    isVideoPlaying,
    setIsVideoPlaying,
    socket,
    axes,
    buttons,
    teamNames,
    handlePlayerSelect,
    analysisResults,
    quickSelectorState,
    thirdsZone,
    setVideoFile,
    setServerVideoPath,
    sessionMode,
    setShowAdminWaitingRoom,
    togglePiP,
    toggleWatchMatch,
    setEvents,
    lastEventButtonLabel
}) => {
    const isLeftHidden = userRole === 'eye_spotter'
        ? layoutConfig['spotter-panel']?.hidden
        : layoutConfig['left-tools']?.hidden;

    const isRightHidden = userRole === 'eye_spotter' ? true : (
        userRole === 'logger'
            ? layoutConfig['logger-audit']?.hidden
            : (layoutConfig['predictor-stats']?.hidden &&
                layoutConfig['event-log']?.hidden &&
                layoutConfig['right-panel-bottom']?.hidden)
    );

    return (
        <div className="flex-1 min-h-0 p-3 grid grid-cols-12 gap-3 relative z-10">
            {/* LEFT COLUMN - System Controls / Spotter Assist */}
            {!isLeftHidden && (
                <DashboardLeftPanel
                    userRole={userRole}
                    isEditMode={isEditMode}
                    layoutConfig={layoutConfig}
                    toggleComponentVisibility={toggleComponentVisibility}
                    teams={teams}
                    selectedTeam={selectedTeam}
                    onTeamUpload={handleTeamUpload}
                    onSelectTeam={handleTeamSelect}
                    trackingMode={trackingMode}
                    keyboardBuffer={keyboardBuffer}
                    showMappings={showMappings}
                    mappings={mappings}
                    pressedButtons={pressedButtons}
                    onUpdateMapping={updateMapping}
                    onResetMappings={resetMappings}
                    handleGameEvent={handleGameEvent}
                    isEditingMode={isEditingMode}
                    setIsEditingMode={setIsEditingMode}
                    hasPermission={hasPermission}
                />
            )}

            {/* CENTER COLUMN - Analytics & Video */}
            <div className={cn(
                "flex flex-col gap-3 h-full min-h-0 overflow-y-auto custom-scrollbar transition-all duration-300",
                userRole === 'eye_spotter' ? "col-span-12" : (
                    isLeftHidden && isRightHidden ? "col-span-12" :
                        isLeftHidden ? "col-span-12 md:col-span-12 lg:col-span-9" :
                            isRightHidden ? "col-span-12 md:col-span-9 lg:col-span-10" :
                                "col-span-12 md:col-span-9 lg:col-span-7"
                )
            )}>
                <DashboardWidget
                    id="main-video"
                    label="Live Feed / Video Player"
                    isEditMode={isEditMode}
                    isHidden={layoutConfig['main-video']?.hidden}
                    onToggleVisibility={toggleComponentVisibility}
                    className="flex-1 min-h-0 relative bg-black rounded-lg overflow-hidden shadow-2xl border border-border/20 flex items-center justify-center"
                >
                    <div className="w-full h-full relative">
                        <div className={showAnalysisView ? 'grid grid-cols-3 gap-2 h-full' : 'h-full'}>
                            {(videoMode === 'live' || videoMode === 'fifaplus') && isIPTVConfigured ? (
                                <div className="w-full h-full relative group">
                                    <LiveStreamPlayer
                                        ref={livePlayerRef}
                                        events={events}
                                        showLiveToasts={showFeed}
                                        variant="streamlined"
                                        onClose={() => { setUseVideoMode(false); setVideoMode('upload'); }}
                                        isEditMode={isEditMode}
                                        layoutConfig={layoutConfig}
                                        onToggleVisibility={toggleComponentVisibility}
                                    />
                                    <div className="absolute top-2 right-12 flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
                                        <Button
                                            variant="secondary"
                                            size="sm"
                                            className="h-7 gap-1.5"
                                            onClick={() => setShowIPTVBrowser(true)}
                                        >
                                            <Monitor className="h-3.5 w-3.5" />
                                            <span>Channels</span>
                                        </Button>
                                        <Button
                                            variant="secondary"
                                            size="sm"
                                            className="h-7 gap-1.5 bg-blue-600/20 hover:bg-blue-600/40 text-blue-400 border-blue-500/30"
                                            onClick={() => setShowFIFAPlusBrowser(true)}
                                        >
                                            <Trophy className="h-3.5 w-3.5" />
                                            <span>FIFA+</span>
                                        </Button>
                                    </div>

                                    {showIPTVBrowser && (
                                        <div className="fixed inset-0 z-[100] bg-background/80 backdrop-blur-sm animate-in fade-in duration-200">
                                            <div className="fixed inset-4 z-[101] bg-slate-950 rounded-2xl border border-white/10 shadow-2xl overflow-hidden flex flex-col">
                                                <div className="h-12 border-b border-white/5 flex items-center justify-between px-4 bg-slate-900/50">
                                                    <div className="flex items-center gap-2">
                                                        <Monitor className="h-4 w-4 text-primary" />
                                                        <span className="text-sm font-bold uppercase tracking-wider">IPTV Channel Browser</span>
                                                    </div>
                                                    <Button variant="ghost" size="icon" className="h-8 w-8 text-slate-400 hover:text-white" onClick={() => setShowIPTVBrowser(false)}>
                                                        <X size={18} />
                                                    </Button>
                                                </div>
                                                <div className="flex-1 min-h-0">
                                                    <IPTVChannelBrowser />
                                                </div>
                                            </div>
                                        </div>
                                    )}

                                    {showFIFAPlusBrowser && (
                                        <div className="fixed inset-0 z-[100] bg-background/80 backdrop-blur-sm animate-in fade-in duration-200">
                                            <div className="fixed inset-4 z-[101] bg-slate-950 rounded-2xl border border-white/10 shadow-2xl overflow-hidden flex flex-col">
                                                <div className="h-12 border-b border-white/5 flex items-center justify-between px-4 bg-slate-900/50">
                                                    <div className="flex items-center gap-2">
                                                        <Trophy className="h-4 w-4 text-primary" />
                                                        <span className="text-sm font-bold uppercase tracking-wider">FIFA+ Digital Browser</span>
                                                    </div>
                                                    <Button variant="ghost" size="icon" className="h-8 w-8 text-slate-400 hover:text-white" onClick={() => setShowFIFAPlusBrowser(false)}>
                                                        <X size={18} />
                                                    </Button>
                                                </div>
                                                <div className="flex-1 min-h-0">
                                                    <FIFAPlusBrowser />
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            ) : useVideoMode ? (
                                <div className="relative w-full h-full">
                                    <AnnotatedVideoPlayer
                                        videoFile={videoFile}
                                        videoUrl={remoteVideoUrl}
                                        events={events}
                                        onTimeUpdate={setVideoTime}
                                        seekTo={seekTime}
                                        isPlaying={isVideoPlaying}
                                        onPlayPause={(playing) => {
                                            setIsVideoPlaying(playing);
                                            // Sync Restriction: Only Admin broadcasts playback state
                                            if (socket && userRole === 'admin') {
                                                if (playing) {
                                                    socket.emit('video-play', videoTime);
                                                } else {
                                                    socket.emit('video-pause', videoTime);
                                                }
                                            }
                                        }}
                                        onSeekComplete={() => setSeekTime(null)}
                                        onSeek={(time) => {
                                            setSeekTime(time); // Update local first
                                            // Sync Restriction: Only Admin broadcasts seek
                                            if (socket && userRole === 'admin') {
                                                socket.emit('video-seek', time);
                                            }
                                        }}
                                        axes={axes}
                                        buttons={buttons}
                                        teams={teams}
                                        selectedTeam={selectedTeam}
                                        teamNames={teamNames}
                                        onPlayerSelect={handlePlayerSelect}
                                        trackingData={analysisResults}
                                        quickSelectorState={quickSelectorState}
                                        timelineVariant={isEditingMode ? 'pro' : 'minimal'}
                                        showLiveToasts={showFeed}
                                        analysisMode={trackingMode}
                                        isEditMode={isEditMode}
                                        layoutConfig={layoutConfig}
                                        onToggleVisibility={toggleComponentVisibility}
                                    />

                                    {/* --- NEW: THIRDS ZONE INDICATOR OVERLAY --- */}
                                    {(thirdsZone.previewZone !== null || thirdsZone.activeThird !== 'MIDFIELD') && (
                                        <div className="absolute bottom-16 left-1/2 -translate-x-1/2 z-[51] pointer-events-none animate-in fade-in slide-in-from-bottom-2 duration-300">
                                            <ZoneIndicator thirdsZone={thirdsZone} />
                                        </div>
                                    )}
                                    {userRole === 'admin' && (
                                        <Button
                                            variant="secondary"
                                            size="sm"
                                            className="absolute top-4 right-4 z-[100] gap-2 bg-slate-900/90 hover:bg-slate-800 text-white border border-white/20 backdrop-blur-md shadow-2xl transition-all"
                                            onClick={() => {
                                                setUseVideoMode(false);
                                                setVideoFile(null);
                                                setVideoMode('upload');
                                                socket?.emit('video-mode-sync', { mode: 'upload', useVideoMode: false });
                                            }}
                                        >
                                            <Upload className="h-4 w-4" /> Change Source
                                        </Button>
                                    )}
                                </div>
                            ) : (
                                <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/40 backdrop-blur-sm z-50">
                                    <div className="bg-card/90 p-6 rounded-xl border border-border/50 shadow-2xl flex flex-col items-center gap-4 max-w-md w-full animate-in zoom-in-95 duration-200">
                                        <div className="text-center space-y-1">
                                            <h3 className="text-lg font-bold text-foreground tracking-tight">Media Source</h3>
                                            <p className="text-[11px] text-muted-foreground">Select a video source to begin the analysis session.</p>
                                        </div>

                                        <Tabs defaultValue="upload" className="w-full">
                                            <TabsList className="grid w-full grid-cols-2">
                                                <TabsTrigger value="upload" className="text-xs">Upload Video</TabsTrigger>
                                                <TabsTrigger value="live" className="text-xs" disabled={!hasPermission('dashboard.live.stream.view')}>Live Stream</TabsTrigger>
                                            </TabsList>

                                            <TabsContent value="upload" className="mt-4">
                                                {userRole === 'admin' || userRole === 'operational_analyst' ? (
                                                    <div className="bg-muted/20 border-2 border-dashed border-muted-foreground/10 rounded-lg p-4 hover:bg-muted/30 transition-colors">
                                                        <VideoUpload
                                                            onVideoUpload={async (file) => {
                                                                setVideoFile(file);
                                                                setUseVideoMode(true);
                                                                setVideoMode('upload');
                                                                const formData = new FormData();
                                                                formData.append('video', file);
                                                                try {
                                                                    const response = await fetch(`${API_BASE_URL}/api/upload-video`, { method: 'POST', body: formData });

                                                                    // Check content type to avoid JSON parse errors on HTML responses
                                                                    const contentType = response.headers.get("content-type");
                                                                    if (!contentType || !contentType.includes("application/json")) {
                                                                        throw new Error("Server returned non-JSON response (likely a 500/404 error page)");
                                                                    }

                                                                    const data = await response.json();
                                                                    if (data.success) {
                                                                        setServerVideoPath(data.filePath); // SAVE SERVER PATH
                                                                        socket?.emit('video-loaded', data.videoUrl);
                                                                        socket?.emit('video-mode-sync', { mode: 'upload', useVideoMode: true });

                                                                        // Trigger Waiting Room if in Collab Mode
                                                                        if (sessionMode === 'collab') {
                                                                            setShowAdminWaitingRoom(true);
                                                                        }
                                                                        toast.success("Video uploaded successfully");
                                                                    } else {
                                                                        throw new Error(data.error || "Upload failed");
                                                                    }
                                                                } catch (e: any) {
                                                                    console.error("Upload error:", e);
                                                                    toast.error(`Upload failed: ${e.message}`);
                                                                }
                                                            }}
                                                            currentVideo={videoFile}
                                                            onClearVideo={() => {
                                                                setVideoFile(null);
                                                                setUseVideoMode(false);
                                                                setServerVideoPath(null);
                                                            }}
                                                        />
                                                    </div>
                                                ) : (
                                                    <div className="flex flex-col items-center justify-center p-8 text-center bg-muted/10 rounded-lg border border-border/20">
                                                        <Activity className="h-8 w-8 text-muted-foreground mb-3 animate-pulse" />
                                                        <p className="text-sm font-medium">Waiting for Host</p>
                                                        <p className="text-[10px] text-muted-foreground mt-1">The session host will upload the analysis video.</p>
                                                        <p className="text-[9px] text-muted-foreground/50 mt-4 uppercase tracking-widest">
                                                            Your Role: {userRole || 'Guest'}
                                                        </p>
                                                    </div>
                                                )}
                                            </TabsContent>

                                            <TabsContent value="live" className="mt-4 space-y-3">
                                                <div className="bg-muted/20 border border-border/50 rounded-lg p-6 flex flex-col items-center gap-3 text-center">
                                                    <div className="h-10 w-10 rounded-full bg-red-500/10 flex items-center justify-center">
                                                        <Radio className="h-5 w-5 text-red-500 animate-pulse" />
                                                    </div>
                                                    <div className="space-y-1">
                                                        <h4 className="text-sm font-semibold">Live Broadcast</h4>
                                                        <p className="text-[10px] text-muted-foreground">Connect to the secured IPTV feed for real-time analysis.</p>
                                                    </div>

                                                    {userRole === 'admin' ? (
                                                        <Button
                                                            className="w-full mt-2 gap-2"
                                                            variant="default"
                                                            onClick={() => {
                                                                setVideoMode('live');
                                                                setUseVideoMode(true);
                                                                socket?.emit('video-mode-sync', { mode: 'live', useVideoMode: true });

                                                                // Trigger Waiting Room if in Collab Mode
                                                                if (sessionMode === 'collab') {
                                                                    setShowAdminWaitingRoom(true);
                                                                }
                                                            }}
                                                        >
                                                            <Monitor className="h-4 w-4" />
                                                            Launch Player
                                                        </Button>
                                                    ) : (
                                                        <div className="w-full mt-2 p-3 bg-slate-950/50 rounded flex items-center justify-center gap-2">
                                                            <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
                                                            <span className="text-[10px] text-muted-foreground">Waiting for Live Stream...</span>
                                                        </div>
                                                    )}
                                                </div>
                                            </TabsContent>
                                        </Tabs>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </DashboardWidget>

                <div className="h-10 shrink-0 flex items-center justify-between px-2 bg-card/50 rounded-lg border border-border/50">
                    <div className="flex items-center gap-4">
                        <Button variant="ghost" size="sm" className="h-7 gap-1.5 transition-colors text-muted-foreground hover:text-primary" onClick={togglePiP}>
                            <Monitor className="h-3.5 w-3.5" /> <span className="text-[10px] font-bold uppercase tracking-wider">Pop Out</span>
                        </Button>
                        <Button variant="ghost" size="sm" className="h-7 gap-1.5 transition-colors text-muted-foreground hover:text-primary" onClick={toggleWatchMatch}>
                            <Monitor className="h-3.5 w-3.5" /> <span className="text-[10px] font-bold uppercase tracking-wider">Watch</span>
                        </Button>
                    </div>
                </div>
            </div>

            {/* RIGHT COLUMN - Event Log / Logger Audit (Visible on LG+) */}
            {!isRightHidden && (
                <DashboardRightPanel
                    userRole={userRole}
                    isEditMode={isEditMode}
                    layoutConfig={layoutConfig}
                    toggleComponentVisibility={toggleComponentVisibility}
                    events={events}
                    setEvents={setEvents}
                    teams={teams}
                    selectedTeam={selectedTeam}
                    teamNames={teamNames}
                    onPlayerSelect={handlePlayerSelect}
                    trackingMode={trackingMode}
                    useVideoMode={useVideoMode}
                    videoFile={videoFile}
                    videoTime={videoTime}
                    lastEventButtonLabel={lastEventButtonLabel}
                />
            )}
        </div>
    );
};
</file>

<file path="src/components/dashboard/views/QAView.tsx">
import React from 'react';
import { ShieldCheck } from 'lucide-react';
import { ValidationSuite } from '@/components/ValidationSuite';
import { LoggedEvent } from '@/hooks/useGamepad';
import { TeamRoster } from '@/types/player';

interface QAViewProps {
    events: LoggedEvent[];
    videoFile: File | null;
    teamNames: { teamA: string; teamB: string };
    availablePlayers: { id: number; name: string }[];
    setEvents: React.Dispatch<React.SetStateAction<LoggedEvent[]>>;
    socket: any;
    setSeekTime: (time: number) => void;
    setTrackingMode: (mode: any) => void;
    setActiveView: (view: any) => void;
}

export const QAView: React.FC<QAViewProps> = ({
    events,
    videoFile,
    teamNames,
    availablePlayers,
    setEvents,
    socket,
    setSeekTime,
    setTrackingMode,
    setActiveView
}) => {
    return (
        <div className="flex-1 p-6 overflow-hidden flex flex-col">
            <div className="mb-4 flex items-center justify-between">
                <h2 className="text-xl font-bold uppercase tracking-wider text-primary flex items-center gap-2">
                    <ShieldCheck className="h-5 w-5" /> Validation Suite
                </h2>
            </div>
            <div className="flex-1 min-h-0 bg-card/40 backdrop-blur-xl rounded-xl border border-border/50 p-4 overflow-y-auto">
                <ValidationSuite
                    events={events}
                    videoFile={videoFile}
                    matchName={`${teamNames.teamA} vs ${teamNames.teamB}`}
                    availablePlayers={availablePlayers}
                    onUpdateEvent={(updated) => {
                        setEvents(prev => prev.map(e => e.id === updated.id ? updated : e));
                        socket?.emit('update-event', updated);
                    }}
                    onAddEvent={(newEvent) => {
                        setEvents(prev => [newEvent, ...prev].sort((a, b) => {
                            const timeA = a.videoTime ?? 0;
                            const timeB = b.videoTime ?? 0;
                            return timeB - timeA;
                        }));
                        socket?.emit('new-event', newEvent);
                    }}
                    onSeekToEvent={(time) => {
                        setSeekTime(time);
                        setTrackingMode('POST_MATCH');
                        setActiveView('dashboard');
                    }}
                />
            </div>
        </div>
    );
};
</file>

<file path="src/components/dashboard/views/SettingsView.tsx">
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { ButtonMappingConfig } from '@/components/ButtonMappingConfig';
import { LoggedEvent, GamepadButtonMapping } from '@/hooks/useGamepad';

interface SettingsViewProps {
    mappings: GamepadButtonMapping[];
    pressedButtons: number[];
    updateMapping: (index: number, eventName: string) => void;
    resetMappings: () => void;
    events: LoggedEvent[];
}

export const SettingsView: React.FC<SettingsViewProps> = ({
    mappings,
    pressedButtons,
    updateMapping,
    resetMappings,
    events
}) => {
    return (
        <div className="flex-1 p-8 grid grid-cols-1 lg:grid-cols-2 gap-8 overflow-y-auto">
            <Card className="bg-card/30 backdrop-blur-md">
                <CardHeader><CardTitle>Button Mappings</CardTitle></CardHeader>
                <CardContent>
                    <ButtonMappingConfig
                        mappings={mappings}
                        pressedButtons={pressedButtons}
                        onUpdateMapping={updateMapping}
                        onResetMappings={resetMappings}
                    />
                </CardContent>
            </Card>
            <Card className="bg-card/30 backdrop-blur-md">
                <CardHeader><CardTitle>System Log</CardTitle></CardHeader>
                <CardContent className="h-[400px] overflow-y-auto font-mono text-[10px]">
                    {events.map((e, idx) => (
                        <div key={idx} className="border-b border-border/50 py-1 flex justify-between">
                            <span>[{e.timestamp.split('T')[1].split('.')[0]}] {e.eventName}</span>
                            <span className="text-muted-foreground">{e.team}</span>
                        </div>
                    ))}
                </CardContent>
            </Card>
        </div>
    );
};
</file>

<file path="src/components/dashboard/views/TacticsView.tsx">
import React from 'react';
import { Activity } from 'lucide-react';
import { TacticalReview } from '@/components/analytics/TacticalReview';
import { LoggedEvent } from '@/hooks/useGamepad';
import { TeamRoster } from '@/types/player';

interface TacticsViewProps {
    events: LoggedEvent[];
    teamNames: { teamA: string; teamB: string };
    teamARoster: TeamRoster;
    teamBRoster: TeamRoster;
}

export const TacticsView: React.FC<TacticsViewProps> = ({
    events,
    teamNames,
    teamARoster,
    teamBRoster
}) => {
    return (
        <div className="flex-1 p-6 overflow-y-auto custom-scrollbar">
            <div className="mb-6 flex items-center justify-between">
                <h2 className="text-xl font-bold uppercase tracking-wider text-primary flex items-center gap-2">
                    <Activity className="h-5 w-5" /> Tactical Review
                </h2>
            </div>
            <TacticalReview
                events={events}
                teamNames={teamNames}
                teamARoster={teamARoster?.PlayerData || []}
                teamBRoster={teamBRoster?.PlayerData || []}
            />
        </div>
    );
};
</file>

<file path="src/components/dashboard/VisualGuide.tsx">
import React from 'react';
import Joyride, { Step, CallBackProps, STATUS } from 'react-joyride';

interface VisualGuideProps {
    run: boolean;
    onFinish: () => void;
}

export const VisualGuide: React.FC<VisualGuideProps> = ({ run, onFinish }) => {
    const steps: Step[] = [
        {
            target: 'body',
            placement: 'center',
            content: (
                <div className="text-left">
                    <h3 className="text-lg font-bold mb-2">Welcome to Tacta!</h3>
                    <p className="text-sm text-muted-foreground">
                        Let's take a quick tour of the dashboard to help you get started with soccer analysis.
                    </p>
                </div>
            ),
            disableBeacon: true,
        },
        {
            target: '#app-sidebar',
            content: (
                <div className="text-left">
                    <h3 className="text-sm font-bold mb-1 uppercase tracking-tight">Navigation</h3>
                    <p className="text-xs text-muted-foreground">
                        Quickly switch between the Dashboard, Analytics, QA Suite, and other specialized views.
                    </p>
                </div>
            ),
            placement: 'right',
        },
        {
            target: '#dashboard-header',
            content: (
                <div className="text-left">
                    <h3 className="text-sm font-bold mb-1 uppercase tracking-tight">Match Control</h3>
                    <p className="text-xs text-muted-foreground">
                        Switch between LIVE and POST-MATCH modes, control the match timer, and manage layout settings.
                    </p>
                </div>
            ),
            placement: 'bottom',
        },
        {
            target: '#left-tools',
            content: (
                <div className="text-left">
                    <h3 className="text-sm font-bold mb-1 uppercase tracking-tight">Team Tools</h3>
                    <p className="text-xs text-muted-foreground">
                        Upload team rosters, select active teams, and view controller/keyboard mappings for event tagging.
                    </p>
                </div>
            ),
            placement: 'right',
        },
        {
            target: '#main-video',
            content: (
                <div className="text-left">
                    <h3 className="text-sm font-bold mb-1 uppercase tracking-tight">Video & Media</h3>
                    <p className="text-xs text-muted-foreground">
                        Upload video files or connect to a live broadcast for analysis. This is your primary workspace.
                    </p>
                </div>
            ),
            placement: 'top',
        },
        {
            target: '#event-log',
            content: (
                <div className="text-left">
                    <h3 className="text-sm font-bold mb-1 uppercase tracking-tight">Event Log</h3>
                    <p className="text-xs text-muted-foreground">
                        All tagged events appear here in real-time. You can undo, edit, or flag missed events.
                    </p>
                </div>
            ),
            placement: 'left',
        },
        {
            target: '#predictor-stats',
            content: (
                <div className="text-left">
                    <h3 className="text-sm font-bold mb-1 uppercase tracking-tight">Sequence Assistant</h3>
                    <p className="text-xs text-muted-foreground">
                        AI-powered predictions for the next likely event to help you tag faster and more accurately.
                    </p>
                </div>
            ),
            placement: 'left',
        },
        {
            target: '#help-button',
            content: (
                <div className="text-left">
                    <h3 className="text-sm font-bold mb-1 uppercase tracking-tight">Need Help?</h3>
                    <p className="text-xs text-muted-foreground">
                        You can restart this tour anytime by clicking the help icon in the header.
                    </p>
                </div>
            ),
            placement: 'bottom',
        },
    ];

    const handleJoyrideCallback = (data: CallBackProps) => {
        const { status } = data;
        if ([STATUS.FINISHED, STATUS.SKIPPED].includes(status as any)) {
            onFinish();
        }
    };

    return (
        <Joyride
            steps={steps}
            run={run}
            continuous
            showProgress
            showSkipButton
            callback={handleJoyrideCallback}
            styles={{
                options: {
                    zIndex: 10000,
                    primaryColor: '#16a34a', // matches Tailwind's green-600
                    backgroundColor: '#0f172a', // matches slate-900
                    textColor: '#f8fafc', // matches slate-50
                    arrowColor: '#0f172a',
                },
                tooltipContainer: {
                    textAlign: 'left',
                },
                buttonBack: {
                    marginRight: 10,
                    color: '#94a3b8', // slate-400
                },
                buttonNext: {
                    fontSize: '12px',
                    fontWeight: 'bold',
                    textTransform: 'uppercase',
                    letterSpacing: '0.05em',
                    padding: '8px 16px',
                    borderRadius: '6px'
                },
                buttonSkip: {
                    fontSize: '12px',
                    color: '#94a3b8'
                }
            }}
        />
    );
};
</file>

<file path="src/components/ErrorBoundary.tsx">
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Button } from '@/components/ui/button';
import { AlertTriangle, RefreshCw, Home } from 'lucide-react';

interface Props {
    children: ReactNode;
}

interface State {
    hasError: boolean;
    error: Error | null;
    errorInfo: ErrorInfo | null;
}

export class ErrorBoundary extends Component<Props, State> {
    public state: State = {
        hasError: false,
        error: null,
        errorInfo: null
    };

    public static getDerivedStateFromError(error: Error): State {
        return { hasError: true, error, errorInfo: null };
    }

    public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.error('Uncaught error:', error, errorInfo);
        this.setState({ errorInfo });
    }

    private handleReset = () => {
        localStorage.removeItem('tacta_user');
        localStorage.removeItem('tacta_token');
        window.location.href = '/login';
    };

    public render() {
        if (this.state.hasError) {
            return (
                <div className="min-h-screen w-full flex items-center justify-center bg-background p-4 animate-in fade-in duration-300">
                    <div className="max-w-md w-full bg-card border border-destructive/20 rounded-xl shadow-2xl overflow-hidden">
                        <div className="p-6 flex flex-col items-center text-center space-y-4">
                            <div className="h-16 w-16 bg-destructive/10 rounded-full flex items-center justify-center mb-2">
                                <AlertTriangle className="h-8 w-8 text-destructive" />
                            </div>

                            <h2 className="text-xl font-bold text-foreground">Something went wrong</h2>

                            <p className="text-sm text-muted-foreground">
                                The application encountered an unexpected error. We've logged this issue.
                            </p>

                            {this.state.error && (
                                <div className="w-full bg-muted/50 p-3 rounded-md overflow-auto text-xs font-mono text-left max-h-32 border border-border/50">
                                    <p className="text-destructive font-semibold mb-1">{this.state.error.toString()}</p>
                                    {this.state.errorInfo && (
                                        <pre className="text-muted-foreground opacity-70 whitespace-pre-wrap">
                                            {this.state.errorInfo.componentStack}
                                        </pre>
                                    )}
                                </div>
                            )}

                            <div className="flex w-full gap-2 pt-2">
                                <Button
                                    variant="outline"
                                    className="flex-1 gap-2 border-primary/20 hover:bg-primary/5"
                                    onClick={() => window.location.reload()}
                                >
                                    <RefreshCw className="h-4 w-4" />
                                    Reload Page
                                </Button>
                                <Button
                                    variant="default"
                                    className="flex-1 gap-2"
                                    onClick={this.handleReset}
                                >
                                    <Home className="h-4 w-4" />
                                    Reset & Login
                                </Button>
                            </div>
                        </div>

                        <div className="bg-muted/30 p-3 border-t border-border/50 text-[10px] text-center text-muted-foreground">
                            Error ID: {Date.now().toString(36)} ‚Ä¢ Session: {localStorage.getItem('tacta_user') ? 'Active' : 'Guest'}
                        </div>
                    </div>
                </div>
            );
        }

        return this.props.children;
    }
}
</file>

<file path="src/components/EventLog.tsx">
import { LoggedEvent } from "@/hooks/useGamepad";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Trophy,
  ArrowRight,
  Crosshair,
  AlertTriangle,
  Flag,
  RefreshCw,
  AlertOctagon,
  CornerUpRight,
  Activity,
  Users,
  Undo2,
  Clock,
  MapPin,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { useAuth } from "@/contexts/AuthContext";
import { PlusCircle, Info } from "lucide-react";
import { useEffect, useState, useRef } from "react";
import { cn } from "@/lib/utils";

// -------------------------------------------
// ICON LOGIC
// -------------------------------------------
const getEventIcon = (name: string) => {
  const t = name.toLowerCase();
  if (t.includes("goal")) return Trophy;
  if (t.includes("pass")) return ArrowRight;
  if (t.includes("shot")) return Crosshair;
  if (t.includes("foul")) return AlertTriangle;
  if (t.includes("offside")) return Flag;
  if (t.includes("sub")) return RefreshCw;
  if (t.includes("penalty")) return AlertOctagon;
  if (t.includes("corner")) return CornerUpRight;
  return Activity;
};

// -------------------------------------------
// COMPONENT
// -------------------------------------------
interface EventLogProps {
  events: LoggedEvent[];
  teamNames?: { teamA: string, teamB: string };
  onUndoEvent?: (id: number) => void;
  onMissedEvent?: () => void;
  onToggleDelay?: (id: number) => void;
  onEventClick?: (event: LoggedEvent) => void;
  editingEventId?: number | null;
}

export const EventLog = ({
  events,
  teamNames,
  onUndoEvent,
  onMissedEvent,
  onToggleDelay,
  onEventClick,
  editingEventId
}: EventLogProps) => {
  const { user } = useAuth();
  const [now, setNow] = useState(Date.now());
  const scrollRef = useRef<HTMLDivElement>(null);
  const isLogger = user?.role === 'logger' || user?.role === 'admin';
  const recentEvents = [...events].reverse().slice(0, 30);

  // Auto-scroll to top (since we reverse)
  useEffect(() => {
    if (scrollRef.current) {
      const scrollContainer = scrollRef.current.querySelector('[data-radix-scroll-area-viewport]');
      if (scrollContainer) {
        scrollContainer.scrollTop = 0;
      }
    }
  }, [events]);

  // Live timer refresh
  useEffect(() => {
    const i = setInterval(() => setNow(Date.now()), 1000);
    return () => clearInterval(i);
  }, []);

  return (
    <Card className="h-full flex flex-col border-none bg-transparent shadow-none">
      {/* HEADER */}
      <div className="flex items-center justify-between p-4 pb-2">
        <h3 className="text-lg font-bold flex items-center gap-2">
          <Activity className="w-5 h-5 text-primary animate-pulse" />
          <span className="tracking-tight">Match Feed</span>
        </h3>

        <div className="flex gap-3 text-xs font-semibold">
          <span className="flex items-center gap-1">
            <div className="w-2.5 h-2.5 rounded-full bg-primary animate-pulse"></div>
            {teamNames?.teamA ?? "Team A"}
          </span>
        </div>
      </div>

      {/* Logger Quick Actions */}
      {isLogger && (
        <div className="px-4 pb-2 flex gap-2">
          <Button
            variant="outline"
            size="sm"
            className="flex-1 h-8 gap-2 border-orange-500/30 text-orange-600 hover:bg-orange-500/10 text-[10px] font-bold uppercase tracking-wider"
            onClick={() => {
              if (onMissedEvent) onMissedEvent();
            }}
          >
            <PlusCircle className="w-3.5 h-3.5" />
            Missed Event
          </Button>
          <Button
            variant="outline"
            size="sm"
            className="flex-1 h-8 gap-2 border-blue-500/30 text-blue-600 hover:bg-blue-500/10 text-[10px] font-bold uppercase tracking-wider"
            onClick={() => {
              // Info or secondary action
            }}
          >
            <Info className="w-3.5 h-3.5" />
            Audit Note
          </Button>
        </div>
      )}

      {/* FEED */}
      <ScrollArea className="flex-1 px-4" ref={scrollRef}>
        <div className="relative space-y-4 py-4 pl-5">

          {/* Vertical Timeline */}
          <div className="absolute left-3 top-4 bottom-4 w-[3px] bg-gradient-to-b from-primary/20 via-border to-destructive/20 rounded-full" />

          {recentEvents.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground text-sm italic">
              Match hasn't started yet.
              <br />
              Waiting for events‚Ä¶
            </div>
          ) : (
            recentEvents.map((event, index) => {
              const Icon = getEventIcon(event.eventName || "");
              const isA = event.team === "TEAM_A";
              const accentColor = isA ? "bg-primary" : "bg-destructive";
              const timeDiff = now - new Date(event.timestamp).getTime();
              const canUndo = timeDiff < 10000 && !event.isCalculated;

              return (
                <div
                  key={`${event.id}-${index}`}
                  className={cn(
                    "relative flex gap-4 group transition-all animate-in fade-in slide-in-from-left-4 duration-300"
                  )}
                >
                  {/* TIMELINE DOT */}
                  <div
                    className={cn(
                      "absolute left-0 mt-2 w-3.5 h-3.5 rounded-full border-2 border-background shadow-lg z-10 transition-transform group-hover:scale-125",
                      accentColor
                    )}
                  />

                  {/* EVENT CARD */}
                  <div
                    className={cn(
                      "flex-1 rounded-xl border border-border/50 bg-card/40 backdrop-blur-md p-3 shadow-sm transition-all duration-300",
                      "hover:shadow-md hover:bg-card/60 group/card relative overflow-hidden",
                      editingEventId === event.id && "ring-2 ring-yellow-400 bg-yellow-400/5"
                    )}
                    onClick={() => onEventClick?.(event)}
                  >
                    {/* Accent Line */}
                    <div className={cn("absolute top-0 left-0 w-1 h-full opacity-30 group-hover/card:opacity-100 transition-opacity", accentColor)} />

                    {/* Top Row */}
                    <div className="flex justify-between items-start">
                      <div className="flex items-center gap-2">
                        <div
                          className={cn(
                            "p-1.5 rounded-lg shadow-sm text-white",
                            accentColor
                          )}
                        >
                          <Icon className="w-3.5 h-3.5" />
                        </div>
                        <span className="font-bold text-xs uppercase tracking-tight">
                          {event.eventName}
                        </span>
                      </div>

                      <span className="text-xs font-mono text-muted-foreground flex items-center gap-1">
                        <Clock className="w-3 h-3" />
                        {event.matchTime || "00:00"}
                      </span>
                    </div>

                    {event.isPendingZone && (
                      <div className="flex items-center gap-1.5 mt-1 text-amber-500 animate-pulse">
                        <MapPin className="w-3 h-3" />
                        <span className="text-[9px] font-bold uppercase tracking-wider">Awaiting Zone</span>
                      </div>
                    )}

                    {/* Bottom Row */}
                    <div className="flex justify-between items-end mt-3">
                      <div>
                        {event.player ? (
                          <div className="flex items-center gap-2 text-xs font-medium">
                            <div className="w-6 h-6 rounded-full bg-muted flex items-center justify-center font-semibold shadow-inner">
                              {event.player.name.charAt(0)}
                            </div>
                            {event.player.name}
                          </div>
                        ) : (
                          <span className="text-xs text-muted-foreground italic">
                            No player assigned
                          </span>
                        )}
                      </div>

                      {isLogger && !event.isCalculated && (
                        <Button
                          variant="ghost"
                          size="icon"
                          className={cn(
                            "h-7 w-7 transition-all ml-1",
                            event.isDelayed ? "text-orange-500 bg-orange-500/10" : "text-muted-foreground hover:text-blue-500 hover:bg-blue-500/10"
                          )}
                          title="Mark as Delayed"
                          onClick={(e) => {
                            e.stopPropagation();
                            if (onToggleDelay) onToggleDelay(event.id);
                          }}
                        >
                          <Clock className="w-3.5 h-3.5" />
                        </Button>
                      )}

                      {canUndo && onUndoEvent && (
                        <Button
                          variant="ghost"
                          size="icon"
                          className="h-7 w-7 text-muted-foreground hover:text-destructive hover:bg-destructive/10 transition-all"
                          onClick={() => onUndoEvent(event.id)}
                        >
                          <Undo2 className="w-3.5 h-3.5" />
                        </Button>
                      )}
                    </div>
                  </div>
                </div>
              );
            })
          )}
        </div>
      </ScrollArea>
    </Card>
  );
};
</file>

<file path="src/components/EventMappingReference.tsx">
import React, { useState, useEffect } from 'react';
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
    Tooltip,
    TooltipContent,
    TooltipProvider,
    TooltipTrigger,
} from "@/components/ui/tooltip";
import {
    Gamepad2, Keyboard, ChevronDown, ChevronUp,
    Zap, Edit2, Save, RotateCcw, X, HelpCircle, Cpu, Eye
} from 'lucide-react';

// Event Definition Type - Enhanced with documentation
export interface EventMapping {
    category: string;
    eventName: string;
    description: string;
    live: { controller: string | null; keyboard: string | null };
    postMatch: { controller: string | null; keyboard: string | null };
    whenToTag?: string;
    commonErrors?: string;
    isAI?: boolean; // AI-calculated event
}

// ============================================================================
// COMPREHENSIVE EVENT DEFINITIONS FROM SOCCER TACTICAL EVENT TAGGING GUIDE
// ============================================================================

const DEFAULT_EVENTS: EventMapping[] = [
    // =========================================================================
    // PART 1: REAL-TIME (LIVE) EVENTS - Controller-Triggered
    // =========================================================================

    // 1.1 POSSESSION EVENTS
    {
        category: 'Possession',
        eventName: 'pass_start',
        description: 'Pass Attempt',
        live: { controller: 'A', keyboard: null },
        postMatch: { controller: 'A', keyboard: '1' },
        whenToTag: 'Exact moment player makes contact with ball to initiate pass',
        commonErrors: 'Tagging too early (before contact) or too late (ball already traveling)'
    },
    {
        category: 'Possession',
        eventName: 'shot_start',
        description: 'Shot Attempt',
        live: { controller: 'B', keyboard: null },
        postMatch: { controller: 'B', keyboard: '2' },
        whenToTag: 'Player strikes ball toward goal - tag on contact, don\'t wait for outcome'
    },
    {
        category: 'Possession',
        eventName: 'cross_start',
        description: 'Cross/Long Ball',
        live: { controller: 'B+RT', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Player delivers ball into penalty area or launches long aerial pass'
    },
    {
        category: 'Possession',
        eventName: 'switch_of_play',
        description: 'Switch of Play',
        live: { controller: 'D-Left', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Long lateral pass changing point of attack (>30m typically)'
    },

    // 1.2 DRIBBLING & CARRIES
    {
        category: 'Dribbling',
        eventName: 'dribble_attempt',
        description: 'Dribble Attempt',
        live: { controller: 'X', keyboard: null },
        postMatch: { controller: 'X', keyboard: '3' },
        whenToTag: 'Player attempts to beat opponent 1v1 with ball at feet'
    },
    {
        category: 'Dribbling',
        eventName: 'carry_start',
        description: 'Ball Carry Start',
        live: { controller: 'X (Hold)', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Player begins advancing with ball over distance (>5m)'
    },

    // 1.3 DEFENSIVE ACTIONS
    {
        category: 'Defense',
        eventName: 'tackle',
        description: 'Tackle',
        live: { controller: 'X', keyboard: null },
        postMatch: { controller: null, keyboard: '4' },
        whenToTag: 'Defender attempts to win ball through physical challenge'
    },
    {
        category: 'Defense',
        eventName: 'interception',
        description: 'Interception',
        live: { controller: 'RB', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Defender reads and cuts out pass without direct duel'
    },
    {
        category: 'Defense',
        eventName: 'clearance',
        description: 'Clearance',
        live: { controller: 'RB+RT', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Defender urgently kicks/heads ball away from danger'
    },
    {
        category: 'Defense',
        eventName: 'duel_aerial',
        description: 'Aerial Duel',
        live: { controller: 'Y+A', keyboard: null },
        postMatch: { controller: null, keyboard: '5' },
        whenToTag: 'Two players contest for ball in the air - tag at moment of jump'
    },
    {
        category: 'Defense',
        eventName: 'duel_ground',
        description: 'Ground Duel',
        live: { controller: 'X+RT', keyboard: null },
        postMatch: { controller: null, keyboard: '4' },
        whenToTag: '50-50 ball contest between two players'
    },
    {
        category: 'Defense',
        eventName: 'turnover',
        description: 'Loss of Possession',
        live: { controller: 'LB', keyboard: null },
        postMatch: { controller: 'LB', keyboard: null },
        whenToTag: 'Team loses control of the ball to opponent'
    },

    // 1.4 TACTICAL PHASE TRIGGERS
    {
        category: 'Phases',
        eventName: 'pressing_trigger',
        description: 'Pressing Trigger',
        live: { controller: 'D-Up', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Team initiates organized pressing sequence - multiple players moving toward ball',
        commonErrors: 'This is a tactical judgment call requiring experienced analyst'
    },
    {
        category: 'Phases',
        eventName: 'press_trap',
        description: 'Pressing Trap',
        live: { controller: 'L3', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Coordinated trap forcing opponent into pressure zone'
    },
    {
        category: 'Phases',
        eventName: 'phase_highpress',
        description: 'High Press Phase',
        live: { controller: 'D-Up (Hold)', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Team pushes entire defensive line high (above halfway)'
    },
    {
        category: 'Phases',
        eventName: 'final_third_entry',
        description: 'Final Third Entry',
        live: { controller: 'D-Right', keyboard: null },
        postMatch: { controller: null, keyboard: 'E' },
        whenToTag: 'Ball enters attacking third (roughly 35m from goal)'
    },

    // 1.5 TRANSITIONS
    {
        category: 'Transitions',
        eventName: 'transition_off_start',
        description: 'Offensive Transition',
        live: { controller: 'RT', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Team wins ball and immediately attacks - within 2-3 seconds of regaining possession'
    },
    {
        category: 'Transitions',
        eventName: 'transition_def_start',
        description: 'Defensive Transition',
        live: { controller: 'LT', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Team loses ball and shifts to defensive organization'
    },
    {
        category: 'Transitions',
        eventName: 'counter_attack',
        description: 'Counter Attack',
        live: { controller: 'Y', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Fast break with numbers up - ball won in own half, quick forward progression'
    },

    // 1.6 SET PIECES
    {
        category: 'Set Pieces',
        eventName: 'corner_start',
        description: 'Corner Kick',
        live: { controller: 'View', keyboard: 'Space' },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Corner awarded and taken'
    },
    {
        category: 'Set Pieces',
        eventName: 'free_kick',
        description: 'Free Kick',
        live: { controller: 'View+RT', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Free kick in dangerous position (attacking third)'
    },
    {
        category: 'Set Pieces',
        eventName: 'penalty',
        description: 'Penalty',
        live: { controller: 'View+LB', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Penalty awarded - always tag, critical match event'
    },
    {
        category: 'Set Pieces',
        eventName: 'throw_in_tactical',
        description: 'Tactical Throw-In',
        live: { controller: 'View+RB', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Throw-in in final third or organized long-throw routine'
    },

    // 1.7 REFEREE EVENTS
    {
        category: 'Referee',
        eventName: 'foul',
        description: 'Foul Committed',
        live: { controller: 'View', keyboard: 'ArrowUp' },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Referee blows whistle for infringement'
    },
    {
        category: 'Referee',
        eventName: 'card_yellow',
        description: 'Yellow Card',
        live: { controller: 'View+Y', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Referee shows yellow card - always tag, impacts tactical decisions'
    },
    {
        category: 'Referee',
        eventName: 'card_red',
        description: 'Red Card',
        live: { controller: 'View+B', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Referee shows red card - game-changing event, always tag'
    },
    {
        category: 'Referee',
        eventName: 'offside',
        description: 'Offside',
        live: { controller: 'View+A', keyboard: 'ArrowDown' },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Linesman/referee flags offside - AI can verify with tracking data later'
    },
    {
        category: 'Referee',
        eventName: 'injury_stoppage',
        description: 'Injury/Stoppage',
        live: { controller: 'Menu', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Player down requiring medical attention'
    },

    // 1.8 DANGER MOMENTS
    {
        category: 'Danger',
        eventName: 'dangerous_attack',
        description: 'Dangerous Attack',
        live: { controller: 'R3', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Sustained pressure in final third - 3+ touches in box, 2+ shots, or clear chance'
    },
    {
        category: 'Danger',
        eventName: 'big_chance',
        description: 'Big Chance',
        live: { controller: 'R3+RT', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Clear 1v1 with keeper or open goal opportunity'
    },

    // 1.9 WORKFLOW EVENTS
    {
        category: 'Workflow',
        eventName: 'tag_start',
        description: 'Generic Tag Start',
        live: { controller: 'Menu', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Beginning of sequence analyst wants to mark for post-analysis'
    },
    {
        category: 'Workflow',
        eventName: 'analyst_note',
        description: 'Analyst Note',
        live: { controller: 'Menu+LB', keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Quick notation for detailed review - tactical change, injury concern, etc.'
    },

    // =========================================================================
    // PART 2: POST-MATCH EVENTS - Keyboard/AI-Assisted
    // =========================================================================

    // 2.1 REFINED POSSESSION ANALYSIS
    {
        category: 'Possession',
        eventName: 'pass_end',
        description: 'Pass Completion',
        live: { controller: null, keyboard: null },
        postMatch: { controller: 'A (2nd)', keyboard: '1' },
        whenToTag: 'Frame-by-frame to moment ball reaches receiver'
    },
    {
        category: 'Possession',
        eventName: 'pass_type',
        description: 'Pass Type',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Short (<10m), Medium (10-25m), Long (>25m), Through Ball, Switch, Cross, Cutback',
        isAI: true
    },
    {
        category: 'Possession',
        eventName: 'key_pass',
        description: 'Key Pass',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'Shift+1' },
        whenToTag: 'Pass immediately preceding shot attempt'
    },
    {
        category: 'Possession',
        eventName: 'assist',
        description: 'Assist',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'Ctrl+1' },
        whenToTag: 'Pass directly leading to goal - confirm goal scored first'
    },
    {
        category: 'Possession',
        eventName: 'pre_assist',
        description: 'Pre-Assist',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'Alt+1' },
        whenToTag: 'Pass immediately before assist - identifies deeper playmaking'
    },
    {
        category: 'Possession',
        eventName: 'progressive_pass',
        description: 'Progressive Pass',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Pass moving ball significantly closer to goal (own half >30m, opp half >10m)',
        isAI: true
    },
    {
        category: 'Possession',
        eventName: 'line_breaking',
        description: 'Line-Breaking Pass',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Pass bypassing opponent defensive line',
        isAI: true
    },

    // 2.2 SHOT ANALYSIS
    {
        category: 'Shots',
        eventName: 'shot_outcome',
        description: 'Shot Outcome',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: '2' },
        whenToTag: 'On Target, Off Target, Blocked, Woodwork'
    },
    {
        category: 'Shots',
        eventName: 'goal',
        description: 'Goal Scored',
        live: { controller: null, keyboard: null },
        postMatch: { controller: 'RB', keyboard: 'Shift+2' },
        whenToTag: 'Ball fully crosses goal line'
    },
    {
        category: 'Shots',
        eventName: 'xg_value',
        description: 'Expected Goals (xG)',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Algorithm considers distance, angle, body part, assist type, pressure',
        isAI: true
    },
    {
        category: 'Shots',
        eventName: 'psxg_value',
        description: 'Post-Shot xG',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'xG adjusted for shot placement quality - velocity, placement, GK position',
        isAI: true
    },
    {
        category: 'Shots',
        eventName: 'xt_value',
        description: 'Expected Threat (xT)',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Value added by moving ball between zones - probability increase of scoring',
        isAI: true
    },

    // 2.3 DRIBBLING SUCCESS/FAILURE
    {
        category: 'Dribbling',
        eventName: 'dribble_success',
        description: 'Dribble Success',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: '3' },
        whenToTag: 'Player successfully beats opponent 1v1 - maintains possession, advances beyond defender'
    },
    {
        category: 'Dribbling',
        eventName: 'dribble_fail',
        description: 'Dribble Failure',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'Shift+3' },
        whenToTag: 'Opponent wins ball or forces backward pass'
    },
    {
        category: 'Dribbling',
        eventName: 'progressive_carry',
        description: 'Progressive Carry',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Player carries ball significantly forward (>5m toward goal)',
        isAI: true
    },

    // 2.4 DEFENSIVE METRICS
    {
        category: 'Defense',
        eventName: 'ppda',
        description: 'PPDA',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Passes Allowed Per Defensive Action - measures pressing intensity',
        isAI: true
    },
    {
        category: 'Defense',
        eventName: 'defensive_line_height',
        description: 'Defensive Line Height',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Average Y-coordinate of back 4/5 - distance from own goal in meters',
        isAI: true
    },
    {
        category: 'Defense',
        eventName: 'compactness',
        description: 'Team Compactness',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Average distance between all players - vertical and horizontal',
        isAI: true
    },
    {
        category: 'Defense',
        eventName: 'pressing_success',
        description: 'Pressing Success',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'P' },
        whenToTag: 'Pressing sequence resulting in ball recovery within 7s and 40m'
    },
    {
        category: 'Defense',
        eventName: 'pressing_fail',
        description: 'Pressing Failure',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'Shift+P' },
        whenToTag: 'Pressing attempt allowing opponent to progress'
    },
    {
        category: 'Defense',
        eventName: 'counter_press_success',
        description: 'Counter-Press Success',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Ball won within 5 seconds and 20m of losing possession',
        isAI: true
    },

    // 2.5 TACTICAL PHASES (DETAILED)
    {
        category: 'Phases',
        eventName: 'phase_buildup_end',
        description: 'Build-Up Phase End',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'Q' },
        whenToTag: 'End of possession sequence from GK/back line - ball enters middle third or lost'
    },
    {
        category: 'Phases',
        eventName: 'phase_consolidation',
        description: 'Consolidation Phase',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'W' },
        whenToTag: 'Team recycles possession without progression - 5+ passes in middle third'
    },
    {
        category: 'Phases',
        eventName: 'phase_progression',
        description: 'Progression Phase',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Active movement of ball toward final third - 3+ progressive actions',
        isAI: true
    },
    {
        category: 'Phases',
        eventName: 'phase_midblock',
        description: 'Mid Block',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'M' },
        whenToTag: 'Defensive line at ~40m from own goal, compacting central areas'
    },
    {
        category: 'Phases',
        eventName: 'phase_lowblock',
        description: 'Low Block',
        live: { controller: 'D-Down', keyboard: null },
        postMatch: { controller: null, keyboard: 'L' },
        whenToTag: 'Defensive line at <30m from own goal, players behind ball'
    },

    // 2.6 TRANSITION METRICS
    {
        category: 'Transitions',
        eventName: 'transition_speed',
        description: 'Transition Speed',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Time from winning ball to shot/final third - Fast <5s, Medium 5-10s, Slow >10s',
        isAI: true
    },
    {
        category: 'Transitions',
        eventName: 'transition_success_rate',
        description: 'Transition Success Rate',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: '(Successful transitions / Total transitions) √ó 100',
        isAI: true
    },

    // 2.7 SET PIECE ANALYSIS
    {
        category: 'Set Pieces',
        eventName: 'corner_type',
        description: 'Corner Type',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Short, Inswinger, Outswinger, Driven Low, Floated'
    },
    {
        category: 'Set Pieces',
        eventName: 'free_kick_type',
        description: 'Free Kick Type',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Direct Shot, Cross, Short, Lay-off'
    },
    {
        category: 'Set Pieces',
        eventName: 'set_piece_routine',
        description: 'Set Piece Routine',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Catalog team\'s set piece variations - movements, decoys, targets'
    },

    // 2.8 PLAYER TRACKING METRICS
    {
        category: 'Tracking',
        eventName: 'player_xy',
        description: 'Player XY Coords',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'X,Y coordinates per player per frame (25-30 FPS)',
        isAI: true
    },
    {
        category: 'Tracking',
        eventName: 'ball_xy',
        description: 'Ball XY Coords',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'X,Y coordinates of ball per frame with speed',
        isAI: true
    },
    {
        category: 'Tracking',
        eventName: 'player_speed',
        description: 'Player Speed',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Instantaneous, average, maximum, and speed zones',
        isAI: true
    },
    {
        category: 'Tracking',
        eventName: 'sprint_count',
        description: 'Sprint Count',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Movement >25 km/h for >1 second',
        isAI: true
    },
    {
        category: 'Tracking',
        eventName: 'distance_covered',
        description: 'Distance Covered',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Total, by speed zone, with/without ball, attacking/defending',
        isAI: true
    },
    {
        category: 'Tracking',
        eventName: 'heatmap',
        description: 'Heatmap',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Visual positioning representation - individual, team, phase-specific',
        isAI: true
    },
    {
        category: 'Tracking',
        eventName: 'formation_detection',
        description: 'Formation Detection',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Clustering player positions - can detect changes during match',
        isAI: true
    },

    // 2.9 OFF-BALL MOVEMENT
    {
        category: 'Off-Ball',
        eventName: 'off_ball_run',
        description: 'Off-Ball Run',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'O' },
        whenToTag: 'In Behind, Checking, Lateral, or Diagonal run creating space'
    },
    {
        category: 'Off-Ball',
        eventName: 'overlap',
        description: 'Overlap',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'Shift+O' },
        whenToTag: 'Wide player runs outside teammate with ball - creates 2v1'
    },
    {
        category: 'Off-Ball',
        eventName: 'underlap',
        description: 'Underlap',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'Alt+O' },
        whenToTag: 'Player runs inside teammate with ball - creates central overload'
    },
    {
        category: 'Off-Ball',
        eventName: 'third_man_run',
        description: 'Third Man Run',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'T' },
        whenToTag: 'Player makes run as 3rd man after 1-2 pass (A‚ÜíB, C runs beyond)'
    },

    // 2.10 SPACE CREATION
    {
        category: 'Off-Ball',
        eventName: 'half_space_occupation',
        description: 'Half-Space Occupation',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Time spent in corridors between center and wing',
        isAI: true
    },
    {
        category: 'Off-Ball',
        eventName: 'dummy_run',
        description: 'Dummy Run',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'D' },
        whenToTag: 'Run designed to pull defender, not receive ball - creates space for teammate'
    },

    // 2.11 QUALITY CONTROL & VALIDATION
    {
        category: 'Workflow',
        eventName: 'ai_suggestion',
        description: 'AI Suggestion',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'AI proposes event during automated analysis - flagged for human verification',
        isAI: true
    },
    {
        category: 'Workflow',
        eventName: 'ai_accept',
        description: 'AI Accept',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'Enter' },
        whenToTag: 'Analyst confirms AI correctly identified event'
    },
    {
        category: 'Workflow',
        eventName: 'ai_reject',
        description: 'AI Reject',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'Backspace' },
        whenToTag: 'Analyst corrects false positive - optionally recode correct event'
    },
    {
        category: 'Workflow',
        eventName: 'timestamp_fix',
        description: 'Timestamp Correction',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'F' },
        whenToTag: 'Navigate frame-by-frame to correct real-time tag timing'
    },

    // 2.12 OUTCOME & PERFORMANCE
    {
        category: 'Performance',
        eventName: 'chance_created',
        description: 'Chance Created',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'C' },
        whenToTag: 'Action directly leading to shot - key pass, cross to header, creating shot'
    },
    {
        category: 'Performance',
        eventName: 'overload_created',
        description: 'Overload Created',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Creating numerical advantage in zone (2v1, 3v2)'
    },
    {
        category: 'Performance',
        eventName: 'dangerous_recovery',
        description: 'Dangerous Recovery',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Ball won in position leading to immediate danger'
    },

    // 2.13 SPECIALIZED TACTICAL
    {
        category: 'Tactical',
        eventName: 'pressing_resistance',
        description: 'Pressing Resistance',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: 'R' },
        whenToTag: 'Successfully playing through opponent\'s press - facing 3+ pressers, maintaining possession'
    },
    {
        category: 'Tactical',
        eventName: 'rest_defense',
        description: 'Rest Defense',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Players not involved in attack maintaining defensive shape'
    },
    {
        category: 'Tactical',
        eventName: 'positional_rotation',
        description: 'Positional Rotation',
        live: { controller: null, keyboard: null },
        postMatch: { controller: null, keyboard: null },
        whenToTag: 'Two players switching positions during play - creates confusion'
    },
];

const STORAGE_KEY = 'tacta_custom_mappings_v2';
const CATEGORIES = [
    'All',
    'Possession',
    'Shots',
    'Dribbling',
    'Defense',
    'Phases',
    'Transitions',
    'Set Pieces',
    'Referee',
    'Danger',
    'Workflow',
    'Off-Ball',
    'Tracking',
    'Performance',
    'Tactical'
];

// Helper to load custom mappings from localStorage
export const loadCustomMappings = (): EventMapping[] => {
    try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
            return JSON.parse(stored);
        }
    } catch (e) {
        console.error('Failed to load custom mappings:', e);
    }
    return DEFAULT_EVENTS;
};

// Helper to save custom mappings to localStorage
const saveCustomMappings = (mappings: EventMapping[]) => {
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(mappings));
    } catch (e) {
        console.error('Failed to save custom mappings:', e);
    }
};

interface EventMappingReferenceProps {
    mode?: 'LIVE' | 'POST_MATCH' | 'ALL';
    compact?: boolean;
}

export const EventMappingReference: React.FC<EventMappingReferenceProps> = ({
    mode = 'ALL',
    compact = false
}) => {
    const [selectedCategory, setSelectedCategory] = useState('All');
    const [isExpanded, setIsExpanded] = useState(!compact);
    const [isEditing, setIsEditing] = useState(false);
    const [events, setEvents] = useState<EventMapping[]>(DEFAULT_EVENTS);
    const [editedEvents, setEditedEvents] = useState<EventMapping[]>([]);
    const [showAI, setShowAI] = useState(true);

    // Load custom mappings on mount
    useEffect(() => {
        const loaded = loadCustomMappings();
        setEvents(loaded);
        setEditedEvents(JSON.parse(JSON.stringify(loaded)));
    }, []);

    const filteredEvents = events.filter(e => {
        if (selectedCategory !== 'All' && e.category !== selectedCategory) return false;
        if (!showAI && e.isAI) return false;
        if (mode === 'LIVE') {
            return e.live.controller || e.live.keyboard;
        }
        if (mode === 'POST_MATCH') {
            return e.postMatch.controller || e.postMatch.keyboard || e.isAI;
        }
        return true;
    });

    const handleStartEdit = () => {
        setEditedEvents(JSON.parse(JSON.stringify(events)));
        setIsEditing(true);
    };

    const handleCancelEdit = () => {
        setIsEditing(false);
        setEditedEvents([]);
    };

    const handleSave = () => {
        setEvents(editedEvents);
        saveCustomMappings(editedEvents);
        setIsEditing(false);
    };

    const handleReset = () => {
        setEvents(DEFAULT_EVENTS);
        setEditedEvents(DEFAULT_EVENTS);
        saveCustomMappings(DEFAULT_EVENTS);
        setIsEditing(false);
    };

    const updateMapping = (eventName: string, mode: 'live' | 'postMatch', field: 'controller' | 'keyboard', value: string) => {
        setEditedEvents(prev => prev.map(e => {
            if (e.eventName === eventName) {
                return {
                    ...e,
                    [mode]: {
                        ...e[mode],
                        [field]: value || null
                    }
                };
            }
            return e;
        }));
    };

    const renderMapping = (controller: string | null, keyboard: string | null, isAI?: boolean) => (
        <div className="flex items-center gap-1 flex-wrap">
            {isAI && (
                <Badge variant="outline" className="gap-1 text-[10px] bg-purple-500/10 border-purple-500/30">
                    <Cpu className="w-2.5 h-2.5" />
                    AI
                </Badge>
            )}
            {controller && (
                <Badge variant="outline" className="gap-1 text-[10px] bg-blue-500/10 border-blue-500/30">
                    <Gamepad2 className="w-2.5 h-2.5" />
                    {controller}
                </Badge>
            )}
            {keyboard && (
                <Badge variant="outline" className="gap-1 text-[10px] bg-green-500/10 border-green-500/30">
                    <Keyboard className="w-2.5 h-2.5" />
                    {keyboard}
                </Badge>
            )}
            {!controller && !keyboard && !isAI && (
                <span className="text-[10px] text-muted-foreground">‚Äî</span>
            )}
        </div>
    );

    const renderEditableMapping = (event: EventMapping, modeKey: 'live' | 'postMatch') => {
        const editEvent = editedEvents.find(e => e.eventName === event.eventName);
        if (!editEvent) return null;

        return (
            <div className="flex gap-1">
                <Input
                    placeholder="Btn"
                    value={editEvent[modeKey].controller || ''}
                    onChange={(e) => updateMapping(event.eventName, modeKey, 'controller', e.target.value)}
                    className="h-6 w-16 text-[10px] px-1"
                />
                <Input
                    placeholder="Key"
                    value={editEvent[modeKey].keyboard || ''}
                    onChange={(e) => updateMapping(event.eventName, modeKey, 'keyboard', e.target.value)}
                    className="h-6 w-16 text-[10px] px-1"
                />
            </div>
        );
    };

    if (compact && !isExpanded) {
        return (
            <Button
                variant="outline"
                size="sm"
                onClick={() => setIsExpanded(true)}
                className="w-full gap-2"
            >
                <ChevronDown className="w-4 h-4" />
                Show Event Mappings
            </Button>
        );
    }

    return (
        <TooltipProvider>
            <Card className="bg-zinc-950/80 border-zinc-800 p-4">
                <div className="flex items-center justify-between mb-4">
                    <h3 className="text-sm font-bold flex items-center gap-2">
                        <Zap className="w-4 h-4 text-primary" />
                        Event Mapping Reference
                        <Badge variant="secondary" className="text-[10px]">
                            {filteredEvents.length} events
                        </Badge>
                    </h3>
                    <div className="flex items-center gap-1">
                        <Button
                            variant={showAI ? "default" : "outline"}
                            size="sm"
                            onClick={() => setShowAI(!showAI)}
                            className="h-7 text-xs gap-1"
                            title="Toggle AI-calculated events"
                        >
                            <Cpu className="w-3 h-3" />
                            AI
                        </Button>
                        {!isEditing ? (
                            <Button variant="outline" size="sm" onClick={handleStartEdit} className="h-7 text-xs gap-1">
                                <Edit2 className="w-3 h-3" />
                                Edit
                            </Button>
                        ) : (
                            <>
                                <Button variant="default" size="sm" onClick={handleSave} className="h-7 text-xs gap-1">
                                    <Save className="w-3 h-3" />
                                    Save
                                </Button>
                                <Button variant="outline" size="sm" onClick={handleReset} className="h-7 text-xs gap-1">
                                    <RotateCcw className="w-3 h-3" />
                                    Reset
                                </Button>
                                <Button variant="ghost" size="sm" onClick={handleCancelEdit} className="h-7 text-xs">
                                    <X className="w-3 h-3" />
                                </Button>
                            </>
                        )}
                        {compact && (
                            <Button variant="ghost" size="sm" onClick={() => setIsExpanded(false)}>
                                <ChevronUp className="w-4 h-4" />
                            </Button>
                        )}
                    </div>
                </div>

                {/* Category Filter */}
                <div className="flex flex-wrap gap-1 mb-4">
                    {CATEGORIES.map(cat => (
                        <Badge
                            key={cat}
                            variant={selectedCategory === cat ? "default" : "outline"}
                            className="cursor-pointer text-[10px]"
                            onClick={() => setSelectedCategory(cat)}
                        >
                            {cat}
                        </Badge>
                    ))}
                </div>

                {/* Event Table */}
                <div className="space-y-1 max-h-96 overflow-y-auto custom-scrollbar">
                    <div className="grid grid-cols-12 gap-2 text-[10px] font-bold text-muted-foreground uppercase tracking-wider pb-1 border-b border-zinc-800 sticky top-0 bg-zinc-950 z-10">
                        <div className="col-span-3">Event</div>
                        <div className="col-span-3">Live Mode</div>
                        <div className="col-span-4">Post-Match</div>
                        <div className="col-span-2 text-right">Help</div>
                    </div>
                    {(isEditing ? editedEvents : filteredEvents).filter(e => {
                        if (selectedCategory !== 'All' && e.category !== selectedCategory) return false;
                        if (!showAI && e.isAI && !isEditing) return false;
                        return true;
                    }).map((event, idx) => (
                        <div
                            key={`${event.eventName}-${idx}`}
                            className="grid grid-cols-12 gap-2 py-1.5 border-b border-zinc-800/50 hover:bg-zinc-800/30"
                        >
                            <div className="col-span-3">
                                <div className="text-xs font-medium truncate flex items-center gap-1">
                                    {event.description}
                                    {event.isAI && (
                                        <Cpu className="w-3 h-3 text-purple-400" />
                                    )}
                                </div>
                                <div className="text-[9px] text-muted-foreground truncate">{event.eventName}</div>
                            </div>
                            <div className="col-span-3">
                                {isEditing
                                    ? renderEditableMapping(event, 'live')
                                    : renderMapping(event.live.controller, event.live.keyboard)
                                }
                            </div>
                            <div className="col-span-4">
                                {isEditing
                                    ? renderEditableMapping(event, 'postMatch')
                                    : renderMapping(event.postMatch.controller, event.postMatch.keyboard, event.isAI)
                                }
                            </div>
                            <div className="col-span-2 flex justify-end">
                                {event.whenToTag && (
                                    <Tooltip>
                                        <TooltipTrigger asChild>
                                            <Button variant="ghost" size="sm" className="h-6 w-6 p-0">
                                                <HelpCircle className="w-3 h-3 text-muted-foreground" />
                                            </Button>
                                        </TooltipTrigger>
                                        <TooltipContent side="left" className="max-w-xs">
                                            <p className="text-xs font-semibold mb-1">When to Tag:</p>
                                            <p className="text-xs text-muted-foreground">{event.whenToTag}</p>
                                            {event.commonErrors && (
                                                <>
                                                    <p className="text-xs font-semibold mt-2 text-yellow-400">‚ö† Common Errors:</p>
                                                    <p className="text-xs text-muted-foreground">{event.commonErrors}</p>
                                                </>
                                            )}
                                        </TooltipContent>
                                    </Tooltip>
                                )}
                            </div>
                        </div>
                    ))}
                </div>

                {/* Legend */}
                <div className="flex items-center gap-4 mt-4 pt-3 border-t border-zinc-800 text-[10px] text-muted-foreground">
                    <div className="flex items-center gap-1">
                        <Gamepad2 className="w-3 h-3 text-blue-400" />
                        <span>Controller</span>
                    </div>
                    <div className="flex items-center gap-1">
                        <Keyboard className="w-3 h-3 text-green-400" />
                        <span>Keyboard</span>
                    </div>
                    <div className="flex items-center gap-1">
                        <Cpu className="w-3 h-3 text-purple-400" />
                        <span>AI-Calculated</span>
                    </div>
                    <div className="flex items-center gap-1">
                        <HelpCircle className="w-3 h-3" />
                        <span>Hover for guidance</span>
                    </div>
                    {isEditing && (
                        <span className="ml-auto text-yellow-400">‚ö† Editing Mode</span>
                    )}
                </div>
            </Card>
        </TooltipProvider>
    );
};
</file>

<file path="src/components/FIFAPlus/FIFAPlusBrowser.tsx">
import React, { useState, useMemo } from 'react';
import { Search, Play, Calendar, Trophy, Globe, History, LayoutGrid, List, X, Info, ExternalLink } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { useMatchContext } from "@/contexts/MatchContext";
import { useAuth } from "@/contexts/AuthContext";
import { toast } from "sonner";
import { cn } from "@/lib/utils";

interface FIFAPlusEvent {
    id: string;
    title: string;
    subtitle: string;
    thumbnail: string;
    type: 'live' | 'archive' | 'highlight';
    date: string;
    streamUrl: string;
    category: string;
}

const MOCK_EVENTS: FIFAPlusEvent[] = [
    {
        id: '1',
        title: 'FIFA World Cup 2026 Qualifiers',
        subtitle: 'Argentina vs Brazil',
        thumbnail: 'https://images.fifa.com/image/upload/t_l1/v1700147648/fifacom/Qualifiers_2026.jpg',
        type: 'live',
        date: 'LIVE NOW',
        streamUrl: 'https://demo.unified-streaming.com/k8s/live/stable/sintel.isml/.m3u8',
        category: 'Qualifiers'
    },
    {
        id: '2',
        title: 'FIFA Club World Cup',
        subtitle: 'Manchester City vs Al Ahly',
        thumbnail: 'https://images.fifa.com/image/upload/t_l1/v1698765432/fifacom/CWC_2023.jpg',
        type: 'archive',
        date: '20 Dec 2023',
        streamUrl: 'https://bitdash-a.akamaihd.net/content/sintel/hls/playlist.m3u8',
        category: 'Club World Cup'
    },
    {
        id: '3',
        title: 'FIFA Women\'s World Cup',
        subtitle: 'Spain vs England - Final',
        thumbnail: 'https://images.fifa.com/image/upload/t_l1/v1692523456/fifacom/WWC_Final.jpg',
        type: 'archive',
        date: '20 Aug 2023',
        streamUrl: 'https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8',
        category: 'Women\'s World Cup'
    },
    {
        id: '4',
        title: 'U-17 World Cup Highlights',
        subtitle: 'Germany vs France',
        thumbnail: 'https://images.fifa.com/image/upload/t_l1/v1701543210/fifacom/U17_Final.jpg',
        type: 'highlight',
        date: '02 Dec 2023',
        streamUrl: 'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8',
        category: 'U-17 World Cup'
    }
];

export function FIFAPlusBrowser() {
    const { setStreamUrl, setVideoMode, setUseVideoMode } = useMatchContext();
    const { user } = useAuth();
    const [searchTerm, setSearchTerm] = useState('');
    const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
    const [filter, setFilter] = useState<'all' | 'live' | 'archive'>('all');

    const filteredEvents = useMemo(() => {
        return MOCK_EVENTS.filter(event => {
            const matchesSearch = event.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                event.subtitle.toLowerCase().includes(searchTerm.toLowerCase());
            const matchesFilter = filter === 'all' || event.type === filter;
            return matchesSearch && matchesFilter;
        });
    }, [searchTerm, filter]);

    const handleSelectEvent = (event: FIFAPlusEvent) => {
        if (user?.role === 'admin') {
            setStreamUrl(event.streamUrl);
            setVideoMode('fifaplus');
            setUseVideoMode(true);
            toast.success(`FIFA+ Selected: ${event.title} - ${event.subtitle}`);
        } else {
            toast.error('Only administrators can broadcast FIFA+ streams');
        }
    };

    return (
        <div className="flex flex-col h-full bg-slate-950 text-slate-100 overflow-hidden">
            {/* Header / Search */}
            <div className="p-6 border-b border-white/5 bg-slate-900/50 backdrop-blur-xl">
                <div className="flex flex-col md:flex-row md:items-center justify-between gap-6">
                    <div className="flex items-center gap-4">
                        <div className="p-3 bg-primary/20 rounded-2xl border border-primary/30">
                            <Trophy className="w-6 h-6 text-primary" />
                        </div>
                        <div>
                            <h2 className="text-xl font-bold tracking-tight">FIFA+ Source</h2>
                            <p className="text-xs text-slate-400 font-medium uppercase tracking-widest">Digital Content Archive</p>
                        </div>
                    </div>

                    <div className="flex items-center gap-3">
                        <div className="relative w-full md:w-80">
                            <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-500" />
                            <Input
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                                placeholder="Search events, matches, teams..."
                                className="bg-slate-800/50 border-white/10 pl-10 h-10 text-sm focus:ring-primary/20"
                            />
                        </div>
                        <div className="flex items-center bg-slate-800/40 rounded-lg p-1 border border-white/5">
                            <Button
                                variant="ghost"
                                size="icon"
                                className={cn("h-8 w-8", viewMode === 'grid' ? "bg-slate-700 text-white" : "text-slate-400")}
                                onClick={() => setViewMode('grid')}
                            >
                                <LayoutGrid className="w-4 h-4" />
                            </Button>
                            <Button
                                variant="ghost"
                                size="icon"
                                className={cn("h-8 w-8", viewMode === 'list' ? "bg-slate-700 text-white" : "text-slate-400")}
                                onClick={() => setViewMode('list')}
                            >
                                <List className="w-4 h-4" />
                            </Button>
                        </div>
                    </div>
                </div>

                <div className="flex items-center gap-2 mt-6 overflow-x-auto pb-2 no-scrollbar">
                    <Button
                        variant={filter === 'all' ? 'default' : 'outline'}
                        size="sm"
                        onClick={() => setFilter('all')}
                        className="rounded-full h-8 px-4 text-xs font-bold uppercase tracking-wider"
                    >
                        All Content
                    </Button>
                    <Button
                        variant={filter === 'live' ? 'default' : 'outline'}
                        size="sm"
                        onClick={() => setFilter('live')}
                        className="rounded-full h-8 px-4 text-xs font-bold uppercase tracking-wider gap-2"
                    >
                        <div className="w-1.5 h-1.5 rounded-full bg-red-500 animate-pulse" />
                        Live
                    </Button>
                    <Button
                        variant={filter === 'archive' ? 'default' : 'outline'}
                        size="sm"
                        onClick={() => setFilter('archive')}
                        className="rounded-full h-8 px-4 text-xs font-bold uppercase tracking-wider"
                    >
                        Full Matches
                    </Button>
                </div>
            </div>

            {/* Content Area */}
            <div className="flex-1 overflow-y-auto p-6 custom-scrollbar">
                {filteredEvents.length > 0 ? (
                    <div className={cn(
                        "grid gap-6",
                        viewMode === 'grid' ? "grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4" : "grid-cols-1"
                    )}>
                        {filteredEvents.map(event => (
                            <div
                                key={event.id}
                                className={cn(
                                    "group relative bg-slate-900/40 border border-white/5 rounded-2xl overflow-hidden transition-all hover:border-primary/50 hover:shadow-2xl hover:shadow-primary/10",
                                    viewMode === 'list' && "flex gap-6 h-48"
                                )}
                            >
                                {/* Thumbnail */}
                                <div className={cn(
                                    "relative overflow-hidden",
                                    viewMode === 'grid' ? "aspect-video" : "w-80 h-full"
                                )}>
                                    <img
                                        src={event.thumbnail}
                                        alt={event.title}
                                        className="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110"
                                    />
                                    <div className="absolute inset-0 bg-gradient-to-t from-slate-950 via-transparent to-transparent opacity-60" />

                                    {event.type === 'live' && (
                                        <Badge className="absolute top-3 left-3 bg-red-600 hover:bg-red-700 text-white border-none px-2 py-0.5 text-[10px] font-black italic">
                                            LIVE
                                        </Badge>
                                    )}

                                    <div className="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity bg-black/40 backdrop-blur-[2px]">
                                        <Button
                                            size="icon"
                                            className="h-14 w-14 rounded-full bg-primary hover:bg-primary/90 text-white shadow-xl scale-90 group-hover:scale-100 transition-transform"
                                            onClick={() => handleSelectEvent(event)}
                                        >
                                            <Play className="w-8 h-8 fill-current ml-1" />
                                        </Button>
                                    </div>
                                </div>

                                {/* Info */}
                                <div className="p-5 flex flex-col justify-between flex-1">
                                    <div>
                                        <div className="flex items-center gap-2 mb-2">
                                            <Badge variant="outline" className="text-[9px] border-white/10 text-slate-400 font-bold uppercase py-0 leading-none">
                                                {event.category}
                                            </Badge>
                                            <span className="text-[10px] text-slate-500 font-mono italic">{event.date}</span>
                                        </div>
                                        <h3 className="font-bold text-slate-100 group-hover:text-primary transition-colors leading-tight mb-1">
                                            {event.title}
                                        </h3>
                                        <p className="text-sm text-slate-400 font-medium">
                                            {event.subtitle}
                                        </p>
                                    </div>

                                    <div className="mt-4 flex items-center justify-between">
                                        <Button
                                            variant="ghost"
                                            size="sm"
                                            className="h-8 px-0 text-xs font-bold text-slate-500 hover:text-white transition-colors gap-2"
                                        >
                                            <Info className="w-3.5 h-3.5" />
                                            Details
                                        </Button>
                                        <Button
                                            variant="ghost"
                                            size="sm"
                                            className="h-8 group/link text-xs font-bold text-primary opacity-0 group-hover:opacity-100 transition-all gap-2"
                                            onClick={() => window.open(`https://www.fifa.com/fifaplus/en/watch/${event.id}`, '_blank')}
                                        >
                                            <ExternalLink className="w-3.5 h-3.5 transition-transform group-hover/link:-translate-y-0.5 group-hover/link:translate-x-0.5" />
                                            Watch on FIFA+
                                        </Button>
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                ) : (
                    <div className="flex flex-col items-center justify-center py-24 text-center">
                        <div className="w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center mb-6 border border-white/5">
                            <Search className="w-8 h-8 text-slate-700" />
                        </div>
                        <h3 className="text-xl font-bold text-white mb-2">No matching events found</h3>
                        <p className="text-slate-400 max-w-md mx-auto">
                            We couldn't find anything matching "{searchTerm}". Try checking your spelling or using more general terms.
                        </p>
                        <Button
                            variant="link"
                            className="mt-4 text-primary font-bold"
                            onClick={() => { setSearchTerm(''); setFilter('all'); }}
                        >
                            Reset Search
                        </Button>
                    </div>
                )}
            </div>

            {/* Footer / Disclaimer */}
            <div className="p-4 border-t border-white/5 bg-slate-900/30 flex items-center justify-between px-6">
                <div className="flex items-center gap-4 text-[10px] font-bold text-slate-500 uppercase tracking-widest leading-none">
                    <span className="flex items-center gap-1.5"><History className="w-3 h-3" /> Recent Activity</span>
                    <span className="flex items-center gap-1.5"><Globe className="w-3 h-3" /> International Feed</span>
                </div>
                <div className="text-[10px] text-slate-600 italic">
                    All trademarks belong to their respective owners.
                </div>
            </div>
        </div>
    );
}
</file>

<file path="src/components/Index/Header.tsx">
// src/components/Index/Header.tsx - Application header with timer and controls
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Mic, MicOff, Monitor, X, Wifi, WifiOff, Download, BarChart2, Zap } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';
import { useSocket as useSocketContext } from '@/contexts/SocketContext';
import { useMatchContext } from '@/contexts/MatchContext';
import { AnalysisMode } from '@/components/AnalysisModeSelector';
import { PostMatchAnalysisPanel } from '@/components/PostMatchAnalysisPanel';
import { EventMappingReference } from '@/components/EventMappingReference';
import {
    Dialog,
    DialogContent,
    DialogTrigger,
    DialogTitle,
} from "@/components/ui/dialog";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { MatchFeedPopover } from './MatchFeedPopover';
import { LoggedEvent } from "@/hooks/useGamepad";

interface HeaderProps {
    matchTime: number;
    formatTime: (seconds: number) => string;
    onToggleMatch: () => void;
    onToggleWatchMatch: () => void;
    onTogglePiP: () => void;
    videoStream: MediaStream | null;
    pipWindow: Window | null;
    voiceLanguage: 'en' | 'fr' | 'ar';
    onVoiceLanguageChange: (lang: 'en' | 'fr' | 'ar') => void;
    isListening: boolean;
    onToggleListening: () => void;
    isSupported: boolean;
    isBroadcasting: boolean;
    onStartAudioBroadcast: () => void;
    onStopAudioBroadcast: () => void;
    remoteAudioStream: MediaStream | null;
    trackingMode: AnalysisMode;
    setTrackingMode: (mode: AnalysisMode) => void;
    onAnalysisComplete: (results: any) => void;
    events: LoggedEvent[];
    teamNames: { teamA: string, teamB: string };
    onUndoEvent?: (eventId: number) => void;
    onEventClick?: (event: LoggedEvent) => void;
}

export function Header({
    matchTime,
    formatTime,
    onToggleMatch,
    onToggleWatchMatch,
    onTogglePiP,
    videoStream,
    pipWindow,
    voiceLanguage,
    onVoiceLanguageChange,
    isListening,
    onToggleListening,
    isSupported,
    isBroadcasting,
    onStartAudioBroadcast,
    onStopAudioBroadcast,
    remoteAudioStream,
    trackingMode,
    setTrackingMode,
    onAnalysisComplete,
    events,
    teamNames,
    onUndoEvent,
    onEventClick,
}: HeaderProps) {
    const { user } = useAuth();
    const { connected, role: socketRole } = useSocketContext();
    const { isMatchActive } = useMatchContext();
    const navigate = useNavigate();

    return (
        <div className={`border-b border-border p-2 md:p-4 bg-card relative z-10 transition-colors duration-300 ${videoStream ? 'bg-black/40 backdrop-blur-sm border-white/10 text-white' : ''}`}>
            <div className="max-w-7xl mx-auto flex flex-col md:flex-row items-start md:items-center justify-between gap-2 md:gap-4">
                {/* Title & Connection Status */}
                <div className="flex items-center gap-2 md:gap-4 w-full md:w-auto">
                    <h1 className="flex items-center gap-2">
                        <img src="/logo.png" alt="Tacta" className="h-8 md:h-10 w-auto object-contain" />
                    </h1>

                    <div className={`flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${connected ? 'bg-green-500/20 text-green-500' : 'bg-red-500/20 text-red-500'}`}>
                        {connected ? <Wifi className="w-3 h-3" /> : <WifiOff className="w-3 h-3" />}
                        <span className="hidden sm:inline">{connected ? 'Synced' : 'Offline'}</span>
                    </div>
                </div>

                {/* Match Timer */}
                <div className="flex items-center gap-2 md:gap-4 md:ml-8 md:border-l md:pl-8 w-full md:w-auto justify-between md:justify-start">
                    <div className="flex flex-col items-center">
                        <span className="text-2xl md:text-3xl font-mono font-bold tabular-nums text-primary">
                            {formatTime(matchTime)}
                        </span>
                        <span className="text-[10px] md:text-xs text-muted-foreground uppercase tracking-wider">Match Time</span>
                    </div>
                    <Button
                        variant={isMatchActive ? 'secondary' : 'default'}
                        size="sm"
                        onClick={onToggleMatch}
                        className="min-w-[80px] md:min-w-[120px] text-xs md:text-sm"
                    >
                        {isMatchActive ? 'Pause' : matchTime === 0 ? 'Start' : 'Resume'}
                    </Button>
                </div>

                {/* Analysis Mode & Controls - Centered or Near Title */}
                {(user?.role === 'admin' || user?.role === 'tactical_analyst' || user?.role === 'quality_controller') && (
                    <div className="flex items-center gap-4 border-l pl-4 ml-4">
                        <Tabs
                            value={trackingMode}
                            onValueChange={(val) => setTrackingMode(val as AnalysisMode)}
                            className="w-auto"
                        >
                            <TabsList className="grid w-full grid-cols-2 h-8">
                                <TabsTrigger value="LIVE" className="text-xs px-3">Live</TabsTrigger>
                                <TabsTrigger value="POST_MATCH" className="text-xs px-3">Post-Match</TabsTrigger>
                            </TabsList>
                        </Tabs>

                        {trackingMode === 'POST_MATCH' && (user?.role === 'admin' || user?.role === 'tactical_analyst') && (
                            <Dialog>
                                <DialogTrigger asChild>
                                    <Button size="sm" className="gap-2 h-8 text-xs bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white border-0 shadow-md">
                                        <span className="text-lg">‚ú®</span>
                                        New Analysis
                                    </Button>
                                </DialogTrigger>
                                <DialogContent className="max-w-4xl max-h-[85vh] overflow-y-auto">
                                    <DialogTitle>New Analysis</DialogTitle>
                                    <PostMatchAnalysisPanel
                                        onAnalysisComplete={(results) => {
                                            onAnalysisComplete(results);
                                            // Close dialog ideally, but for now just pass through
                                        }}
                                    />
                                </DialogContent>
                            </Dialog>
                        )}
                    </div>
                )}

                {/* Control Buttons */}
                <div className="flex flex-wrap items-center gap-1 md:gap-2 w-full md:w-auto">


                    <MatchFeedPopover
                        events={events}
                        teamNames={teamNames}
                        onUndoEvent={onUndoEvent}
                        onEventClick={onEventClick}
                    />

                    {/* Analytics Button */}
                    {(user?.role === 'admin' || user?.role === 'tactical_analyst') && (
                        <Button
                            variant="outline"
                            size="sm"
                            onClick={() => navigate('/analytics')}
                            className="gap-1 text-xs"
                            title="Go to Analytics Dashboard"
                        >
                            <BarChart2 className="h-3 w-3 md:h-4 md:w-4" />
                            <span className="hidden sm:inline">Analytics</span>
                        </Button>
                    )}

                    {/* Event Mapping Reference */}
                    {(user?.role === 'admin' || user?.role === 'operational_analyst') && (
                        <Dialog>
                            <DialogTrigger asChild>
                                <Button
                                    variant="outline"
                                    size="sm"
                                    className="gap-1 text-xs"
                                    title="View Event Mappings"
                                >
                                    <Zap className="h-3 w-3 md:h-4 md:w-4" />
                                    <span className="hidden sm:inline">Mappings</span>
                                </Button>
                            </DialogTrigger>
                            <DialogContent className="max-w-3xl max-h-[85vh] overflow-y-auto">
                                <DialogTitle>Event Mapping Reference</DialogTitle>
                                <EventMappingReference mode="ALL" compact={false} />
                            </DialogContent>
                        </Dialog>
                    )}

                    {/* Watch Match Button */}
                    <Button
                        variant={videoStream ? 'destructive' : 'secondary'}
                        size="sm"
                        onClick={onToggleWatchMatch}
                        className="gap-1 text-xs"
                        title={videoStream ? 'Stop Watching' : 'Watch Match (HUD Mode)'}
                    >
                        {videoStream ? <X className="h-3 w-3 md:h-4 md:w-4" /> : <Monitor className="h-3 w-3 md:h-4 md:w-4" />}
                        <span className="hidden sm:inline">{videoStream ? 'Stop Match' : 'Watch Match'}</span>
                    </Button>

                    {/* Audio Broadcast Button */}
                    {socketRole === 'broadcaster' && (
                        <Button
                            variant={isBroadcasting ? 'destructive' : 'outline'}
                            size="sm"
                            onClick={isBroadcasting ? onStopAudioBroadcast : onStartAudioBroadcast}
                            className="gap-1 text-xs"
                        >
                            {isBroadcasting ? <MicOff className="h-3 w-3 md:h-4 md:w-4 animate-pulse" /> : <Mic className="h-3 w-3 md:h-4 md:w-4" />}
                            <span className="hidden sm:inline">{isBroadcasting ? 'Broadcasting' : 'Broadcast Audio'}</span>
                        </Button>
                    )}

                    {socketRole === 'viewer' && remoteAudioStream && (
                        <div className="flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-green-500/20 text-green-500">
                            <Mic className="w-3 h-3 animate-pulse" />
                            <span className="hidden sm:inline">Receiving Audio</span>
                        </div>
                    )}

                    {/* Pop Out Button */}
                    <Button
                        variant="outline"
                        size="sm"
                        onClick={onTogglePiP}
                        className="gap-1 text-xs hidden md:flex"
                        title={pipWindow ? 'Restore to Tab' : 'Pop Out Window'}
                    >
                        <Download className="h-3 w-3 md:h-4 md:w-4 rotate-180" />
                        <span className="hidden lg:inline">{pipWindow ? 'Restore' : 'Pop Out'}</span>
                    </Button>

                    {/* Voice Controls */}
                    {isSupported && (
                        <div className="flex items-center gap-1 md:gap-2">
                            <Select value={voiceLanguage} onValueChange={onVoiceLanguageChange}>
                                <SelectTrigger className="w-[70px] md:w-[100px] h-8 md:h-9 text-xs">
                                    <SelectValue />
                                </SelectTrigger>
                                <SelectContent>
                                    <SelectItem value="en">English</SelectItem>
                                    <SelectItem value="fr">Fran√ßais</SelectItem>
                                    <SelectItem value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</SelectItem>
                                </SelectContent>
                            </Select>
                            <Button
                                variant={isListening ? 'destructive' : 'outline'}
                                size="sm"
                                onClick={onToggleListening}
                                className="gap-1 text-xs"
                            >
                                {isListening ? <MicOff className="h-3 w-3 md:h-4 md:w-4 animate-pulse" /> : <Mic className="h-3 w-3 md:h-4 md:w-4" />}
                                <span className="hidden sm:inline">{isListening ? 'Stop Voice' : 'Voice'}</span>
                            </Button>
                        </div>
                    )}
                </div>
            </div>
        </div >
    );
}
</file>

<file path="src/components/Index/LiveEventToast.tsx">
import { LoggedEvent } from "@/hooks/useGamepad";
import { useEffect, useState, useRef } from "react";
import { cn } from "@/lib/utils";
import { Trophy, ArrowRight, Crosshair, AlertTriangle, Flag, RefreshCw, AlertOctagon, CornerUpRight, Activity } from "lucide-react";

// -------------------------------------------
// ICON LOGIC
// -------------------------------------------
const getEventIcon = (name: string) => {
    const t = name.toLowerCase();
    if (t.includes("goal")) return Trophy;
    if (t.includes("pass")) return ArrowRight;
    if (t.includes("shot")) return Crosshair;
    if (t.includes("foul")) return AlertTriangle;
    if (t.includes("offside")) return Flag;
    if (t.includes("sub")) return RefreshCw;
    if (t.includes("penalty")) return AlertOctagon;
    if (t.includes("corner")) return CornerUpRight;
    return Activity;
};

interface LiveEventToastProps {
    events: LoggedEvent[];
}

export const LiveEventToast = ({ events }: LiveEventToastProps) => {
    const [activeToasts, setActiveToasts] = useState<LoggedEvent[]>([]);
    const lastEventIdRef = useRef<number | null>(null);

    useEffect(() => {
        if (events.length > 0) {
            const newestEvent = events[0];

            // Only add if it's a new event ID we haven't processed
            if (newestEvent.id !== lastEventIdRef.current) {
                lastEventIdRef.current = newestEvent.id;

                // Add to active toasts (limit to 3)
                setActiveToasts(prev => [newestEvent, ...prev].slice(0, 3));

                // Auto-dismiss after 5 seconds
                const timer = setTimeout(() => {
                    setActiveToasts(prev => prev.filter(e => e.id !== newestEvent.id));
                }, 5000);

                return () => clearTimeout(timer);
            }
        }
    }, [events]);

    if (activeToasts.length === 0) return null;

    return (
        <div className="fixed bottom-4 right-4 z-50 flex flex-col gap-2 pointer-events-none">
            {activeToasts.map((event, index) => {
                const Icon = getEventIcon(event.eventName);
                const isA = event.team === "TEAM_A";
                const colorClass = isA ? "border-l-primary" : "border-l-destructive";

                return (
                    <div
                        key={event.id}
                        className={cn(
                            "bg-background/95 backdrop-blur border border-border rounded-lg shadow-lg p-3 w-[280px]",
                            "border-l-4 transition-all duration-500 transform origin-bottom-right",
                            colorClass,
                            "animate-in slide-in-from-right-10 fade-in zoom-in-95"
                        )}
                    >
                        <div className="flex items-start justify-between">
                            <div className="flex items-center gap-2">
                                <Icon className="w-4 h-4" />
                                <span className="font-bold text-sm">{event.eventName}</span>
                            </div>
                            <span className="text-[10px] font-mono text-muted-foreground">{event.matchTime}</span>
                        </div>
                        {event.player && (
                            <div className="text-xs text-muted-foreground mt-1 ml-6">
                                {event.player.name}
                            </div>
                        )}
                    </div>
                );
            })}
        </div>
    );
};
</file>

<file path="src/components/Index/MatchFeedPopover.tsx">
import { LoggedEvent } from "@/hooks/useGamepad";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
    Trophy,
    ArrowRight,
    Crosshair,
    AlertTriangle,
    Flag,
    RefreshCw,
    AlertOctagon,
    CornerUpRight,
    Activity,
    Bell,
    Clock,
    Undo2
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { useEffect, useState, useRef } from "react";
import { cn } from "@/lib/utils";
import {
    Popover,
    PopoverContent,
    PopoverTrigger,
} from "@/components/ui/popover";

// -------------------------------------------
// ICON LOGIC (Reused)
// -------------------------------------------
const getEventIcon = (name: string) => {
    const t = name.toLowerCase();
    if (t.includes("goal")) return Trophy;
    if (t.includes("pass")) return ArrowRight;
    if (t.includes("shot")) return Crosshair;
    if (t.includes("foul")) return AlertTriangle;
    if (t.includes("offside")) return Flag;
    if (t.includes("sub")) return RefreshCw;
    if (t.includes("penalty")) return AlertOctagon;
    if (t.includes("corner")) return CornerUpRight;
    return Activity;
};

// -------------------------------------------
// COMPONENT
// -------------------------------------------
interface MatchFeedPopoverProps {
    events: LoggedEvent[];
    teamNames?: { teamA: string, teamB: string };
    onUndoEvent?: (eventId: number) => void;
    onEventClick?: (event: LoggedEvent) => void;
}

export const MatchFeedPopover = ({ events, teamNames, onUndoEvent, onEventClick }: MatchFeedPopoverProps) => {
    const recentEvents = [...events].slice(0, 50); // Limit to 50 for performance
    const [now, setNow] = useState(Date.now());
    const [isOpen, setIsOpen] = useState(false);
    const [hasNewEvents, setHasNewEvents] = useState(false);
    const lastEventIdRef = useRef<number | null>(null);

    // Live timer refresh
    useEffect(() => {
        const i = setInterval(() => setNow(Date.now()), 1000);
        return () => clearInterval(i);
    }, []);

    // Check for new events to show badge
    useEffect(() => {
        if (events.length > 0) {
            if (lastEventIdRef.current !== null && events[0].id !== lastEventIdRef.current) {
                if (!isOpen) setHasNewEvents(true);
            }
            lastEventIdRef.current = events[0].id;
        }
    }, [events, isOpen]);

    // Clear badge when opened
    useEffect(() => {
        if (isOpen) setHasNewEvents(false);
    }, [isOpen]);

    return (
        <Popover open={isOpen} onOpenChange={setIsOpen}>
            <PopoverTrigger asChild>
                <Button variant="outline" size="sm" className="gap-2 relative">
                    <Activity className="h-4 w-4" />
                    <span className="hidden md:inline">Feed</span>
                    {hasNewEvents && (
                        <span className="absolute -top-1 -right-1 flex h-3 w-3">
                            <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span>
                            <span className="relative inline-flex rounded-full h-3 w-3 bg-red-500"></span>
                        </span>
                    )}
                </Button>
            </PopoverTrigger>
            <PopoverContent className="w-[350px] p-0" align="end">
                <Card className="h-[500px] flex flex-col border-none bg-transparent shadow-none">
                    {/* HEADER */}
                    <div className="flex items-center justify-between p-4 pb-2 border-b">
                        <h3 className="text-sm font-bold flex items-center gap-2">
                            <Activity className="w-4 h-4 text-primary" />
                            <span>Match Feed</span>
                        </h3>

                        <div className="flex gap-3 text-[10px] font-semibold">
                            <span className="flex items-center gap-1">
                                <div className="w-2 h-2 rounded-full bg-primary"></div>
                                {teamNames?.teamA ?? "Team A"}
                            </span>
                            <span className="flex items-center gap-1">
                                <div className="w-2 h-2 rounded-full bg-destructive"></div>
                                {teamNames?.teamB ?? "Team B"}
                            </span>
                        </div>
                    </div>

                    {/* FEED */}
                    <ScrollArea className="flex-1">
                        <div className="relative space-y-4 p-4">

                            {/* Vertical Timeline */}
                            <div className="absolute left-7 top-4 bottom-4 w-[2px] bg-border" />

                            {recentEvents.length === 0 ? (
                                <div className="text-center py-8 text-muted-foreground text-xs italic">
                                    Waiting for events...
                                </div>
                            ) : (
                                recentEvents.map((event, index) => {
                                    const Icon = getEventIcon(event.eventName);
                                    const isA = event.team === "TEAM_A";
                                    const color = isA ? "bg-primary" : "bg-destructive";
                                    const timeDiff = now - new Date(event.timestamp).getTime();
                                    const canUndo = timeDiff < 10000 && !event.isCalculated;

                                    return (
                                        <div
                                            key={`${event.id}-${index}`}
                                            className="relative flex gap-3 group"
                                        >
                                            {/* TIMELINE DOT */}
                                            <div
                                                className={cn(
                                                    "absolute left-2.5 mt-1.5 w-2 h-2 rounded-full border border-background z-10",
                                                    color
                                                )}
                                            />

                                            {/* EVENT CARD */}
                                            <div
                                                className={cn(
                                                    "flex-1 rounded-lg border bg-card p-3 shadow-sm hover:bg-muted/50 transition-colors ml-6 text-sm",
                                                    "cursor-pointer"
                                                )}
                                                onClick={() => onEventClick?.(event)}
                                            >
                                                <div className="flex justify-between items-start mb-1">
                                                    <span className="font-semibold flex items-center gap-2">
                                                        <Icon className="w-3.5 h-3.5 opacity-70" />
                                                        {event.eventName}
                                                    </span>
                                                    <span className="text-[10px] font-mono text-muted-foreground">
                                                        {event.matchTime || "00:00"}
                                                    </span>
                                                </div>

                                                {(event.player || canUndo) && (
                                                    <div className="flex justify-between items-end mt-2">
                                                        {event.player ? (
                                                            <div className="text-xs text-muted-foreground flex items-center gap-1">
                                                                <span className={cn("w-1 h-3 rounded-full", color)}></span>
                                                                {event.player.name}
                                                            </div>
                                                        ) : <span></span>}

                                                        {canUndo && onUndoEvent && (
                                                            <Button
                                                                variant="ghost"
                                                                size="icon"
                                                                className="h-5 w-5 -mb-1 -mr-1 text-muted-foreground hover:text-destructive"
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    onUndoEvent(event.id);
                                                                }}
                                                            >
                                                                <Undo2 className="w-3 h-3" />
                                                            </Button>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })
                            )}
                        </div>
                    </ScrollArea>
                </Card>
            </PopoverContent>
        </Popover>
    );
};
</file>

<file path="src/components/Index/VideoBackground.tsx">
// src/components/Index/VideoBackground.tsx - HUD mode video background
import { RefObject } from 'react';

interface VideoBackgroundProps {
    videoRef: RefObject<HTMLVideoElement>;
    videoStream: MediaStream | null;
}

export function VideoBackground({ videoRef, videoStream }: VideoBackgroundProps) {
    if (!videoStream) return null;

    return (
        <video
            ref={videoRef}
            autoPlay
            playsInline
            muted
            className="absolute inset-0 w-full h-full object-cover z-0"
        />
    );
}
</file>

<file path="src/components/IPTV/index.ts">
export { IPTVVideoPlayer } from "./IPTVVideoPlayer";
export { IPTVChannelBrowser } from "./IPTVChannelBrowser";
export { IPTVChannelListItem } from "./IPTVChannelListItem";
export { IPTVChannelListPanel } from "./IPTVChannelListPanel";
export { IPTVVideoPlayerArea } from "./IPTVVideoPlayerArea";
export { IPTVCategoriesSidebar } from "./IPTVCategoriesSidebar";
export { IPTVMobileControls } from "./IPTVMobileControls";
export { IPTVLoginForm } from "./IPTVLoginForm";
</file>

<file path="src/components/IPTV/IPTVCategoriesSidebar.tsx">
import { Tv, ChevronLeft, ChevronRight } from "lucide-react";
import type { ChannelCategory } from "@/types/xtream";

interface IPTVCategoriesSidebarProps {
    categories: ChannelCategory[];
    selectedCategoryId: string;
    onCategorySelect: (categoryId: string) => void;
    isSidebarOpen: boolean;
    isMenuCollapsed: boolean;
    onToggleMenuCollapsed: () => void;
    totals: { totalStreams: number; totalCategories: number };
}

export const IPTVCategoriesSidebar = ({
    categories,
    selectedCategoryId,
    onCategorySelect,
    isSidebarOpen,
    isMenuCollapsed,
    onToggleMenuCollapsed,
    totals,
}: IPTVCategoriesSidebarProps) => {
    return (
        <aside
            className={`fixed lg:static inset-y-0 left-0 z-50 bg-slate-900/95 backdrop-blur-md border-r border-white/10 transition-all duration-300 ease-in-out shadow-2xl shadow-black/40 lg:shadow-none ${isSidebarOpen ? "translate-x-0" : "-translate-x-full lg:translate-x-0"
                } ${isMenuCollapsed ? "w-16" : "w-64"}`}
        >
            <div className="flex h-full flex-col">
                {/* Header */}
                <div className="flex items-center justify-between p-3 border-b border-white/10">
                    {!isMenuCollapsed && (
                        <div className="flex items-center gap-2">
                            <Tv className="h-5 w-5 text-blue-500" />
                            <span className="font-semibold text-white">IPTV</span>
                        </div>
                    )}
                    <button
                        onClick={onToggleMenuCollapsed}
                        className="rounded-md p-1.5 text-slate-400 hover:text-white transition-colors"
                        title={isMenuCollapsed ? "Expand menu" : "Collapse menu"}
                    >
                        {isMenuCollapsed ? (
                            <ChevronRight className="h-4 w-4" />
                        ) : (
                            <ChevronLeft className="h-4 w-4" />
                        )}
                    </button>
                </div>

                {/* Stats */}
                {!isMenuCollapsed && (
                    <div className="p-3 border-b border-white/10">
                        <div className="flex gap-4 text-xs text-slate-400">
                            <span>{totals.totalCategories} categories</span>
                            <span>{totals.totalStreams} channels</span>
                        </div>
                    </div>
                )}

                {/* Categories List */}
                <div className="flex-1 overflow-y-auto p-2 scrollbar-thin">
                    {categories.map((category) => (
                        <button
                            key={category.id}
                            onClick={() => onCategorySelect(category.id)}
                            className={`w-full rounded-md p-2 mb-1 text-left transition-all ${selectedCategoryId === category.id
                                    ? "bg-blue-600 text-white"
                                    : "text-slate-300 hover:bg-white/10 hover:text-white"
                                }`}
                            title={category.name}
                        >
                            {isMenuCollapsed ? (
                                <span className="text-xs font-bold">
                                    {category.name.charAt(0).toUpperCase()}
                                </span>
                            ) : (
                                <div className="flex items-center justify-between">
                                    <span className="text-sm font-medium truncate">
                                        {category.name}
                                    </span>
                                    <span className="text-xs text-slate-400">
                                        {category.streams.length}
                                    </span>
                                </div>
                            )}
                        </button>
                    ))}
                </div>
            </div>
        </aside>
    );
};
</file>

<file path="src/components/IPTV/IPTVChannelBrowser.tsx">
import { useMemo, useState, useCallback, useEffect } from "react";
import { AlertCircle, RefreshCw, Tv } from "lucide-react";
import { Button } from "@/components/ui/button";
import { IPTVVideoPlayerArea } from "./IPTVVideoPlayerArea";
import { IPTVCategoriesSidebar } from "./IPTVCategoriesSidebar";
import { IPTVChannelListPanel } from "./IPTVChannelListPanel";
import { IPTVMobileControls } from "./IPTVMobileControls";
import { useIPTVAuth } from "@/contexts/IPTVAuthContext";
import type { ChannelCategory, ChannelStream, IPTVCredentials } from "@/types/xtream";
import { useMatchContext } from "@/contexts/MatchContext";
import { useAuth } from "@/contexts/AuthContext";
import { toast } from "sonner";

const CACHE_KEY = "react-iptv-categories-cache";
const CACHE_DURATION = 5 * 60 * 1000;

interface CacheData {
    categories: ChannelCategory[];
    timestamp: number;
    credentialsHash: string;
}

import { API_BASE_URL } from "@/utils/apiConfig";

// Xtream API client functions
const buildXtreamUrl = (
    searchParams: Record<string, string | number>,
    credentials: IPTVCredentials
) => {
    const url = new URL(credentials.apiBase);
    const params = new URLSearchParams({
        username: credentials.username,
        password: credentials.password,
        ...Object.fromEntries(
            Object.entries(searchParams).map(([key, value]) => [key, String(value)])
        ),
    });
    url.search = params.toString();

    // Route through our proxy to avoid CORS
    const proxiedUrl = `${API_BASE_URL}/api/proxy?url=${encodeURIComponent(url.toString())}`;
    return proxiedUrl;
};

const normaliseStreams = (
    streams: any[],
    credentials: IPTVCredentials
): ChannelStream[] => {
    const baseUrl = new URL(credentials.apiBase);
    const origin = `${baseUrl.protocol}//${baseUrl.host}`;

    return streams
        .map((stream) => {
            const streamType = stream.stream_type?.toLowerCase() ?? "live";
            const extension = streamType === "live" ? "m3u8" : "mp4";
            const folder = streamType === "live" ? "live" : "movie";
            const streamUrl = `${origin}/${folder}/${credentials.username}/${credentials.password}/${stream.stream_id}.${extension}`;

            return {
                id: stream.stream_id,
                name: stream.name,
                streamType,
                streamIcon: stream.stream_icon ?? null,
                added: stream.added,
                streamUrl,
            };
        })
        .sort((a, b) =>
            a.name.localeCompare(b.name, "tr", { sensitivity: "base" })
        );
};

export function IPTVChannelBrowser() {
    const { credentials, isConfigured } = useIPTVAuth();
    const { setStreamUrl, setUseVideoMode, setVideoMode } = useMatchContext();
    const { user } = useAuth();
    const [categories, setCategories] = useState<ChannelCategory[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    const orderedCategories = useMemo(
        () =>
            [...categories].sort((a, b) =>
                a.name.localeCompare(b.name, "tr", { sensitivity: "base" })
            ),
        [categories]
    );

    const [selectedCategoryId, setSelectedCategoryId] = useState<string>(
        orderedCategories[0]?.id ?? ""
    );
    const [searchTerm, setSearchTerm] = useState("");
    const [showChannelFavorites, setShowChannelFavorites] = useState(false);
    const [selectedStream, setSelectedStream] = useState<ChannelStream | null>(
        null
    );
    const [isPlayerOpen, setIsPlayerOpen] = useState(false);
    const [isSidebarOpen, setIsSidebarOpen] = useState(false);
    const [isChannelListOpen, setIsChannelListOpen] = useState(false);
    const [isMenuCollapsed, setIsMenuCollapsed] = useState(false);
    const [isChannelPanelCollapsed, setIsChannelPanelCollapsed] = useState(false);

    const credentialsHash = useMemo(() => {
        if (!credentials) return "";
        return btoa(JSON.stringify(credentials)).slice(0, 16);
    }, [credentials]);

    const loadCategories = useCallback(
        async (forceRefresh = false) => {
            if (!credentials) {
                setIsLoading(false);
                return;
            }

            setIsLoading(true);
            setError(null);

            try {
                // Check cache first
                if (!forceRefresh) {
                    const cached = localStorage.getItem(CACHE_KEY);
                    if (cached) {
                        const cacheData: CacheData = JSON.parse(cached);
                        const isExpired = Date.now() - cacheData.timestamp > CACHE_DURATION;
                        const isSameCredentials =
                            cacheData.credentialsHash === credentialsHash;

                        if (
                            !isExpired &&
                            isSameCredentials &&
                            cacheData.categories.length > 0
                        ) {
                            setCategories(cacheData.categories);
                            if (cacheData.categories.length > 0 && !selectedCategoryId) {
                                setSelectedCategoryId(cacheData.categories[0].id);
                            }
                            setIsLoading(false);
                            return;
                        }
                    }
                }

                // 1. Fetch live categories
                const categoryUrl = buildXtreamUrl(
                    { action: "get_live_categories" },
                    credentials
                );

                // 2. Fetch all live streams at once (Much faster than sequential)
                const streamsUrl = buildXtreamUrl(
                    { action: "get_live_streams" },
                    credentials
                );

                console.log("üöÄ Optimizing IPTV loading: Fetching categories and all streams in parallel...");

                const [categoryResponse, streamsResponse] = await Promise.all([
                    fetch(categoryUrl),
                    fetch(streamsUrl)
                ]);

                if (!categoryResponse.ok || !streamsResponse.ok) {
                    throw new Error("Failed to fetch IPTV data");
                }

                const [rawCategories, rawStreams] = await Promise.all([
                    categoryResponse.json(),
                    streamsResponse.json()
                ]);

                console.log(`‚úÖ Fetched ${rawCategories.length} categories and ${rawStreams.length} streams`);

                // 3. Group streams by category_id for efficient lookup
                const streamsByCategory: Record<string, any[]> = {};
                rawStreams.forEach((stream: any) => {
                    const catId = stream.category_id;
                    if (!streamsByCategory[catId]) {
                        streamsByCategory[catId] = [];
                    }
                    streamsByCategory[catId].push(stream);
                });

                // 4. Create the final categories list
                const categoriesWithStreams: ChannelCategory[] = rawCategories
                    .map((category: any, index: number) => {
                        const streams = streamsByCategory[category.category_id] || [];
                        return {
                            id: category.category_id,
                            name: category.category_name,
                            parentId: category.parent_id,
                            order: Number.parseInt(category.category_id, 10) || index,
                            streams: normaliseStreams(streams, credentials),
                        };
                    })
                    .filter((cat: ChannelCategory) => cat.streams.length > 0);

                const sortedCategories = categoriesWithStreams.sort((a, b) =>
                    a.name.localeCompare(b.name, "tr", { sensitivity: "base" })
                );

                // Save to cache
                const cacheData: CacheData = {
                    categories: sortedCategories,
                    timestamp: Date.now(),
                    credentialsHash,
                };
                localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
                setCategories(sortedCategories);

                if (sortedCategories.length > 0 && !selectedCategoryId) {
                    setSelectedCategoryId(sortedCategories[0].id);
                }
            } catch (err) {
                setError(
                    err instanceof Error
                        ? err.message
                        : "Error loading categories"
                );
            } finally {
                setIsLoading(false);
            }
        },
        [credentials, selectedCategoryId, credentialsHash]
    );

    useEffect(() => {
        if (isConfigured && credentials) {
            loadCategories();
        } else {
            setIsLoading(false);
        }
    }, [loadCategories, isConfigured, credentials]);

    const toggleSidebar = useCallback(() => {
        setIsSidebarOpen((prev) => {
            const next = !prev;
            if (next) setIsChannelListOpen(false);
            return next;
        });
    }, []);

    const toggleChannelList = useCallback(() => {
        setIsChannelListOpen((prev) => {
            const next = !prev;
            if (next) setIsSidebarOpen(false);
            return next;
        });
    }, []);

    const selectedCategory = useMemo(() => {
        if (!selectedCategoryId) return orderedCategories[0];
        return (
            orderedCategories.find(
                (category) => category.id === selectedCategoryId
            ) ?? orderedCategories[0]
        );
    }, [orderedCategories, selectedCategoryId]);

    const activeStreamId = selectedStream?.id ?? null;
    const totals = useMemo(
        () => ({
            totalStreams: categories.reduce(
                (acc, category) => acc + category.streams.length,
                0
            ),
            totalCategories: categories.length,
        }),
        [categories]
    );

    const handlePlayStream = useCallback((stream: ChannelStream) => {
        setSelectedStream(stream);
        setIsPlayerOpen(true);
        setIsChannelListOpen(false);

        // Synchronize for all collaborative roles if user is admin
        if (user?.role === 'admin') {
            setStreamUrl(stream.streamUrl);
            setVideoMode('live');
            setUseVideoMode(true);
            toast.success(`Broadcasting channel: ${stream.name}`);
        }
    }, [user, setStreamUrl, setVideoMode, setUseVideoMode]);

    const handleClosePlayer = useCallback(() => {
        setIsPlayerOpen(false);
        setSelectedStream(null);
    }, []);

    if (!isConfigured) {
        return (
            <div className="flex h-full w-full items-center justify-center bg-slate-950">
                <div className="text-center max-w-md mx-4">
                    <div className="rounded-full bg-slate-500/20 p-6 mb-6 mx-auto w-fit">
                        <Tv className="h-12 w-12 text-slate-400" />
                    </div>
                    <h2 className="text-xl font-semibold text-white mb-4">
                        IPTV Not Configured
                    </h2>
                    <p className="text-slate-300 mb-6 leading-relaxed">
                        Please configure your IPTV service credentials to access channels.
                    </p>
                </div>
            </div>
        );
    }

    if (isLoading) {
        return (
            <div className="flex h-full w-full items-center justify-center bg-slate-950">
                <div className="text-center">
                    <div className="w-12 h-12 border-4 border-blue-500/30 border-t-blue-500 rounded-full animate-spin mx-auto mb-4" />
                    <p className="text-slate-400 mb-4">Loading IPTV data...</p>
                    <Button
                        variant="outline"
                        size="sm"
                        onClick={() => loadCategories(true)}
                        className="text-xs"
                    >
                        Force Retry
                    </Button>
                </div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="flex h-full w-full items-center justify-center bg-slate-950">
                <div className="text-center max-w-md mx-4">
                    <div className="rounded-full bg-red-500/20 p-6 mb-6 mx-auto w-fit">
                        <AlertCircle className="h-12 w-12 text-red-400" />
                    </div>
                    <h2 className="text-xl font-semibold text-white mb-4">
                        IPTV Data Failed to Load
                    </h2>
                    <p className="text-slate-300 mb-6 leading-relaxed">{error}</p>
                    <button
                        onClick={() => loadCategories(true)}
                        className="flex items-center gap-2 rounded-xl bg-blue-600 px-6 py-3 text-sm font-medium text-white hover:bg-blue-500 transition-colors mx-auto"
                    >
                        <RefreshCw className="h-4 w-4" />
                        Try Again
                    </button>
                </div>
            </div>
        );
    }

    if (categories.length === 0) {
        return (
            <div className="flex h-full w-full items-center justify-center bg-slate-950">
                <div className="text-center max-w-md mx-4">
                    <div className="rounded-full bg-slate-500/20 p-6 mb-6 mx-auto w-fit">
                        <Tv className="h-12 w-12 text-slate-400" />
                    </div>
                    <h2 className="text-xl font-semibold text-white mb-4">
                        No Categories Found
                    </h2>
                    <p className="text-slate-300 mb-6 leading-relaxed">
                        Your IPTV service doesn't have any categories or you don't have access.
                    </p>
                    <button
                        onClick={() => loadCategories(true)}
                        className="flex items-center gap-2 rounded-xl bg-blue-600 px-6 py-3 text-sm font-medium text-white hover:bg-blue-500 transition-colors mx-auto"
                    >
                        <RefreshCw className="h-4 w-4" />
                        Refresh
                    </button>
                </div>
            </div>
        );
    }

    return (
        <div className="flex h-full w-full flex-col bg-slate-950 lg:flex-row">
            <IPTVMobileControls
                isSidebarOpen={isSidebarOpen}
                onToggleSidebar={toggleSidebar}
                onToggleChannelList={toggleChannelList}
            />

            {/* Sidebar Overlay (Mobile) */}
            {(isSidebarOpen || isChannelListOpen) && (
                <div
                    className="fixed inset-0 z-40 bg-black/50 backdrop-blur-sm lg:hidden"
                    onClick={() => {
                        setIsSidebarOpen(false);
                        setIsChannelListOpen(false);
                    }}
                />
            )}

            <IPTVCategoriesSidebar
                categories={orderedCategories}
                selectedCategoryId={selectedCategoryId}
                onCategorySelect={(categoryId) => {
                    setSelectedCategoryId(categoryId);
                    setSearchTerm("");
                    setIsSidebarOpen(false);
                }}
                isSidebarOpen={isSidebarOpen}
                isMenuCollapsed={isMenuCollapsed}
                onToggleMenuCollapsed={() => setIsMenuCollapsed(!isMenuCollapsed)}
                totals={totals}
            />

            <IPTVChannelListPanel
                selectedCategory={selectedCategory}
                searchTerm={searchTerm}
                onSearchChange={setSearchTerm}
                showChannelFavorites={showChannelFavorites}
                onToggleChannelFavorites={() =>
                    setShowChannelFavorites(!showChannelFavorites)
                }
                isChannelPanelCollapsed={isChannelPanelCollapsed}
                onToggleChannelPanelCollapsed={() =>
                    setIsChannelPanelCollapsed(!isChannelPanelCollapsed)
                }
                onPlayStream={handlePlayStream}
                activeStreamId={activeStreamId}
            />

            <IPTVVideoPlayerArea
                selectedStream={selectedStream}
                isPlayerOpen={isPlayerOpen}
                onClosePlayer={handleClosePlayer}
            />
        </div>
    );
}
</file>

<file path="src/components/IPTV/IPTVChannelListItem.tsx">
import { useCallback, useState } from "react";
import { Play, ExternalLink, Heart, HeartOff } from "lucide-react";
import type { ChannelStream } from "@/types/xtream";

interface IPTVChannelListItemProps {
    stream: ChannelStream;
    onPlay: (stream: ChannelStream) => void;
    isFavorite: boolean;
    onToggleFavorite: () => void;
    isActive: boolean;
}

export const IPTVChannelListItem = ({
    stream,
    onPlay,
    isFavorite,
    onToggleFavorite,
    isActive,
}: IPTVChannelListItemProps) => {
    const [imageError, setImageError] = useState(false);
    const handlePlayClick = useCallback(() => onPlay(stream), [onPlay, stream]);

    const handleExternalClick = useCallback(
        (e: React.MouseEvent) => {
            e.stopPropagation();
            window.open(stream.streamUrl, "_blank", "noopener,noreferrer");
        },
        [stream.streamUrl]
    );

    return (
        <div
            className={`group flex items-center gap-2 rounded-md p-2 transition-all hover:border-blue-500/50 hover:bg-white/10 ${isActive
                    ? "border-blue-500 bg-blue-500/20 shadow-lg shadow-blue-500/20"
                    : "border-white/10 bg-white/5"
                }`}
        >
            {/* Channel Logo */}
            <div className="relative h-8 w-8 shrink-0 overflow-hidden rounded-md bg-gradient-to-tr from-slate-800 to-slate-700">
                {stream.streamIcon && !imageError ? (
                    <img
                        src={stream.streamIcon}
                        alt={stream.name}
                        className="h-full w-full object-contain object-center p-0.5"
                        onError={() => setImageError(true)}
                    />
                ) : (
                    <div className="flex h-full w-full items-center justify-center">
                        <span
                            className={`text-xs font-semibold uppercase ${isActive ? "text-white/80" : "text-white/60"
                                }`}
                        >
                            {stream.name.charAt(0)}
                        </span>
                    </div>
                )}
            </div>

            {/* Channel Info */}
            <div className="flex-1 min-w-0">
                <h3
                    className={`truncate text-xs font-semibold transition-colors ${isActive ? "text-white" : "text-white group-hover:text-blue-400"
                        }`}
                >
                    {stream.name}
                </h3>
                <p className={`text-xs ${isActive ? "text-white/80" : "text-slate-400"}`}>
                    {stream.streamType === "live" ? "Live" : stream.streamType}
                </p>
            </div>

            {/* Action Buttons */}
            <div className="flex items-center gap-1">
                <button
                    type="button"
                    onClick={(e) => {
                        e.stopPropagation();
                        onToggleFavorite();
                    }}
                    className={`group/btn inline-flex items-center gap-1 rounded-md px-1.5 py-1 text-xs font-medium transition ${isFavorite
                            ? "text-red-400 hover:text-red-300"
                            : "text-slate-500 hover:text-slate-300"
                        }`}
                    title={isFavorite ? "Remove from favorites" : "Add to favorites"}
                >
                    {isFavorite ? (
                        <Heart className="h-3 w-3" />
                    ) : (
                        <HeartOff className="h-3 w-3" />
                    )}
                </button>
                <button
                    type="button"
                    onClick={handlePlayClick}
                    className={`group/btn inline-flex items-center gap-1 rounded-md bg-blue-600 px-2 py-1 text-xs font-medium text-white transition hover:bg-blue-500 ${isActive &&
                        "ring-2 ring-blue-500/60 ring-offset-1 ring-offset-slate-900"
                        }`}
                    title="Play channel"
                >
                    <Play className="h-3 w-3 transition-transform group-hover/btn:scale-110" />
                </button>
                <button
                    type="button"
                    onClick={handleExternalClick}
                    className="group/btn inline-flex items-center gap-1 rounded-md border border-white/20 bg-white/5 px-1.5 py-1 text-xs font-medium text-white transition hover:bg-white/10"
                    title="Open in new tab"
                >
                    <ExternalLink className="h-3 w-3 transition-transform group-hover/btn:scale-110" />
                </button>
            </div>
        </div>
    );
};
</file>

<file path="src/components/IPTV/IPTVChannelListPanel.tsx">
import { useMemo } from "react";
import { Search, Star, StarOff, ChevronLeft, ChevronRight } from "lucide-react";
import { IPTVChannelListItem } from "./IPTVChannelListItem";
import { useIPTVFavorites } from "@/hooks/useIPTVFavorites";
import type { ChannelCategory, ChannelStream } from "@/types/xtream";

interface IPTVChannelListPanelProps {
    selectedCategory: ChannelCategory | undefined;
    searchTerm: string;
    onSearchChange: (term: string) => void;
    showChannelFavorites: boolean;
    onToggleChannelFavorites: () => void;
    isChannelPanelCollapsed: boolean;
    onToggleChannelPanelCollapsed: () => void;
    onPlayStream: (stream: ChannelStream) => void;
    activeStreamId: number | null;
}

export const IPTVChannelListPanel = ({
    selectedCategory,
    searchTerm,
    onSearchChange,
    showChannelFavorites,
    onToggleChannelFavorites,
    isChannelPanelCollapsed,
    onToggleChannelPanelCollapsed,
    onPlayStream,
    activeStreamId,
}: IPTVChannelListPanelProps) => {
    const { isChannelFavorite, toggleChannelFavorite, getFavoriteChannels } =
        useIPTVFavorites();

    const filteredStreams = useMemo(() => {
        if (!selectedCategory) return [] as ChannelStream[];

        let streams = selectedCategory.streams;
        const term = searchTerm.trim().toLowerCase();

        if (term) {
            streams = streams.filter((stream) =>
                stream.name.toLowerCase().includes(term)
            );
        }

        const trStreams = streams.filter((stream) =>
            stream.name.toLowerCase().startsWith("tr")
        );
        const otherStreams = streams.filter(
            (stream) => !stream.name.toLowerCase().startsWith("tr")
        );

        const favoriteTrStreams = getFavoriteChannels(trStreams);
        const favoriteOtherStreams = getFavoriteChannels(otherStreams);
        const nonFavoriteTrStreams = trStreams.filter(
            (stream) => !favoriteTrStreams.some((fav) => fav.id === stream.id)
        );
        const nonFavoriteOtherStreams = otherStreams.filter(
            (stream) => !favoriteOtherStreams.some((fav) => fav.id === stream.id)
        );

        if (showChannelFavorites) {
            return [...favoriteTrStreams, ...favoriteOtherStreams];
        }

        return [
            ...favoriteTrStreams,
            ...nonFavoriteTrStreams,
            ...favoriteOtherStreams,
            ...nonFavoriteOtherStreams,
        ];
    }, [selectedCategory, searchTerm, showChannelFavorites, getFavoriteChannels]);

    return (
        <aside
            className={`fixed lg:static inset-y-0 right-0 z-50 bg-slate-900/95 backdrop-blur-md border-l border-white/10 transition-transform duration-300 ease-in-out shadow-2xl shadow-black/40 lg:shadow-none ${isChannelPanelCollapsed
                    ? "translate-x-full lg:translate-x-0"
                    : "translate-x-0"
                } ${isChannelPanelCollapsed ? "w-12" : "w-[85vw] max-w-sm sm:w-80 lg:w-72"}`}
        >
            <div className="flex h-full flex-col">
                {/* Channel Panel Header */}
                <div className="flex items-center justify-between p-2 sm:p-3 border-b border-white/10">
                    {!isChannelPanelCollapsed && (
                        <div className="flex-1">
                            <div className="flex items-center justify-between mb-2">
                                <h2 className="text-base sm:text-lg font-semibold text-white">
                                    {selectedCategory?.name || "Channels"}
                                </h2>
                                <button
                                    onClick={onToggleChannelFavorites}
                                    className={`rounded-md p-1 sm:p-1.5 transition-colors ${showChannelFavorites
                                            ? "bg-yellow-500/20 text-yellow-400"
                                            : "bg-white/5 text-slate-400 hover:text-white"
                                        }`}
                                    title={
                                        showChannelFavorites
                                            ? "Show all channels"
                                            : "Show favorites only"
                                    }
                                >
                                    {showChannelFavorites ? (
                                        <Star className="h-3 w-3 sm:h-4 sm:w-4" />
                                    ) : (
                                        <StarOff className="h-3 w-3 sm:h-4 sm:w-4" />
                                    )}
                                </button>
                            </div>

                            {/* Channel Search */}
                            <div className="relative">
                                <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-3 w-3 text-slate-500" />
                                <input
                                    value={searchTerm}
                                    onChange={(e) => onSearchChange(e.target.value)}
                                    placeholder="Search channels..."
                                    className="w-full rounded-md border border-white/10 bg-slate-950/60 py-1.5 sm:py-2 pl-7 pr-2 text-xs text-white shadow-inner placeholder:text-slate-500 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500/30"
                                />
                            </div>

                            <p className="text-xs text-slate-300 mt-1">
                                {filteredStreams.length} channels found
                            </p>
                        </div>
                    )}
                    <button
                        onClick={onToggleChannelPanelCollapsed}
                        className="rounded-md p-1 sm:p-1.5 text-slate-400 hover:text-white transition-colors"
                        title={isChannelPanelCollapsed ? "Expand panel" : "Collapse panel"}
                    >
                        {isChannelPanelCollapsed ? (
                            <ChevronRight className="h-3 w-3 sm:h-4 sm:w-4" />
                        ) : (
                            <ChevronLeft className="h-3 w-3 sm:h-4 sm:w-4" />
                        )}
                    </button>
                </div>

                {/* Channel List Content */}
                {!isChannelPanelCollapsed && (
                    <div className="flex-1 min-h-0 p-2 sm:p-3">
                        <div className="h-full overflow-y-auto space-y-1 pr-2 scrollbar-thin">
                            {filteredStreams.length === 0 ? (
                                <div className="rounded-lg border border-dashed border-white/10 bg-white/5 p-4 text-center text-slate-400">
                                    <p className="text-xs">
                                        No channels found for selected category.
                                    </p>
                                </div>
                            ) : (
                                filteredStreams.map((stream) => (
                                    <IPTVChannelListItem
                                        key={stream.id}
                                        stream={stream}
                                        onPlay={onPlayStream}
                                        isFavorite={isChannelFavorite(stream.id)}
                                        onToggleFavorite={() => toggleChannelFavorite(stream.id)}
                                        isActive={activeStreamId === stream.id}
                                    />
                                ))
                            )}
                        </div>
                    </div>
                )}

                {/* Collapsed Panel Icons */}
                {isChannelPanelCollapsed && (
                    <div className="flex-1 flex flex-col items-center py-4 space-y-2">
                        <div className="rounded-md p-2 bg-white/5 text-slate-400">
                            <Search className="h-4 w-4" />
                        </div>
                        <div className="text-xs text-slate-500 text-center">
                            {filteredStreams.length}
                        </div>
                    </div>
                )}
            </div>
        </aside>
    );
};
</file>

<file path="src/components/IPTV/IPTVLoginForm.tsx">
import { useState, type FormEvent } from "react";
import {
    Eye,
    EyeOff,
    Lock,
    User,
    AlertCircle,
    Server,
    Globe,
    Settings,
} from "lucide-react";
import { useIPTVAuth } from "@/contexts/IPTVAuthContext";
import type { IPTVCredentials } from "@/types/xtream";

export function IPTVLoginForm() {
    const [apiBase, setApiBase] = useState("");
    const [username, setUsername] = useState("");
    const [password, setPassword] = useState("");
    const [sessionCookie, setSessionCookie] = useState("");
    const [userAgent, setUserAgent] = useState("");
    const [streamReferer, setStreamReferer] = useState("");
    const [showPassword, setShowPassword] = useState(false);
    const [error, setError] = useState("");
    const [isLoading, setIsLoading] = useState(false);

    const { configureIPTV } = useIPTVAuth();

    const handleSubmit = async (e: FormEvent) => {
        e.preventDefault();
        setError("");
        setIsLoading(true);

        try {
            if (!apiBase.trim() || !username.trim() || !password.trim()) {
                setError("API Base URL, username, and password are required");
                return;
            }

            try {
                new URL(apiBase);
            } catch {
                setError("Please enter a valid API Base URL");
                return;
            }

            await new Promise((resolve) => setTimeout(resolve, 300));

            const credentials: IPTVCredentials = {
                apiBase: apiBase.trim(),
                username: username.trim(),
                password: password.trim(),
                sessionCookie: sessionCookie.trim() || undefined,
                userAgent: userAgent.trim() || undefined,
                streamReferer: streamReferer.trim() || undefined,
            };

            configureIPTV(credentials);
        } catch (err) {
            setError("An error occurred while saving configuration");
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="bg-card/40 backdrop-blur-md rounded-xl border border-border/50 p-6 shadow-2xl max-w-2xl mx-auto">
            <div className="text-center mb-8">
                <div className="inline-flex items-center justify-center w-12 h-12 bg-primary/20 rounded-full mb-4">
                    <Settings className="h-6 w-6 text-primary" />
                </div>
                <h2 className="text-xl font-bold text-foreground mb-1">
                    IPTV Configuration
                </h2>
                <p className="text-sm text-muted-foreground">
                    Configure your Xtream Codes IPTV service
                </p>
            </div>

            <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label htmlFor="apiBase" className="block text-[10px] font-bold uppercase tracking-wider text-muted-foreground mb-1.5">
                        API Base URL *
                    </label>
                    <div className="relative">
                        <Server className="absolute left-3 top-1/2 transform -translate-y-1/2 h-3.5 w-3.5 text-muted-foreground" />
                        <input
                            id="apiBase"
                            type="url"
                            value={apiBase}
                            onChange={(e) => setApiBase(e.target.value)}
                            className="w-full pl-9 pr-4 py-2 bg-muted/30 border border-border/50 rounded-lg text-sm placeholder-muted-foreground focus:border-primary focus:outline-none transition-colors"
                            placeholder="http://server.com:8080/player_api.php"
                            required
                            disabled={isLoading}
                        />
                    </div>
                </div>

                <div className="grid grid-cols-2 gap-4">
                    <div>
                        <label htmlFor="username" className="block text-[10px] font-bold uppercase tracking-wider text-muted-foreground mb-1.5">
                            Username *
                        </label>
                        <div className="relative">
                            <User className="absolute left-3 top-1/2 transform -translate-y-1/2 h-3.5 w-3.5 text-muted-foreground" />
                            <input
                                id="username"
                                type="text"
                                value={username}
                                onChange={(e) => setUsername(e.target.value)}
                                className="w-full pl-9 pr-4 py-2 bg-muted/30 border border-border/50 rounded-lg text-sm placeholder-muted-foreground focus:border-primary focus:outline-none transition-colors"
                                placeholder="Username"
                                required
                                disabled={isLoading}
                            />
                        </div>
                    </div>

                    <div>
                        <label htmlFor="password" className="block text-[10px] font-bold uppercase tracking-wider text-muted-foreground mb-1.5">
                            Password *
                        </label>
                        <div className="relative">
                            <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 h-3.5 w-3.5 text-muted-foreground" />
                            <input
                                id="password"
                                type={showPassword ? "text" : "password"}
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="w-full pl-9 pr-10 py-2 bg-muted/30 border border-border/50 rounded-lg text-sm placeholder-muted-foreground focus:border-primary focus:outline-none transition-colors"
                                placeholder="Password"
                                required
                                disabled={isLoading}
                            />
                            <button
                                type="button"
                                onClick={() => setShowPassword(!showPassword)}
                                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground hover:text-foreground transition-colors"
                                disabled={isLoading}
                            >
                                {showPassword ? <EyeOff className="h-3.5 w-3.5" /> : <Eye className="h-3.5 w-3.5" />}
                            </button>
                        </div>
                    </div>
                </div>

                <div className="pt-2">
                    <button
                        type="button"
                        className="text-[10px] font-bold text-primary uppercase tracking-widest hover:underline mb-2"
                        onClick={() => {
                            const el = document.getElementById('advanced-options');
                            if (el) el.classList.toggle('hidden');
                        }}
                    >
                        Advanced Options
                    </button>

                    <div id="advanced-options" className="hidden space-y-4 pt-2 border-t border-border/30">
                        <div>
                            <label htmlFor="sessionCookie" className="block text-[10px] font-bold uppercase tracking-wider text-muted-foreground mb-1.5">
                                Session Cookie
                            </label>
                            <input
                                id="sessionCookie"
                                type="text"
                                value={sessionCookie}
                                onChange={(e) => setSessionCookie(e.target.value)}
                                className="w-full px-3 py-2 bg-muted/30 border border-border/50 rounded-lg text-sm placeholder-muted-foreground focus:border-primary focus:outline-none transition-colors"
                                placeholder="capp_name_session=..."
                                disabled={isLoading}
                            />
                        </div>

                        <div>
                            <label htmlFor="userAgent" className="block text-[10px] font-bold uppercase tracking-wider text-muted-foreground mb-1.5">
                                User Agent
                            </label>
                            <input
                                id="userAgent"
                                type="text"
                                value={userAgent}
                                onChange={(e) => setUserAgent(e.target.value)}
                                className="w-full px-3 py-2 bg-muted/30 border border-border/50 rounded-lg text-sm placeholder-muted-foreground focus:border-primary focus:outline-none transition-colors"
                                placeholder="Mozilla/5.0..."
                                disabled={isLoading}
                            />
                        </div>

                        <div>
                            <label htmlFor="streamReferer" className="block text-[10px] font-bold uppercase tracking-wider text-muted-foreground mb-1.5">
                                Stream Referer
                            </label>
                            <input
                                id="streamReferer"
                                type="url"
                                value={streamReferer}
                                onChange={(e) => setStreamReferer(e.target.value)}
                                className="w-full px-3 py-2 bg-muted/30 border border-border/50 rounded-lg text-sm placeholder-muted-foreground focus:border-primary focus:outline-none transition-colors"
                                placeholder="http://server.com/"
                                disabled={isLoading}
                            />
                        </div>
                    </div>
                </div>

                {error && (
                    <div className="flex items-center gap-2 p-3 bg-destructive/10 border border-destructive/20 rounded-lg text-destructive text-xs">
                        <AlertCircle className="h-3.5 w-3.5 flex-shrink-0" />
                        <span>{error}</span>
                    </div>
                )}

                <button
                    type="submit"
                    disabled={isLoading || !apiBase || !username || !password}
                    className="w-full py-2.5 bg-primary hover:bg-primary/90 disabled:bg-muted disabled:text-muted-foreground text-white text-sm font-bold uppercase tracking-widest rounded-lg transition-all shadow-lg active:scale-[0.98]"
                >
                    {isLoading ? "Configuring..." : "Save Configuration"}
                </button>
            </form>
        </div>
    );
}
</file>

<file path="src/components/IPTV/IPTVMobileControls.tsx">
import { Menu, List } from "lucide-react";

interface IPTVMobileControlsProps {
    isSidebarOpen: boolean;
    onToggleSidebar: () => void;
    onToggleChannelList: () => void;
}

export const IPTVMobileControls = ({
    isSidebarOpen,
    onToggleSidebar,
    onToggleChannelList,
}: IPTVMobileControlsProps) => {
    return (
        <div className="lg:hidden fixed top-0 left-0 right-0 z-50 flex items-center justify-between bg-slate-900/95 backdrop-blur-md border-b border-white/10 px-4 py-3">
            <button
                onClick={onToggleSidebar}
                className={`rounded-md p-2 transition-colors ${isSidebarOpen
                        ? "bg-blue-600 text-white"
                        : "text-slate-400 hover:text-white hover:bg-white/10"
                    }`}
                title="Toggle categories"
            >
                <Menu className="h-5 w-5" />
            </button>

            <span className="text-white font-semibold">IPTV Player</span>

            <button
                onClick={onToggleChannelList}
                className="rounded-md p-2 text-slate-400 hover:text-white hover:bg-white/10 transition-colors"
                title="Toggle channel list"
            >
                <List className="h-5 w-5" />
            </button>
        </div>
    );
};
</file>

<file path="src/components/IPTV/IPTVVideoPlayer.tsx">
import { useState, useRef, useEffect, useCallback } from "react";
import { createPortal } from "react-dom";
import {
    X,
    Volume2,
    VolumeX,
    Maximize,
    Minimize,
    Play,
    Pause,
    RotateCcw,
    Loader2,
    Radio, // Added for the transfer button icon
} from "lucide-react";
import Hls from "hls.js";

import { API_BASE_URL } from "@/utils/apiConfig";
import { useMatchContext } from "@/contexts/MatchContext"; // Import context to communicate with LiveStreamPlayer
import { toast } from "sonner"; // Assuming you use sonner for feedback as seen in LiveStreamPlayer

interface IPTVVideoPlayerProps {
    streamUrl: string;
    channelName: string;
    isOpen: boolean;
    onClose: () => void;
    isEmbedded?: boolean;
}

export function IPTVVideoPlayer({
    streamUrl,
    channelName,
    isOpen,
    onClose,
    isEmbedded = false,
}: IPTVVideoPlayerProps) {
    const { setStreamUrl } = useMatchContext(); // Access the global stream state
    const [isPlaying, setIsPlaying] = useState(false);
    const [volume, setVolume] = useState(0.8);
    const [isMuted, setIsMuted] = useState(false);
    const [isFullscreen, setIsFullscreen] = useState(false);
    const [isLoading, setIsLoading] = useState(true);
    const [hasError, setHasError] = useState(false);
    const [showControls, setShowControls] = useState(true);

    const videoRef = useRef<HTMLVideoElement>(null);
    const playerContainerRef = useRef<HTMLDivElement>(null);
    const hlsRef = useRef<Hls | null>(null);
    const controlsTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

    // Function to transfer current stream to the main LiveStreamPlayer and close IPTV player
    const handleSendToLivePlayer = () => {
        setStreamUrl(streamUrl);
        toast.success(`Transferred "${channelName}" to Live Player`);
        // Close the IPTV player after transferring (unless embedded)
        if (!isEmbedded) {
            onClose();
        }
    };

    const loadStream = useCallback(async () => {
        setIsLoading(true);
        setHasError(false);
        setIsPlaying(false);

        try {
            // ALWAYS use proxy for the stream manifest
            const normalizedStreamUrl = `${API_BASE_URL}/api/proxy?url=${encodeURIComponent(streamUrl)}`;

            const video = videoRef.current;
            if (!video) return;

            // Reset video element
            try {
                video.pause();
                video.currentTime = 0;
                video.src = "";
                video.load(); // Force reset
            } catch { }

            // Wait a bit for video element to reset
            await new Promise(resolve => setTimeout(resolve, 100));

            if (Hls.isSupported()) {
                if (hlsRef.current) {
                    hlsRef.current.destroy();
                    hlsRef.current = null;
                }

                const hls = new Hls({
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90,
                    maxBufferLength: 30,
                    maxMaxBufferLength: 60,
                    liveSyncDurationCount: 3,
                    liveMaxLatencyDurationCount: 5,
                    debug: false, // Set to true to see more logs

                    // Important: Configure fragLoadingTimeOut and manifestLoadingTimeOut
                    fragLoadingTimeOut: 20000,
                    manifestLoadingTimeOut: 10000,
                    levelLoadingTimeOut: 10000,

                    xhrSetup: (xhr, url) => {
                        // Proxy all segment requests
                        let finalUrl = url;

                        if (url && !url.includes("/api/proxy")) {
                            finalUrl = `${API_BASE_URL}/api/proxy?url=${encodeURIComponent(url)}`;
                        }

                        // Override the URL for this request
                        const originalOpen = xhr.open;
                        xhr.open = function (method: string, requestUrl: string) {
                            // Use our proxied URL instead
                            return originalOpen.call(this, method, finalUrl);
                        };

                        // Set safe headers
                        try {
                            xhr.setRequestHeader("Accept", "*/*");
                        } catch (e) {
                            console.warn('Failed to set Accept header:', e);
                        }
                    },
                });

                hlsRef.current = hls;

                // HLS Events
                hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                    console.log('[HLS] Media attached to video element');
                });

                hls.on(Hls.Events.MANIFEST_PARSED, async (event, data) => {
                    console.log('[HLS] Manifest parsed, levels:', data.levels.length);
                    setIsLoading(false);
                    setHasError(false);

                    try {
                        // Try to play the video
                        await video.play();
                        console.log('[HLS] Playback started');
                    } catch (error) {
                        console.error('[HLS] Autoplay failed:', error);
                    }
                });

                hls.on(Hls.Events.LEVEL_LOADED, (event, data) => {
                    console.log('[HLS] Level loaded:', data.level, 'fragments:', data.details.fragments.length);
                });

                hls.on(Hls.Events.FRAG_LOADING, (event, data) => {
                    console.log('[HLS] Loading fragment:', data.frag.sn);
                });

                hls.on(Hls.Events.FRAG_LOADED, (event, data) => {
                    console.log('[HLS] Fragment loaded:', data.frag.sn);
                });

                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('[HLS] Error:', data.type, data.details, data.fatal);

                    if (data.fatal) {
                        setIsLoading(false);

                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.error('[HLS] Fatal network error, trying to recover');
                                // Try to recover from network error
                                setTimeout(() => {
                                    if (hlsRef.current) {
                                        hlsRef.current.startLoad();
                                    }
                                }, 1000);
                                break;

                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.error('[HLS] Fatal media error, trying to recover');
                                // Try to recover from media error
                                if (hlsRef.current) {
                                    hlsRef.current.recoverMediaError();
                                }
                                break;

                            default:
                                // Cannot recover
                                setHasError(true);
                                setIsPlaying(false);
                                if (videoRef.current) {
                                    videoRef.current.pause();
                                }
                                if (hlsRef.current) {
                                    hlsRef.current.destroy();
                                    hlsRef.current = null;
                                }
                                break;
                        }
                    }
                });

                // Attach media FIRST, then load source
                hls.attachMedia(video);

                // Wait for media to be attached
                await new Promise<void>((resolve) => {
                    hls.once(Hls.Events.MEDIA_ATTACHED, () => resolve());
                    // Timeout after 5 seconds
                    setTimeout(() => resolve(), 5000);
                });

                // Now load the source
                console.log('[HLS] Loading source:', normalizedStreamUrl);
                hls.loadSource(normalizedStreamUrl);

            } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
                // Native HLS support (Safari)
                console.log('[Native] Using native HLS support');
                video.src = normalizedStreamUrl;

                video.addEventListener('loadedmetadata', () => {
                    console.log('[Native] Metadata loaded');
                    setIsLoading(false);
                }, { once: true });

                video.addEventListener('canplay', async () => {
                    console.log('[Native] Can play');
                    try {
                        await video.play();
                    } catch (e) {
                        console.error('[Native] Play failed:', e);
                    }
                }, { once: true });

            } else {
                throw new Error("HLS is not supported in this browser");
            }
        } catch (error) {
            console.error('[Player] Load stream error:', error);
            setIsLoading(false);
            setHasError(true);
            setIsPlaying(false);
            if (videoRef.current) {
                videoRef.current.pause();
            }
            if (hlsRef.current) {
                hlsRef.current.destroy();
                hlsRef.current = null;
            }
        }
    }, [streamUrl]);

    const resetControlsTimeout = useCallback(() => {
        if (controlsTimeoutRef.current) clearTimeout(controlsTimeoutRef.current);

        setShowControls(true);
        controlsTimeoutRef.current = setTimeout(() => {
            if (isPlaying) {
                setShowControls(false);
            }
        }, 3000);
    }, [isPlaying]);

    const handleMouseMove = useCallback(() => {
        resetControlsTimeout();
    }, [resetControlsTimeout]);

    const handlePlayPause = useCallback(async () => {
        const video = videoRef.current;
        if (!video) return;

        try {
            if (video.paused) {
                if (isLoading || hasError) return;
                await video.play();
            } else {
                video.pause();
            }
        } catch { }

        resetControlsTimeout();
    }, [hasError, isLoading, resetControlsTimeout]);

    const handleVolumeChange = useCallback(
        (newVolume: number) => {
            const video = videoRef.current;
            if (!video) return;

            setVolume(newVolume);
            video.volume = newVolume;
            setIsMuted(newVolume === 0);
            resetControlsTimeout();
        },
        [resetControlsTimeout]
    );

    const handleMuteToggle = useCallback(() => {
        const video = videoRef.current;
        if (!video) return;

        if (isMuted) {
            video.volume = 0.8;
            setVolume(0.8);
            setIsMuted(false);
        } else {
            video.volume = 0;
            setIsMuted(true);
        }
        resetControlsTimeout();
    }, [isMuted, resetControlsTimeout]);

    const handleFullscreen = useCallback(() => {
        const container = playerContainerRef.current;
        if (!container) return;

        const fullscreenElement =
            document.fullscreenElement ||
            (document as any).webkitFullscreenElement ||
            (document as any).msFullscreenElement;

        if (!fullscreenElement) {
            const requestFullscreen =
                container.requestFullscreen ||
                (container as any).webkitRequestFullscreen ||
                (container as any).msRequestFullscreen;

            if (requestFullscreen) {
                requestFullscreen.call(container);
            }
        } else {
            const exitFullscreen =
                document.exitFullscreen ||
                (document as any).webkitExitFullscreen ||
                (document as any).msExitFullscreen;

            if (exitFullscreen) {
                exitFullscreen.call(document);
            }
        }

        resetControlsTimeout();
    }, [resetControlsTimeout]);

    useEffect(() => {
        const handleFullscreenChange = () => {
            const fullscreenElement =
                document.fullscreenElement ||
                (document as any).webkitFullscreenElement ||
                (document as any).msFullscreenElement;

            setIsFullscreen(Boolean(fullscreenElement));

            if (!fullscreenElement) {
                setShowControls(true);
            }
        };

        document.addEventListener("fullscreenchange", handleFullscreenChange);
        document.addEventListener("webkitfullscreenchange", handleFullscreenChange);
        document.addEventListener("MSFullscreenChange", handleFullscreenChange);

        return () => {
            document.removeEventListener("fullscreenchange", handleFullscreenChange);
            document.removeEventListener(
                "webkitfullscreenchange",
                handleFullscreenChange
            );
            document.removeEventListener(
                "MSFullscreenChange",
                handleFullscreenChange
            );
        };
    }, []);

    const handleRestart = async () => {
        const video = videoRef.current;
        if (!video) return;

        if (hasError) {
            setHasError(false);
            setIsLoading(true);
            setIsPlaying(false);

            if (hlsRef.current) {
                hlsRef.current.destroy();
                hlsRef.current = null;
            }

            try {
                video.pause();
                video.currentTime = 0;
                video.src = "";
                video.load();
            } catch { }

            setTimeout(() => loadStream(), 200);
        } else {
            try {
                video.currentTime = 0;
                if (!video.paused) await video.play();
            } catch { }
        }
        resetControlsTimeout();
    };

    useEffect(() => {
        const handleKeyDown = (event: KeyboardEvent) => {
            if (event.key === "Escape" && isOpen && !isEmbedded) {
                onClose();
            } else if (event.key === " " && isOpen) {
                event.preventDefault();
                handlePlayPause();
            } else if (event.key === "f" && isOpen) {
                event.preventDefault();
                handleFullscreen();
            }
        };

        if (isOpen) {
            document.addEventListener("keydown", handleKeyDown);
            if (!isEmbedded) {
                document.body.style.overflow = "hidden";
            }
        }

        return () => {
            document.removeEventListener("keydown", handleKeyDown);
            if (!isEmbedded) {
                document.body.style.overflow = "unset";
            }
        };
    }, [handleFullscreen, handlePlayPause, isEmbedded, isOpen, onClose]);

    useEffect(() => {
        if (!isOpen || !videoRef.current) return;

        loadStream();

        return () => {
            if (hlsRef.current) {
                hlsRef.current.destroy();
                hlsRef.current = null;
            }
        };
    }, [isOpen, loadStream]);

    useEffect(() => {
        const video = videoRef.current;
        if (!video) return;

        const handlePlay = () => {
            console.log('[Video] Play event');
            setIsPlaying(true);
        };

        const handlePause = () => {
            console.log('[Video] Pause event');
            setIsPlaying(false);
        };

        const handleError = (e: Event) => {
            console.error('[Video] Error event:', e);
            setIsLoading(false);
            setHasError(true);
            setIsPlaying(false);
            if (videoRef.current) {
                videoRef.current.pause();
            }
            if (hlsRef.current) {
                hlsRef.current.destroy();
                hlsRef.current = null;
            }
        };

        const handleWaiting = () => {
            console.log('[Video] Waiting for data');
        };

        const handleCanPlay = () => {
            console.log('[Video] Can play');
        };

        video.addEventListener("play", handlePlay);
        video.addEventListener("pause", handlePause);
        video.addEventListener("error", handleError);
        video.addEventListener("waiting", handleWaiting);
        video.addEventListener("canplay", handleCanPlay);

        return () => {
            video.removeEventListener("play", handlePlay);
            video.removeEventListener("pause", handlePause);
            video.removeEventListener("error", handleError);
            video.removeEventListener("waiting", handleWaiting);
            video.removeEventListener("canplay", handleCanPlay);
        };
    }, [isOpen]);

    if (!isOpen) return null;

    const playerContent = (
        <div
            ref={playerContainerRef}
            className={`flex h-full w-full items-center justify-center overflow-hidden bg-black ${isFullscreen ? "" : "rounded-lg"
                }`}
        >
            <div
                className={`relative flex w-full items-center justify-center bg-black ${!isFullscreen && "aspect-video"
                    }`}
                onMouseMove={handleMouseMove}
                onMouseLeave={() => {
                    if (isPlaying) {
                        setShowControls(false);
                    }
                }}
            >
                <video
                    ref={videoRef}
                    className="h-full w-full object-contain bg-black"
                    autoPlay
                    muted={isMuted}
                    playsInline
                    crossOrigin="anonymous"
                />

                {/* Loading Overlay */}
                {isLoading && (
                    <div className="absolute inset-0 flex items-center justify-center bg-black/80 backdrop-blur-sm">
                        <div className="flex flex-col items-center gap-6">
                            <div className="relative">
                                <Loader2 className="h-16 w-16 animate-spin text-blue-500" />
                            </div>
                            <div className="text-center">
                                <p className="text-lg font-semibold text-white">
                                    Loading Stream
                                </p>
                                <p className="text-sm text-slate-300 mt-1">Please wait...</p>
                            </div>
                        </div>
                    </div>
                )}

                {/* Error Overlay */}
                {hasError && (
                    <div className="absolute inset-0 flex items-center justify-center bg-black/90 backdrop-blur-sm">
                        <div className="flex flex-col items-center gap-6 text-center max-w-md mx-4">
                            <div className="relative">
                                <div className="rounded-full bg-red-500/20 p-6">
                                    <X className="h-12 w-12 text-red-400" />
                                </div>
                                <div className="absolute -top-2 -right-2 h-6 w-6 rounded-full bg-red-500 animate-pulse" />
                            </div>
                            <div>
                                <h3 className="text-xl font-semibold text-white mb-2">
                                    Stream Failed to Load
                                </h3>
                                <p className="text-sm text-slate-300 leading-relaxed">
                                    This channel is currently unavailable or there is a temporary
                                    issue. Check the console for details.
                                </p>
                            </div>
                            <button
                                onClick={handleRestart}
                                className="flex items-center gap-2 rounded-xl bg-blue-600 px-6 py-3 text-sm font-medium text-white hover:bg-blue-500 transition-colors"
                            >
                                <RotateCcw className="h-4 w-4" />
                                Try Again
                            </button>
                        </div>
                    </div>
                )}

                {/* Controls Overlay */}
                <div
                    className={`absolute inset-0 flex flex-col justify-between bg-gradient-to-t from-black/80 via-transparent to-black/40 transition-opacity duration-300 ${showControls ? "opacity-100" : "opacity-0"
                        }`}
                >
                    {/* Top Controls */}
                    <div className="flex items-center justify-between p-4">
                        <div className="flex items-center gap-3">
                            <div className="flex items-center gap-2">
                                <div className="h-2 w-2 rounded-full bg-red-500 animate-pulse" />
                                <span className="text-xs font-medium text-white bg-red-500/20 px-2 py-1 rounded-full border border-red-500/30">
                                    LIVE
                                </span>
                            </div>
                            <h2 className="text-sm font-semibold text-white truncate max-w-xs">
                                {channelName}
                            </h2>
                        </div>

                        <div className="flex items-center gap-2">
                            {/* Transfer to LiveStreamPlayer Button */}
                            <button
                                onClick={handleSendToLivePlayer}
                                className="flex items-center gap-2 rounded-lg bg-blue-600/80 px-3 py-2 text-xs font-bold text-white hover:bg-blue-500 transition-colors backdrop-blur-sm shadow-lg border border-blue-400/30"
                                title="Send to Main Player"
                            >
                                <Radio className="h-3.5 w-3.5" />
                                <span className="hidden sm:inline">SEND TO LIVE PLAYER</span>
                            </button>

                            <button
                                onClick={handleMuteToggle}
                                className="rounded-lg bg-black/60 p-2 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                                title={isMuted ? "Unmute" : "Mute"}
                            >
                                {isMuted ? (
                                    <VolumeX className="h-4 w-4" />
                                ) : (
                                    <Volume2 className="h-4 w-4" />
                                )}
                            </button>
                            {!isEmbedded && (
                                <button
                                    onClick={onClose}
                                    className="rounded-lg bg-black/60 p-2 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                                    title="Close (ESC)"
                                >
                                    <X className="h-4 w-4" />
                                </button>
                            )}
                        </div>
                    </div>

                    {/* Bottom Controls */}
                    <div className="p-4">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <button
                                    onClick={handlePlayPause}
                                    className="rounded-lg bg-black/60 p-2 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                                >
                                    {isPlaying ? (
                                        <Pause className="h-4 w-4" />
                                    ) : (
                                        <Play className="h-4 w-4" />
                                    )}
                                </button>

                                <button
                                    onClick={handleRestart}
                                    className="rounded-lg bg-black/60 p-2 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                                    title="Restart"
                                >
                                    <RotateCcw className="h-4 w-4" />
                                </button>

                                <div className="flex items-center gap-2 ml-2">
                                    <input
                                        type="range"
                                        min="0"
                                        max="1"
                                        step="0.1"
                                        value={isMuted ? 0 : volume}
                                        onChange={(e) =>
                                            handleVolumeChange(parseFloat(e.target.value))
                                        }
                                        className="w-20 h-1 bg-white/20 rounded-lg appearance-none cursor-pointer accent-blue-500"
                                        title={`Volume: ${Math.round((isMuted ? 0 : volume) * 100)}%`}
                                    />
                                </div>
                            </div>

                            <div className="flex items-center gap-2">
                                <button
                                    onClick={handleFullscreen}
                                    className="rounded-lg bg-black/60 p-2 text-white hover:bg-black/80 transition-colors backdrop-blur-sm"
                                    title="Fullscreen (F)"
                                >
                                    {isFullscreen ? (
                                        <Minimize className="h-4 w-4" />
                                    ) : (
                                        <Maximize className="h-4 w-4" />
                                    )}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );

    if (isEmbedded) {
        return playerContent;
    }

    return createPortal(
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/95 backdrop-blur-md">
            <div className="w-full h-full max-w-5xl max-h-[80vh] px-4 flex items-center">
                {playerContent}
            </div>
        </div>,
        document.body);
}
</file>

<file path="src/components/IPTV/IPTVVideoPlayerArea.tsx">
import { Tv } from "lucide-react";
import { IPTVVideoPlayer } from "./IPTVVideoPlayer";
import type { ChannelStream } from "@/types/xtream";

interface IPTVVideoPlayerAreaProps {
    selectedStream: ChannelStream | null;
    isPlayerOpen: boolean;
    onClosePlayer: () => void;
}

export const IPTVVideoPlayerArea = ({
    selectedStream,
    isPlayerOpen,
    onClosePlayer,
}: IPTVVideoPlayerAreaProps) => {
    return (
        <div className="flex-1 flex flex-col min-w-0">
            {selectedStream && isPlayerOpen ? (
                <div className="h-full w-full bg-black">
                    <IPTVVideoPlayer
                        streamUrl={selectedStream.streamUrl}
                        channelName={selectedStream.name}
                        isOpen={true}
                        onClose={onClosePlayer}
                        isEmbedded={true}
                    />
                </div>
            ) : (
                <div className="flex-1 flex items-center justify-center bg-slate-900/50">
                    <div className="text-center text-slate-400">
                        <Tv className="h-16 w-16 mx-auto mb-4 text-slate-500" />
                        <h3 className="text-lg font-semibold mb-2">Video Player</h3>
                        <p className="text-sm">Select a channel to play</p>
                    </div>
                </div>
            )}
        </div>
    );
};
</file>

<file path="src/components/KeyboardShortcutsGrid.tsx">
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";

interface KeyboardMapping {
    key: string;
    modifier?: 'Ctrl' | 'Shift' | 'Alt';
    eventName: string;
    description: string;
    category?: string;
}

export const POST_MATCH_KEYBOARD_MAPPINGS: KeyboardMapping[] = [
    // POSSESSION EVENTS (1 key)
    { key: '1', eventName: 'pass_end', description: 'Pass Completed', category: 'Possession' },
    { key: '1', modifier: 'Shift', eventName: 'key_pass', description: 'Key Pass', category: 'Possession' },
    { key: '1', modifier: 'Ctrl', eventName: 'assist', description: 'Assist', category: 'Possession' },
    { key: '1', modifier: 'Alt', eventName: 'pre_assist', description: 'Pre-Assist', category: 'Possession' },

    // SHOT EVENTS (2 key)
    { key: '2', eventName: 'shot_outcome', description: 'Shot Outcome', category: 'Shots' },
    { key: '2', modifier: 'Shift', eventName: 'goal', description: 'Goal Scored', category: 'Shots' },

    // DRIBBLING EVENTS (3 key)
    { key: '3', eventName: 'dribble_success', description: 'Dribble Success', category: 'Dribbling' },
    { key: '3', modifier: 'Shift', eventName: 'dribble_fail', description: 'Dribble Failure', category: 'Dribbling' },

    // DEFENSIVE EVENTS (4-5 keys)
    { key: '4', eventName: 'duel_ground', description: 'Ground Duel', category: 'Defense' },
    { key: '5', eventName: 'duel_aerial', description: 'Aerial Duel', category: 'Defense' },

    // PRESSING EVENTS (P key)
    { key: 'P', eventName: 'pressing_success', description: 'Pressing Success', category: 'Defense' },
    { key: 'P', modifier: 'Shift', eventName: 'pressing_fail', description: 'Pressing Failure', category: 'Defense' },

    // TACTICAL PHASES (Q, W, E, M, L keys)
    { key: 'Q', eventName: 'phase_buildup_end', description: 'Build-Up Phase', category: 'Phases' },
    { key: 'W', eventName: 'phase_consolidation', description: 'Consolidation', category: 'Phases' },
    { key: 'E', eventName: 'phase_final_third', description: 'Final Third', category: 'Phases' },
    { key: 'M', eventName: 'phase_midblock', description: 'Mid Block', category: 'Phases' },
    { key: 'L', eventName: 'phase_lowblock', description: 'Low Block', category: 'Phases' },

    // TRANSITIONS (Z key)
    { key: 'Z', eventName: 'transition_end', description: 'Transition End', category: 'Transitions' },

    // OFF-BALL MOVEMENT (O, T, D keys)
    { key: 'O', eventName: 'off_ball_run', description: 'Off-Ball Run', category: 'Off-Ball' },
    { key: 'O', modifier: 'Shift', eventName: 'overlap', description: 'Overlap', category: 'Off-Ball' },
    { key: 'O', modifier: 'Alt', eventName: 'underlap', description: 'Underlap', category: 'Off-Ball' },
    { key: 'T', eventName: 'third_man_run', description: 'Third Man Run', category: 'Off-Ball' },
    { key: 'D', eventName: 'dummy_run', description: 'Dummy Run', category: 'Off-Ball' },

    // PERFORMANCE METRICS (C, R keys)
    { key: 'C', eventName: 'chance_created', description: 'Chance Created', category: 'Performance' },
    { key: 'R', eventName: 'pressing_resistance', description: 'Press Resistance', category: 'Tactical' },

    // WORKFLOW (F, Enter, Backspace keys)
    { key: 'F', eventName: 'timestamp_fix', description: 'Fix Timestamp', category: 'Workflow' },
    { key: 'Enter', eventName: 'ai_accept', description: 'AI Accept', category: 'Workflow' },
    { key: 'Backspace', eventName: 'ai_reject', description: 'AI Reject', category: 'Workflow' },
];

interface KeyboardShortcutsGridProps {
    onKeyPress?: (eventName: string, key: string) => void;
}

export const KeyboardShortcutsGrid = ({ onKeyPress }: KeyboardShortcutsGridProps) => {
    return (
        <div className="space-y-2">
            <div className="flex items-center justify-between">
                <h3 className="text-xs font-bold uppercase tracking-wider text-muted-foreground">Keyboard Shortcuts</h3>
                <Badge variant="outline" className="text-[10px]">Live & Post-Match</Badge>
            </div>

            <div className="grid grid-cols-4 gap-1.5">
                {POST_MATCH_KEYBOARD_MAPPINGS.map((mapping, idx) => {
                    const label = mapping.modifier
                        ? `${mapping.modifier}+${mapping.key}`
                        : mapping.key;

                    return (
                        <Card
                            key={`${mapping.key}-${mapping.modifier || ''}-${idx}`}
                            onClick={() => onKeyPress?.(mapping.eventName, label)}
                            className="p-1.5 border border-zinc-700 bg-zinc-900/50 hover:bg-zinc-800 hover:border-primary/50 cursor-pointer transition-all text-center select-none"
                        >
                            <div className="flex flex-col items-center gap-0.5">
                                <span className="text-sm font-mono font-bold text-primary">
                                    {label}
                                </span>
                                <span className="text-[9px] text-muted-foreground leading-tight line-clamp-1">
                                    {mapping.description}
                                </span>
                            </div>
                        </Card>
                    );
                })}
            </div>
        </div>
    );
};
</file>

<file path="src/components/kpi/dialogs/CompetitorDetailDialog.tsx">
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Competitor } from "@/utils/kpiEngine";

interface CompetitorDetailDialogProps {
    isOpen: boolean;
    onClose: () => void;
    competitor: Competitor | null;
}

export function CompetitorDetailDialog({ isOpen, onClose, competitor }: CompetitorDetailDialogProps) {
    if (!competitor) return null;

    return (
        <Dialog open={isOpen} onOpenChange={onClose}>
            <DialogContent className="max-w-md">
                <DialogHeader>
                    <DialogTitle className="text-xl font-bold flex items-center gap-2">
                        üõ°Ô∏è Competitor Intelligence
                    </DialogTitle>
                </DialogHeader>

                <div className="mt-4 space-y-4">
                    <div className="p-4 bg-slate-900 text-white rounded-lg shadow-md">
                        <div className="text-sm text-slate-400 uppercase font-bold text-center mb-1">Competitor Name</div>
                        <div className="text-2xl font-bold text-center text-blue-400">{competitor.name}</div>
                    </div>

                    <div className="grid grid-cols-2 gap-4">
                        <div className="p-3 bg-red-50 border border-red-100 rounded">
                            <div className="text-xs text-red-600 font-bold uppercase mb-1">Threat Level</div>
                            <div className="font-bold text-red-800">{competitor.threat}</div>
                        </div>
                        <div className="p-3 bg-red-50 border border-red-100 rounded">
                            <div className="text-xs text-red-600 font-bold uppercase mb-1">Their Strength</div>
                            <div className="text-sm text-red-800 leading-tight">{competitor.strength}</div>
                        </div>
                    </div>

                    <div className="p-4 bg-green-50 border border-green-200 rounded-lg">
                        <div className="text-xs text-green-700 font-bold uppercase mb-2">Our Winning Advantage</div>
                        <div className="font-medium text-green-900">
                            {competitor.advantage}
                        </div>
                    </div>
                </div>
            </DialogContent>
        </Dialog>
    );
}
</file>

<file path="src/components/kpi/dialogs/FunnelDrilldownDialog.tsx">
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
import { KPIModel } from "@/utils/kpiEngine";

interface FunnelDrilldownDialogProps {
    isOpen: boolean;
    onClose: () => void;
    stage: string | null;
    targetCount: number;
}

export function FunnelDrilldownDialog({ isOpen, onClose, stage, targetCount }: FunnelDrilldownDialogProps) {
    if (!stage) return null;

    // Generate dummy data based on the stage and target count
    const entities = Array.from({ length: Math.min(targetCount, 20) }).map((_, i) => {
        const companies = ["ES Setif", "MC Alger", "JS Kabylie", "CR Belouizdad", "USM Alger", "CS Constantine", "MC Oran", "JS Saoura", "ASO Chlef", "US Biskra"];
        const contacts = ["Ahmed Z.", "Mohamed K.", "Yassine B.", "Karim H.", "Omar F.", "Said M.", "Amine T.", "Rachid S.", "Walid G.", "Hamza L."];

        return {
            id: `funnel-${i}`,
            company: companies[i % companies.length] + (i >= companies.length ? ` (${Math.floor(i / companies.length) + 1})` : ""),
            contact: contacts[i % contacts.length],
            value: 150000 + (Math.random() * 100000),
            probability: stage === "Lead Generation" ? 10 : stage === "Demo/Discovery" ? 30 : 60,
            date: new Date(Date.now() + (Math.random() * 90 * 24 * 60 * 60 * 1000)).toLocaleDateString()
        };
    });

    return (
        <Dialog open={isOpen} onOpenChange={onClose}>
            <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
                <DialogHeader>
                    <DialogTitle className="text-xl font-bold flex items-center gap-2">
                        üéØ Funnel Drilldown: <span className="text-blue-600">{stage}</span>
                    </DialogTitle>
                    <DialogDescription>
                        Showing top {entities.length} active {stage.toLowerCase()} entities (Target: {targetCount}).
                    </DialogDescription>
                </DialogHeader>

                <div className="mt-4 border rounded-md overflow-hidden">
                    <table className="w-full text-sm text-left">
                        <thead className="bg-slate-50 text-slate-500 font-medium border-b sticky top-0">
                            <tr>
                                <th className="p-3">Company / Org</th>
                                <th className="p-3">Primary Contact</th>
                                <th className="p-3 text-right">Deal Value</th>
                                <th className="p-3 text-right">Probability</th>
                                <th className="p-3 text-right">Est. Close</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y">
                            {entities.map((e) => (
                                <tr key={e.id} className="hover:bg-slate-50">
                                    <td className="p-3 font-medium text-slate-900">{e.company}</td>
                                    <td className="p-3 text-slate-600">{e.contact}</td>
                                    <td className="p-3 text-right font-mono text-slate-700">{e.value.toLocaleString(undefined, { maximumFractionDigits: 0 })} DZD</td>
                                    <td className="p-3 text-right">
                                        <div className="flex items-center justify-end gap-2">
                                            <div className="w-16 bg-slate-100 rounded-full h-1.5 overflow-hidden">
                                                <div className="bg-blue-500 h-full" style={{ width: `${e.probability}%` }}></div>
                                            </div>
                                            <span className="text-xs font-bold">{e.probability}%</span>
                                        </div>
                                    </td>
                                    <td className="p-3 text-right text-slate-500">{e.date}</td>
                                </tr>
                            ))}
                        </tbody>
                        <tfoot className="bg-slate-50 font-bold border-t">
                            <tr>
                                <td className="p-3" colSpan={2}>PIPELINE VALUE (Top 20)</td>
                                <td className="p-3 text-right text-blue-600">
                                    {entities.reduce((sum, e) => sum + e.value, 0).toLocaleString(undefined, { maximumFractionDigits: 0 })} DZD
                                </td>
                                <td colSpan={2}></td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
            </DialogContent>
        </Dialog>
    );
}
</file>

<file path="src/components/kpi/dialogs/RiskSimulationDialog.tsx">
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
import { Risk } from "@/utils/kpiEngine";

interface RiskSimulationDialogProps {
    isOpen: boolean;
    onClose: () => void;
    risk: Risk | null;
}

export function RiskSimulationDialog({ isOpen, onClose, risk }: RiskSimulationDialogProps) {
    if (!risk) return null;

    const score = risk.prob * risk.impactLevel / 100;
    const severityColor = score > 2.5 ? "bg-red-500" : score > 1.5 ? "bg-orange-500" : "bg-yellow-500";
    const severityText = score > 2.5 ? "Critical" : score > 1.5 ? "High" : "Moderate";

    return (
        <Dialog open={isOpen} onOpenChange={onClose}>
            <DialogContent className="max-w-lg">
                <DialogHeader>
                    <DialogTitle className="text-xl font-bold flex items-center gap-2">
                        ‚ö†Ô∏è Risk Analysis: <span className="text-red-600">{risk.name}</span>
                    </DialogTitle>
                </DialogHeader>

                <div className="space-y-6 mt-4">
                    <div className="grid grid-cols-2 gap-4">
                        <div className="p-4 bg-slate-50 rounded border border-slate-200">
                            <div className="text-xs text-slate-500 uppercase font-bold">Probability</div>
                            <div className="text-3xl font-bold text-slate-800">{risk.prob}%</div>
                            <div className="w-full bg-slate-200 h-2 rounded-full mt-2">
                                <div className="bg-blue-600 h-2 rounded-full" style={{ width: `${risk.prob}%` }}></div>
                            </div>
                        </div>
                        <div className="p-4 bg-slate-50 rounded border border-slate-200">
                            <div className="text-xs text-slate-500 uppercase font-bold">Impact Level</div>
                            <div className="text-3xl font-bold text-slate-800">{risk.impactLevel}<span className="text-sm text-slate-400">/10</span></div>
                            <div className="w-full bg-slate-200 h-2 rounded-full mt-2">
                                <div className="bg-orange-500 h-2 rounded-full" style={{ width: `${risk.impactLevel * 10}%` }}></div>
                            </div>
                        </div>
                    </div>

                    <div className="p-6 bg-slate-100 rounded-lg flex items-center justify-between">
                        <div>
                            <div className="text-sm font-bold text-slate-500">CALCULATED RISK SCORE</div>
                            <div className="text-4xl font-black text-slate-900">{score.toFixed(1)}</div>
                        </div>
                        <div className={`px-4 py-2 rounded text-white font-bold ${severityColor}`}>
                            {severityText} Risk
                        </div>
                    </div>

                    <div>
                        <h4 className="font-bold text-slate-800 mb-2">Mitigation Strategy</h4>
                        <div className="p-4 border border-green-200 bg-green-50 rounded text-green-800">
                            " {risk.mitigation} "
                        </div>
                    </div>
                </div>
            </DialogContent>
        </Dialog>
    );
}
</file>

<file path="src/components/kpi/dialogs/SegmentSimulationDialog.tsx">
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
import { KPIModel, MarketSegment } from "@/utils/kpiEngine";
import { Line } from "react-chartjs-2";
import { Chart as ChartJS, CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend } from 'chart.js';

ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

interface SegmentSimulationDialogProps {
    isOpen: boolean;
    onClose: () => void;
    segment: MarketSegment | null;
    kpi: KPIModel;
}

export function SegmentSimulationDialog({ isOpen, onClose, segment, kpi }: SegmentSimulationDialogProps) {
    if (!segment) return null;

    // Generate constituents if they don't exist
    const constituents = segment.constituents && segment.constituents.length > 0
        ? segment.constituents
        : Array.from({ length: segment.count }).map((_, i) => ({
            id: `gen-${i}`,
            name: `${segment.name} - Organization ${i + 1}`,
            tier: "Standard",
            revenue: segment.price,
            status: "Prospect" as const
        }));

    // Simulation Data for the chart
    const years = [1, 2, 3, 4, 5];
    const targetClients = segment.count * (segment.penRate / 100);
    const yearlyData = years.map(y => {
        const progress = y / 5;
        const clients = Math.ceil(targetClients * progress);
        const revenue = clients * segment.price;
        return { year: y, clients, revenue };
    });

    const chartData = {
        labels: ['Y1', 'Y2', 'Y3', 'Y4', 'Y5'],
        datasets: [
            {
                label: 'Projected Revenue (DZD)',
                data: yearlyData.map(d => d.revenue),
                borderColor: 'rgb(37, 99, 235)',
                backgroundColor: 'rgba(37, 99, 235, 0.5)',
            }
        ],
    };

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: { display: false },
            title: { display: false },
        },
    };

    return (
        <Dialog open={isOpen} onOpenChange={onClose}>
            <DialogContent className="max-w-5xl max-h-[90vh] overflow-y-auto">
                <DialogHeader>
                    <DialogTitle className="text-2xl font-bold flex items-center gap-2">
                        üìã Granular Data: <span className="text-blue-600">{segment.name}</span>
                    </DialogTitle>
                    <DialogDescription>
                        Detailed breakdown of the {segment.count} organizations in this segment.
                    </DialogDescription>
                </DialogHeader>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mt-6">
                    {/* Left: Granular Table */}
                    <div className="md:col-span-2 space-y-4">
                        <h4 className="font-bold text-slate-800 flex items-center gap-2">
                            Entity List <span className="text-xs font-normal text-slate-500">({constituents.length} rows)</span>
                        </h4>
                        <div className="border rounded-lg overflow-hidden">
                            <table className="w-full text-sm text-left">
                                <thead className="bg-slate-50 text-slate-500 font-medium border-b">
                                    <tr>
                                        <th className="p-3">Entity Name</th>
                                        <th className="p-3">Status</th>
                                        <th className="p-3 text-right">Potential ARPU</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y">
                                    {constituents.map((c) => (
                                        <tr key={c.id} className="hover:bg-slate-50">
                                            <td className="p-3 font-medium text-slate-900">{c.name}</td>
                                            <td className="p-3">
                                                <span className={`px-2 py-0.5 rounded-full text-[10px] font-bold uppercase ${c.status === 'Active' ? 'bg-green-100 text-green-700' :
                                                        c.status === 'Lead' ? 'bg-blue-100 text-blue-700' :
                                                            c.status === 'Prospect' ? 'bg-slate-100 text-slate-600' : 'bg-red-50 text-red-600'
                                                    }`}>
                                                    {c.status}
                                                </span>
                                            </td>
                                            <td className="p-3 text-right font-mono text-slate-600">
                                                {c.revenue.toLocaleString()}
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                                <tfoot className="bg-slate-50 font-bold border-t">
                                    <tr>
                                        <td className="p-3" colSpan={2}>TOTAL SEGMENT POTENTIAL</td>
                                        <td className="p-3 text-right text-blue-600">
                                            {(segment.count * segment.price).toLocaleString()} DZD
                                        </td>
                                    </tr>
                                </tfoot>
                            </table>
                        </div>
                    </div>

                    {/* Right: Summary & Simulation */}
                    <div className="space-y-6">
                        <div className="p-4 bg-blue-50 rounded-lg border border-blue-100">
                            <h4 className="font-bold text-blue-800 text-sm mb-3 uppercase tracking-wider">Market Summary</h4>
                            <div className="space-y-3">
                                <div>
                                    <div className="text-[10px] text-blue-600 font-bold">TARGET PENETRATION</div>
                                    <div className="text-xl font-black text-blue-900">{segment.penRate}%</div>
                                </div>
                                <div>
                                    <div className="text-[10px] text-blue-600 font-bold">SOM TARGET (Y5)</div>
                                    <div className="text-xl font-black text-blue-900">
                                        {((segment.count * segment.price * segment.penRate) / 100).toLocaleString()} DZD
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="p-4 bg-slate-50 rounded-lg border border-slate-200">
                            <h4 className="font-bold text-slate-800 text-sm mb-3 uppercase tracking-wider">Growth Simulation</h4>
                            <div className="h-[150px] w-full">
                                <Line data={chartData} options={chartOptions} />
                            </div>
                            <div className="mt-4 space-y-2">
                                {yearlyData.map(d => (
                                    <div key={d.year} className="flex justify-between text-xs border-b border-slate-100 pb-1">
                                        <span className="text-slate-500 font-medium">Year {d.year}</span>
                                        <span className="font-bold text-slate-700">{d.revenue.toLocaleString()}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            </DialogContent>
        </Dialog>
    );
}
</file>

<file path="src/components/kpi/EditableCell.tsx">
import { useState, useEffect, useRef } from "react";
import { useKPI } from "@/contexts/KPIContext";
import { KPIModel } from "@/utils/kpiEngine";
import { cn } from "@/lib/utils";

interface EditableCellProps {
    value: string | number;
    kpiKey?: keyof KPIModel;
    onChange?: (val: string | number) => void;
    suffix?: string;
    className?: string;
    type?: "text" | "number";
}

export function EditableCell({ value, kpiKey, onChange, suffix = "", className, type = "number" }: EditableCellProps) {
    const { updateKPI } = useKPI();
    const [isEditing, setIsEditing] = useState(false);
    const [tempValue, setTempValue] = useState(value);
    const inputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        setTempValue(value);
    }, [value]);

    useEffect(() => {
        if (isEditing && inputRef.current) {
            inputRef.current.focus();
        }
    }, [isEditing]);

    const handleBlur = () => {
        setIsEditing(false);
        if (String(tempValue) !== String(value)) {
            if (onChange) {
                onChange(tempValue);
            } else if (kpiKey) {
                updateKPI(kpiKey, tempValue);
            }
        }
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
        if (e.key === 'Enter') {
            handleBlur();
        }
    };

    if (isEditing) {
        return (
            <div className="flex items-center">
                <input
                    ref={inputRef}
                    type={type === "number" ? "text" : "text"}
                    value={tempValue}
                    onChange={(e) => setTempValue(e.target.value)} // Keep as string until submit for numbers to allow typing
                    onBlur={handleBlur}
                    onKeyDown={handleKeyDown}
                    className={cn("w-full min-w-[60px] rounded-sm border border-blue-500 bg-blue-50 px-1 py-0.5 text-right font-medium text-blue-700 outline-none", className)}
                />
                {suffix && <span className="ml-1 text-slate-400">{suffix}</span>}
            </div>
        );
    }

    return (
        <div
            onClick={() => (kpiKey || onChange) && setIsEditing(true)}
            className={cn(
                "cursor-pointer border-b border-dashed border-slate-400 px-1 py-0.5 text-right transition-colors hover:bg-blue-50 hover:border-blue-500",
                kpiKey ? "text-blue-600 font-medium" : "text-slate-800 cursor-default border-transparent",
                className
            )}
        >
            {value}{suffix}
        </div>
    );
}
</file>

<file path="src/components/kpi/KPISidebar.tsx">
import { ChevronDown, Printer, Save, RotateCcw } from "lucide-react";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible";
import { Button } from "@/components/ui/button";
import { useKPI } from "@/contexts/KPIContext";
import { useState } from "react";
import { cn } from "@/lib/utils";

const ConfigGroup = ({ title, isOpen, onToggle, children }: { title: string, isOpen: boolean, onToggle: () => void, children: React.ReactNode }) => (
    <Collapsible open={isOpen} onOpenChange={onToggle} className="border-b border-slate-700">
        <CollapsibleTrigger className="flex w-full items-center justify-between bg-slate-800 px-5 py-3 text-xs font-bold uppercase text-slate-100 hover:bg-slate-700">
            {title}
            <ChevronDown className={cn("h-4 w-4 transition-transform", isOpen && "rotate-180")} />
        </CollapsibleTrigger>
        <CollapsibleContent className="bg-slate-900 p-5 space-y-2">
            {children}
        </CollapsibleContent>
    </Collapsible>
);

const Inp = ({ label, id, type = "number", step }: { label: string, id: string, type?: string, step?: string }) => {
    const { kpi, updateKPI } = useKPI();
    // @ts-ignore
    const value = kpi[id];

    return (
        <div className="flex items-center justify-between gap-2 text-xs">
            <label className="flex-1 text-slate-300">{label}</label>
            <input
                type={type}
                step={step}
                value={value}
                onChange={(e) => updateKPI(id as any, e.target.value)}
                className="w-24 rounded border border-slate-600 bg-slate-800 px-2 py-1 text-right font-mono text-white focus:border-blue-500 focus:outline-none"
            />
        </div>
    );
};

export function KPISidebar() {
    const { resetDefaults, exportData } = useKPI();
    const [openSection, setOpenSection] = useState<string>("market");

    const toggle = (section: string) => {
        setOpenSection(openSection === section ? "" : section);
    };

    return (
        <div className="flex h-screen w-[400px] flex-col border-r border-slate-700 bg-slate-800 text-white overflow-y-auto">
            <div className="border-b border-slate-700 bg-slate-900/50 p-5">
                <h1 className="text-xl font-extrabold text-white">
                    SportData<span className="text-blue-500">Analytics</span>
                    <span className="ml-2 rounded bg-blue-600 px-2 py-0.5 text-[10px] text-white">KPI Engine v2.5</span>
                </h1>
                <p className="mt-2 text-xs text-slate-400">Interactive Business Model Calculator</p>
            </div>

            <ConfigGroup title="1. Growth & Adoption" isOpen={openSection === "growth"} onToggle={() => toggle("growth")}>
                <Inp label="New clients Y1" id="g_y1" />
                <Inp label="New clients Y2" id="g_y2" />
                <Inp label="New clients Y3" id="g_y3" />
                <Inp label="New clients Y4" id="g_y4" />
                <Inp label="New clients Y5" id="g_y5" />
                <Inp label="Churn Y1 (%)" id="ch_y1" />
                <Inp label="Churn Y2 (%)" id="ch_y2" />
                <Inp label="Churn stable (%)" id="ch_stable" />
            </ConfigGroup>

            <ConfigGroup title="4. Revenue Streams" isOpen={openSection === "revenue"} onToggle={() => toggle("revenue")}>
                <Inp label="SaaS subscriptions (%)" id="rev_saas" />
                <Inp label="Training & cert (%)" id="rev_train" />
                <Inp label="Prof services (%)" id="rev_prof" />
            </ConfigGroup>

            <ConfigGroup title="5. Operating Costs" isOpen={openSection === "costs"} onToggle={() => toggle("costs")}>
                <Inp label="Team headcount Y1" id="c_head" />
                <Inp label="Hires per year" id="c_hire" step="0.1" />
                <Inp label="Net salary/mo (DZD)" id="c_sal" />
                <Inp label="CNAS load (%)" id="tax_cnas" />
                <Inp label="Payroll % of costs" id="c_pay_pct" />
                <Inp label="Infra % of costs" id="c_infra_pct" />
                <Inp label="Marketing % of costs" id="c_mkt_pct" />
                <Inp label="Ops % of costs" id="c_ops_pct" />
            </ConfigGroup>

            <ConfigGroup title="6. Sales KPIs" isOpen={openSection === "sales"} onToggle={() => toggle("sales")}>
                <Inp label="Sales cycle (months)" id="s_cycle" />
                <Inp label="Lead‚ÜíDemo conv (%)" id="s_lead" />
                <Inp label="Demo‚ÜíPOC conv (%)" id="s_demo" />
                <Inp label="POC‚ÜíClient conv (%)" id="s_poc" />
                <Inp label="Sales comm (%)" id="s_comm" />
                <Inp label="CAC (k DZD)" id="s_cac" />
            </ConfigGroup>

            <ConfigGroup title="7. Distribution Channels" isOpen={openSection === "channels"} onToggle={() => toggle("channels")}>
                <Inp label="B2B Direct (%)" id="ch_b2b" />
                <Inp label="Institutional (%)" id="ch_inst" />
                <Inp label="Inter-club ref (%)" id="ch_ref" />
            </ConfigGroup>

            <ConfigGroup title="8. Fiscal & Cash Flow" isOpen={openSection === "fiscal"} onToggle={() => toggle("fiscal")}>
                <Inp label="Payment delay (mo)" id="cash_delay" />
                <Inp label="TVA (%)" id="tax_tva" />
                <Inp label="IBS corp tax (%)" id="tax_ibs" />
                <Inp label="Gross margin (%)" id="f_margin" />
            </ConfigGroup>

            <ConfigGroup title="9. Unit Economics" isOpen={openSection === "unit"} onToggle={() => toggle("unit")}>
                <Inp label="LTV (k DZD)" id="u_ltv" />
                <Inp label="LTV/CAC target" id="u_ltv_cac" step="0.1" />
                <Inp label="Break-even clients" id="u_breakeven" />
            </ConfigGroup>

            <ConfigGroup title="10. Funding Strategy" isOpen={openSection === "funding"} onToggle={() => toggle("funding")}>
                <Inp label="Seed ask (M DZD)" id="inv_seed" step="0.1" />
                <Inp label="Pre-money val (M DZD)" id="inv_pre" step="0.1" />
                <Inp label="Series A ask (M DZD)" id="inv_a" step="0.5" />
                <Inp label="Phase 1 budget (k DZD)" id="bud_p1" />
                <Inp label="Phase 2 budget (k DZD)" id="bud_p2" />
                <Inp label="Phase 3 budget (k DZD)" id="bud_p3" />
            </ConfigGroup>

            <div className="mt-auto border-t border-slate-700 p-5 space-y-3">
                <Button className="w-full bg-blue-600 hover:bg-blue-700" onClick={() => window.print()}>
                    <Printer className="mr-2 h-4 w-4" /> Print Report
                </Button>
                <div className="grid grid-cols-2 gap-3">
                    <Button variant="outline" className="border-slate-600 bg-transparent text-slate-300 hover:bg-slate-700" onClick={exportData}>
                        <Save className="mr-2 h-4 w-4" /> Export
                    </Button>
                    <Button variant="outline" className="border-slate-600 bg-transparent text-slate-300 hover:bg-slate-700" onClick={resetDefaults}>
                        <RotateCcw className="mr-2 h-4 w-4" /> Reset
                    </Button>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="src/components/kpi/tabs/BusinessModelTab.tsx">
import { useKPI } from "@/contexts/KPIContext";

const fmt = (n: number) => {
    if (Math.abs(n) >= 1000000) return (n / 1000000).toFixed(2) + 'M';
    if (Math.abs(n) >= 1000) return (n / 1000).toFixed(0) + 'k';
    return n.toFixed(0);
};

export function BusinessModelTab() {
    const { kpi, metrics } = useKPI();
    const { breakEvenClients } = metrics;

    return (
        <div className="mx-auto w-[210mm] min-h-auto bg-white p-[20mm] shadow-lg rounded-lg">
            <h2 className="text-2xl font-bold text-slate-900 mb-2">Business Model Canvas</h2>
            <p className="mb-6 text-sm text-slate-500">Complete business model visualization with live data integration</p>

            <div className="grid grid-cols-5 gap-3">
                {/* KEY PARTNERS */}
                <div className="row-span-2 rounded bg-slate-50 p-4 border border-slate-200 text-xs">
                    <h4 className="mb-2 font-bold text-blue-600 uppercase tracking-wide">ü§ù Key Partners</h4>
                    <ul className="list-disc pl-4 space-y-1 text-slate-700">
                        <li><strong>Institutional:</strong> FAF, LFP, DTN</li>
                        <li><strong>Technical:</strong> ISSAL NET (hosting), Chargily Pay</li>
                        <li><strong>Training:</strong> ESSTS, former internationals</li>
                    </ul>
                </div>

                {/* KEY ACTIVITIES */}
                <div className="rounded bg-slate-50 p-4 border border-slate-200 text-xs">
                    <h4 className="mb-2 font-bold text-blue-600 uppercase tracking-wide">üîß Key Activities</h4>
                    <ul className="list-disc pl-4 space-y-1 text-slate-700">
                        <li>Product development (MVP)</li>
                        <li>Consultative selling</li>
                        <li>Integrated training</li>
                        <li>Compliance management</li>
                    </ul>
                </div>

                {/* VALUE PROPOSITION */}
                <div className="rounded bg-slate-50 p-4 border border-slate-200 text-xs">
                    <h4 className="mb-2 font-bold text-blue-600 uppercase tracking-wide">üíé Value Proposition</h4>
                    <ul className="list-disc pl-4 space-y-1 text-slate-700">
                        <li>‚úÖ 100% Law 25-11 compliant</li>
                        <li>üåç AR/FR interface</li>
                        <li>üéì Guaranteed adoption training</li>
                        <li>üë®‚Äçüíº Premium on-site support</li>
                        <li>üìä Local football expertise</li>
                    </ul>
                </div>

                {/* CUSTOMER RELATIONS */}
                <div className="rounded bg-slate-50 p-4 border border-slate-200 text-xs">
                    <h4 className="mb-2 font-bold text-blue-600 uppercase tracking-wide">ü§ó Customer Relations</h4>
                    <ul className="list-disc pl-4 space-y-1 text-slate-700">
                        <li>Dedicated account mgmt (1:8-10)</li>
                        <li>Mandatory in-person training</li>
                        <li>24/7 post-training support</li>
                        <li>Community building</li>
                    </ul>
                </div>

                {/* CUSTOMER SEGMENTS */}
                <div className="row-span-2 rounded bg-slate-50 p-4 border border-slate-200 text-xs">
                    <h4 className="mb-2 font-bold text-blue-600 uppercase tracking-wide">üë• Customer Segments</h4>
                    <ul className="list-disc pl-4 space-y-1 text-slate-700">
                        {kpi.marketSegments.map(s => (
                            <li key={s.id}><strong>{s.name} ({s.count}):</strong> {fmt(s.price)} DZD</li>
                        ))}
                    </ul>
                </div>

                {/* KEY RESOURCES */}
                <div className="rounded bg-slate-50 p-4 border border-slate-200 text-xs">
                    <h4 className="mb-2 font-bold text-blue-600 uppercase tracking-wide">üéØ Key Resources</h4>
                    <ul className="list-disc pl-4 space-y-1 text-slate-700">
                        <li>Expert local team (CEO, CTO, Training)</li>
                        <li>Compliant infrastructure (local hosting)</li>
                        <li>IP (methodology, interfaces)</li>
                        <li>Institutional relations (FAF/LFP)</li>
                    </ul>
                </div>

                {/* CHANNELS */}
                <div className="col-span-2 rounded bg-slate-50 p-4 border border-slate-200 text-xs">
                    <h4 className="mb-2 font-bold text-blue-600 uppercase tracking-wide">üì° Channels</h4>
                    <ul className="list-disc pl-4 space-y-1 text-slate-700">
                        <li><strong>B2B Direct ({kpi.ch_b2b}%):</strong> Relationship prospecting, long cycles</li>
                        <li><strong>Institutional ({kpi.ch_inst}%):</strong> FAF/LFP endorsements</li>
                        <li><strong>Inter-Club ({kpi.ch_ref}%):</strong> Ambassador program</li>
                    </ul>
                </div>

                {/* REVENUE STREAMS */}
                <div className="col-span-2 rounded bg-slate-50 p-4 border border-slate-200 text-xs">
                    <h4 className="mb-2 font-bold text-blue-600 uppercase tracking-wide">üí∞ Revenue Streams</h4>
                    <ul className="list-disc pl-4 space-y-1 text-slate-700">
                        <li><strong>SaaS Subscriptions ({kpi.rev_saas}%):</strong> Varies by segment ({fmt(Math.min(...kpi.marketSegments.map(s => s.price)))} - {fmt(Math.max(...kpi.marketSegments.map(s => s.price)))} DZD)</li>
                        <li><strong>Training & Certification ({kpi.rev_train}%):</strong> Recurring annual fees</li>
                        <li><strong>Professional Services ({kpi.rev_prof}%):</strong> Consulting, customization</li>
                        <li><strong>ARPU Average:</strong> {fmt(kpi.p_arpu)} DZD/year</li>
                    </ul>
                </div>

                {/* COST STRUCTURE */}
                <div className="col-span-2 rounded bg-slate-50 p-4 border border-slate-200 text-xs">
                    <h4 className="mb-2 font-bold text-blue-600 uppercase tracking-wide">üí∏ Cost Structure</h4>
                    <ul className="list-disc pl-4 space-y-1 text-slate-700">
                        <li><strong>Fixed Costs Dominant:</strong> Break-even at {breakEvenClients.toFixed(0)} customers</li>
                        <li><strong>Team Salaries ({kpi.c_pay_pct}%):</strong> Main cost item</li>
                        <li><strong>Infrastructure ({kpi.c_infra_pct}%):</strong> Hosting, security, compliance</li>
                        <li><strong>Marketing & Sales ({kpi.c_mkt_pct}%):</strong> Prospecting, events, travel</li>
                        <li><strong>Operations ({kpi.c_ops_pct}%):</strong> Support, admin, legal</li>
                    </ul>
                </div>

            </div>
        </div>
    );
}
</file>

<file path="src/components/kpi/tabs/DashboardTab.tsx">
import { useKPI } from "@/contexts/KPIContext";
import { Bar, Line } from "react-chartjs-2";
import {
    Chart as ChartJS,
    CategoryScale,
    LinearScale,
    BarElement,
    Title,
    Tooltip,
    Legend,
    PointElement,
    LineElement,
    Filler
} from "chart.js";

// Register ChartJS components
ChartJS.register(
    CategoryScale,
    LinearScale,
    BarElement,
    Title,
    Tooltip,
    Legend,
    PointElement,
    LineElement,
    Filler
);

function KPICard({ title, value, sub }: { title: string, value: string, sub: string }) {
    return (
        <div className="rounded-xl border border-slate-200 bg-white p-5 shadow-sm">
            <div className="mb-2 text-[10px] font-bold uppercase tracking-wider text-slate-500">{title}</div>
            <div className="mb-1 text-2xl font-extrabold text-slate-900">{value}</div>
            <div className="text-[11px] text-slate-400">{sub}</div>
        </div>
    );
}

const fmt = (n: number) => {
    if (Math.abs(n) >= 1000000) return (n / 1000000).toFixed(2) + 'M';
    if (Math.abs(n) >= 1000) return (n / 1000).toFixed(0) + 'k';
    return n.toFixed(0);
};

const fmtPct = (n: number) => n.toFixed(1) + '%';

export function DashboardTab() {
    const { metrics, kpi } = useKPI();
    const { y5, years, cashFlow } = metrics;

    // Charts Data
    const revenueData = {
        labels: years.map(y => `Y${y.year}`),
        datasets: [
            { label: 'ARR', data: years.map(y => y.arr / 1000), backgroundColor: '#10b981', stack: 'revenue' },
            { label: 'Personnel', data: years.map(y => y.personnel / 1000), backgroundColor: '#ef4444', stack: 'costs' },
            { label: 'Other OpEx', data: years.map(y => (y.totalCosts - y.personnel) / 1000), backgroundColor: '#f59e0b', stack: 'costs' }
        ]
    };

    const cashData = {
        labels: cashFlow.map(c => `Y${c.year}`),
        datasets: [{
            label: 'Cumulative Cash',
            data: cashFlow.map(c => c.cumulativeCash / 1000),
            borderColor: '#2563eb',
            backgroundColor: 'rgba(37,99,235,0.1)',
            fill: true,
            tension: 0.4
        }]
    };

    const options = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { position: 'bottom' as const } }
    };

    let alertColor = "bg-green-100 text-green-800";
    let alertText = `‚úÖ PROFITABLE: Y5 net income of ${fmt(y5.netIncome)} DZD with ${fmtPct(y5.margin)} margin. Strong unit economics support expansion.`;

    if (metrics.minCash < 0) {
        alertColor = "bg-red-100 text-red-800";
        alertText = `‚ö†Ô∏è CASH DEFICIT: Minimum cash balance reaches ${fmt(metrics.minCash)} DZD. Additional funding required before Phase 1 completion.`;
    } else if (y5.netIncome < 0) {
        alertColor = "bg-amber-100 text-amber-800";
        alertText = `‚ö†Ô∏è VALIDATION PHASE: Y5 net loss of ${fmt(Math.abs(y5.netIncome))} DZD. Phase 1 serves as market validation. Series A expansion to Maghreb essential for profitability.`;
    }

    return (
        <div className="mx-auto w-[210mm] min-h-[297mm] bg-white p-[20mm] shadow-lg rounded-lg">
            <h2 className="mb-2 text-2xl font-bold text-slate-900">Executive Dashboard</h2>
            <p className="mb-6 text-sm text-slate-500">
                Live 5-year projection engine. <span className="text-blue-600 font-medium">Tip: Use the sidebar to update the model.</span>
            </p>

            <div className={`mb-6 rounded-lg p-4 text-sm font-medium ${alertColor}`}>
                {alertText}
            </div>

            <h3 className="mb-4 mt-8 border-b-2 border-slate-200 pb-2 text-lg font-bold text-slate-900">Key Performance Indicators (Year 5)</h3>
            <div className="grid grid-cols-5 gap-4 mb-8">
                <KPICard title="ARR" value={fmt(y5.arr)} sub="DZD Annual Recurring" />
                <KPICard title="Active Clients" value={y5.activeClients.toFixed(1)} sub="After churn" />
                <KPICard title="Net Margin" value={fmtPct(y5.margin)} sub="EBITDA margin" />
                <KPICard title="LTV/CAC" value={metrics.ltv_cac.toFixed(1)} sub="Unit economics" />
                <KPICard title="Cash Position" value={fmt(metrics.minCash)} sub="Minimum runway" />
            </div>

            <h3 className="mb-4 mt-8 border-b-2 border-slate-200 pb-2 text-lg font-bold text-slate-900">5-Year Revenue & Cost Projection</h3>
            <div className="h-[300px] w-full mb-8">
                {/* @ts-ignore */}
                <Bar data={revenueData} options={options} />
            </div>

            <h3 className="mb-4 mt-8 border-b-2 border-slate-200 pb-2 text-lg font-bold text-slate-900">Cash Flow Evolution</h3>
            <div className="h-[300px] w-full mb-8">
                <Line data={cashData} options={options} />
            </div>

            <h3 className="mb-4 mt-8 border-b-2 border-slate-200 pb-2 text-lg font-bold text-slate-900">Market Penetration Progress</h3>
            <div className="grid grid-cols-5 gap-4">
                <KPICard title="TAM" value={fmt(metrics.tam)} sub="Total addressable" />
                <KPICard title="SAM" value={fmt(metrics.sam)} sub="Serviceable addressable" />
                <KPICard title="SOM" value={fmt(metrics.som)} sub="Serviceable obtainable" />
                <KPICard title="Penetration" value={fmtPct((y5.arr / metrics.tam) * 100)} sub="Of TAM" />
                <KPICard title="Market Share" value={fmtPct((y5.activeClients / kpi.marketSegments.reduce((sum, s) => sum + s.count, 0)) * 100)} sub="Target segment" />
            </div>
        </div>
    );
}
</file>

<file path="src/components/kpi/tabs/DataSourcesTab.tsx">
import { useKPI } from "@/contexts/KPIContext";

const fmt = (n: number) => {
    if (Math.abs(n) >= 1000000) return (n / 1000000).toFixed(2) + 'M';
    if (Math.abs(n) >= 1000) return (n / 1000).toFixed(0) + 'k';
    return n.toFixed(0);
};

const fmtPct = (n: number) => n.toFixed(1) + '%';

export function DataSourcesTab() {
    const { kpi, metrics } = useKPI();
    const { y5, ltv, ltv_cac, breakEvenClients, tam } = metrics;

    const sources = [
        { metric: 'TAM (Total Addressable)', value: fmt(tam), source: 'ms.txt + bp.txt', calc: 'Sum of all segment sizes √ó respective ARPU' },
        { metric: 'Market Segments', value: `${kpi.marketSegments.reduce((sum, s) => sum + s.count, 0)} orgs`, source: 'ms.txt', calc: 'L1 Elite + L1 Std + L2 Prog + FAF' },
        { metric: 'ARPU Average', value: fmt(kpi.p_arpu), source: 'bp.txt', calc: 'Weighted average across pricing tiers' },
        { metric: 'Y5 Active Clients', value: y5.activeClients.toFixed(1), source: 'Calculated', calc: 'Active(n-1) √ó (1-Churn) + New(n)' },
        { metric: 'Churn Rate (stable)', value: fmtPct(kpi.ch_stable), source: 'bp.txt', calc: 'Industry benchmark for B2B SaaS' },
        { metric: 'CAC', value: fmt(kpi.s_cac * 1000), source: 'bp.txt + benchmarks', calc: 'Sales & marketing costs / new clients' },
        { metric: 'LTV', value: fmt(ltv), source: 'Calculated', calc: 'ARPU / Churn Rate' },
        { metric: 'LTV/CAC Ratio', value: ltv_cac.toFixed(1), source: 'bp.txt', calc: 'LTV / CAC (target >3:1)' },
        { metric: 'Gross Margin', value: kpi.f_margin + '%', source: 'bp.txt', calc: 'SaaS industry standard' },
        { metric: 'Team Headcount Y5', value: y5.headcount.toFixed(1), source: 'Calculated', calc: 'Base + (years √ó hire rate)' },
        { metric: 'Payroll Y5', value: fmt(y5.personnel), source: 'Calculated', calc: 'Headcount √ó salary √ó (1 + CNAS load)' },
        { metric: 'Break-even Clients', value: breakEvenClients.toFixed(0), source: 'Calculated', calc: 'Total costs / ARPU' },
        { metric: 'Seed Investment', value: fmt(kpi.inv_seed * 1000000), source: 'bp.txt', calc: 'Phase 1 validation funding' },
        { metric: 'Series A Target', value: fmt(kpi.inv_a * 1000000), source: 'bp.txt', calc: 'Phase 2 expansion funding' }
    ];

    return (
        <div className="mx-auto w-[210mm] min-h-[297mm] bg-white p-[20mm] shadow-lg rounded-lg space-y-8">
            <div>
                <h2 className="text-2xl font-bold text-slate-900">Data Sources & Calculations</h2>
                <p className="mb-6 text-sm text-slate-500">Complete methodology and source documentation for all metrics</p>
            </div>

            {/* PRIMARY METRICS */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Primary Metrics & Sources</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Metric</th>
                            <th className="p-2 text-left">Current Value</th>
                            <th className="p-2 text-left">Source Document</th>
                            <th className="p-2 text-left">Calculation Method</th>
                        </tr>
                    </thead>
                    <tbody>
                        {sources.map((s, i) => (
                            <tr key={i} className="border-b border-slate-100 last:border-0 hover:bg-slate-50">
                                <td className="p-2 font-medium text-slate-700">{s.metric}</td>
                                <td className="p-2 font-bold text-slate-900">{s.value}</td>
                                <td className="p-2 text-slate-500">{s.source}</td>
                                <td className="p-2 text-slate-500 text-xs">{s.calc}</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* FORMULA REFERENCE */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Formula Reference</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Metric</th>
                            <th className="p-2 text-left">Formula</th>
                            <th className="p-2 text-left">Variables</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td className="p-2 font-medium">TAM</td>
                            <td className="p-2 font-mono text-xs">Œ£(Segment Size √ó ARPU)</td>
                            <td className="p-2 text-slate-500">Market segments, pricing tiers</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">Active Clients</td>
                            <td className="p-2 font-mono text-xs">Active(n-1) √ó (1-Churn) + New(n)</td>
                            <td className="p-2 text-slate-500">Previous clients, churn rate, new acquisitions</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">ARR</td>
                            <td className="p-2 font-mono text-xs">Active Clients √ó ARPU Average</td>
                            <td className="p-2 text-slate-500">Client count, average revenue per user</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">EBITDA</td>
                            <td className="p-2 font-mono text-xs">ARR - Total Operating Costs</td>
                            <td className="p-2 text-slate-500">Revenue, personnel, infrastructure, marketing, ops</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">LTV</td>
                            <td className="p-2 font-mono text-xs">ARPU / Churn Rate</td>
                            <td className="p-2 text-slate-500">Average revenue, stabilized churn</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            {/* DOCUMENT FILES */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Document References</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Document</th>
                            <th className="p-2 text-left">Key Metrics Extracted</th>
                            <th className="p-2 text-left">Last Updated</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td className="p-2 font-bold">bp.txt</td>
                            <td className="p-2">Financial projections, cost structure, revenue model</td>
                            <td className="p-2 text-slate-500">Dec 2025</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-bold">bm.txt</td>
                            <td className="p-2">Business model canvas, value proposition, segments</td>
                            <td className="p-2 text-slate-500">Dec 2025</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-bold">ms.txt</td>
                            <td className="p-2">Market analysis, TAM/SAM/SOM, competition</td>
                            <td className="p-2 text-slate-500">Sep 2025</td>
                        </tr>
                    </tbody>
                </table>
            </div>

        </div>
    );
}
</file>

<file path="src/components/kpi/tabs/FinancialsTab.tsx">
import { useKPI } from "@/contexts/KPIContext";
import { EditableCell } from "../EditableCell";

const fmt = (n: number) => {
    if (Math.abs(n) >= 1000000) return (n / 1000000).toFixed(2) + 'M';
    if (Math.abs(n) >= 1000) return (n / 1000).toFixed(0) + 'k';
    return n.toFixed(0);
};

export function FinancialsTab() {
    const { kpi, metrics } = useKPI();
    const { years, cashFlow, y5, breakEvenClients, breakEvenARR } = metrics;

    return (
        <div className="mx-auto w-[210mm] min-h-[297mm] bg-white p-[20mm] shadow-lg rounded-lg space-y-8">
            <div>
                <h2 className="text-2xl font-bold text-slate-900">Financial Projections & P&L</h2>
                <div className="mt-2 rounded bg-amber-50 p-3 text-sm text-amber-900 border border-amber-200">
                    <strong>‚ö†Ô∏è Break-Even Analysis:</strong> Break-even requires <strong>{breakEvenClients.toFixed(0)} clients</strong> generating <strong>{fmt(breakEvenARR)} DZD ARR</strong>.
                    Phase 1 TAM limitation makes standalone profitability challenging. Phase 2 expansion essential for long-term viability.
                </div>
            </div>

            {/* P&L */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">5-Year P&L Statement (Projections)</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Year</th>
                            <th className="p-2 text-right">Clients</th>
                            <th className="p-2 text-right">ARR</th>
                            <th className="p-2 text-right">Personnel</th>
                            <th className="p-2 text-right">Other OpEx</th>
                            <th className="p-2 text-right">EBITDA</th>
                            <th className="p-2 text-right">Tax</th>
                            <th className="p-2 text-right">Net Income</th>
                        </tr>
                    </thead>
                    <tbody>
                        {years.map(y => (
                            <tr key={y.year}>
                                <td className="p-2 font-bold text-slate-700">Y{y.year}</td>
                                <td className="p-2 text-right">{y.activeClients.toFixed(1)}</td>
                                <td className="p-2 text-right font-medium">{fmt(y.arr)}</td>
                                <td className="p-2 text-right text-slate-500">{fmt(y.personnel)}</td>
                                <td className="p-2 text-right text-slate-500">{fmt(y.infrastructure + y.marketing + y.operations)}</td>
                                <td className="p-2 text-right font-medium">{fmt(y.ebitda)}</td>
                                <td className="p-2 text-right text-slate-400">{fmt(y.tax)}</td>
                                <td className={`p-2 text-right font-bold ${y.netIncome > 0 ? "text-green-600" : "text-red-500"}`}>
                                    {fmt(y.netIncome)}
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* CASH FLOW */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Cash Flow Analysis</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Year</th>
                            <th className="p-2 text-right">Cash In</th>
                            <th className="p-2 text-right">Cash Out</th>
                            <th className="p-2 text-right">Net Cash Flow</th>
                            <th className="p-2 text-right">Cumulative Cash</th>
                        </tr>
                    </thead>
                    <tbody>
                        {cashFlow.map(c => (
                            <tr key={c.year}>
                                <td className="p-2 font-bold text-slate-700">Y{c.year}</td>
                                <td className="p-2 text-right text-green-700">{fmt(c.cashIn)}</td>
                                <td className="p-2 text-right text-red-700">{fmt(c.cashOut)}</td>
                                <td className={`p-2 text-right font-medium ${c.netCashFlow > 0 ? "text-green-600" : "text-red-600"}`}>
                                    {fmt(c.netCashFlow)}
                                </td>
                                <td className="p-2 text-right text-blue-700 font-bold">{fmt(c.cumulativeCash)}</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* REVENUE STREAMS */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Revenue Breakdown by Stream</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Stream</th>
                            <th className="p-2 text-right">Mix (%)</th>
                            <th className="p-2 text-right">Y1 Revenue</th>
                            <th className="p-2 text-right">Y5 Revenue</th>
                            <th className="p-2 text-right">Margin</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td className="p-2 font-medium text-blue-600">SaaS Subscriptions</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.rev_saas} kpiKey="rev_saas" suffix="%" /></td>
                            <td className="p-2 text-right">{fmt(years[0].arr * kpi.rev_saas / 100)}</td>
                            <td className="p-2 text-right font-bold">{fmt(y5.arr * kpi.rev_saas / 100)}</td>
                            <td className="p-2 text-right text-slate-500">85%</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium text-blue-600">Training & Certification</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.rev_train} kpiKey="rev_train" suffix="%" /></td>
                            <td className="p-2 text-right">{fmt(years[0].arr * kpi.rev_train / 100)}</td>
                            <td className="p-2 text-right font-bold">{fmt(y5.arr * kpi.rev_train / 100)}</td>
                            <td className="p-2 text-right text-slate-500">90%</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium text-blue-600">Professional Services</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.rev_prof} kpiKey="rev_prof" suffix="%" /></td>
                            <td className="p-2 text-right">{fmt(years[0].arr * kpi.rev_prof / 100)}</td>
                            <td className="p-2 text-right font-bold">{fmt(y5.arr * kpi.rev_prof / 100)}</td>
                            <td className="p-2 text-right text-slate-500">65%</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            {/* COST STRUCTURE */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Cost Structure Detail</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Category</th>
                            <th className="p-2 text-right">Alloc. (%)</th>
                            <th className="p-2 text-right">Y1 Cost</th>
                            <th className="p-2 text-right">Y5 Cost</th>
                            <th className="p-2 text-right">Growth</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td className="p-2 font-medium text-blue-600">Team Salaries</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.c_pay_pct} kpiKey="c_pay_pct" suffix="%" /></td>
                            <td className="p-2 text-right">{fmt(y5.personnel * (years[0].totalCosts / y5.totalCosts))}</td>
                            <td className="p-2 text-right">{fmt(y5.personnel)}</td>
                            <td className="p-2 text-right text-slate-500">
                                +{((y5.personnel / (y5.personnel * (years[0].totalCosts / y5.totalCosts)) - 1) * 100).toFixed(0)}%
                            </td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium text-blue-600">Infrastructure</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.c_infra_pct} kpiKey="c_infra_pct" suffix="%" /></td>
                            <td className="p-2 text-right">{fmt(y5.infrastructure * (years[0].totalCosts / y5.totalCosts))}</td>
                            <td className="p-2 text-right">{fmt(y5.infrastructure)}</td>
                            <td className="p-2 text-right text-slate-500">
                                +{((y5.infrastructure / (y5.infrastructure * (years[0].totalCosts / y5.totalCosts)) - 1) * 100).toFixed(0)}%
                            </td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium text-blue-600">Marketing & Sales</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.c_mkt_pct} kpiKey="c_mkt_pct" suffix="%" /></td>
                            <td className="p-2 text-right">{fmt(y5.marketing * (years[0].totalCosts / y5.totalCosts))}</td>
                            <td className="p-2 text-right">{fmt(y5.marketing)}</td>
                            <td className="p-2 text-right text-slate-500">
                                +{((y5.marketing / (y5.marketing * (years[0].totalCosts / y5.totalCosts)) - 1) * 100).toFixed(0)}%
                            </td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium text-blue-600">Operations</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.c_ops_pct} kpiKey="c_ops_pct" suffix="%" /></td>
                            <td className="p-2 text-right">{fmt(y5.operations * (years[0].totalCosts / y5.totalCosts))}</td>
                            <td className="p-2 text-right">{fmt(y5.operations)}</td>
                            <td className="p-2 text-right text-slate-500">
                                +{((y5.operations / (y5.operations * (years[0].totalCosts / y5.totalCosts)) - 1) * 100).toFixed(0)}%
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

        </div>
    );
}
</file>

<file path="src/components/kpi/tabs/MarketTab.tsx">
import { useKPI } from "@/contexts/KPIContext";
import { EditableCell } from "../EditableCell";
import { Plus, Trash2, Eye } from "lucide-react";
import { useState } from "react";
import { MarketSegment, Competitor, Risk } from "@/utils/kpiEngine";
import { SegmentSimulationDialog } from "../dialogs/SegmentSimulationDialog";
import { CompetitorDetailDialog } from "../dialogs/CompetitorDetailDialog";
import { RiskSimulationDialog } from "../dialogs/RiskSimulationDialog";
import { FunnelDrilldownDialog } from "../dialogs/FunnelDrilldownDialog";

const fmt = (n: number) => {
    if (Math.abs(n) >= 1000000) return (n / 1000000).toFixed(2) + 'M';
    if (Math.abs(n) >= 1000) return (n / 1000).toFixed(0) + 'k';
    return n.toFixed(0);
};

export function MarketTab() {
    const { kpi, metrics, updateKPI } = useKPI();
    const { tam, sam, som } = metrics;

    // Dialog State
    const [selectedSegment, setSelectedSegment] = useState<MarketSegment | null>(null);
    const [selectedCompetitor, setSelectedCompetitor] = useState<Competitor | null>(null);
    const [selectedRisk, setSelectedRisk] = useState<Risk | null>(null);
    const [selectedFunnelStage, setSelectedFunnelStage] = useState<string | null>(null);
    const [funnelTargetCount, setFunnelTargetCount] = useState<number>(0);

    // Funnel Calculations
    const estimatedClients = (kpi.g_y1 + kpi.g_y2) / 2;
    const overallConv = (kpi.s_lead * kpi.s_demo * kpi.s_poc / 10000) / 100;
    const neededLeads = estimatedClients / overallConv;

    // Segment Handlers
    const updateSegment = (id: string, field: string, value: any) => {
        const newSegments = kpi.marketSegments.map(s => {
            if (s.id === id) return { ...s, [field]: Number(value) || value };
            return s;
        });
        updateKPI("marketSegments", newSegments);
    };

    const addSegment = () => {
        const newId = (Math.max(0, ...kpi.marketSegments.map(s => Number(s.id))) + 1).toString();
        const newSegments = [...kpi.marketSegments, {
            id: newId,
            name: "New Segment",
            count: 10,
            price: 50000,
            penRate: 10
        }];
        updateKPI("marketSegments", newSegments);
    };

    const deleteSegment = (id: string) => {
        const newSegments = kpi.marketSegments.filter(s => s.id !== id);
        updateKPI("marketSegments", newSegments);
    };

    // Calculate dynamic totals
    const totalOrgs = kpi.marketSegments.reduce((sum, s) => sum + s.count, 0);

    // Competitor Handlers
    const updateCompetitor = (id: string, field: string, value: any) => {
        const newComps = kpi.competitors.map(c => {
            if (c.id === id) return { ...c, [field]: value };
            return c;
        });
        updateKPI("competitors", newComps);
    };

    const addCompetitor = () => {
        const newId = (Math.max(0, ...kpi.competitors.map(s => Number(s.id))) + 1).toString();
        const newComps = [...kpi.competitors, {
            id: newId,
            name: "New Competitor",
            threat: "Med",
            strength: "Strength",
            advantage: "Our Advantage"
        }];
        updateKPI("competitors", newComps);
    };

    const deleteCompetitor = (id: string) => {
        updateKPI("competitors", kpi.competitors.filter(c => c.id !== id));
    };

    // Risk Handlers
    const updateRisk = (id: string, field: string, value: any) => {
        const newRisks = kpi.risks.map(r => {
            if (r.id === id) return { ...r, [field]: field === 'prob' || field === 'impactLevel' ? Number(value) : value };
            return r;
        });
        updateKPI("risks", newRisks);
    };

    const addRisk = () => {
        const newId = (Math.max(0, ...kpi.risks.map(s => Number(s.id))) + 1).toString();
        const newRisks = [...kpi.risks, {
            id: newId,
            name: "New Risk",
            prob: 30,
            impactLevel: 2,
            impact: "Medium",
            score: 0.6,
            mitigation: "Mitigation plan"
        }];
        updateKPI("risks", newRisks);
    };

    const deleteRisk = (id: string) => {
        updateKPI("risks", kpi.risks.filter(r => r.id !== id));
    };


    return (
        <div className="mx-auto w-[210mm] min-h-[297mm] bg-white p-[20mm] shadow-lg rounded-lg space-y-8 relative">

            {/* Simulation Dialogs */}
            <SegmentSimulationDialog
                isOpen={!!selectedSegment}
                onClose={() => setSelectedSegment(null)}
                segment={selectedSegment}
                kpi={kpi}
            />
            <CompetitorDetailDialog
                isOpen={!!selectedCompetitor}
                onClose={() => setSelectedCompetitor(null)}
                competitor={selectedCompetitor}
            />
            <RiskSimulationDialog
                isOpen={!!selectedRisk}
                onClose={() => setSelectedRisk(null)}
                risk={selectedRisk}
            />
            <FunnelDrilldownDialog
                isOpen={!!selectedFunnelStage}
                onClose={() => setSelectedFunnelStage(null)}
                stage={selectedFunnelStage}
                targetCount={funnelTargetCount}
            />

            <div>
                <h2 className="text-2xl font-bold text-slate-900">Market Analysis & Segmentation</h2>
                <div className="mt-2 rounded bg-blue-50 p-2 text-xs text-blue-700 flex justify-between items-center">
                    <span>‚úé All blue underlined values are editable. Click <Eye size={12} className="inline" /> to view simulation details.</span>
                </div>
            </div>

            {/* MARKET STRUCTURE */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2 flex justify-between items-center">
                    <span>Market Structure</span>
                    <button onClick={addSegment} className="flex items-center gap-1 text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700">
                        <Plus size={12} /> Add Segment
                    </button>
                </h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Segment</th>
                            <th className="p-2 text-right">Organizations</th>
                            <th className="p-2 text-right">ARPU (DZD/y)</th>
                            <th className="p-2 text-right">TAM Contrib</th>
                            <th className="p-2 text-right">Target Pen.</th>
                            <th className="p-2 text-right">SOM Target</th>
                            <th className="p-2 w-16 text-center">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {kpi.marketSegments.map(seg => (
                            <tr key={seg.id} className="hover:bg-slate-50 group">
                                <td className="p-2 font-medium">
                                    <EditableCell value={seg.name} onChange={(v) => updateSegment(seg.id, 'name', v)} type="text" />
                                </td>
                                <td className="p-2 text-right">
                                    <EditableCell value={seg.count} onChange={(v) => updateSegment(seg.id, 'count', v)} />
                                </td>
                                <td className="p-2 text-right">
                                    <EditableCell value={seg.price} onChange={(v) => updateSegment(seg.id, 'price', v)} />
                                </td>
                                <td className="p-2 text-right text-slate-500">{fmt(seg.count * seg.price)}</td>
                                <td className="p-2 text-right">
                                    <EditableCell value={seg.penRate} onChange={(v) => updateSegment(seg.id, 'penRate', v)} suffix="%" />
                                </td>
                                <td className="p-2 text-right font-medium">{fmt(seg.count * seg.price * (seg.penRate / 100))}</td>
                                <td className="p-2 text-center flex items-center justify-center gap-2">
                                    <button onClick={() => setSelectedSegment(seg)} className="text-blue-400 hover:text-blue-600" title="View Simulation">
                                        <Eye size={14} />
                                    </button>
                                    <button onClick={() => deleteSegment(seg.id)} className="text-slate-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity" title="Delete">
                                        <Trash2 size={14} />
                                    </button>
                                </td>
                            </tr>
                        ))}
                        <tr className="bg-slate-50 font-bold border-t-2 border-slate-200">
                            <td className="p-2">TOTAL</td>
                            <td className="p-2 text-right">{totalOrgs}</td>
                            <td className="p-2 text-right">-</td>
                            <td className="p-2 text-right">{fmt(tam)}</td>
                            <td className="p-2 text-right">-</td>
                            <td className="p-2 text-right">{fmt(som)}</td>
                            <td></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            {/* FUNNEL */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Customer Acquisition Funnel</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Stage</th>
                            <th className="p-2 text-right">Conversion Rate</th>
                            <th className="p-2 text-right">Average Time</th>
                            <th className="p-2 text-right">Annual Target</th>
                            <th className="p-2 w-16 text-center">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td className="p-2 font-medium text-blue-600">Lead Generation</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.s_lead} kpiKey="s_lead" suffix="%" /></td>
                            <td className="p-2 text-right"><EditableCell value={kpi.s_lead_time} kpiKey="s_lead_time" type="text" /></td>
                            <td className="p-2 text-right">{Math.ceil(neededLeads)}+ leads</td>
                            <td className="p-2 text-center">
                                <button onClick={() => { setSelectedFunnelStage("Lead Generation"); setFunnelTargetCount(Math.ceil(neededLeads)); }} className="text-blue-400 hover:text-blue-600" title="View Leads">
                                    <Eye size={14} />
                                </button>
                            </td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium text-blue-600">Demo/Discovery</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.s_demo} kpiKey="s_demo" suffix="%" /></td>
                            <td className="p-2 text-right"><EditableCell value={kpi.s_demo_time} kpiKey="s_demo_time" type="text" /></td>
                            <td className="p-2 text-right">{Math.ceil(neededLeads * kpi.s_lead / 100)}+ demos</td>
                            <td className="p-2 text-center">
                                <button onClick={() => { setSelectedFunnelStage("Demo/Discovery"); setFunnelTargetCount(Math.ceil(neededLeads * kpi.s_lead / 100)); }} className="text-blue-400 hover:text-blue-600" title="View Demos">
                                    <Eye size={14} />
                                </button>
                            </td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium text-blue-600">POC/Pilot</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.s_poc} kpiKey="s_poc" suffix="%" /></td>
                            <td className="p-2 text-right"><EditableCell value={kpi.s_poc_time} kpiKey="s_poc_time" type="text" /></td>
                            <td className="p-2 text-right">{Math.ceil(neededLeads * kpi.s_lead / 100 * kpi.s_demo / 100)}+ POCs</td>
                            <td className="p-2 text-center">
                                <button onClick={() => { setSelectedFunnelStage("POC/Pilot"); setFunnelTargetCount(Math.ceil(neededLeads * kpi.s_lead / 100 * kpi.s_demo / 100)); }} className="text-blue-400 hover:text-blue-600" title="View POCs">
                                    <Eye size={14} />
                                </button>
                            </td>
                        </tr>
                        <tr className="bg-green-50">
                            <td className="p-2 font-bold text-green-700">Paid Customer</td>
                            <td className="p-2 text-right font-bold text-green-700">{(overallConv * 100).toFixed(1)}%</td>
                            <td className="p-2 text-right text-green-700">Contract signed</td>
                            <td className="p-2 text-right font-bold text-green-700">{estimatedClients.toFixed(1)} clients</td>
                            <td></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            {/* COMPETITORS */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2 flex justify-between items-center">
                    <span>Competitive Positioning</span>
                    <button onClick={addCompetitor} className="flex items-center gap-1 text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700">
                        <Plus size={12} /> Add
                    </button>
                </h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Competitor</th>
                            <th className="p-2 text-left">Threat Level</th>
                            <th className="p-2 text-left">Key Strength</th>
                            <th className="p-2 text-left">Our Advantage</th>
                            <th className="p-2 w-16 text-center">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {kpi.competitors.map(c => (
                            <tr key={c.id} className="hover:bg-slate-50 group">
                                <td className="p-2 font-medium">
                                    <EditableCell value={c.name} onChange={(v) => updateCompetitor(c.id, 'name', v)} type="text" />
                                </td>
                                <td className="p-2">
                                    <EditableCell value={c.threat} onChange={(v) => updateCompetitor(c.id, 'threat', v)} type="text" />
                                </td>
                                <td className="p-2">
                                    <EditableCell value={c.strength} onChange={(v) => updateCompetitor(c.id, 'strength', v)} type="text" />
                                </td>
                                <td className="p-2">
                                    <EditableCell value={c.advantage} onChange={(v) => updateCompetitor(c.id, 'advantage', v)} type="text" />
                                </td>
                                <td className="p-2 text-center flex items-center justify-center gap-2">
                                    <button onClick={() => setSelectedCompetitor(c)} className="text-blue-400 hover:text-blue-600" title="View Details">
                                        <Eye size={14} />
                                    </button>
                                    <button onClick={() => deleteCompetitor(c.id)} className="text-slate-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity">
                                        <Trash2 size={14} />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* RISKS */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2 flex justify-between items-center">
                    <span>Risk Assessment Matrix</span>
                    <button onClick={addRisk} className="flex items-center gap-1 text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700">
                        <Plus size={12} /> Add
                    </button>
                </h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Risk Factor</th>
                            <th className="p-2 text-right">Probability</th>
                            <th className="p-2 text-left">Impact Level</th>
                            <th className="p-2 text-left">Risk Score</th>
                            <th className="p-2 text-left">Mitigation</th>
                            <th className="p-2 w-16 text-center">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {kpi.risks.map(r => (
                            <tr key={r.id} className="hover:bg-slate-50 group">
                                <td className="p-2 font-medium">
                                    <EditableCell value={r.name} onChange={(v) => updateRisk(r.id, 'name', v)} type="text" />
                                </td>
                                <td className="p-2 text-right">
                                    <EditableCell value={r.prob} onChange={(v) => updateRisk(r.id, 'prob', v)} suffix="%" />
                                </td>
                                <td className="p-2 text-center">
                                    <EditableCell value={r.impactLevel} onChange={(v) => updateRisk(r.id, 'impactLevel', v)} suffix="/10" />
                                </td>
                                <td className="p-2 font-bold">
                                    {(r.prob * r.impactLevel / 100).toFixed(1)}
                                </td>
                                <td className="p-2 text-xs text-slate-500">
                                    <EditableCell value={r.mitigation} onChange={(v) => updateRisk(r.id, 'mitigation', v)} type="text" />
                                </td>
                                <td className="p-2 text-center flex items-center justify-center gap-2">
                                    <button onClick={() => setSelectedRisk(r)} className="text-blue-400 hover:text-blue-600" title="View Risk Analysis">
                                        <Eye size={14} />
                                    </button>
                                    <button onClick={() => deleteRisk(r.id)} className="text-slate-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity">
                                        <Trash2 size={14} />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
}
</file>

<file path="src/components/kpi/tabs/UnitEconomicsTab.tsx">
import { useKPI } from "@/contexts/KPIContext";
import { EditableCell } from "../EditableCell";

const fmt = (n: number) => {
    if (Math.abs(n) >= 1000000) return (n / 1000000).toFixed(2) + 'M';
    if (Math.abs(n) >= 1000) return (n / 1000).toFixed(0) + 'k';
    return n.toFixed(0);
};

const fmtPct = (n: number) => n.toFixed(1) + '%';

function KPICard({ title, value, sub }: { title: string, value: string, sub: string }) {
    return (
        <div className="rounded-xl border border-slate-200 bg-white p-5 shadow-sm">
            <div className="mb-2 text-[10px] font-bold uppercase tracking-wider text-slate-500">{title}</div>
            <div className="mb-1 text-2xl font-extrabold text-slate-900">{value}</div>
            <div className="text-[11px] text-slate-400">{sub}</div>
        </div>
    );
}

export function UnitEconomicsTab() {
    const { kpi, metrics } = useKPI();
    const { y5, years, ltv, ltv_cac, paybackMonths, customerLifeMonths, nrr } = metrics;

    return (
        <div className="mx-auto w-[210mm] min-h-[297mm] bg-white p-[20mm] shadow-lg rounded-lg space-y-8">
            <div>
                <h2 className="text-2xl font-bold text-slate-900">Unit Economics & KPIs</h2>
                <div className="mt-4 rounded bg-blue-50 p-3 text-sm text-blue-800 border border-blue-200">
                    <strong>üí° Key Insight:</strong> LTV/CAC ratio of <span className="font-bold">{ltv_cac.toFixed(1)}:1</span> indicates <strong>{ltv_cac >= 3 ? 'healthy' : 'concerning'}</strong> unit economics.
                    However, long sales cycles ({kpi.s_cycle} months) require careful cash management.
                </div>
            </div>

            {/* CORE METRICS */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Core Unit Economics</h3>
                <div className="grid grid-cols-5 gap-4">
                    <KPICard title="CAC" value={fmt(kpi.s_cac * 1000)} sub="Customer Acq. Cost" />
                    <KPICard title="LTV" value={fmt(ltv)} sub="Lifetime Value" />
                    <KPICard title="LTV/CAC" value={ltv_cac.toFixed(1)} sub="Target: >3:1" />
                    <KPICard title="Gross Margin" value={fmtPct(kpi.f_margin)} sub="SaaS standard: 80%+" />
                    <KPICard title="Payback" value={paybackMonths.toFixed(0)} sub="Months to recover CAC" />
                </div>
            </div>

            {/* GROWTH METRICS */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Growth Metrics</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Metric</th>
                            <th className="p-2 text-right">Y1</th>
                            <th className="p-2 text-right">Y2</th>
                            <th className="p-2 text-right">Y3</th>
                            <th className="p-2 text-right">Y4</th>
                            <th className="p-2 text-right">Y5</th>
                            <th className="p-2 text-right">CAGR</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td className="p-2 font-medium">New Clients</td>
                            {['g_y1', 'g_y2', 'g_y3', 'g_y4', 'g_y5'].map(k => (
                                // @ts-ignore
                                <td key={k} className="p-2 text-right"><EditableCell value={kpi[k]} kpiKey={k as any} /></td>
                            ))}
                            <td className="p-2 text-right">-</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">Active Clients</td>
                            {years.map(y => <td key={y.year} className="p-2 text-right">{y.activeClients.toFixed(1)}</td>)}
                            <td className="p-2 text-right">-</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">ARR (k DZD)</td>
                            {years.map(y => <td key={y.year} className="p-2 text-right">{fmt(y.arr)}</td>)}
                            <td className="p-2 text-right font-bold text-green-600">
                                {fmtPct((Math.pow(y5.arr / years[0].arr, 1 / 4) - 1) * 100)}
                            </td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">Churn Rate</td>
                            <td className="p-2 text-right"><EditableCell value={kpi.ch_y1} kpiKey="ch_y1" suffix="%" /></td>
                            <td className="p-2 text-right"><EditableCell value={kpi.ch_y2} kpiKey="ch_y2" suffix="%" /></td>
                            <td colSpan={3} className="p-2 text-center text-slate-500">
                                Stabilizes at <EditableCell value={kpi.ch_stable} kpiKey="ch_stable" suffix="%" className="inline-block" />
                            </td>
                            <td className="p-2 text-right">-</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            {/* BENCHMARKS */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Customer Metrics & Benchmarks</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Metric</th>
                            <th className="p-2 text-left">Your Value</th>
                            <th className="p-2 text-left">Industry Benchmark</th>
                            <th className="p-2 text-left">Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td className="p-2 font-medium">Churn Rate (stabilized)</td>
                            <td className="p-2"><EditableCell value={kpi.ch_stable} kpiKey="ch_stable" suffix="%" /></td>
                            <td className="p-2"><EditableCell value={kpi.bench_churn} kpiKey="bench_churn" type="text" /></td>
                            <td className="p-2">{kpi.ch_stable <= 10 ? '‚úÖ Good' : '‚ö†Ô∏è High'}</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">Net Revenue Retention</td>
                            <td className="p-2">{fmtPct(nrr)}</td>
                            <td className="p-2"><EditableCell value={kpi.bench_nrr} kpiKey="bench_nrr" type="text" /></td>
                            <td className="p-2">{nrr >= 100 ? '‚úÖ Good' : '‚ö†Ô∏è Concern'}</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">Customer Lifetime</td>
                            <td className="p-2">{customerLifeMonths.toFixed(0)} months</td>
                            <td className="p-2"><EditableCell value={kpi.bench_life} kpiKey="bench_life" type="text" /></td>
                            <td className="p-2">{customerLifeMonths >= 36 ? '‚úÖ Good' : '‚ö†Ô∏è Short'}</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">Avg Contract Value</td>
                            <td className="p-2"><EditableCell value={kpi.p_arpu} kpiKey="p_arpu" /></td>
                            <td className="p-2">-</td>
                            <td className="p-2">-</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            {/* SALES EFFICIENCY */}
            <div>
                <h3 className="mb-4 text-lg font-bold text-slate-800 border-b pb-2">Sales Efficiency</h3>
                <table className="w-full text-sm">
                    <thead className="bg-slate-50 text-slate-500">
                        <tr>
                            <th className="p-2 text-left">Metric</th>
                            <th className="p-2 text-left">Value</th>
                            <th className="p-2 text-left">Target</th>
                            <th className="p-2 text-left">Performance</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td className="p-2 font-medium">Sales Cycle</td>
                            <td className="p-2"><EditableCell value={kpi.s_cycle} kpiKey="s_cycle" suffix=" months" /></td>
                            <td className="p-2"><EditableCell value={kpi.target_cycle} kpiKey="target_cycle" type="text" /></td>
                            <td className="p-2">{kpi.s_cycle <= 9 ? '‚úÖ' : '‚ö†Ô∏è'}</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">Lead Conversion</td>
                            <td className="p-2"><EditableCell value={kpi.s_lead} kpiKey="s_lead" suffix="%" /></td>
                            <td className="p-2"><EditableCell value={kpi.target_lead} kpiKey="target_lead" type="text" /></td>
                            <td className="p-2">{kpi.s_lead >= 30 ? '‚úÖ' : '‚ö†Ô∏è'}</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">Demo Conversion</td>
                            <td className="p-2"><EditableCell value={kpi.s_demo} kpiKey="s_demo" suffix="%" /></td>
                            <td className="p-2"><EditableCell value={kpi.target_demo} kpiKey="target_demo" type="text" /></td>
                            <td className="p-2">{kpi.s_demo >= 50 ? '‚úÖ' : '‚ö†Ô∏è'}</td>
                        </tr>
                        <tr>
                            <td className="p-2 font-medium">POC Conversion</td>
                            <td className="p-2"><EditableCell value={kpi.s_poc} kpiKey="s_poc" suffix="%" /></td>
                            <td className="p-2"><EditableCell value={kpi.target_poc} kpiKey="target_poc" type="text" /></td>
                            <td className="p-2">{kpi.s_poc >= 60 ? '‚úÖ' : '‚ö†Ô∏è'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>

        </div>
    );
}
</file>

<file path="src/components/LiveStreamPlayer.tsx">
import React, { useEffect, useRef, useState } from 'react';
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Slider } from "@/components/ui/slider";
import { Badge } from "@/components/ui/badge";
import {
    Play, Pause, Volume2, Maximize,
    Monitor, Camera, Gamepad2, Radio, Loader2, AlertCircle,
    LinkIcon, Unlink, X, RefreshCw, ChevronDown, ChevronUp, Settings2,
    RotateCcw, RotateCw, Timer, Activity as ActivityIcon
} from 'lucide-react';
import { Toaster } from "sonner";
import { Switch } from "@/components/ui/switch";
import { useSocket as useSocketContext } from '@/contexts/SocketContext';
import { useAuth } from '@/contexts/AuthContext';
import { useMatchContext } from '@/contexts/MatchContext';
import { toast } from "sonner";
import Hls from 'hls.js';
import { cn } from '@/lib/utils';
import { StatisticsDashboard } from './StatisticsDashboard';

// Feature flag to disable OBS integration
const OBS_ENABLED = false;

const SCENE_MAPPINGS: Record<string, string[]> = {
    "Game Capture": ["Game Capture", "Capture de jeu", "Game", "Jeu", "Game Capture Source"],
    "Camera Feed": ["Camera Feed", "P√©riph√©rique de capture vid√©o", "Camera", "Cam√©ra", "Video Capture Device"],
    "Display Capture": ["Display Capture", "Capture d'√©cran", "Screen", "√âcran", "Display", "Monitor"]
};

import { DashboardWidget } from './common/DashboardWidget';
import { LayoutConfig } from '@/hooks/useDashboardLayout';

export interface LiveStreamPlayerRef {
    toggleRecording: () => Promise<void>;
    handleSourceSwitch: (sourceName: string) => Promise<void>;
}

export const LiveStreamPlayer = React.forwardRef<LiveStreamPlayerRef, {
    onClose?: () => void,
    events?: any[],
    showLiveToasts?: boolean,
    variant?: 'default' | 'streamlined',
    isEditMode?: boolean,
    layoutConfig?: LayoutConfig,
    onToggleVisibility?: (id: string) => void
}>(({ onClose, events = [], showLiveToasts = true, variant = 'default', isEditMode = false, layoutConfig = {}, onToggleVisibility }, ref) => {
    const videoRef = useRef<HTMLVideoElement>(null);
    const fullscreenContainerRef = useRef<HTMLDivElement>(null);
    const obsRef = useRef<any>(null);
    const { socket } = useSocketContext();
    const { user } = useAuth();
    const {
        streamUrl, setStreamUrl, useStreamProxy, setUseStreamProxy,
        matchTime, currentPossession, events: allEvents
    } = useMatchContext();

    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };
    const isAdmin = user?.role === 'admin';

    // State
    const [isPlaying, setIsPlaying] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [volume, setVolume] = useState(1);
    const [isMuted, setIsMuted] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [showLiveFeedback, setShowLiveFeedback] = useState(true);
    const hlsRef = useRef<Hls | null>(null);
    const lastSwitchedSceneRef = useRef<string | null>(null);
    const lastSwitchTimeRef = useRef<number>(0);

    // OBS State
    const [obsConnected, setObsConnected] = useState(false);
    const [isRecording, setIsRecording] = useState(false);
    const [obsAddress, setObsAddress] = useState(`ws://${window.location.hostname}:4455`);
    const [obsPassword, setObsPassword] = useState("");
    const [isConnectingObs, setIsConnectingObs] = useState(false);
    const [availableScenes, setAvailableScenes] = useState<string[]>([]);
    const [useProxy] = useState(window.location.protocol === 'https:');
    const [showObsSettings, setShowObsSettings] = useState(false);
    const proxyCallbacks = useRef<Map<string, {
        resolve: (val: any) => void,
        reject: (err: any) => void,
        timeout: NodeJS.Timeout
    }>>(new Map());

    /* ---------------------------------------------------------
       SOCKET CONNECTION MONITOR
    --------------------------------------------------------- */
    useEffect(() => {
        if (!socket) {
            console.warn('‚ö†Ô∏è Socket is null');
            return;
        }

        const onConnect = () => {
            console.log('‚úÖ Socket connected:', socket.id);
        };

        const onConnectError = (err: any) => {
            console.error('‚ùå Socket connection error:', err);
            setError(`Socket connection error: ${err.message || 'Unknown error'}`);
        };

        const onDisconnect = (reason: string) => {
            console.warn('üîå Socket disconnected:', reason);
            if (obsConnected) {
                setObsConnected(false);
                setIsRecording(false);
                setError('Socket disconnected. OBS connection lost.');
            }
        };

        socket.on('connect', onConnect);
        socket.on('connect_error', onConnectError);
        socket.on('disconnect', onDisconnect);

        // Log current connection status
        console.log('üì° Socket status:', {
            connected: socket.connected,
            id: socket.id
        });

        return () => {
            socket.off('connect', onConnect);
            socket.off('connect_error', onConnectError);
            socket.off('disconnect', onDisconnect);
        };
    }, [socket, obsConnected]);

    /* ---------------------------------------------------------
       HLS STREAM INITIALIZATION - New IPTV Implementation
    --------------------------------------------------------- */
    useEffect(() => {
        const video = videoRef.current;
        console.log('üîÑ Player useEffect triggered', {
            hasVideo: !!video,
            streamUrl,
            useStreamProxy,
            isLoading
        });

        if (!video || !streamUrl) {
            console.log('‚ö†Ô∏è Skipping player init: video or streamUrl missing');
            return;
        }

        setIsLoading(true);
        setError(null);

        // Determine the final URL to load
        let finalUrl = streamUrl;

        // Auto-enable proxy if on HTTPS and stream is HTTP
        const isPageHttps = window.location.protocol === 'https:';
        const isStreamHttp = streamUrl.startsWith('http:');

        // Detect massive playlists that shouldn't be loaded directly
        if (streamUrl.includes('type=m3u')) {
            setError("Playlist Mode: Please use the 'Channels' browser to select a specific live channel.");
            setIsLoading(false);
            return;
        }

        // Get stream origin for headers
        let streamOrigin = "";
        try {
            const streamUrlObj = new URL(streamUrl);
            streamOrigin = streamUrlObj.origin;
        } catch {
            streamOrigin = "http://tgrpro25.xyz:8080";
        }

        // Force proxy for live streams to avoid strict CORS from providers
        const shouldProxy = true;

        if (shouldProxy) {
            const rawBase = (import.meta as any).env.VITE_API_BASE_URL;
            const baseUrl = rawBase && !rawBase.includes('localhost') ? rawBase : window.location.origin;

            finalUrl = `${baseUrl}/api/proxy?url=${encodeURIComponent(streamUrl)}`;
            console.log('üõ°Ô∏è Using CORS Proxy for stream (Auto-detected if HTTPS):', finalUrl);

            if (isPageHttps && isStreamHttp && !useStreamProxy) {
                console.log('üîÑ Auto-switching to proxy due to Mixed Content (HTTPS -> HTTP)');
                setUseStreamProxy(true);
            }
        } else {
            console.log('üåê Loading stream DIRECTLY (No Proxy):', finalUrl);
        }

        if (Hls.isSupported()) {
            console.log('üì¶ Initializing HLS.js with new IPTV config...');
            if (hlsRef.current) {
                console.log('üóëÔ∏è Destroying old HLS instance');
                hlsRef.current.destroy();
            }

            const hls = new Hls({
                enableWorker: true,
                lowLatencyMode: true,
                backBufferLength: 90,
                maxBufferLength: 30,
                maxMaxBufferLength: 60,
                liveSyncDurationCount: 3,
                liveMaxLatencyDurationCount: 5,
                debug: import.meta.env.DEV,
                xhrSetup: (xhr, url) => {
                    const shouldProxy = useStreamProxy || (isPageHttps && url.startsWith('http:'));

                    if (shouldProxy) {
                        let finalXhrUrl = url;

                        // If URL is not pointing to our proxy, make it so
                        if (url && !url.includes("/api/proxy")) {
                            const rawBase = (import.meta as any).env.VITE_API_BASE_URL;
                            const baseUrl = rawBase && !rawBase.includes('localhost') ? rawBase : window.location.origin;
                            finalXhrUrl = `${baseUrl}/api/proxy?url=${encodeURIComponent(url)}`;

                            // Use a trick to change the request URL for XHR
                            const originalOpen = xhr.open;
                            xhr.open = function () {
                                const args = Array.prototype.slice.call(arguments);
                                args[1] = finalXhrUrl;
                                return originalOpen.apply(this, args as any);
                            };
                        }
                    }

                    // Set headers for upstream server via proxy
                    try {
                        xhr.setRequestHeader(
                            "User-Agent",
                            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
                        );
                        xhr.setRequestHeader("Accept", "*/*");
                        if (streamOrigin) {
                            xhr.setRequestHeader("Referer", `${streamOrigin}/`);
                        }
                    } catch (e) {
                        // Headers may fail in some contexts
                    }
                },
            });

            hls.loadSource(finalUrl);
            hls.attachMedia(video);
            hlsRef.current = hls;

            hls.on(Hls.Events.MANIFEST_PARSED, () => {
                console.log('‚úÖ HLS Manifest Parsed Success');
                video.play().catch((e) => {
                    console.log("Autoplay blocked/failed:", e.message);
                });
                setIsLoading(false);
                setIsPlaying(true);
            });

            hls.on(Hls.Events.ERROR, (event, data) => {
                console.error('‚ùå HLS Error Event:', data.type, data.details, data.fatal);
                if (data.fatal) {
                    switch (data.type) {
                        case Hls.ErrorTypes.NETWORK_ERROR:
                            console.error("Fatal network error - recovering...");
                            hls.startLoad();
                            break;
                        case Hls.ErrorTypes.MEDIA_ERROR:
                            console.error("Fatal media error - recovering...");
                            hls.recoverMediaError();
                            break;
                        default:
                            console.error("Unrecoverable error - destroying");
                            hls.destroy();
                            hlsRef.current = null;
                            setError(`Video Stream Error: ${data.details}`);
                            setIsLoading(false);
                            setIsPlaying(false);
                            break;
                    }
                }
            });

        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            console.log('üçé Initializing Native Safari HLS...');
            video.src = finalUrl;
            video.addEventListener('loadedmetadata', () => {
                video.play();
                setIsLoading(false);
                setIsPlaying(true);
            });
        } else {
            console.error('üö´ HLS is NOT supported in this browser');
            setError("Your browser does not support HLS playback.");
            setIsLoading(false);
        }

        return () => {
            if (hlsRef.current) {
                console.log('‚ôªÔ∏è Cleaning up HLS on effect exit');
                hlsRef.current.destroy();
                hlsRef.current = null;
            }
        };
    }, [streamUrl, useStreamProxy]);



    /* ---------------------------------------------------------
       OBS CONNECTION - IMPROVED ERROR HANDLING
    --------------------------------------------------------- */
    const connectToOBS = async () => {
        console.log('=== CONNECT TO OBS STARTED ===');
        console.log('Socket connected:', socket?.connected);
        console.log('OBS Address:', obsAddress);
        console.log('Has Password:', !!obsPassword);
        console.log('Use Proxy:', useProxy);

        setIsConnectingObs(true);
        setError(null);

        try {
            // Validate inputs first
            if (!obsAddress.trim()) {
                throw new Error("OBS address is required");
            }

            if (useProxy) {
                if (!socket || !socket.connected) {
                    throw new Error("Socket connection not available. Please refresh the page and try again.");
                }

                console.log('üì§ Emitting obs-proxy-connect event...');
                socket.emit('obs-proxy-connect', {
                    address: obsAddress.trim(),
                    password: obsPassword
                });

                console.log('‚úÖ obs-proxy-connect event emitted successfully');

                // Set a connection timeout
                const connectionTimeout = setTimeout(() => {
                    console.error('‚è∞ OBS connection timeout triggered');
                    if (isConnectingObs) {
                        setError("OBS connection timeout. Please check if OBS is running and the WebSocket server is enabled.");
                        setIsConnectingObs(false);
                    }
                }, 15000); // 15 second timeout for initial connection

                // Store timeout to clear it later
                (window as any).__obsConnectionTimeout = connectionTimeout;

            } else {
                throw new Error("Direct OBS connection requires HTTP. Please use the proxy mode or switch to HTTP.");
            }

        } catch (err: any) {
            console.error("=== CONNECT TO OBS FAILED ===");
            setError(`Failed to connect to OBS: ${err.message || "Unknown error"}`);
            setIsConnectingObs(false);
        }
    };

    const refreshScenes = async (silent = false) => {
        if (!obsConnected) return;
        try {
            if (!silent) console.log('üîÑ Refreshing OBS scene list...');
            const response = await callOBS("GetSceneList");
            if (response && response.scenes) {
                const sceneNames = response.scenes.map((s: any) => s.sceneName);
                setAvailableScenes(sceneNames);
                if (!silent) {
                    console.log('üìã Available OBS Scenes:', sceneNames);
                    toast.success("Scene list updated", { duration: 2000 });
                }
                return sceneNames;
            }
        } catch (err) {
            console.warn('Failed to fetch OBS scenes:', err);
            if (!silent) toast.error("Failed to refresh scenes");
        }
        return [];
    };

    // Improved Proxy Event Listeners
    useEffect(() => {
        if (!socket) {
            console.warn('‚ö†Ô∏è Socket not available for OBS listeners');
            return;
        }

        const onConnected = async ({ address }: { address: string }) => {
            console.log("‚úÖ Connected to OBS via Proxy:", address);

            // Clear connection timeout
            if ((window as any).__obsConnectionTimeout) {
                clearTimeout((window as any).__obsConnectionTimeout);
                delete (window as any).__obsConnectionTimeout;
            }

            setObsConnected(true);
            setIsConnectingObs(false);
            setError(null);

            // Fetch available scenes
            await refreshScenes(true);

            // Save settings on successful connection
            try {
                localStorage.setItem('obsAddress', obsAddress);
                localStorage.setItem('obsPassword', obsPassword);
            } catch (e) {
                console.warn('Failed to save OBS settings to localStorage:', e);
            }

            toast.success("OBS Connected Successfully");
        };

        const onDisconnected = () => {
            console.log("‚ùå OBS Proxy Disconnected");
            setObsConnected(false);
            setIsRecording(false);
            obsRef.current = null;

            // Clear all pending callbacks
            proxyCallbacks.current.forEach(({ timeout, reject }) => {
                clearTimeout(timeout);
                reject(new Error("OBS disconnected"));
            });
            proxyCallbacks.current.clear();

            toast.error("OBS Disconnected");
        };

        const onError = ({ message, code, requestId }: {
            message?: string,
            code?: string,
            requestId?: string
        }) => {
            console.error("‚ùå OBS Proxy Error:", { message, code, requestId });

            // Clear connection timeout
            if ((window as any).__obsConnectionTimeout) {
                clearTimeout((window as any).__obsConnectionTimeout);
                delete (window as any).__obsConnectionTimeout;
            }

            if (requestId && proxyCallbacks.current.has(requestId)) {
                const callback = proxyCallbacks.current.get(requestId);
                if (callback) {
                    clearTimeout(callback.timeout);
                    callback.reject(new Error(message || 'OBS request failed'));
                    proxyCallbacks.current.delete(requestId);
                }
            } else {
                let displayMessage = message || 'An unknown error occurred';
                if (code === 'ECONNREFUSED') displayMessage = 'Cannot connect to OBS. Check if OBS is running and WebSocket is enabled.';
                else if (code === 'ETIMEDOUT') displayMessage = 'Connection timeout. Check OBS address and firewall.';

                setError(`OBS Error: ${displayMessage}`);
                setIsConnectingObs(false);
                toast.error(displayMessage);
            }
        };

        const onProxyEvent = ({ event, data }: { event: string, data: any }) => {
            console.log('üì° OBS Event:', event, data);
            if (event === 'RecordStateChanged') {
                const newState = data.outputActive;
                setIsRecording(newState);
                toast.success(newState ? "Recording started" : "Recording stopped");
            } else if (event === 'SceneListChanged' || event === 'SceneNameChanged') {
                refreshScenes(true);
            }
        };

        const onProxyResponse = ({ response, requestId }: { response: any, requestId: string }) => {
            if (proxyCallbacks.current.has(requestId)) {
                const callback = proxyCallbacks.current.get(requestId);
                if (callback) {
                    clearTimeout(callback.timeout);
                    callback.resolve(response);
                    proxyCallbacks.current.delete(requestId);
                }
            }
        };

        socket.on('obs-proxy-connected', onConnected);
        socket.on('obs-proxy-disconnected', onDisconnected);
        socket.on('obs-proxy-error', onError);
        socket.on('obs-proxy-event', onProxyEvent);
        socket.on('obs-proxy-response', onProxyResponse);

        return () => {
            socket.off('obs-proxy-connected', onConnected);
            socket.off('obs-proxy-disconnected', onDisconnected);
            socket.off('obs-proxy-error', onError);
            socket.off('obs-proxy-event', onProxyEvent);
            socket.off('obs-proxy-response', onProxyResponse);
        };
    }, [socket, obsAddress, obsPassword, obsConnected]);

    const callOBS = async (requestType: string, requestData?: any): Promise<any> => {
        if (!obsConnected) throw new Error("OBS not connected");
        if (!socket || !socket.connected) throw new Error("Socket connection lost");

        const requestId = `${Date.now()}-${Math.random().toString(36).substring(7)}`;

        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                if (proxyCallbacks.current.has(requestId)) {
                    proxyCallbacks.current.delete(requestId);
                    reject(new Error(`OBS request timeout: ${requestType}`));
                }
            }, 15000);

            proxyCallbacks.current.set(requestId, { resolve, reject, timeout });
            socket.emit('obs-proxy-call', { requestType, requestData, requestId });
        });
    };

    const disconnectOBS = async () => {
        if (socket) socket.emit('obs-proxy-disconnect');
        setObsConnected(false);
        setIsRecording(false);
        obsRef.current = null;
        proxyCallbacks.current.forEach(({ timeout }) => clearTimeout(timeout));
        proxyCallbacks.current.clear();
    };

    const toggleRecording = async () => {
        if (!obsConnected) {
            toast.error("OBS not connected");
            return;
        }
        try {
            if (isRecording) {
                await callOBS("StopRecord");
                setIsRecording(false);
            } else {
                await callOBS("StartRecord");
                setIsRecording(true);
            }
        } catch (err: any) {
            const msg = `Recording error: ${err.message || "Unknown error"}`;
            setError(msg);
            toast.error(msg);
        }
    };

    const handleSourceSwitch = async (sourceName: string) => {
        if (!obsConnected) {
            toast.error("OBS not connected");
            return;
        }

        // UI Guard: Prevent double-triggering or loops
        const now = Date.now();
        if (lastSwitchedSceneRef.current === sourceName && (now - lastSwitchTimeRef.current) < 2000) {
            console.log(`‚ö†Ô∏è Guard: Skipping redundant switch to "${sourceName}"`);
            return;
        }

        lastSwitchedSceneRef.current = sourceName;
        lastSwitchTimeRef.current = now;

        try {
            const variations = SCENE_MAPPINGS[sourceName] || [sourceName];
            let targetScene = "";
            let currentScenes = availableScenes;

            // Step 0: If scene list is empty, refresh it
            if (currentScenes.length === 0) {
                currentScenes = await refreshScenes(true);
            }

            console.log(`üîç Attempting switch for: ${sourceName} (Variations: ${variations.join(', ')})`);

            const findMatch = (scenes: string[]) => {
                // 1. Direct Match
                for (const v of variations) {
                    const match = scenes.find(s => s.toLowerCase() === v.toLowerCase());
                    if (match) return match;
                }
                // 2. Partial Match
                for (const v of variations) {
                    const match = scenes.find(s => s.toLowerCase().includes(v.toLowerCase()));
                    if (match) return match;
                }
                return "";
            };

            targetScene = findMatch(currentScenes);

            // Step 3: If still no match, refresh and try one more time
            if (!targetScene) {
                console.log('üßê No match in current list. Refreshing scenes and retrying...');
                currentScenes = await refreshScenes(true);
                targetScene = findMatch(currentScenes);
            }

            // Step 4: Fallback - Search inside scenes for sources
            if (!targetScene) {
                console.log('üîé Searching within scene items...');
                toast.loading("Scanning OBS for matching source...", { duration: 2000 });
                for (const sceneName of currentScenes) {
                    try {
                        const response = await callOBS("GetSceneItemList", { sceneName });
                        if (response && response.sceneItems) {
                            for (const item of response.sceneItems) {
                                const itemName = (item.sourceName || item.itemName) as string;
                                const isMatch = variations.some(v =>
                                    itemName.toLowerCase() === v.toLowerCase() ||
                                    itemName.toLowerCase().includes(v.toLowerCase())
                                );
                                if (isMatch) {
                                    targetScene = sceneName;
                                    console.log(`‚ú® Found source match "${itemName}" in scene "${sceneName}"`);
                                    break;
                                }
                            }
                        }
                    } catch (err) { /* ignore */ }
                    if (targetScene) break;
                }
            }

            // Step 5: Verify targetScene is actually a scene
            if (targetScene && !currentScenes.includes(targetScene)) {
                targetScene = currentScenes.find(s => s.toLowerCase() === targetScene.toLowerCase()) || "";
            }

            if (!targetScene) {
                throw new Error(`Could not find a scene mapped to "${sourceName}". Available: ${currentScenes.join(', ')}`);
            }

            console.log(`üîÑ Finalizing OBS switch to scene: ${targetScene}`);
            await callOBS("SetCurrentProgramScene", { sceneName: targetScene });
            toast.success(`Switched to scene: ${targetScene}`);
        } catch (err: any) {
            console.error(`Failed to switch to ${sourceName}:`, err);
            let displayMsg = err.message || "Unknown error";
            if (displayMsg.includes("is not a scene")) displayMsg = `Target "${sourceName}" is not a valid OBS scene.`;
            toast.error(`Switch error: ${displayMsg}`);
        }
    };

    React.useImperativeHandle(ref, () => ({
        toggleRecording,
        handleSourceSwitch
    }));

    /* ---------------------------------------------------------
       LOAD SAVED OBS SETTINGS
    --------------------------------------------------------- */
    useEffect(() => {
        try {
            const savedAddress = localStorage.getItem('obsAddress');
            const savedPassword = localStorage.getItem('obsPassword');
            if (savedAddress) setObsAddress(savedAddress);
            if (savedPassword) setObsPassword(savedPassword);
        } catch (e) { /* ignore */ }
    }, []);

    const togglePlay = () => {
        const video = videoRef.current;
        if (!video) return;
        if (isPlaying) video.pause();
        else video.play();
    };

    const handleVolumeChange = (values: number[]) => {
        const video = videoRef.current;
        if (!video) return;
        const vol = values[0];
        video.volume = vol;
        setVolume(vol);
        setIsMuted(vol === 0);
    };

    const toggleFullscreen = () => {
        const container = fullscreenContainerRef.current;
        if (!container) return;
        if (document.fullscreenElement) document.exitFullscreen();
        else container.requestFullscreen();
    };

    const seek = (seconds: number) => {
        const video = videoRef.current;
        if (!video) return;
        video.currentTime = Math.max(0, video.currentTime + seconds);
    };

    const lastEvent = allEvents[0];
    const [showEventOverlay, setShowEventOverlay] = useState(false);

    useEffect(() => {
        if (lastEvent) {
            setShowEventOverlay(true);
            const timer = setTimeout(() => setShowEventOverlay(false), 3000);
            return () => clearTimeout(timer);
        }
    }, [lastEvent?.id]);

    if (variant === 'streamlined') {
        return (
            <div
                ref={fullscreenContainerRef}
                className="relative w-full h-full bg-black group overflow-hidden"
            >
                <video
                    ref={videoRef}
                    className="w-full h-full object-contain"
                    autoPlay
                    muted={isMuted}
                    playsInline
                    crossOrigin="anonymous"
                />

                {/* Fullscreen Toaster */}
                {showLiveFeedback && <Toaster position="top-center" expand={true} richColors closeButton />}

                {/* Event Name Overlay (Top Left) */}
                {showLiveFeedback && showEventOverlay && lastEvent && (
                    <div className="absolute top-6 left-6 z-50 animate-in fade-in slide-in-from-left-4 duration-500">
                        <div className="bg-black/60 backdrop-blur-xl border border-primary/40 rounded-xl p-4 shadow-2xl flex items-center gap-4">
                            <div className="bg-primary/20 p-2.5 rounded-lg border border-primary/30">
                                <ActivityIcon className="w-6 h-6 text-primary animate-pulse" />
                            </div>
                            <div>
                                <div className="text-[10px] text-primary font-bold uppercase tracking-widest leading-none mb-1">Last Action</div>
                                <div className="text-xl font-black text-white uppercase tracking-tight leading-none italic">
                                    {lastEvent.eventName.replace(/_/g, ' ')}
                                </div>
                                <div className="text-[10px] text-slate-400 mt-1 font-mono">
                                    {lastEvent.player?.name ? `#${lastEvent.player.id} ${lastEvent.player.name}` : lastEvent.team.replace('_', ' ')}
                                </div>
                            </div>
                        </div>
                    </div>
                )}

                {/* Statistics Dashboard Overlay */}
                <DashboardWidget
                    id="live-stats"
                    label="Live Stats Overlay"
                    isEditMode={isEditMode}
                    isHidden={layoutConfig['live-stats']?.hidden}
                    onToggleVisibility={onToggleVisibility}
                    className="absolute top-4 left-4 z-[45]"
                >
                    <StatisticsDashboard events={events} isOverlay={true} />
                </DashboardWidget>

                {/* Match Timer & Chain Overlay (Top Right) */}
                <div className="absolute top-6 right-6 z-50 flex flex-col items-end gap-3 pointer-events-none">
                    <div className="bg-black/60 backdrop-blur-xl border border-white/10 rounded-xl px-4 py-2 flex items-center gap-3">
                        <Timer className="w-4 h-4 text-primary" />
                        <span className="text-2xl font-mono font-bold text-white tracking-widest leading-none">
                            {formatTime(matchTime || 0)}
                        </span>
                    </div>

                    {currentPossession && currentPossession.passCount > 0 && (
                        <div className="bg-primary/95 backdrop-blur-md rounded-lg px-3 py-1.5 flex items-center gap-2 border border-primary animate-in fade-in slide-in-from-right-4">
                            <Gamepad2 className="w-3.5 h-3.5 text-white" />
                            <span className="text-[11px] font-bold text-white uppercase tracking-wider">
                                {currentPossession.passCount} PASSES
                            </span>
                            <div className="w-px h-3 bg-white/30 mx-1" />
                            <span className="text-[10px] text-white/80 font-medium">
                                {currentPossession.buildUpSpeed || 'MEDIUM'} SPEED
                            </span>
                        </div>
                    )}
                </div>

                {/* Streamlined Controls Overlay */}
                <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-transparent to-black/20 opacity-0 group-hover:opacity-100 transition-all duration-500 flex flex-col justify-between p-4 z-40">
                    <div className="flex justify-between items-start">
                        <div className="flex items-center gap-2 bg-black/40 backdrop-blur-md px-3 py-1.5 rounded-full border border-white/10">
                            <div className="h-2 w-2 rounded-full bg-red-500 animate-pulse" />
                            <span className="text-[10px] font-bold tracking-widest text-white uppercase">Live Stream</span>
                        </div>
                    </div>

                    <div className="flex items-center gap-4 bg-black/40 backdrop-blur-md p-3 rounded-2xl border border-white/10 shadow-2xl">
                        <Button
                            variant="ghost"
                            size="icon"
                            className="h-10 w-10 text-white hover:bg-white/20 hover:scale-110 transition-transform"
                            onClick={togglePlay}
                        >
                            {isPlaying ? <Pause className="w-6 h-6 fill-current" /> : <Play className="w-6 h-6 fill-current" />}
                        </Button>

                        <div className="flex items-center gap-2">
                            <Button
                                variant="ghost"
                                size="icon"
                                className="h-8 w-8 text-white/70 hover:text-white"
                                onClick={() => seek(-5)}
                            >
                                <RotateCcw className="w-4 h-4" />
                            </Button>
                            <Button
                                variant="ghost"
                                size="icon"
                                className="h-8 w-8 text-white/70 hover:text-white"
                                onClick={() => seek(5)}
                            >
                                <RotateCw className="w-4 h-4" />
                            </Button>
                        </div>

                        <div className="flex items-center gap-3 flex-1 px-2">
                            <Volume2 className="w-5 h-5 text-slate-300" />
                            <Slider
                                value={[volume]}
                                max={1}
                                step={0.01}
                                onValueChange={handleVolumeChange}
                                className="w-full cursor-pointer"
                            />
                        </div>

                        <div className="flex items-center gap-2">
                            {onClose && (
                                <Button
                                    variant="ghost"
                                    size="icon"
                                    onClick={onClose}
                                    className="h-10 w-10 text-white hover:bg-red-500/20 hover:text-red-400 transition-colors"
                                >
                                    <X className="w-6 h-6" />
                                </Button>
                            )}

                            <Button
                                variant="ghost"
                                size="icon"
                                className={cn("h-10 w-10 transition-all", showLiveFeedback ? "text-primary" : "text-white/40")}
                                onClick={() => setShowLiveFeedback(!showLiveFeedback)}
                                title="Toggle Live Feedback"
                            >
                                <Radio className="w-5 h-5" />
                            </Button>

                            <Button
                                variant="ghost"
                                size="icon"
                                className="h-10 w-10 text-white hover:bg-white/20 transition-all"
                                onClick={toggleFullscreen}
                            >
                                <Maximize className="w-6 h-6" />
                            </Button>
                        </div>
                    </div>
                </div>

                {/* Loading/Error states for streamlined mode */}
                {isLoading && (
                    <div className="absolute inset-0 flex items-center justify-center bg-black/60">
                        <Loader2 className="h-10 w-10 animate-spin text-primary" />
                    </div>
                )}
                {error && (
                    <div className="absolute inset-0 flex items-center justify-center bg-black/80 p-4 text-center">
                        <div className="space-y-2">
                            <AlertCircle className="w-10 h-10 text-destructive mx-auto" />
                            <p className="text-xs text-slate-300">{error}</p>
                            <Button size="sm" variant="outline" onClick={() => window.location.reload()}>Retry</Button>
                        </div>
                    </div>
                )}
            </div>
        );
    }

    return (
        <Card className="w-full max-w-4xl mx-auto bg-slate-900 text-white border-slate-800">
            <CardContent className="p-6 space-y-6">
                <div className="flex items-center justify-between">
                    <h2 className="text-2xl font-bold flex items-center gap-2">
                        <Radio className="w-6 h-6 text-red-500" />
                        Live Stream Player
                    </h2>
                    <div className="flex items-center gap-2">
                        {streamUrl && isPlaying && <Badge variant="destructive" className="animate-pulse">LIVE</Badge>}
                        {obsConnected && isRecording && <Badge variant="destructive" className="bg-red-600 animate-pulse">REC</Badge>}
                        {onClose && (
                            <Button variant="ghost" size="icon" onClick={onClose} className="h-8 w-8 text-slate-400 hover:text-white hover:bg-slate-800">
                                <X className="w-4 h-4" />
                            </Button>
                        )}
                    </div>
                </div>

                {isAdmin && (
                    <div className="space-y-4 pt-2">
                        <div className="space-y-2">
                            <Label htmlFor="stream-url" className="text-slate-400 uppercase text-xs font-bold tracking-wider flex items-center gap-2">
                                <Settings2 className="w-3 h-3 text-blue-400" />
                                Stream Configuration
                            </Label>
                            <div className="flex gap-2">
                                <Input
                                    id="stream-url"
                                    value={streamUrl}
                                    onChange={(e) => setStreamUrl(e.target.value)}
                                    placeholder="Paste your .m3u8 or .ts link here..."
                                    className="bg-slate-950 border-slate-800 h-9 text-xs flex-1 shadow-inner focus:border-blue-500/50 transition-colors"
                                />
                                <Button size="sm" variant="outline" className="h-9 px-3 text-[10px] border-slate-700 hover:bg-slate-800" onClick={() => setStreamUrl("https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8")}>
                                    Test Link
                                </Button>
                            </div>
                        </div>

                        <div className="flex items-center justify-between bg-blue-900/10 border border-blue-500/20 rounded-md px-3 py-2">
                            <div className="space-y-0.5">
                                <div className="flex items-center gap-2">
                                    <Badge variant="outline" className="text-[9px] h-4 bg-blue-500/10 text-blue-400 border-blue-500/30">CORS Bypass</Badge>
                                    <Label className="text-[11px] font-bold text-slate-300">Enable Stream Proxy</Label>
                                </div>
                                <p className="text-[9px] text-slate-500">Enable if the video fails to load or shows a "CORS" error.</p>
                            </div>
                            <Switch
                                checked={useStreamProxy}
                                onCheckedChange={setUseStreamProxy}
                                className="data-[state=checked]:bg-blue-600"
                            />
                        </div>

                        {OBS_ENABLED && (
                            <div className="border-t border-slate-800/50 pt-4">
                                <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => setShowObsSettings(!showObsSettings)}
                                    className="w-full flex items-center justify-between h-8 px-2 text-slate-500 hover:text-slate-300 hover:bg-slate-800/50 group"
                                >
                                    <div className="flex items-center gap-2">
                                        <Monitor className={`w-3.5 h-3.5 ${obsConnected ? 'text-green-500' : 'text-slate-600'}`} />
                                        <span className="text-[10px] font-bold uppercase tracking-widest">OBS Integration (Optional)</span>
                                    </div>
                                    {showObsSettings ? <ChevronUp className="w-4 h-4" /> : <ChevronDown className="w-4 h-4" />}
                                </Button>

                                {showObsSettings && (
                                    <div className="mt-4 space-y-4 animate-in fade-in slide-in-from-top-2 duration-300">
                                        <div className="flex items-center justify-between">
                                            <Label className="text-[10px] text-slate-500 uppercase font-semibold">WebSocket Connection</Label>
                                            <div className="flex items-center gap-2">
                                                <Badge variant={obsConnected ? "default" : "outline"} className={`text-[9px] px-1.5 h-4 ${obsConnected ? "bg-green-600 border-none" : "text-slate-500 border-slate-800"}`}>
                                                    {obsConnected ? "Connected" : "Disconnected"}
                                                </Badge>
                                                <Badge variant={socket?.connected ? "default" : "outline"} className={`text-[9px] px-1.5 h-4 ${socket?.connected ? "bg-blue-600 border-none" : "text-slate-500 border-slate-800"}`}>
                                                    Socket: {socket?.connected ? "OK" : "Error"}
                                                </Badge>
                                            </div>
                                        </div>

                                        {error && (
                                            <div className="bg-red-900/10 border border-red-500/20 rounded p-3">
                                                <div className="flex items-start gap-2">
                                                    <AlertCircle className="w-4 h-4 text-red-500 mt-0.5 flex-shrink-0" />
                                                    <div className="flex-1 space-y-1">
                                                        <p className="text-[10px] text-red-400 whitespace-pre-line leading-relaxed">{error}</p>
                                                        <div className="flex gap-2 mt-2">
                                                            <Button variant="ghost" size="sm" onClick={() => setError(null)} className="h-6 text-[9px] text-red-400 hover:bg-red-500/10">Dismiss</Button>
                                                            <Button variant="ghost" size="sm" onClick={() => { setError(null); connectToOBS(); }} className="h-6 text-[9px] text-red-400 hover:bg-red-500/10 font-bold">Retry</Button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        )}

                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-3 pb-2">
                                            <div className="space-y-1.5">
                                                <Label htmlFor="obs-address" className="text-[9px] text-slate-500 ml-1">WebSocket Address</Label>
                                                <Input id="obs-address" value={obsAddress} onChange={(e) => setObsAddress(e.target.value)} placeholder="ws://localhost:4455" className="bg-slate-950 border-slate-800 h-8 text-xs focus:ring-1 focus:ring-slate-700" disabled={obsConnected || isConnectingObs} />
                                            </div>
                                            <div className="space-y-1.5">
                                                <Label htmlFor="obs-password" className="text-[9px] text-slate-500 ml-1">Password</Label>
                                                <Input id="obs-password" type="password" value={obsPassword} onChange={(e) => setObsPassword(e.target.value)} placeholder="Optional" className="bg-slate-950 border-slate-800 h-8 text-xs focus:ring-1 focus:ring-slate-700" disabled={obsConnected || isConnectingObs} />
                                            </div>
                                        </div>

                                        <div className="flex gap-2 border-t border-slate-800 pt-3">
                                            <Button onClick={obsConnected ? disconnectOBS : connectToOBS} disabled={isConnectingObs} variant={obsConnected ? "destructive" : "default"} className="flex-1 h-8 text-xs font-bold uppercase tracking-wider">
                                                {isConnectingObs ? <><Loader2 className="w-3 h-3 animate-spin mr-2" />Connecting...</> : obsConnected ? <><Unlink className="w-3 h-3 mr-2" />Disconnect</> : <><LinkIcon className="w-3 h-3 mr-2" />Connect OBS</>}
                                            </Button>
                                            {obsConnected && (
                                                <Button onClick={toggleRecording} variant={isRecording ? "destructive" : "outline"} className="flex-1 h-8 text-xs font-bold uppercase tracking-wider border-red-500/30 text-red-400 hover:bg-red-950/20">
                                                    <Radio className={`w-3 h-3 mr-2 ${isRecording ? 'animate-pulse' : ''}`} />
                                                    {isRecording ? "Stop Record" : "Start Record"}
                                                </Button>
                                            )}
                                        </div>

                                        <div className="space-y-3 pt-2">
                                            <div className="flex items-center justify-between border-b border-slate-800 pb-1">
                                                <Label className="text-slate-500 text-[9px] font-bold uppercase tracking-wider">Quick Select Scenes</Label>
                                                <Button variant="ghost" size="sm" onClick={() => refreshScenes()} className="h-5 text-[9px] text-slate-500 hover:text-white" disabled={!obsConnected}>
                                                    <RefreshCw className="w-2.5 h-2.5 mr-1" /> Sync
                                                </Button>
                                            </div>
                                            <div className="flex gap-2 flex-wrap">
                                                <Button variant="outline" size="sm" className="h-7 text-[9px] flex-1 border-slate-800 hover:bg-slate-800" disabled={!obsConnected} onClick={() => handleSourceSwitch("Game Capture")}>
                                                    <Gamepad2 className="w-3 h-3 mr-1.5" /> Game
                                                </Button>
                                                <Button variant="outline" size="sm" className="h-7 text-[9px] flex-1 border-slate-800 hover:bg-slate-800" disabled={!obsConnected} onClick={() => handleSourceSwitch("Camera Feed")}>
                                                    <Camera className="w-3 h-3 mr-1.5" /> Camera
                                                </Button>
                                                <Button variant="outline" size="sm" className="h-7 text-[9px] flex-1 border-slate-800 hover:bg-slate-800" disabled={!obsConnected} onClick={() => handleSourceSwitch("Display Capture")}>
                                                    <Monitor className="w-3 h-3 mr-1.5" /> Screen
                                                </Button>
                                            </div>

                                            {obsConnected && availableScenes.length > 0 && (
                                                <div className="flex gap-1.5 flex-wrap pt-1">
                                                    {availableScenes.map(sceneName => (
                                                        <Button key={sceneName} variant="ghost" size="sm" className="h-6 px-2 text-[9px] bg-slate-950 border border-slate-800/50 hover:bg-slate-800 whitespace-nowrap" onClick={() => handleSourceSwitch(sceneName)}>
                                                            {sceneName}
                                                        </Button>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                )}

                <div ref={fullscreenContainerRef} className="relative aspect-video bg-black rounded-lg overflow-hidden border border-slate-800 shadow-2xl group">
                    <video ref={videoRef} className="w-full h-full object-contain" playsInline />
                    <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex flex-col justify-end p-4">
                        <div className="flex items-center gap-4">
                            <Button variant="ghost" size="icon" onClick={togglePlay} className="text-white hover:bg-white/20" disabled={isLoading}>
                                {isPlaying ? <Pause className="w-6 h-6" /> : <Play className="w-6 h-6" />}
                            </Button>
                            <div className="flex items-center gap-2 flex-1">
                                <Volume2 className="w-4 h-4 text-slate-300" />
                                <Slider value={[volume]} max={1} step={0.1} onValueChange={handleVolumeChange} className="w-24" />
                            </div>
                            <Button variant="ghost" size="icon" onClick={toggleFullscreen} className="text-white hover:bg-white/20">
                                <Maximize className="w-6 h-6" />
                            </Button>
                        </div>
                    </div>
                </div>

                {/* Video Player Section */}
            </CardContent>
        </Card>
    );
});

LiveStreamPlayer.displayName = "LiveStreamPlayer";
</file>

<file path="src/components/LoggerAuditPanel.tsx">
import {
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
    DialogFooter,
    DialogTrigger
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import {
    ClipboardCheck,
    Mic,
    Activity,
    AlertCircle,
    FileOutput,
    Video
} from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Card } from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { useSocket as useSocketContext } from '@/contexts/SocketContext';
import { useState, useEffect } from "react";
import { LoggedEvent } from "@/hooks/useGamepad";
import { toast } from "sonner";

// --- TYPES ---
interface RealityEvent {
    id: number;
    time: string;
    eventName: string;
    target: string;
    source: string;
}

interface LoggerAuditPanelProps {
    systemEvents: LoggedEvent[];
    onExport: () => void;
}

// --- ZONE SELECTOR COMPONENT ---
const ZoneSelector = ({ value, onChange }: { value: number, onChange: (z: number) => void }) => {
    // 3 Columns x 6 Rows Grid
    const rows = 6;
    const cols = 3;

    return (
        <div className="grid grid-cols-3 gap-1 w-full max-w-[200px] mx-auto aspect-[3/4] bg-slate-900/50 p-2 rounded-lg border border-white/10">
            {Array.from({ length: rows * cols }).map((_, i) => {
                const zoneId = i + 1;
                const isActive = value === zoneId;
                return (
                    <button
                        key={zoneId}
                        onClick={() => onChange(zoneId)}
                        className={cn(
                            "rounded text-[10px] font-bold flex items-center justify-center transition-all",
                            "hover:bg-primary/20 hover:text-primary",
                            isActive
                                ? "bg-primary text-black font-black shadow-[0_0_10px_rgba(34,197,94,0.4)]"
                                : "bg-white/5 text-slate-500"
                        )}
                    >
                        {zoneId}
                    </button>
                );
            })}
        </div>
    );
};

export const LoggerAuditPanel = ({ systemEvents, onExport }: LoggerAuditPanelProps) => {
    const { socket } = useSocketContext();
    const [realityFeed, setRealityFeed] = useState<RealityEvent[]>([]);
    const [customReality, setCustomReality] = useState('');

    // --- EDITING STATE ---
    const [editingEvent, setEditingEvent] = useState<LoggedEvent | null>(null);
    const [editForm, setEditForm] = useState<{ zone: number, note?: string }>({ zone: 0 });



    // Listen for Spotter Pings
    useEffect(() => {
        if (!socket) return;

        const handleSpotterPing = (ping: any) => {
            const newEntry: RealityEvent = {
                id: ping.id,
                time: ping.matchTime,
                eventName: 'Spotter Ping',
                target: ping.target,
                source: 'PING'
            };
            setRealityFeed(prev => [newEntry, ...prev]);
            toast.info(`Reality Flag: Spotter Ping ${ping.target}`);
        };

        socket.on('spotter-ping', handleSpotterPing);
        return () => { socket.off('spotter-ping', handleSpotterPing); };
    }, [socket]);

    const addManualReality = (name: string, target: 'HOME' | 'AWAY' = 'HOME') => {
        const newEntry: RealityEvent = {
            id: Date.now(),
            time: 'LIVE', // This should Ideally be synced to match time
            eventName: name,
            target,
            source: 'VOICE'
        };
        setRealityFeed(prev => [newEntry, ...prev]);
    };

    // Open Edit Modal
    const handleEventClick = (event: LoggedEvent) => {
        setEditingEvent(event);
        setEditForm({ zone: event.zone || 0, note: event.validationNotes || '' });
    };

    // Save Changes (Ideally this would bubble up to parent or context)
    const handleSaveEdit = () => {
        if (editingEvent) {
            // Update local object reference (In real app, trigger an API call or Context update)
            editingEvent.zone = editForm.zone;
            editingEvent.validationNotes = editForm.note;
            editingEvent.isValidated = true; // Mark as validated since human touched it

            toast.success(`Updated Event #${editingEvent.id}: Zone ${editForm.zone}`);
            setEditingEvent(null);
        }
    };

    return (
        <div className="flex flex-col h-full bg-slate-950/20 gap-4 p-4 overflow-hidden">
            {/* HEADER ACTIONS */}
            <div className="flex items-center justify-between">
                <div className="flex items-center gap-3">
                    <div className="p-2 bg-primary/10 rounded-lg">
                        <ClipboardCheck className="w-5 h-5 text-primary" />
                    </div>
                    <div>
                        <h2 className="text-sm font-bold uppercase tracking-tight text-white">System Audit Log</h2>
                        <p className="text-[10px] text-slate-500 font-medium">REALITY vs SYSTEM MIRROR</p>
                    </div>
                </div>
                <div className="flex gap-2 items-center">
                    <Button variant="outline" size="sm" className="h-8 text-[10px] gap-2 border-white/5 bg-slate-900/50" onClick={onExport}>
                        <FileOutput className="w-3.5 h-3.5" /> EXPORT REPORT
                    </Button>
                </div>
            </div>

            <div className="grid grid-cols-2 flex-1 min-h-0 gap-4">
                {/* REALITY FEED (LEFT) */}
                <Card className="flex flex-col bg-slate-900/30 border-white/5 overflow-hidden">
                    <div className="p-3 border-b border-white/5 bg-slate-800/50 flex items-center justify-between">
                        <span className="text-[10px] font-bold uppercase tracking-widest flex items-center gap-2 text-primary">
                            <Mic className="w-3 h-3" /> Reality Feed
                        </span>
                        <div className="flex gap-1">
                            <button onClick={() => addManualReality('Possession', 'HOME')} className="text-[9px] px-2 py-0.5 rounded-full bg-primary/20 text-primary border border-primary/30">HOME</button>
                            <button onClick={() => addManualReality('Possession', 'AWAY')} className="text-[9px] px-2 py-0.5 rounded-full bg-destructive/20 text-destructive border border-destructive/30">AWAY</button>
                        </div>
                    </div>

                    <ScrollArea className="flex-1 p-2">
                        <div className="space-y-2">
                            {realityFeed.map(item => (
                                <div key={item.id} className="p-2 rounded-lg bg-slate-800/20 border border-white/5 flex items-center justify-between animate-in slide-in-from-left-2 transition-all">
                                    <div className="flex items-center gap-2">
                                        <Badge variant="outline" className="text-[9px] font-mono h-4 px-1 border-white/10">{item.time}</Badge>
                                        <span className="text-[11px] font-bold">{item.eventName}</span>
                                        <span className={cn("text-[9px] font-black", item.target === 'HOME' ? 'text-primary' : 'text-destructive')}>{item.target}</span>
                                    </div>
                                    <div className="flex items-center gap-1 opacity-50">
                                        <span className="text-[8px] uppercase font-bold">{item.source}</span>
                                    </div>
                                </div>
                            ))}
                            {realityFeed.length === 0 && (
                                <div className="h-32 flex items-center justify-center text-[10px] text-slate-500 italic">Waiting for Spotter voice/ping...</div>
                            )}
                        </div>
                    </ScrollArea>
                </Card>

                {/* SYSTEM FEED (RIGHT) */}
                <Card className="flex flex-col bg-slate-900/30 border-white/5 overflow-hidden">
                    <div className="p-3 border-b border-white/5 bg-slate-800/50">
                        <span className="text-[10px] font-bold uppercase tracking-widest flex items-center gap-2 text-emerald-400">
                            <Activity className="w-3 h-3" /> System Feed
                        </span>
                        <span className="ml-auto text-[9px] text-slate-500 italic px-2">Click Event to Edit</span>
                    </div>

                    <ScrollArea className="flex-1 p-2">
                        <div className="space-y-2">
                            {systemEvents.slice(0, 50).map((event, index) => (
                                <div
                                    key={event.id}
                                    onClick={() => handleEventClick(event)}
                                    className="p-2 rounded-lg bg-slate-800/40 border border-white/5 space-y-2 hover:bg-white/5 cursor-pointer transition-colors group"
                                >
                                    <div className="flex items-center justify-between">
                                        <div className="flex items-center gap-2">
                                            <Badge variant="outline" className="text-[9px] font-mono h-4 px-1 border-white/10">{event.matchTime || '00:00'}</Badge>
                                            <span className="text-[11px] font-bold uppercase">{event.eventName}</span>
                                        </div>
                                        <div className="flex gap-2 items-center">
                                            {event.zone && (
                                                <Badge variant="secondary" className="text-[9px] h-4 px-1 bg-white/10">Z{event.zone}</Badge>
                                            )}
                                            <Badge className="bg-emerald-500/20 text-emerald-500 border-none text-[8px] h-4 group-hover:bg-emerald-500 group-hover:text-black transition-colors">EDIT</Badge>
                                        </div>
                                    </div>

                                    {/* REAL FLAGS RENDERING (Placeholder for future real logic) */}
                                    {event.isCalculated && (
                                        <div className="flex gap-2">
                                            <div className="flex items-center gap-1 text-[9px] text-blue-500 font-bold bg-blue-500/10 px-1.5 py-0.5 rounded">
                                                <Activity className="w-3 h-3" /> CALCULATED
                                            </div>
                                        </div>
                                    )}
                                </div>
                            ))}
                            {systemEvents.length === 0 && (
                                <div className="h-32 flex items-center justify-center text-[10px] text-slate-500 italic">No system events recorded.</div>
                            )}
                        </div>
                    </ScrollArea>
                </Card>
            </div>

            {/* EDIT DIALOG */}
            <Dialog open={!!editingEvent} onOpenChange={(open) => !open && setEditingEvent(null)}>
                <DialogContent className="bg-slate-900 border-white/10 text-white sm:max-w-md">
                    <DialogHeader>
                        <DialogTitle className="flex items-center justify-between text-sm">
                            <span>Edit Event: <span className="text-primary">{editingEvent?.eventName}</span></span>
                            <Badge variant="outline" className="font-mono bg-black/20">{editingEvent?.matchTime}</Badge>
                        </DialogTitle>
                    </DialogHeader>

                    <div className="grid gap-4 py-4">
                        <div className="flex gap-4">
                            {/* Zone Selector */}
                            <div className="flex-1 space-y-2">
                                <Label className="text-xs text-slate-400">Tactical Zone</Label>
                                <ZoneSelector
                                    value={editForm.zone}
                                    onChange={(z) => setEditForm(prev => ({ ...prev, zone: z }))}
                                />
                                <div className="text-center text-xs font-mono text-slate-500">
                                    Current: {editForm.zone ? `Zone ${editForm.zone}` : "None"}
                                </div>
                            </div>

                            {/* Notes / Details */}
                            <div className="flex-1 space-y-4">
                                <div className="space-y-2">
                                    <Label className="text-xs text-slate-400">Validation Notes</Label>
                                    <Input
                                        value={editForm.note}
                                        onChange={(e) => setEditForm(prev => ({ ...prev, note: e.target.value }))}
                                        className="bg-black/20 border-white/10 text-xs h-8"
                                        placeholder="Reason for change..."
                                    />
                                </div>
                                <div className="p-3 bg-red-500/10 border border-red-500/20 rounded text-[10px] text-red-300">
                                    <p>Changing zones will affect analytics heatmaps and passing networks linked to this event.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <DialogFooter>
                        <Button size="sm" variant="ghost" className="h-8 text-xs hover:bg-white/10" onClick={() => setEditingEvent(null)}>Cancel</Button>
                        <Button size="sm" className="h-8 text-xs bg-primary text-black hover:bg-primary/90" onClick={handleSaveEdit}>Save Changes</Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>

            {/* FOOTER - MISSING EVENT TRACKER */}
            <div className="bg-destructive/10 border border-destructive/20 p-3 rounded-xl flex items-center justify-between">
                <div className="flex items-center gap-3">
                    <AlertCircle className="w-5 h-5 text-destructive" />
                    <div>
                        <span className="text-[10px] font-bold text-destructive uppercase">Audit Alert</span>
                        <p className="text-[11px] font-medium text-white">3 Missed events detected in last phase.</p>
                    </div>
                </div>
                <Button variant="destructive" size="sm" className="h-7 text-[10px] font-black italic">MARK MISSED</Button>
            </div>
        </div>
    );
};
</file>

<file path="src/components/MappingOverlay.tsx">
import React, { useState, useMemo } from 'react';
import { useEventConfig } from '@/contexts/EventConfigContext';
import { BUTTON_LABELS } from '@/hooks/useGamepad';

const MappingOverlay = () => {
    const [isOpen, setIsOpen] = useState(true);
    const { events } = useEventConfig();

    const { liveMappings, postMatchMappings } = useMemo(() => {
        const live: any[] = [];
        const post: any[] = [];

        events.forEach(event => {
            if (!event.gamepadMappings) return;

            event.gamepadMappings.forEach(m => {
                const label = m.modifier ? `${m.modifier}+${BUTTON_LABELS[m.buttonIndex]}` : BUTTON_LABELS[m.buttonIndex];
                const item = {
                    eventName: event.eventName,
                    eventDescription: event.label,
                    buttonLabel: label
                };

                if (m.mode === 'LIVE' || m.mode === 'BOTH') {
                    live.push(item);
                }
                if (m.mode === 'POST' || m.mode === 'BOTH') {
                    post.push(item);
                }
            });
        });

        // Sort by button index/label stability if needed, but registry order is usually fine
        return { liveMappings: live, postMatchMappings: post };
    }, [events]);

    if (!isOpen) {
        return (
            <div
                className="fixed bottom-4 right-4 z-50 bg-black/50 text-white p-2 rounded cursor-pointer hover:bg-black/70 text-xs"
                onClick={() => setIsOpen(true)}
            >
                Show Mappings
            </div>
        );
    }

    return (
        <div className="fixed top-0 right-0 h-screen w-80 bg-black/20 backdrop-blur-sm z-50 p-4 overflow-y-auto text-white border-l border-white/10 shadow-2xl transition-all duration-300 pointer-events-none hover:pointer-events-auto hover:bg-black/40">
            <div className="flex justify-between items-center mb-4 pointer-events-auto">
                <h2 className="text-sm font-bold uppercase tracking-wider text-green-400">Tacta Control Map</h2>
                <button
                    onClick={() => setIsOpen(false)}
                    className="text-xs bg-white/10 hover:bg-white/20 px-2 py-1 rounded"
                >
                    Hide
                </button>
            </div>

            <div className="space-y-6">
                {/* LIVE MODE */}
                <div>
                    <h3 className="text-xs font-semibold text-gray-400 mb-2 border-b border-white/10 pb-1">Live Mode (Gamepad)</h3>
                    <div className="grid gap-2 text-xs">
                        {liveMappings.map((m, i) => (
                            <div key={`${m.eventName}-${i}`} className="flex justify-between items-center hover:bg-white/5 p-1 rounded">
                                <span className="text-gray-300 font-mono">{m.eventDescription}</span>
                                <span className="font-bold bg-white/10 px-1.5 rounded text-green-300 min-w-[24px] text-center">{m.buttonLabel}</span>
                            </div>
                        ))}
                    </div>
                </div>

                {/* POST MATCH MODE */}
                <div>
                    <h3 className="text-xs font-semibold text-gray-400 mb-2 border-b border-white/10 pb-1">Post-Match (Keyboard)</h3>
                    <div className="grid gap-2 text-xs">
                        {/* Hardcoded visual reference for Keyboard since it's not in the mappings array yet */}
                        <div className="flex justify-between items-center hover:bg-white/5 p-1 rounded">
                            <span className="text-gray-300">Play / Pause</span>
                            <span className="font-bold bg-white/10 px-1.5 rounded text-yellow-300">Space</span>
                        </div>
                        <div className="flex justify-between items-center hover:bg-white/5 p-1 rounded">
                            <span className="text-gray-300">Pass End</span>
                            <span className="font-bold bg-white/10 px-1.5 rounded text-yellow-300">1</span>
                        </div>
                        <div className="flex justify-between items-center hover:bg-white/5 p-1 rounded">
                            <span className="text-gray-300">Key Pass</span>
                            <span className="font-bold bg-white/10 px-1.5 rounded text-yellow-300">Shift+1</span>
                        </div>
                        <div className="flex justify-between items-center hover:bg-white/5 p-1 rounded">
                            <span className="text-gray-300">Assist</span>
                            <span className="font-bold bg-white/10 px-1.5 rounded text-yellow-300">Ctrl+1</span>
                        </div>
                        <div className="flex justify-between items-center hover:bg-white/5 p-1 rounded">
                            <span className="text-gray-300">Shot Outcome</span>
                            <span className="font-bold bg-white/10 px-1.5 rounded text-yellow-300">2</span>
                        </div>
                        <div className="flex justify-between items-center hover:bg-white/5 p-1 rounded">
                            <span className="text-gray-300">Tactical Tags (Q/W/E/R/Z)</span>
                            <span className="font-bold bg-white/10 px-1.5 rounded text-yellow-300">Keys</span>
                        </div>
                    </div>

                    <h3 className="text-xs font-semibold text-gray-400 mt-4 mb-2 border-b border-white/10 pb-1">Post-Match (Gamepad)</h3>
                    <div className="grid gap-2 text-xs">
                        {postMatchMappings.map((m, i) => (
                            <div key={`${m.eventName}-${i}`} className="flex justify-between items-center hover:bg-white/5 p-1 rounded">
                                <span className="text-gray-300 font-mono">{m.eventDescription}</span>
                                <span className="font-bold bg-white/10 px-1.5 rounded text-blue-300 min-w-[24px] text-center">{m.buttonLabel}</span>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default MappingOverlay;
</file>

<file path="src/components/MatchStateIndicator.tsx">
// src/components/MatchStateIndicator.tsx
// Visual display of current match state - shows possession, phase, zone, and transition status

import { useMatchContext } from '@/contexts/MatchContext';
import { useEffect, useState } from 'react';
import {
    ArrowRightLeft,
    Target,
    Shield,
    Flame,
    Timer,
    Users,
    TrendingUp,
    AlertTriangle,
    Zap
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface MatchStateIndicatorProps {
    compact?: boolean;
    className?: string;
}

export function MatchStateIndicator({ compact = false, className }: MatchStateIndicatorProps) {
    const {
        matchState,
        isInTransition,
        transitionTimeRemaining,
        currentPossession,
        stateLabel
    } = useMatchContext();

    const [countdown, setCountdown] = useState(0);

    // Update countdown for transition window
    useEffect(() => {
        if (isInTransition && transitionTimeRemaining > 0) {
            setCountdown(Math.ceil(transitionTimeRemaining / 1000));
            const interval = setInterval(() => {
                setCountdown(prev => Math.max(0, prev - 1));
            }, 1000);
            return () => clearInterval(interval);
        } else {
            setCountdown(0);
        }
    }, [isInTransition, transitionTimeRemaining]);

    // Team colors
    const teamColor = matchState.teamInPossession === 'TEAM_A'
        ? 'bg-blue-500'
        : matchState.teamInPossession === 'TEAM_B'
            ? 'bg-red-500'
            : 'bg-gray-400';

    const teamName = matchState.teamInPossession === 'TEAM_A'
        ? 'Home'
        : matchState.teamInPossession === 'TEAM_B'
            ? 'Away'
            : 'Neutral';

    // Phase display
    const phaseConfig: Record<string, { icon: React.ReactNode; label: string; color: string }> = {
        'BUILD_UP': { icon: <TrendingUp className="w-3 h-3" />, label: 'Build-Up', color: 'text-green-400' },
        'CONSOLIDATION': { icon: <Shield className="w-3 h-3" />, label: 'Consolidation', color: 'text-blue-400' },
        'FINAL_THIRD': { icon: <Target className="w-3 h-3" />, label: 'Final Third', color: 'text-orange-400' },
        'TRANSITION_OFF': { icon: <Zap className="w-3 h-3" />, label: 'Transition ‚ö°', color: 'text-yellow-400' },
        'TRANSITION_DEF': { icon: <Shield className="w-3 h-3" />, label: 'Def. Transition', color: 'text-purple-400' },
        'SET_PIECE': { icon: <Target className="w-3 h-3" />, label: 'Set Piece', color: 'text-cyan-400' },
        'NEUTRAL': { icon: <ArrowRightLeft className="w-3 h-3" />, label: 'Neutral', color: 'text-gray-400' },
    };

    const phase = phaseConfig[matchState.phase] || phaseConfig['NEUTRAL'];

    // Threat level styling
    const threatConfig: Record<string, { color: string; pulse: boolean }> = {
        'HIGH': { color: 'bg-red-500', pulse: true },
        'MEDIUM': { color: 'bg-yellow-500', pulse: false },
        'LOW': { color: 'bg-green-500', pulse: false },
    };

    const threat = threatConfig[matchState.threatLevel] || threatConfig['LOW'];

    // Pressure styling
    const pressureConfig: Record<string, string> = {
        'HIGH': 'üî¥ High Press',
        'MEDIUM': 'üü° Medium',
        'LOW': 'üü¢ Low Block',
    };

    // Zone display
    const zoneLabel = `${matchState.zone.third.charAt(0)}${matchState.zone.third.slice(1).toLowerCase()} ${matchState.zone.lane.replace(/_/g, ' ').toLowerCase()}`;

    if (compact) {
        return (
            <div className={cn(
                "flex items-center gap-2 px-3 py-1.5 rounded-lg bg-background/80 backdrop-blur-sm border border-border/50",
                className
            )}>
                {/* Team indicator */}
                <div className={cn("w-2 h-2 rounded-full", teamColor)} />
                <span className="text-xs font-medium">{teamName}</span>

                {/* Phase */}
                <span className={cn("text-xs", phase.color)}>
                    {phase.label}
                </span>

                {/* Transition countdown */}
                {isInTransition && countdown > 0 && (
                    <span className="flex items-center gap-1 text-xs text-yellow-400 animate-pulse">
                        <Timer className="w-3 h-3" />
                        {countdown}s
                    </span>
                )}

                {/* Threat */}
                <div className={cn(
                    "w-2 h-2 rounded-full",
                    threat.color,
                    threat.pulse && "animate-pulse"
                )} />
            </div>
        );
    }

    return (
        <div className={cn(
            "rounded-lg border border-border/50 bg-card/95 backdrop-blur-sm shadow-lg overflow-hidden",
            className
        )}>
            {/* Header with team possession */}
            <div className={cn(
                "px-4 py-2 flex items-center justify-between",
                teamColor,
                "text-white"
            )}>
                <div className="flex items-center gap-2">
                    <Users className="w-4 h-4" />
                    <span className="font-semibold text-sm">{teamName} Possession</span>
                </div>
                {currentPossession && (
                    <span className="text-xs opacity-80">
                        Chain #{currentPossession.id}
                    </span>
                )}
            </div>

            {/* State details */}
            <div className="p-3 space-y-2">
                {/* Phase row */}
                <div className="flex items-center justify-between">
                    <span className="text-xs text-muted-foreground">Phase</span>
                    <div className={cn("flex items-center gap-1.5 font-medium text-sm", phase.color)}>
                        {phase.icon}
                        {phase.label}
                    </div>
                </div>

                {/* Zone row */}
                <div className="flex items-center justify-between">
                    <span className="text-xs text-muted-foreground">Zone</span>
                    <span className="text-sm font-medium capitalize">{zoneLabel}</span>
                </div>

                {/* Pressure row */}
                <div className="flex items-center justify-between">
                    <span className="text-xs text-muted-foreground">Pressure</span>
                    <span className="text-sm">{pressureConfig[matchState.pressure]}</span>
                </div>

                {/* Threat level */}
                <div className="flex items-center justify-between">
                    <span className="text-xs text-muted-foreground">Threat</span>
                    <div className="flex items-center gap-1.5">
                        <div className={cn(
                            "w-2 h-2 rounded-full",
                            threat.color,
                            threat.pulse && "animate-pulse"
                        )} />
                        <span className="text-sm">{matchState.threatLevel}</span>
                    </div>
                </div>

                {/* Transition window countdown */}
                {isInTransition && countdown > 0 && (
                    <div className="mt-2 pt-2 border-t border-border/50">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-1.5 text-yellow-400">
                                <Zap className="w-4 h-4" />
                                <span className="text-sm font-semibold">Transition Window</span>
                            </div>
                            <div className="flex items-center gap-1 text-yellow-400 font-mono font-bold animate-pulse">
                                <Timer className="w-4 h-4" />
                                {countdown}s
                            </div>
                        </div>
                        {/* Progress bar */}
                        <div className="mt-1.5 h-1 bg-yellow-900/30 rounded-full overflow-hidden">
                            <div
                                className="h-full bg-yellow-400 transition-all duration-1000 ease-linear"
                                style={{ width: `${(countdown / 5) * 100}%` }}
                            />
                        </div>
                    </div>
                )}

                {/* Pressing context */}
                {matchState.pressingContext.active && (
                    <div className="mt-2 pt-2 border-t border-border/50">
                        <div className="flex items-center gap-1.5 text-orange-400">
                            <AlertTriangle className="w-4 h-4" />
                            <span className="text-sm font-semibold">Pressing Active</span>
                        </div>
                    </div>
                )}

                {/* Possession chain info */}
                {currentPossession && (
                    <div className="mt-2 pt-2 border-t border-border/50 text-xs text-muted-foreground">
                        <div className="flex justify-between">
                            <span>Passes: {currentPossession.passCount}</span>
                            <span>Events: {currentPossession.events.length}</span>
                        </div>
                        {currentPossession.enteredFinalThird && (
                            <span className="text-green-400">‚úì Final third entered</span>
                        )}
                        {currentPossession.fromTransition && (
                            <span className="text-yellow-400 ml-2">‚ö° From transition</span>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
}

export default MatchStateIndicator;
</file>

<file path="src/components/NavLink.tsx">
import { NavLink as RouterNavLink, NavLinkProps } from "react-router-dom";
import { forwardRef } from "react";
import { cn } from "@/lib/utils";

interface NavLinkCompatProps extends Omit<NavLinkProps, "className"> {
  className?: string;
  activeClassName?: string;
  pendingClassName?: string;
}

const NavLink = forwardRef<HTMLAnchorElement, NavLinkCompatProps>(
  ({ className, activeClassName, pendingClassName, to, ...props }, ref) => {
    return (
      <RouterNavLink
        ref={ref}
        to={to}
        className={({ isActive, isPending }) =>
          cn(className, isActive && activeClassName, isPending && pendingClassName)
        }
        {...props}
      />
    );
  },
);

NavLink.displayName = "NavLink";

export { NavLink };
</file>

<file path="src/components/PassingNetworkViz.tsx">
import React, { useMemo, useEffect, useRef, useState } from 'react';
import * as d3 from 'd3';
import { LoggedEvent } from '@/hooks/useGamepad';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import {
    Zap,
    Target,
    Activity,
    Share2,
    Cpu,
    ChevronRight,
    Network,
    TrendingUp,
    Users
} from 'lucide-react';

// --- Types ---
// LoggedEvent is imported from @/hooks/useGamepad

export interface PassConnection {
    from: number;
    to: number;
    count: number;
    team: string;
    bidirectional: boolean;
}

export interface PlayerNetworkNode extends d3.SimulationNodeDatum {
    playerId: number;
    playerName: string;
    team: string;
    passesGiven: number;
    passesReceived: number;
    centrality: number;
    betweenness: number;
    totalInvolvement: number;
    influence: number;
    reliability: number;
    threat: number;
    role: string;
}

export interface PassingNetwork {
    team: string;
    connections: PassConnection[];
    nodes: PlayerNetworkNode[];
    metrics: {
        totalPasses: number;
        uniquePassers: number;
        uniqueReceivers: number;
        avgPassesPerPlayer: number;
        networkDensity: number;
        keyPasser: PlayerNetworkNode | null;
        keyReceiver: PlayerNetworkNode | null;
        mostCentralPlayer: PlayerNetworkNode | null;
        mostFrequentConnection: PassConnection | null;
        bidirectionalConnections: number;
        transmissionRate: number;      // passes per minute
        stabilityScore: string;        // "OPTIMAL", "STABLE", "FRAGILE"
        threatVectors: number;         // passes crossing into final third
        systemEntropy: string;         // "LOW", "MEDIUM", "HIGH" based on density
    };
}

// --- Helper Functions ---

const isPass = (e: LoggedEvent) =>
    e.eventName === "PASS" ||
    e.eventName === "Successful Pass" ||
    e.eventName === "PASS_SUCCESS" ||
    e.eventName === "pass_start" ||
    e.eventName === "pass_end";

function getPlayerName(playerId: number, roster: any[]): string {
    const player = roster?.find(p =>
        (p.id !== undefined && p.id === playerId) ||
        (p.number !== undefined && p.number === playerId)
    );
    return player?.name || `Player ${playerId}`;
}

function calculateBetweennessCentrality(
    nodes: PlayerNetworkNode[],
    connections: PassConnection[]
): Map<number, number> {
    const betweennessMap = new Map<number, number>();
    nodes.forEach(node => {
        const incoming = connections.filter(c => c.to === node.playerId).length;
        const outgoing = connections.filter(c => c.from === node.playerId).length;
        betweennessMap.set(node.playerId, incoming * outgoing);
    });
    return betweennessMap;
}

function calculateNetworkDensity(nodes: number, connections: number): number {
    if (nodes <= 1) return 0;
    return connections / (nodes * (nodes - 1));
}

// --- Intelligence Engine (Pro logic) ---

const computeInfluence = (nodes: PlayerNetworkNode[], links: any[]) => {
    nodes.forEach(n => n.influence = 1);
    for (let i = 0; i < 5; i++) {
        const nextInfluence = new Map<number, number>();
        links.forEach(l => {
            const s = typeof l.source === 'object' ? l.source.playerId : l.source;
            const t = typeof l.target === 'object' ? l.target.playerId : l.target;
            nextInfluence.set(t, (nextInfluence.get(t) || 0) + (nodes.find(n => n.playerId === s)?.influence || 0));
        });
        const max = Math.max(...Array.from(nextInfluence.values()), 1);
        nodes.forEach(n => n.influence = (nextInfluence.get(n.playerId) || 0) / max);
    }
};

// --- Main Builder Function ---

export function buildPassingNetwork(
    events: LoggedEvent[],
    team: "TEAM_A" | "TEAM_B",
    roster: any[] = [],
    timeWindow: number = 8
): PassingNetwork {
    const teamPasses = events
        .filter(e => e.team === team && isPass(e))
        .sort((a, b) => (Number(a.videoTime) || Number(a.timestamp) || 0) - (Number(b.videoTime) || Number(b.timestamp) || 0));

    if (teamPasses.length === 0) return createEmptyNetwork(team);

    const passesWithPlayers = teamPasses.filter(p => p.player?.id !== undefined);
    if (passesWithPlayers.length === 0) return createEmptyNetwork(team);

    const connectionsList: Array<{ from: number, to: number }> = [];
    for (let i = 0; i < passesWithPlayers.length - 1; i++) {
        const p = passesWithPlayers[i];
        const r = passesWithPlayers[i + 1];
        const dt = (Number(r.videoTime) || Number(r.timestamp) || 0) - (Number(p.videoTime) || Number(p.timestamp) || 0);

        if (p.player!.id !== r.player!.id && dt >= 0 && dt < timeWindow) {
            connectionsList.push({ from: p.player!.id, to: r.player!.id });
        }
    }

    const connectionMap = new Map<string, PassConnection>();
    connectionsList.forEach(({ from, to }) => {
        const key = `${from}-${to}`;
        if (connectionMap.has(key)) {
            connectionMap.get(key)!.count++;
        } else {
            connectionMap.set(key, { from, to, count: 1, team, bidirectional: false });
        }
    });

    const aggregated = Array.from(connectionMap.values());
    aggregated.forEach(c => {
        const rev = `${c.to}-${c.from}`;
        if (connectionMap.has(rev)) c.bidirectional = true;
    });

    // Step 4: Build player nodes with stats and role heuristics
    const playerStatsMap = new Map<number, PlayerNetworkNode>();
    aggregated.forEach(c => {
        [c.from, c.to].forEach(id => {
            if (!playerStatsMap.has(id)) {
                playerStatsMap.set(id, {
                    playerId: id,
                    playerName: getPlayerName(id, roster),
                    team,
                    passesGiven: 0,
                    passesReceived: 0,
                    centrality: 0,
                    betweenness: 0,
                    totalInvolvement: 0,
                    influence: 0,
                    reliability: 0.8, // Default base
                    threat: 0,
                    role: "Asset"
                });
            }
        });
        playerStatsMap.get(c.from)!.passesGiven += c.count;
        playerStatsMap.get(c.to)!.passesReceived += c.count;
        playerStatsMap.get(c.from)!.totalInvolvement += c.count;
        playerStatsMap.get(c.to)!.totalInvolvement += c.count;
    });

    const nodes = Array.from(playerStatsMap.values());
    const betweenness = calculateBetweennessCentrality(nodes, aggregated);
    const maxB = Math.max(...Array.from(betweenness.values()), 1);

    // Calculate quality-based reliability if ratings exist
    const playerRatings = new Map<number, number[]>();
    events.filter(e => e.team === team && e.player?.id).forEach(e => {
        if (e.qualityRating) {
            const ratings = playerRatings.get(e.player!.id) || [];
            ratings.push(e.qualityRating);
            playerRatings.set(e.player!.id, ratings);
        }
    });

    nodes.forEach(n => {
        const degree = n.passesGiven + n.passesReceived;
        n.centrality = nodes.length > 1 ? degree / ((nodes.length - 1) * 2) : 0;
        n.betweenness = (betweenness.get(n.playerId) || 0) / maxB;

        // Threat calculation: involvement in final third passes
        const playerPasses = teamPasses.filter(p => p.player?.id === n.playerId);
        const playerThreat = playerPasses.filter(p => (p.endX || 0) > 70).length;
        n.threat = playerThreat / (playerPasses.length || 1);

        // Reliability: Avg Quality Rating or base 0.8
        const ratings = playerRatings.get(n.playerId);
        if (ratings && ratings.length > 0) {
            n.reliability = ratings.reduce((a, b) => a + b, 0) / (ratings.length * 5);
        } else {
            // No quality ratings available
            n.reliability = 0;
        }

        // Roles
        if (n.betweenness > 0.7) n.role = "Tactical Hub";
        else if (n.threat > 0.4) n.role = "Incisive Outlet";
        else if (n.passesGiven > n.passesReceived * 1.5) n.role = "Distributor";
        else if (n.passesReceived > n.passesGiven * 1.5) n.role = "Target Asset";
        else n.role = "Connector";
    });

    // Metric Calculations
    const times = teamPasses.map(p => Number(p.videoTime) || Number(p.timestamp) || 0).filter(t => t > 0);
    const durationSec = times.length > 1 ? Math.max(...times) - Math.min(...times) : 60;
    const transmissionRate = (teamPasses.length / (durationSec / 60));
    const threatVectors = teamPasses.filter(p => (p.endX || 0) > 70).length;
    const density = calculateNetworkDensity(nodes.length, aggregated.length);
    const stability = teamPasses.length > 0 ? (aggregated.reduce((s, c) => s + c.count, 0) / teamPasses.length) : 0;

    const mostFreq = aggregated.length > 0 ? aggregated.reduce((a, b) => a.count > b.count ? a : b) : null;

    return {
        team,
        connections: aggregated,
        nodes,
        metrics: {
            totalPasses: aggregated.reduce((s, c) => s + c.count, 0),
            uniquePassers: new Set(aggregated.map(c => c.from)).size,
            uniqueReceivers: new Set(aggregated.map(c => c.to)).size,
            avgPassesPerPlayer: nodes.length > 0 ? Math.round((aggregated.reduce((s, c) => s + c.count, 0) / nodes.length) * 10) / 10 : 0,
            networkDensity: Math.round(density * 100) / 100,
            keyPasser: nodes.length > 0 ? nodes.reduce((a, b) => a.passesGiven > b.passesGiven ? a : b) : null,
            keyReceiver: nodes.length > 0 ? nodes.reduce((a, b) => a.passesReceived > b.passesReceived ? a : b) : null,
            mostCentralPlayer: nodes.length > 0 ? nodes.reduce((a, b) => a.betweenness > b.betweenness ? a : b) : null,
            mostFrequentConnection: mostFreq,
            bidirectionalConnections: aggregated.filter(c => c.bidirectional).length,
            transmissionRate: Math.round(transmissionRate * 10) / 10,
            threatVectors,
            stabilityScore: stability > 0.8 ? "OPTIMAL" : stability > 0.5 ? "STABLE" : "FRAGILE",
            systemEntropy: density > 0.4 ? "LOW" : density > 0.2 ? "STABLE" : "HIGH"
        }
    };
}

function createEmptyNetwork(team: string): PassingNetwork {
    return {
        team, connections: [], nodes: [],
        metrics: {
            totalPasses: 0, uniquePassers: 0, uniqueReceivers: 0, avgPassesPerPlayer: 0,
            networkDensity: 0, keyPasser: null, keyReceiver: null, mostCentralPlayer: null,
            mostFrequentConnection: null, bidirectionalConnections: 0,
            transmissionRate: 0, threatVectors: 0, stabilityScore: "N/A", systemEntropy: "N/A"
        }
    };
}

// --- Visualization Component ---

interface PassingNetworkVizProps {
    network: PassingNetwork;
    teamName?: string;
    width?: number;
    height?: number;
    showLabels?: boolean;
    highlightBidirectional?: boolean;
}

export const PassingNetworkViz: React.FC<PassingNetworkVizProps> = ({
    network,
    teamName = "Team",
    width = 800,
    height = 600,
    showLabels = true,
    highlightBidirectional = true
}) => {
    const svgRef = useRef<SVGSVGElement>(null);
    const [hoveredNode, setHoveredNode] = useState<PlayerNetworkNode | null>(null);

    useEffect(() => {
        if (!svgRef.current || network.nodes.length === 0) return;

        const svg = d3.select(svgRef.current);
        svg.selectAll("*").remove();

        const nodes = network.nodes.map(n => ({ ...n }));
        const links = network.connections.map(c => ({
            source: c.from,
            target: c.to,
            weight: c.count,
            bidirectional: c.bidirectional
        }));

        // Compute influence using the Pro logic
        computeInfluence(nodes, links);

        const defs = svg.append("defs");
        const filter = defs.append("filter").attr("id", "neon-glow");
        filter.append("feGaussianBlur").attr("stdDeviation", "2.5").attr("result", "blur");
        const merge = filter.append("feMerge");
        merge.append("feMergeNode").attr("in", "blur");
        merge.append("feMergeNode").attr("in", "SourceGraphic");

        const simulation = d3.forceSimulation<any>(nodes)
            .force("link", d3.forceLink(links).id((d: any) => Number(d.playerId)).distance(150))  // FIXED: Added Number() conversion
            .force("charge", d3.forceManyBody().strength(-1500))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(60));

        const g = svg.append("g");

        // Links (The "Flow")
        const link = g.append("g")
            .selectAll("path")
            .data(links)
            .enter().append("path")
            .attr("stroke", d => d.bidirectional && highlightBidirectional ? "rgba(239, 68, 68, 0.6)" : "rgba(34, 211, 238, 0.4)")
            .attr("stroke-width", d => Math.sqrt(d.weight) * 3)
            .attr("fill", "none")
            .attr("class", d => d.weight > 3 ? "animate-pulse" : "");

        const node = g.append("g")
            .selectAll("g")
            .data(nodes)
            .enter().append("g")
            .on("mouseenter", (e, d) => setHoveredNode(d))
            .on("mouseleave", () => setHoveredNode(null))
            .call(d3.drag<any, any>()
                .on("start", (e, d) => {
                    if (!e.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x; d.fy = d.y;
                })
                .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
                .on("end", (e, d) => {
                    if (!e.active) simulation.alphaTarget(0);
                    d.fx = null; d.fy = null;
                })
            );

        node.append("circle")
            .attr("r", d => 20 + (d.influence || 0) * 30)
            .attr("fill", "#0f172a")
            .attr("stroke", d => (d.influence || 0) > 0.7 ? "#22d3ee" : "#334155")
            .attr("stroke-width", 3)
            .style("filter", d => (d.influence || 0) > 0.7 ? "url(#neon-glow)" : "none");

        node.append("text")
            .attr("dy", "0.35em")
            .attr("text-anchor", "middle")
            .text(d => d.playerName.split(' ').pop() || "")
            .attr("fill", "#f8fafc")
            .style("font-size", "11px")
            .style("font-weight", "900")
            .style("text-transform", "uppercase")
            .style("pointer-events", "none");

        simulation.on("tick", () => {
            link.attr("d", (d: any) => {
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const dr = Math.sqrt(dx * dx + dy * dy) * 2;
                return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
            });
            node.attr("transform", (d: any) => `translate(${d.x},${d.y})`);
        });

        return () => { simulation.stop(); };
    }, [network, width, height, highlightBidirectional]);

    if (network.nodes.length === 0) {
        return (
            <Card className="bg-[#020617] border-slate-800">
                <CardHeader>
                    <CardTitle className="text-cyan-400 uppercase italic">Network Offline</CardTitle>
                </CardHeader>
                <CardContent className="h-40 flex items-center justify-center text-slate-500 font-mono text-xs">
                    SYSTEM_MESSAGE: NO_PASSING_DATA_IN_CURRENT_WINDOW
                </CardContent>
            </Card>
        );
    }

    return (
        <Card className="bg-[#020617] border-slate-800 shadow-2xl overflow-hidden text-slate-200">
            <CardHeader className="border-b border-slate-800 bg-slate-900/50 backdrop-blur-md">
                <div className="flex justify-between items-center">
                    <div className="space-y-1">
                        <CardTitle className="text-2xl font-black tracking-tighter flex items-center gap-2 italic">
                            <Cpu className="text-cyan-400 w-6 h-6" />
                            TACTICAL FLOW <span className="text-cyan-400">OS</span>
                        </CardTitle>
                        <div className="text-[10px] text-slate-500 font-mono uppercase tracking-widest">
                            {teamName} Network Synthesis // Nodes: {network.nodes.length} // Flux: {network.metrics.totalPasses}
                        </div>
                    </div>
                    <div className="flex gap-4">
                        <div className="text-right">
                            <div className="text-xs font-mono text-slate-500 uppercase">Density</div>
                            <div className="text-lg font-black text-cyan-400">{(network.metrics.networkDensity * 100).toFixed(1)}%</div>
                        </div>
                    </div>
                </div>
            </CardHeader>

            <CardContent className="p-0 relative">
                <svg
                    ref={svgRef}
                    viewBox={`0 0 ${width} ${height}`}
                    className="w-full h-auto bg-[radial-gradient(#1e293b_1px,transparent_1px)] [background-size:25px_25px]"
                />

                {/* Hub Overlay */}
                <div className="absolute top-6 left-6 space-y-2">
                    {network.nodes.sort((a, b) => b.influence - a.influence).slice(0, 3).map((n, i) => (
                        <div key={n.playerId} className="bg-slate-900/80 border border-slate-700 p-2 rounded-lg flex items-center gap-3 backdrop-blur-xl border-l-4 border-l-cyan-400 w-48">
                            <div className="bg-cyan-500/10 text-cyan-400 text-[10px] font-black h-8 w-8 rounded flex items-center justify-center">
                                0{i + 1}
                            </div>
                            <div className="overflow-hidden">
                                <div className="text-[9px] font-mono text-slate-500 uppercase truncate">Primary {n.role}</div>
                                <div className="text-xs font-bold uppercase italic truncate">{n.playerName}</div>
                            </div>
                        </div>
                    ))}
                </div>

                {/* Node Inspector */}
                {hoveredNode && (
                    <div className="absolute bottom-6 left-6 right-6 bg-cyan-950/40 border border-cyan-500/30 backdrop-blur-2xl p-4 rounded-xl flex justify-between animate-in fade-in slide-in-from-bottom-4">
                        <div className="flex items-center gap-4">
                            <div className="h-12 w-12 rounded-full border-2 border-cyan-400 flex items-center justify-center bg-cyan-400/10">
                                <Activity className="text-cyan-400" />
                            </div>
                            <div>
                                <h4 className="text-lg font-black uppercase italic tracking-tighter">{hoveredNode.playerName}</h4>
                                <p className="text-[10px] font-mono text-cyan-400 uppercase">Influence: {(hoveredNode.influence * 100).toFixed(1)}% // Role: {hoveredNode.role}</p>
                            </div>
                        </div>
                        <div className="flex gap-8 text-right">
                            <div>
                                <div className="text-[9px] text-slate-400 font-mono">RELIABILITY</div>
                                <div className="text-xl font-black text-white">{Math.round(hoveredNode.reliability * 100)}%</div>
                            </div>
                            <div>
                                <div className="text-[9px] text-slate-400 font-mono">DELIVERED</div>
                                <div className="text-xl font-black">{hoveredNode.passesGiven}</div>
                            </div>
                            <div>
                                <div className="text-[9px] text-slate-400 font-mono">ACQUIRED</div>
                                <div className="text-xl font-black">{hoveredNode.passesReceived}</div>
                            </div>
                        </div>
                    </div>
                )}
            </CardContent>

            <div className="bg-slate-900/80 p-6 grid grid-cols-4 gap-4 border-t border-slate-800">
                {[
                    { label: 'Transmission Rate', val: `${network.metrics.transmissionRate} p/m`, icon: Zap },
                    { label: 'System Cohesion', val: `${(network.metrics.networkDensity * 100).toFixed(0)}%`, icon: Share2 },
                    { label: 'Entropy', val: network.metrics.systemEntropy, icon: Target },
                    { label: 'Threat Vectors', val: network.metrics.threatVectors, icon: ChevronRight },
                ].map((stat, i) => (
                    <div key={i} className="space-y-1 border-r border-slate-800 last:border-0 px-4">
                        <div className="flex items-center gap-2 text-[9px] font-mono text-slate-500 uppercase">
                            <stat.icon className="w-3 h-3 text-cyan-500" /> {stat.label}
                        </div>
                        <div className="text-lg font-black text-slate-200">{stat.val}</div>
                    </div>
                ))}
            </div>

            {/* Distribution intelligence Table */}
            <div className="p-6 bg-slate-950/50">
                <div className="text-[10px] font-black uppercase tracking-[0.3em] text-cyan-500 mb-4 flex items-center gap-3">
                    <div className="h-[1px] w-8 bg-cyan-500/50" /> Distribution Intelligence <div className="h-[1px] flex-1 bg-white/5" />
                </div>
                <div className="border border-slate-800 rounded-lg overflow-hidden font-mono text-[11px]">
                    <div className="bg-slate-900/50 grid grid-cols-5 p-3 font-bold text-slate-400 border-b border-slate-800">
                        <div>ASSET_ID</div>
                        <div className="text-center">SENT</div>
                        <div className="text-center">RECV</div>
                        <div className="text-center">VOL</div>
                        <div className="text-right">CONNECTIVITY</div>
                    </div>
                    {network.nodes.sort((a, b) => b.totalInvolvement - a.totalInvolvement).map(node => (
                        <div key={node.playerId} className="grid grid-cols-5 p-3 border-b border-slate-800/50 hover:bg-cyan-500/5 transition-colors">
                            <div className="flex items-center gap-2 font-bold">
                                <span className="text-cyan-500 opacity-50">#{node.playerId}</span>
                                {node.playerName.toUpperCase()}
                            </div>
                            <div className="text-center">{node.passesGiven}</div>
                            <div className="text-center">{node.passesReceived}</div>
                            <div className="text-center font-bold text-cyan-400">{node.totalInvolvement}</div>
                            <div className="flex items-center justify-end gap-2">
                                <div className="w-20 h-1 bg-slate-800 rounded-full overflow-hidden">
                                    <div className="h-full bg-cyan-500" style={{ width: `${node.centrality * 100}%` }} />
                                </div>
                                <span className="text-[9px] text-slate-500">{Math.round(node.centrality * 100)}%</span>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        </Card>
    );
};

// --- TacticalNetworkPro (User's specific request component) ---

export const TacticalNetworkPro: React.FC<{
    events: LoggedEvent[];
    team: "TEAM_A" | "TEAM_B";
    roster: any[];
}> = ({ events, team, roster }) => {
    const network = useMemo(() => buildPassingNetwork(events, team, roster), [events, team, roster]);
    return <PassingNetworkViz network={network} teamName={team === "TEAM_A" ? "Attack Alpha" : "Strike Bravo"} />;
};

export default PassingNetworkViz;
</file>

<file path="src/components/PendingEventsQueue.tsx">
import React from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { MapPin, X, ChevronRight } from 'lucide-react';
import { LoggedEvent } from '@/hooks/useGamepad';

interface PendingEventsQueueProps {
    events: LoggedEvent[];
    onSelectEvent: (event: LoggedEvent) => void;
    onDismiss: (eventId: number) => void;
}

const PendingEventsQueue: React.FC<PendingEventsQueueProps> = ({ events, onSelectEvent, onDismiss }) => {
    if (events.length === 0) return null;

    return (
        <Card className="bg-black/60 backdrop-blur-md border-amber-500/30 shadow-lg p-2 max-w-sm">
            <div className="flex items-center justify-between mb-2 px-2">
                <div className="flex items-center gap-2">
                    <MapPin className="w-4 h-4 text-amber-500 animate-pulse" />
                    <h3 className="text-[11px] font-bold uppercase tracking-wider text-amber-500">
                        Pending Zones ({events.length})
                    </h3>
                </div>
            </div>

            <ScrollArea className="h-[120px]">
                <div className="space-y-1 pr-3">
                    {events.map((event) => (
                        <div
                            key={event.id}
                            className="group relative flex items-center justify-between bg-white/5 hover:bg-white/10 rounded border border-white/10 px-2 py-1.5 transition-all"
                        >
                            <div
                                className="flex-1 cursor-pointer pr-6"
                                onClick={() => onSelectEvent(event)}
                            >
                                <div className="flex items-center gap-2">
                                    <Badge
                                        variant="outline"
                                        className={`text-[9px] h-4 px-1 ${event.team === 'TEAM_A' ? 'border-red-500/50 text-red-500' : 'border-blue-500/50 text-blue-500'}`}
                                    >
                                        {event.team === 'TEAM_A' ? 'T.A' : 'T.B'}
                                    </Badge>
                                    <span className="text-[10px] font-medium text-zinc-100 truncate">
                                        {event.eventName.replace(/_/g, ' ')}
                                    </span>
                                </div>
                                <div className="text-[8px] text-zinc-500 mt-0.5 font-mono">
                                    {new Date(event.timestamp).toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })}
                                </div>
                            </div>

                            <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                <Button
                                    variant="ghost"
                                    size="icon"
                                    className="h-6 w-6 text-zinc-500 hover:text-amber-500"
                                    onClick={() => onSelectEvent(event)}
                                >
                                    <ChevronRight className="w-4 h-4" />
                                </Button>
                                <Button
                                    variant="ghost"
                                    size="icon"
                                    className="h-6 w-6 text-zinc-500 hover:text-red-500"
                                    onClick={() => onDismiss(event.id)}
                                >
                                    <X className="w-4 h-4" />
                                </Button>
                            </div>

                            {/* Visual Indicator for the row */}
                            <div className="absolute left-0 top-0 bottom-0 w-0.5 bg-amber-500/50 rounded-l" />
                        </div>
                    ))}
                </div>
            </ScrollArea>
        </Card>
    );
};

export default PendingEventsQueue;
</file>

<file path="src/components/PitchMap.tsx">
import React, { useRef, useState } from 'react';

interface Point {
    x: number;
    y: number;
}

// Standard FIFA pitch landmarks in meters (105x68m pitch)
const PITCH_LANDMARKS = [
    // Corners (4)
    { x: 0, y: 0, name: 'Corner: Top-Left' },
    { x: 105, y: 0, name: 'Corner: Top-Right' },
    { x: 105, y: 68, name: 'Corner: Bottom-Right' },
    { x: 0, y: 68, name: 'Corner: Bottom-Left' },

    // Halfway Line (3)
    { x: 52.5, y: 0, name: 'Halfway: Top' },
    { x: 52.5, y: 34, name: 'Halfway: Center' },
    { x: 52.5, y: 68, name: 'Halfway: Bottom' },

    // Center Circle (Perimeter points)
    { x: 43.35, y: 34, name: 'Center Circle: Left' },
    { x: 61.65, y: 34, name: 'Center Circle: Right' },
    { x: 52.5, y: 24.85, name: 'Center Circle: Top' },
    { x: 52.5, y: 43.15, name: 'Center Circle: Bottom' },

    // Left Penalty Area
    { x: 11, y: 34, name: 'Left Penalty Spot' },
    { x: 0, y: 13.84, name: 'Left Penalty: Top' },
    { x: 0, y: 54.16, name: 'Left Penalty: Bottom' },
    { x: 16.5, y: 13.84, name: 'Left Penalty Area: Far-Top' },
    { x: 16.5, y: 54.16, name: 'Left Penalty Area: Far-Bottom' },

    // Left Goal Area
    { x: 0, y: 24.84, name: 'Left Goal Area: Top' },
    { x: 0, y: 43.16, name: 'Left Goal Area: Bottom' },
    { x: 5.5, y: 24.84, name: 'Left Goal Area: Far-Top' },
    { x: 5.5, y: 43.16, name: 'Left Goal Area: Far-Bottom' },

    // Right Penalty Area
    { x: 94, y: 34, name: 'Right Penalty Spot' },
    { x: 105, y: 13.84, name: 'Right Penalty: Top' },
    { x: 105, y: 54.16, name: 'Right Penalty: Bottom' },
    { x: 88.5, y: 13.84, name: 'Right Penalty Area: Far-Top' },
    { x: 88.5, y: 54.16, name: 'Right Penalty Area: Far-Bottom' },

    // Right Goal Area
    { x: 105, y: 24.84, name: 'Right Goal Area: Top' },
    { x: 105, y: 43.16, name: 'Right Goal Area: Bottom' },
    { x: 99.5, y: 24.84, name: 'Right Goal Area: Far-Top' },
    { x: 99.5, y: 43.16, name: 'Right Goal Area: Far-Bottom' },

    // Intermediate Side Points (29-point system often uses 1/4 and 3/4 points)
    { x: 26.25, y: 0, name: 'Top Touchline: 1/4' },
    { x: 78.75, y: 0, name: 'Top Touchline: 3/4' },
    { x: 26.25, y: 68, name: 'Bottom Touchline: 1/4' },
    { x: 78.75, y: 68, name: 'Bottom Touchline: 3/4' },
];

interface PitchMapProps {
    className?: string;
    onPointClick?: (point: Point) => void;
    onPlayerClick?: (player: { x: number; y: number; team: string; id?: number | string }) => void;
    selectedPoint?: Point | null;
    playerPositions?: Array<{ x: number; y: number; team: string; id?: number | string }>;
    calibrationPoints?: Array<{ pitch: Point; label: number }>;
    showLandmarks?: boolean;
}

export default function PitchMap({
    className = '',
    onPointClick,
    onPlayerClick,
    selectedPoint,
    playerPositions = [],
    calibrationPoints = [],
    showLandmarks = true
}: PitchMapProps) {
    const svgRef = useRef<SVGSVGElement>(null);
    const [hoverPoint, setHoverPoint] = useState<Point | null>(null);
    const [hoveredLandmark, setHoveredLandmark] = useState<string | null>(null);

    const handleClick = (e: React.MouseEvent<SVGSVGElement>) => {
        if (!onPointClick || !svgRef.current) return;

        const rect = svgRef.current.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 105;
        const y = ((e.clientY - rect.top) / rect.height) * 68;

        onPointClick({ x, y });
    };

    const handleMouseMove = (e: React.MouseEvent<SVGSVGElement>) => {
        if (!svgRef.current) return;
        const rect = svgRef.current.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 105;
        const y = ((e.clientY - rect.top) / rect.height) * 68;
        setHoverPoint({ x, y });
    };

    const handleLandmarkClick = (landmark: { x: number; y: number; name: string }, e: React.MouseEvent) => {
        e.stopPropagation();
        if (onPointClick) {
            onPointClick({ x: landmark.x, y: landmark.y });
        }
    };

    return (
        <div className={`relative aspect-[105/68] rounded-xl overflow-hidden shadow-2xl ${className}`}>
            {/* Outer border with stadium effect */}
            <div className="absolute inset-0 bg-gradient-to-b from-gray-800 via-gray-700 to-gray-900 p-4">
                <div className="relative w-full h-full rounded-lg overflow-hidden shadow-inner">
                    <svg
                        ref={svgRef}
                        viewBox="0 0 105 68"
                        className="w-full h-full cursor-crosshair"
                        onClick={handleClick}
                        onMouseMove={handleMouseMove}
                        onMouseLeave={() => setHoverPoint(null)}
                    >
                        <defs>
                            {/* Grass texture gradient */}
                            <linearGradient id="grassGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" stopColor="#1a5c2e" />
                                <stop offset="50%" stopColor="#247a3d" />
                                <stop offset="100%" stopColor="#1a5c2e" />
                            </linearGradient>

                            {/* Radial gradient for center spotlight */}
                            <radialGradient id="spotlight" cx="50%" cy="50%">
                                <stop offset="0%" stopColor="rgba(255,255,255,0.08)" />
                                <stop offset="70%" stopColor="rgba(255,255,255,0)" />
                            </radialGradient>

                            {/* Shadow filter */}
                            <filter id="shadow">
                                <feDropShadow dx="0" dy="0.2" stdDeviation="0.3" floodOpacity="0.5" />
                            </filter>

                            {/* Glow filter for selected point */}
                            <filter id="glow">
                                <feGaussianBlur stdDeviation="0.8" result="coloredBlur" />
                                <feMerge>
                                    <feMergeNode in="coloredBlur" />
                                    <feMergeNode in="SourceGraphic" />
                                </feMerge>
                            </filter>

                            {/* Net pattern */}
                            <pattern id="netPattern" width="1.5" height="1.5" patternUnits="userSpaceOnUse">
                                <path d="M 0 0 L 1.5 1.5 M 1.5 0 L 0 1.5" stroke="rgba(255,255,255,0.3)" strokeWidth="0.1" />
                            </pattern>
                        </defs>

                        {/* Base grass field */}
                        <rect x="0" y="0" width="105" height="68" fill="url(#grassGradient)" />

                        {/* Grass stripes for realistic look */}
                        {[...Array(15)].map((_, i) => (
                            <rect
                                key={`stripe-${i}`}
                                x={i * 7}
                                y="0"
                                width="7"
                                height="68"
                                fill={i % 2 === 0 ? "rgba(26,92,46,0.3)" : "rgba(36,122,61,0.3)"}
                            />
                        ))}

                        {/* Subtle vignette effect */}
                        <rect x="0" y="0" width="105" height="68" fill="url(#spotlight)" />

                        {/* Outer boundary */}
                        <rect x="2" y="2" width="101" height="64" fill="none" stroke="white" strokeWidth="0.25" opacity="0.95" filter="url(#shadow)" />

                        {/* Center Line */}
                        <line x1="52.5" y1="2" x2="52.5" y2="66" stroke="white" strokeWidth="0.25" opacity="0.95" filter="url(#shadow)" />

                        {/* Center Circle */}
                        <circle cx="52.5" cy="34" r="9.15" fill="none" stroke="white" strokeWidth="0.25" opacity="0.95" filter="url(#shadow)" />

                        {/* Center Spot */}
                        <circle cx="52.5" cy="34" r="0.4" fill="white" opacity="0.95" filter="url(#shadow)" />

                        {/* Left Penalty Area */}
                        <rect x="2" y="13.5" width="16.5" height="41" fill="none" stroke="white" strokeWidth="0.25" opacity="0.95" filter="url(#shadow)" />

                        {/* Right Penalty Area */}
                        <rect x="86.5" y="13.5" width="16.5" height="41" fill="none" stroke="white" strokeWidth="0.25" opacity="0.95" filter="url(#shadow)" />

                        {/* Left Goal Area */}
                        <rect x="2" y="23.5" width="5.5" height="21" fill="none" stroke="white" strokeWidth="0.25" opacity="0.95" filter="url(#shadow)" />

                        {/* Right Goal Area */}
                        <rect x="97" y="23.5" width="5.5" height="21" fill="none" stroke="white" strokeWidth="0.25" opacity="0.95" filter="url(#shadow)" />

                        {/* Left Penalty Spot */}
                        <circle cx="13" cy="34" r="0.4" fill="white" opacity="0.95" filter="url(#shadow)" />

                        {/* Right Penalty Spot */}
                        <circle cx="92" cy="34" r="0.4" fill="white" opacity="0.95" filter="url(#shadow)" />

                        {/* Left Penalty Arc */}
                        <path
                            d="M 18.5 24.85 A 9.15 9.15 0 0 1 18.5 43.15"
                            fill="none"
                            stroke="white"
                            strokeWidth="0.25"
                            opacity="0.95"
                            filter="url(#shadow)"
                        />

                        {/* Right Penalty Arc */}
                        <path
                            d="M 86.5 24.85 A 9.15 9.15 0 0 0 86.5 43.15"
                            fill="none"
                            stroke="white"
                            strokeWidth="0.25"
                            opacity="0.95"
                            filter="url(#shadow)"
                        />

                        {/* Corner Arcs */}
                        <path d="M 2 3 A 1 1 0 0 0 3 2" fill="none" stroke="white" strokeWidth="0.25" opacity="0.95" />
                        <path d="M 2 65 A 1 1 0 0 1 3 66" fill="none" stroke="white" strokeWidth="0.25" opacity="0.95" />
                        <path d="M 103 3 A 1 1 0 0 1 102 2" fill="none" stroke="white" strokeWidth="0.25" opacity="0.95" />
                        <path d="M 103 65 A 1 1 0 0 0 102 66" fill="none" stroke="white" strokeWidth="0.25" opacity="0.95" />

                        {/* Corner Flags */}
                        <g filter="url(#shadow)">
                            <line x1="2.5" y1="2.5" x2="2.5" y2="0.5" stroke="#888" strokeWidth="0.15" />
                            <path d="M 2.5 0.5 L 3.5 1 L 2.5 1.5 Z" fill="#fbbf24" />

                            <line x1="2.5" y1="65.5" x2="2.5" y2="67.5" stroke="#888" strokeWidth="0.15" />
                            <path d="M 2.5 67.5 L 3.5 67 L 2.5 66.5 Z" fill="#fbbf24" />

                            <line x1="102.5" y1="2.5" x2="102.5" y2="0.5" stroke="#888" strokeWidth="0.15" />
                            <path d="M 102.5 0.5 L 101.5 1 L 102.5 1.5 Z" fill="#fbbf24" />

                            <line x1="102.5" y1="65.5" x2="102.5" y2="67.5" stroke="#888" strokeWidth="0.15" />
                            <path d="M 102.5 67.5 L 101.5 67 L 102.5 66.5 Z" fill="#fbbf24" />
                        </g>

                        {/* Left Goal */}
                        <g filter="url(#shadow)">
                            <rect x="-2" y="26.5" width="4" height="15" fill="none" stroke="white" strokeWidth="0.3" opacity="0.9" />
                            <rect x="-2" y="26.5" width="4" height="15" fill="url(#netPattern)" opacity="0.4" />
                            <line x1="-2" y1="26.5" x2="2" y2="28" stroke="white" strokeWidth="0.15" opacity="0.5" />
                            <line x1="-2" y1="41.5" x2="2" y2="40" stroke="white" strokeWidth="0.15" opacity="0.5" />
                        </g>

                        {/* Right Goal */}
                        <g filter="url(#shadow)">
                            <rect x="103" y="26.5" width="4" height="15" fill="none" stroke="white" strokeWidth="0.3" opacity="0.9" />
                            <rect x="103" y="26.5" width="4" height="15" fill="url(#netPattern)" opacity="0.4" />
                            <line x1="107" y1="26.5" x2="103" y2="28" stroke="white" strokeWidth="0.15" opacity="0.5" />
                            <line x1="107" y1="41.5" x2="103" y2="40" stroke="white" strokeWidth="0.15" opacity="0.5" />
                        </g>

                        {/* Player/Ball Positions */}
                        {playerPositions.map((player, idx) => {
                            const isBall = player.team === 'BALL';
                            return (
                                <g key={`player-${idx}`} filter="url(#shadow)">
                                    <circle
                                        cx={player.x}
                                        cy={player.y}
                                        r={isBall ? "0.8" : "1.2"}
                                        fill={isBall ? "#fbbf24" : (player.team === 'A' ? '#ef4444' : '#3b82f6')}
                                        stroke="white"
                                        strokeWidth={isBall ? "0.15" : "0.25"}
                                        className="cursor-pointer transition-all hover:r-[1.5]"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            if (onPlayerClick) {
                                                onPlayerClick(player);
                                            }
                                        }}
                                    />
                                    {!isBall && (
                                        <circle
                                            cx={player.x}
                                            cy={player.y}
                                            r="1.8"
                                            fill="none"
                                            stroke={player.team === 'A' ? '#ef4444' : '#3b82f6'}
                                            strokeWidth="0.15"
                                            opacity="0.3"
                                        />
                                    )}
                                    {isBall && (
                                        <circle
                                            cx={player.x}
                                            cy={player.y}
                                            r="1.2"
                                            fill="none"
                                            stroke="#fbbf24"
                                            strokeWidth="0.1"
                                            opacity="0.5"
                                            className="animate-pulse"
                                        />
                                    )}
                                </g>
                            );
                        })}

                        {/* Calibration Points */}
                        {calibrationPoints.map((point, idx) => (
                            <g key={`calib-${idx}`} filter="url(#shadow)">
                                <circle
                                    cx={point.pitch.x}
                                    cy={point.pitch.y}
                                    r="1.5"
                                    fill="#eab308"
                                    stroke="white"
                                    strokeWidth="0.3"
                                />
                                <text
                                    x={point.pitch.x}
                                    y={point.pitch.y}
                                    dy="0.5"
                                    textAnchor="middle"
                                    fontSize="1.5"
                                    fill="black"
                                    fontWeight="bold"
                                >
                                    {point.label}
                                </text>
                            </g>
                        ))}

                        {/* Predefined Landmark Markers */}
                        {showLandmarks && PITCH_LANDMARKS.map((landmark, idx) => (
                            <g
                                key={`landmark-${idx}`}
                                className="cursor-pointer"
                                onClick={(e) => handleLandmarkClick(landmark, e)}
                                onMouseEnter={() => setHoveredLandmark(landmark.name)}
                                onMouseLeave={() => setHoveredLandmark(null)}
                            >
                                <circle
                                    cx={landmark.x}
                                    cy={landmark.y}
                                    r="1.2"
                                    fill={hoveredLandmark === landmark.name ? '#22c55e' : 'rgba(59, 130, 246, 0.8)'}
                                    stroke="white"
                                    strokeWidth="0.2"
                                    className="transition-all duration-150"
                                />
                                {hoveredLandmark === landmark.name && (
                                    <circle
                                        cx={landmark.x}
                                        cy={landmark.y}
                                        r="2"
                                        fill="none"
                                        stroke="#22c55e"
                                        strokeWidth="0.3"
                                        className="animate-pulse"
                                    />
                                )}
                            </g>
                        ))}

                        {/* Selected Point Indicator */}
                        {selectedPoint && (
                            <g filter="url(#glow)">
                                <circle
                                    cx={selectedPoint.x}
                                    cy={selectedPoint.y}
                                    r="1.5"
                                    fill="none"
                                    stroke="#eab308"
                                    strokeWidth="0.4"
                                    className="animate-pulse"
                                />
                                <circle
                                    cx={selectedPoint.x}
                                    cy={selectedPoint.y}
                                    r="2.5"
                                    fill="none"
                                    stroke="#eab308"
                                    strokeWidth="0.2"
                                    opacity="0.5"
                                    className="animate-pulse"
                                />
                            </g>
                        )}
                    </svg>

                    {/* Hover Coordinates Display */}
                    {hoverPoint && (
                        <div className="absolute bottom-2 right-2 bg-black/70 backdrop-blur-sm text-white text-xs px-3 py-1.5 rounded-lg pointer-events-none border border-white/20 shadow-lg">
                            <span className="font-mono">
                                X: {hoverPoint.x.toFixed(1)} ‚Ä¢ Y: {hoverPoint.y.toFixed(1)}
                            </span>
                        </div>
                    )}

                    {/* Hovered Landmark Tooltip */}
                    {hoveredLandmark && (
                        <div className="absolute top-2 left-1/2 -translate-x-1/2 bg-green-600/90 backdrop-blur-sm text-white text-xs px-3 py-1.5 rounded-lg pointer-events-none border border-white/30 shadow-lg font-medium">
                            {hoveredLandmark}
                        </div>
                    )}
                </div>
            </div>

            {/* Stadium Atmosphere - Corner Lights */}
            <div className="absolute top-0 left-0 w-4 h-4 bg-yellow-200/20 blur-xl rounded-full"></div>
            <div className="absolute top-0 right-0 w-4 h-4 bg-yellow-200/20 blur-xl rounded-full"></div>
            <div className="absolute bottom-0 left-0 w-4 h-4 bg-yellow-200/20 blur-xl rounded-full"></div>
            <div className="absolute bottom-0 right-0 w-4 h-4 bg-yellow-200/20 blur-xl rounded-full"></div>
        </div>
    );
}
</file>

<file path="src/components/PlayerCard.tsx">
import { Card } from "@/components/ui/card";
import { Player } from "@/types/player";
import { User } from "lucide-react";

interface PlayerCardProps {
  player: Player;
}

export const PlayerCard = ({ player }: PlayerCardProps) => {
  return (
    <Card className="p-3 border border-border bg-card hover:border-primary/50 transition-all hover:shadow-lg group">
      <div className="flex items-center gap-3">
        {/* Player Image */}
        <div className="relative w-12 h-12 rounded-full overflow-hidden bg-muted flex-shrink-0 border border-border/50">
          {player.ImageURL ? (
            <img
              src={player.ImageURL}
              alt={`${player.Forename} ${player.Surname}`}
              className="w-full h-full object-cover"
              onError={(e) => {
                e.currentTarget.style.display = 'none';
                e.currentTarget.nextElementSibling?.classList.remove('hidden');
              }}
            />
          ) : null}
          <div className={`${player.ImageURL ? 'hidden' : 'flex'} absolute inset-0 items-center justify-center`}>
            <User className="w-6 h-6 text-muted-foreground" />
          </div>
        </div>

        {/* Player Info */}
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            {player.Number && (
              <span className="text-xs font-bold text-primary bg-primary/10 px-1.5 py-0.5 rounded">
                #{player.Number}
              </span>
            )}
            <h4 className="text-sm font-semibold text-foreground truncate">
              {player.Forename} {player.Surname}
            </h4>
          </div>
          {player.Position && (
            <p className="text-xs text-muted-foreground mt-0.5">{player.Position}</p>
          )}
        </div>
      </div>
    </Card>
  );
};
</file>

<file path="src/components/PlayerGrid.tsx">
import { PlayerCard } from "@/components/PlayerCard";
import { Player } from "@/types/player";

interface PlayerGridProps {
  players: Player[];
  teamName?: string;
}

export const PlayerGrid = ({ players, teamName }: PlayerGridProps) => {
  if (players.length === 0) {
    return null;
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-semibold text-foreground">
          {teamName || "Team Roster"}
        </h2>
        <span className="text-sm text-muted-foreground">
          {players.length} players
        </span>
      </div>
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
        {players.map((player) => (
          <PlayerCard key={player.ID} player={player} />
        ))}
      </div>
    </div>
  );
};
</file>

<file path="src/components/PlayerHeatmap.tsx">
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Checkbox } from "@/components/ui/checkbox";
import { Loader2, Download, RefreshCw, AlertCircle } from "lucide-react";
import { extractPositions, generateHeatmap, getHeatmapImageUrl, type PositionData } from "@/utils/heatmapApi";

interface PlayerHeatmapProps {
    videoFile: File | null;
    teamNames?: { teamA: string, teamB: string };
}

export const PlayerHeatmap = ({ videoFile, teamNames = { teamA: "Team A", teamB: "Team B" } }: PlayerHeatmapProps) => {
    const [isExtracting, setIsExtracting] = useState(false);
    const [isGenerating, setIsGenerating] = useState(false);
    const [positionData, setPositionData] = useState<PositionData | null>(null);
    const [selectedTeam, setSelectedTeam] = useState<'A' | 'B' | 'both'>('both');
    const [heatmapUrl, setHeatmapUrl] = useState<string | null>(null);
    const [error, setError] = useState<string | null>(null);
    const [extractionProgress, setExtractionProgress] = useState<string>('');

    // Time range state
    const [startTime, setStartTime] = useState<string>('0');
    const [endTime, setEndTime] = useState<string>('');

    // Scatter plot state
    const [showScatter, setShowScatter] = useState<boolean>(false);

    const handleExtractPositions = async () => {
        if (!videoFile) {
            setError('No video file uploaded');
            return;
        }

        setIsExtracting(true);
        setError(null);
        setExtractionProgress('Analyzing video...');

        try {
            setExtractionProgress('Uploading and detecting players...');

            // Parse time inputs
            const start = parseFloat(startTime) || 0;
            const end = endTime ? parseFloat(endTime) : undefined;

            if (end !== undefined && start >= end) {
                throw new Error('Start time must be less than end time');
            }

            // Pass the file object and time range directly for upload
            const positions = await extractPositions(videoFile, start, end);

            setPositionData(positions);
            setExtractionProgress('');

            // Auto-generate heatmap after extraction
            await handleGenerateHeatmap(selectedTeam);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to extract positions');
            setExtractionProgress('');
        } finally {
            setIsExtracting(false);
        }
    };

    const handleGenerateHeatmap = async (team: 'A' | 'B' | 'both') => {
        setIsGenerating(true);
        setError(null);

        try {
            const teamParam = team === 'both' ? undefined : team;
            const result = await generateHeatmap(teamParam, showScatter);

            if (result.success && result.imageUrl) {
                // Add timestamp to force reload
                setHeatmapUrl(`${result.imageUrl}?t=${Date.now()}`);
            } else {
                setError(result.error || 'Failed to generate heatmap');
            }
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to generate heatmap');
        } finally {
            setIsGenerating(false);
        }
    };

    const handleTeamChange = async (team: 'A' | 'B' | 'both') => {
        setSelectedTeam(team);
        if (positionData) {
            await handleGenerateHeatmap(team);
        }
    };

    const handleScatterChange = async (checked: boolean) => {
        setShowScatter(checked);
        if (positionData) {
            // We need to trigger regeneration, but state update might not be immediate
            // So we pass the new value directly
            setIsGenerating(true);
            setError(null);

            try {
                const teamParam = selectedTeam === 'both' ? undefined : selectedTeam;
                const result = await generateHeatmap(teamParam, checked);

                if (result.success && result.imageUrl) {
                    setHeatmapUrl(`${result.imageUrl}?t=${Date.now()}`);
                } else {
                    setError(result.error || 'Failed to generate heatmap');
                }
            } catch (err) {
                setError(err instanceof Error ? err.message : 'Failed to generate heatmap');
            } finally {
                setIsGenerating(false);
            }
        }
    };

    const handleDownload = () => {
        if (heatmapUrl) {
            const link = document.createElement('a');
            link.href = heatmapUrl;
            link.download = `heatmap_team_${selectedTeam}${showScatter ? '_scatter' : ''}.png`;
            link.click();
        }
    };

    if (!videoFile) {
        return (
            <Card>
                <CardHeader>
                    <CardTitle>Player Heatmaps</CardTitle>
                    <CardDescription>Upload a video first to generate player activity heatmaps</CardDescription>
                </CardHeader>
                <CardContent>
                    <Alert>
                        <AlertCircle className="h-4 w-4" />
                        <AlertDescription>
                            Please upload a match video to generate heatmaps showing where players were most active.
                        </AlertDescription>
                    </Alert>
                </CardContent>
            </Card>
        );
    }

    return (
        <Card className="w-full">
            <CardHeader>
                <CardTitle>Player Heatmaps</CardTitle>
                <CardDescription>
                    AI-powered analysis showing where players were most active during the match
                </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
                {/* Generate Button */}
                {!positionData && !heatmapUrl && (
                    <div className="flex flex-col items-center justify-center py-8 space-y-4">
                        <div className="grid grid-cols-2 gap-4 w-full max-w-xs mb-2">
                            <div className="space-y-2">
                                <label className="text-xs font-medium text-muted-foreground">Start Time (s)</label>
                                <input
                                    type="number"
                                    min="0"
                                    step="1"
                                    value={startTime}
                                    onChange={(e) => setStartTime(e.target.value)}
                                    className="flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50"
                                    placeholder="0"
                                />
                            </div>
                            <div className="space-y-2">
                                <label className="text-xs font-medium text-muted-foreground">End Time (s)</label>
                                <input
                                    type="number"
                                    min="0"
                                    step="1"
                                    value={endTime}
                                    onChange={(e) => setEndTime(e.target.value)}
                                    className="flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50"
                                    placeholder="End"
                                />
                            </div>
                        </div>

                        <div className="flex items-center space-x-2 mb-2">
                            <Checkbox
                                id="scatter-mode"
                                checked={showScatter}
                                onCheckedChange={(checked) => setShowScatter(checked as boolean)}
                            />
                            <label
                                htmlFor="scatter-mode"
                                className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                            >
                                Show Player Points (Scatter Plot)
                            </label>
                        </div>

                        <p className="text-sm text-muted-foreground text-center">
                            Click below to analyze the video and generate heatmaps
                        </p>
                        <Button
                            onClick={handleExtractPositions}
                            disabled={isExtracting}
                            size="lg"
                        >
                            {isExtracting ? (
                                <>
                                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                    Analyzing Video...
                                </>
                            ) : (
                                'Generate Heatmaps'
                            )}
                        </Button>
                        {extractionProgress && (
                            <p className="text-xs text-muted-foreground animate-pulse">
                                {extractionProgress}
                            </p>
                        )}
                    </div>
                )}

                {/* Error Display */}
                {error && (
                    <Alert variant="destructive">
                        <AlertCircle className="h-4 w-4" />
                        <AlertDescription>{error}</AlertDescription>
                    </Alert>
                )}

                {/* Team Selector */}
                {(positionData || heatmapUrl) && (
                    <div className="flex flex-col space-y-4">
                        <div className="flex items-center justify-between">
                            <div className="flex gap-2">
                                <Button
                                    variant={selectedTeam === 'A' ? 'default' : 'outline'}
                                    size="sm"
                                    onClick={() => handleTeamChange('A')}
                                    disabled={isGenerating}
                                >
                                    {teamNames.teamA}
                                </Button>
                                <Button
                                    variant={selectedTeam === 'B' ? 'default' : 'outline'}
                                    size="sm"
                                    onClick={() => handleTeamChange('B')}
                                    disabled={isGenerating}
                                >
                                    {teamNames.teamB}
                                </Button>
                                <Button
                                    variant={selectedTeam === 'both' ? 'default' : 'outline'}
                                    size="sm"
                                    onClick={() => handleTeamChange('both')}
                                    disabled={isGenerating}
                                >
                                    Both Teams
                                </Button>
                            </div>
                            <div className="flex gap-2">
                                <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={handleExtractPositions}
                                    disabled={isExtracting || isGenerating}
                                >
                                    <RefreshCw className="mr-2 h-4 w-4" />
                                    Regenerate
                                </Button>
                                {heatmapUrl && (
                                    <Button
                                        variant="outline"
                                        size="sm"
                                        onClick={handleDownload}
                                    >
                                        <Download className="mr-2 h-4 w-4" />
                                        Download
                                    </Button>
                                )}
                            </div>
                        </div>

                        <div className="flex items-center space-x-2 justify-center">
                            <Checkbox
                                id="scatter-mode-active"
                                checked={showScatter}
                                onCheckedChange={(checked) => handleScatterChange(checked as boolean)}
                                disabled={isGenerating}
                            />
                            <label
                                htmlFor="scatter-mode-active"
                                className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                            >
                                Show Player Points (Scatter Plot)
                            </label>
                        </div>
                    </div>
                )}

                {/* Heatmap Display */}
                {isGenerating && (
                    <div className="flex flex-col items-center justify-center py-12 space-y-4">
                        <Loader2 className="h-8 w-8 animate-spin text-primary" />
                        <p className="text-sm text-muted-foreground">Generating {showScatter ? 'scatter plot' : 'heatmap'}...</p>
                    </div>
                )}

                {heatmapUrl && !isGenerating && (
                    <div className="relative rounded-lg overflow-hidden border bg-muted/20">
                        <img
                            src={heatmapUrl}
                            alt={`Heatmap for ${selectedTeam === 'both' ? 'both teams' : `Team ${selectedTeam}`}`}
                            className="w-full h-auto"
                        />
                    </div>
                )}

                {/* Stats Display */}
                {positionData && (
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 pt-4 border-t">
                        <div className="text-center">
                            <p className="text-2xl font-bold text-primary">
                                {positionData.positions.length}
                            </p>
                            <p className="text-xs text-muted-foreground">Positions Detected</p>
                        </div>
                        <div className="text-center">
                            <p className="text-2xl font-bold text-primary">
                                {Math.round(positionData.video_info.duration)}s
                            </p>
                            <p className="text-xs text-muted-foreground">Video Duration</p>
                        </div>
                        <div className="text-center">
                            <p className="text-2xl font-bold text-primary">
                                {positionData.positions.filter(p => p.team === 'A').length}
                            </p>
                            <p className="text-xs text-muted-foreground">{teamNames.teamA} Positions</p>
                        </div>
                        <div className="text-center">
                            <p className="text-2xl font-bold text-primary">
                                {positionData.positions.filter(p => p.team === 'B').length}
                            </p>
                            <p className="text-xs text-muted-foreground">{teamNames.teamB} Positions</p>
                        </div>
                    </div>
                )}
            </CardContent>
        </Card>
    );
};
</file>

<file path="src/components/PlayerSelectionSidebar.tsx">
import { Player } from "@/types/player";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Card } from "@/components/ui/card";

interface PlayerSelectionSidebarProps {
    players: Player[];
    selectedPlayerId: number | null;
    onSelectPlayer: (playerId: number) => void;
    teamName: string;
    startingNumbers?: number[]; // Optional array of jersey numbers for starting XI
}

export const PlayerSelectionSidebar = ({
    players,
    selectedPlayerId,
    onSelectPlayer,
    teamName,
    startingNumbers
}: PlayerSelectionSidebarProps) => {
    // Filter to show only starting players
    // If startingNumbers is provided, use those; otherwise default to 1-11
    const defaultStarting = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    const numbersToShow = startingNumbers || defaultStarting;

    const startingPlayers = players
        .filter(player => numbersToShow.includes(player.Number))
        .sort((a, b) => a.Number - b.Number);

    return (
        <Card className="h-auto flex flex-col border-r border-border bg-card rounded-none border-y-0 border-l-0">
            <div className="p-4 border-b border-border">
                <h2 className="font-semibold text-lg">Starting XI</h2>
                <p className="text-sm text-muted-foreground truncate">{teamName}</p>
            </div>

            <ScrollArea className="flex-1">
                <div className="p-1 grid grid-cols-3 gap-1">
                    {startingPlayers.map((player) => (
                        <div
                            key={player.ID}
                            onClick={() => onSelectPlayer(player.ID)}
                            className={`flex flex-col items-center justify-center p-1 rounded cursor-pointer transition-all border h-16 ${selectedPlayerId === player.ID
                                ? "bg-primary/20 border-primary"
                                : "bg-card hover:bg-secondary/50 border-border hover:border-primary/30"
                                }`}
                        >
                            <span className="text-lg font-bold font-mono text-primary leading-none">
                                {player.Number || "#"}
                            </span>
                            <p className="font-medium text-[10px] text-center leading-tight line-clamp-1 w-full px-0.5 mt-0.5">
                                {player.Surname}
                            </p>
                        </div>
                    ))}
                </div>
            </ScrollArea>
        </Card>
    );
};
</file>

<file path="src/components/PlayerUpload.tsx">
import { useState, useEffect } from "react";
import { Upload, RefreshCw, List, Check } from "lucide-react";
import { Card } from "@/components/ui/card";
import { toast } from "sonner";
import { TeamRoster, LFPData } from "@/types/player";
import { API_BASE_URL } from "@/utils/apiConfig";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Button } from "@/components/ui/button";

interface PlayerUploadProps {
  onUpload: (teams: Map<string, TeamRoster>) => void;
}

const CLUB_NAME_MAPPING: Record<number, string> = {
  524: "ÿ¨ŸÖÿπŸäÿ© ÿßŸÑÿ¥ŸÑŸÅ",
  670: "ÿ¥ÿ®ÿßÿ® ÿ®ŸÑŸàÿ≤ÿØÿßÿØ",
  678: "ÿ¥ÿ®ÿßÿ® ŸÇÿ≥ŸÜÿ∑ŸäŸÜÿ©",
  755: "ŸÜÿ¨ŸÖ ÿ®ŸÜ ÿπŸÉŸÜŸàŸÜ",
  694: "ÿ™ÿ±ÿ¨Ÿä ŸÖÿ≥ÿ™ÿ∫ÿßŸÜŸÖ",
  676: "ŸàŸÅÿßŸÇ ÿ≥ÿ∑ŸäŸÅ",
  674: "ÿ¥ÿ®Ÿäÿ®ÿ© ÿßŸÑŸÇÿ®ÿßÿ¶ŸÑ",
  672: "ÿ¥ÿ®Ÿäÿ®ÿ© ÿßŸÑÿ≥ÿßŸàÿ±ÿ©",
  409: "ŸÖÿ≥ÿ™ŸÇÿ®ŸÑ ÿßŸÑÿ±ŸàŸäÿ≥ÿßÿ™",
  677: "ŸÖŸàŸÑŸàÿØŸäÿ© ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±",
  657: "ŸÖŸàŸÑŸàÿØŸäÿ© ÿßŸÑÿ®Ÿäÿ∂",
  675: "ŸÖŸàŸÑŸàÿØŸäÿ© ŸàŸáÿ±ÿßŸÜ",
  758: "ÿ£ŸàŸÑŸÖÿ®ŸäŸÉ ÿ£ŸÇÿ®Ÿà",
  680: "ŸÜÿßÿØŸä ÿ®ÿßÿ±ÿßÿØŸà",
  673: "ÿ•ÿ™ÿ≠ÿßÿØ ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±",
  653: "ÿ•ÿ™ÿ≠ÿßÿØ ÿÆŸÜÿ¥ŸÑÿ©",
};

// Official LFP Logo
const LFPLogo = () => (
  <svg width="24" height="24" viewBox="0 0 219 222" fill="none" xmlns="http://www.w3.org/2000/svg" className="w-6 h-6">
    <path d="M100.626 3.77393C106.013 0.962563 112.401 0.874376 117.851 3.51025L118.374 3.77393L206.526 49.7817C212.861 53.0876 216.832 59.6407 216.832 66.7856V155.345C216.832 162.267 213.105 168.632 207.113 172.029L206.526 172.348L118.374 218.357C112.987 221.168 106.599 221.256 101.149 218.621L100.626 218.357L12.4736 172.348C6.13957 169.042 2.1681 162.49 2.16797 155.345V66.7856C2.16797 59.8639 5.89495 53.4977 11.8867 50.1011L12.4736 49.7817L100.626 3.77393Z" stroke="white" strokeWidth="2.70765"></path>
    <path d="M101.361 18.1094C106.461 15.4474 112.541 15.4474 117.642 18.1094L193.171 57.5293C198.981 60.5617 202.624 66.5724 202.624 73.1264V149.004C202.624 155.558 198.981 161.569 193.171 164.601L117.642 204.021C112.541 206.683 106.461 206.683 101.361 204.021L25.832 164.601C20.0218 161.569 16.3788 155.558 16.3788 149.004V73.1263C16.3788 66.5724 20.0218 60.5617 25.832 57.5293L101.361 18.1094Z" fill="#A70912"></path>
  </svg>
);

export const PlayerUpload = ({ onUpload }: PlayerUploadProps) => {
  const [isScraping, setIsScraping] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [storedTeams, setStoredTeams] = useState<Record<string, TeamRoster>>({});
  const [selectedTeamKey, setSelectedTeamKey] = useState<string | null>(null);

  // Load stored teams on mount
  useEffect(() => {
    const saved = localStorage.getItem("lfp_scraped_data");
    if (saved) {
      try {
        setStoredTeams(JSON.parse(saved));
      } catch (e) {
        console.error("Failed to parse stored teams", e);
      }
    }
  }, []);

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const json = JSON.parse(e.target?.result as string);
        const teamsMap = new Map<string, TeamRoster>();
        let totalPlayers = 0;

        if (json.Clubs && Array.isArray(json.Clubs)) {
          const lfpData = json as LFPData;
          lfpData.Clubs.forEach((club) => {
            const clubName = CLUB_NAME_MAPPING[club.ClubID] || club.ClubName;
            teamsMap.set(clubName, {
              teamName: clubName,
              PlayerData: club.Players
            });
            totalPlayers += club.Players.length;
          });
        }
        else if (json.PlayerData) {
          const teamName = file.name.replace('.json', '');
          teamsMap.set(teamName, json);
          totalPlayers = json.PlayerData.length;
        } else {
          Object.keys(json).forEach((teamKey) => {
            if (json[teamKey].PlayerData) {
              const teamName = json[teamKey].name || teamKey;
              teamsMap.set(teamName, json[teamKey]);
              totalPlayers += json[teamKey].PlayerData.length;
            }
          });
        }

        onUpload(teamsMap);
        toast.success("Teams loaded successfully", {
          description: `${teamsMap.size} team(s), ${totalPlayers} players imported`,
        });
      } catch (error) {
        toast.error("Invalid JSON file");
      }
    };
    reader.readAsText(file);
    event.target.value = '';
  };

  const scrapeLFPData = async () => {
    setIsScraping(true);
    const toastId = toast.loading("Connecting to LFP.dz...", { description: "Scraping live data (this may take a minute)..." });

    try {
      const response = await fetch(`${API_BASE_URL}/api/scrape-lfp`);
      if (!response.ok) throw new Error("Scraping failed");

      const teamsData = await response.json();
      const teamCount = Object.keys(teamsData).length;

      if (teamCount === 0) {
        toast.error("No data found", { id: toastId, description: "Could not extract teams from LFP.dz" });
        setIsScraping(false);
        return;
      }

      // Save to Persistence
      localStorage.setItem("lfp_scraped_data", JSON.stringify(teamsData));
      setStoredTeams(teamsData);

      toast.success("LFP Data Updated", {
        id: toastId,
        description: `Successfully cached ${teamCount} teams. Ready to select.`,
      });

      // Auto-open modal after scrape
      setIsModalOpen(true);

    } catch (error) {
      console.error("Failed to load LFP teams:", error);
      toast.error("Scraping Failed", {
        id: toastId,
        description: "Could not connect to LFP.dz or parse data.",
      });
    } finally {
      setIsScraping(false);
    }
  };

  const handleConfirmSelection = () => {
    if (!selectedTeamKey || !storedTeams[selectedTeamKey]) return;

    const team = storedTeams[selectedTeamKey];
    const teamsMap = new Map<string, TeamRoster>();
    teamsMap.set(team.teamName, team);

    onUpload(teamsMap);
    setIsModalOpen(false);
    toast.success(`Loaded ${team.teamName}`, {
      description: `${team.PlayerData.length} players imported.`,
    });
  };

  return (
    <div className="space-y-2">
      <Card className="p-4 border-2 border-dashed border-primary/30 bg-card/50 hover:border-primary/60 transition-colors">
        <label className="cursor-pointer flex items-center justify-center gap-3 py-2">
          <Upload className="w-5 h-5 text-primary" />
          <span className="text-sm font-medium text-foreground">Upload Team JSON</span>
          <input type="file" accept=".json" onChange={handleFileUpload} className="hidden" />
        </label>
      </Card>

      <div className="grid grid-cols-2 gap-2">
        <button
          onClick={scrapeLFPData}
          disabled={isScraping}
          className="flex items-center justify-center gap-2 p-2 rounded-md bg-emerald-600/20 hover:bg-emerald-600/30 border border-emerald-600/50 text-emerald-500 hover:text-emerald-400 transition-all text-xs font-semibold uppercase tracking-wider disabled:opacity-50"
        >
          {isScraping ? <RefreshCw className="w-4 h-4 animate-spin" /> : <LFPLogo />}
          {isScraping ? "Scraping..." : "Update LFP Data"}
        </button>

        <button
          onClick={() => setIsModalOpen(true)}
          disabled={Object.keys(storedTeams).length === 0}
          className="flex items-center justify-center gap-2 p-2 rounded-md bg-blue-600/20 hover:bg-blue-600/30 border border-blue-600/50 text-blue-500 hover:text-blue-400 transition-all text-xs font-semibold uppercase tracking-wider disabled:opacity-50"
        >
          <List className="w-3 h-3" />
          Select Team
        </button>
      </div>

      <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
        <DialogContent className="sm:max-w-[425px] bg-slate-900 border-slate-700 text-slate-100">
          <DialogHeader>
            <DialogTitle>Select Ligue 1 Team</DialogTitle>
            <DialogDescription className="text-slate-400">
              Choose a team from the cached LFP data to load into the analyzer.
            </DialogDescription>
          </DialogHeader>

          <ScrollArea className="h-[300px] w-full rounded-md border border-slate-700 p-2 bg-slate-950/50">
            <div className="flex flex-col gap-1">
              {Object.keys(storedTeams).length === 0 ? (
                <div className="text-center py-8 text-muted-foreground text-sm">
                  No data cached. Click "Update Data" first.
                </div>
              ) : (
                Object.values(storedTeams).map((team) => (
                  <button
                    key={team.teamName}
                    onClick={() => setSelectedTeamKey(team.teamName)}
                    className={`flex items-center justify-between p-3 rounded-md text-sm transition-colors ${selectedTeamKey === team.teamName
                      ? "bg-emerald-600/30 border border-emerald-500/50 text-emerald-400"
                      : "hover:bg-slate-800 border border-transparent text-slate-300"
                      }`}
                  >
                    <span className="font-medium">{team.teamName}</span>
                    <span className="text-xs opacity-70 bg-slate-900 px-2 py-0.5 rounded-full">
                      {team.PlayerData.length} players
                    </span>
                    {selectedTeamKey === team.teamName && <Check className="w-4 h-4 ml-2" />}
                  </button>
                ))
              )}
            </div>
          </ScrollArea>

          <DialogFooter>
            <div className="flex justify-between w-full items-center">
              <span className="text-xs text-slate-500">
                {Object.keys(storedTeams).length} teams cached
              </span>
              <Button
                onClick={handleConfirmSelection}
                disabled={!selectedTeamKey}
                className="bg-emerald-600 hover:bg-emerald-700 text-white"
              >
                Load Team
              </Button>
            </div>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
};
</file>

<file path="src/components/PossessionTimeline.tsx">
// src/components/PossessionTimeline.tsx
// Visual timeline of possession chains - shows flow of the match

import { useMatchContext } from '@/contexts/MatchContext';
import { PossessionChain } from '@/utils/PossessionChain';
import { cn } from '@/lib/utils';
import { useState } from 'react';
import {
    ChevronDown,
    ChevronUp,
    Target,
    Zap,
    AlertTriangle,
    Goal,
    ArrowRight
} from 'lucide-react';

interface PossessionTimelineProps {
    className?: string;
    maxVisible?: number;
}

export function PossessionTimeline({ className, maxVisible = 10 }: PossessionTimelineProps) {
    const { possessionHistory, currentPossession, chainStats } = useMatchContext();
    const [expanded, setExpanded] = useState(false);
    const [selectedChain, setSelectedChain] = useState<number | null>(null);

    // Get recent chains plus current
    const chains: (PossessionChain & { isCurrent?: boolean })[] = [
        ...(currentPossession ? [{ ...currentPossession, isCurrent: true }] : []),
        ...possessionHistory.slice().reverse().slice(0, expanded ? 50 : maxVisible),
    ];

    if (chains.length === 0) {
        return (
            <div className={cn(
                "rounded-lg border border-border/50 bg-card/95 p-4",
                className
            )}>
                <div className="text-center text-muted-foreground text-sm">
                    No possession chains recorded yet
                </div>
            </div>
        );
    }

    return (
        <div className={cn(
            "rounded-lg border border-border/50 bg-card/95 overflow-hidden",
            className
        )}>
            {/* Header */}
            <div className="px-4 py-2 bg-muted/30 border-b border-border/30 flex items-center justify-between">
                <div className="flex items-center gap-2">
                    <ArrowRight className="w-4 h-4 text-muted-foreground" />
                    <span className="text-sm font-semibold">Possession Flow</span>
                </div>
                {chainStats && (
                    <div className="text-xs text-muted-foreground">
                        {chainStats.totalChains} chains | {(chainStats.finalThirdEntryRate * 100).toFixed(0)}% to final third
                    </div>
                )}
            </div>

            {/* Timeline */}
            <div className="p-3">
                <div className="flex flex-wrap gap-1.5">
                    {chains.map((chain) => (
                        <ChainPill
                            key={chain.id}
                            chain={chain}
                            isCurrent={chain.isCurrent}
                            isSelected={selectedChain === chain.id}
                            onClick={() => setSelectedChain(selectedChain === chain.id ? null : chain.id)}
                        />
                    ))}
                </div>

                {/* Expand/collapse */}
                {possessionHistory.length > maxVisible && (
                    <button
                        onClick={() => setExpanded(!expanded)}
                        className="mt-2 w-full flex items-center justify-center gap-1 text-xs text-muted-foreground hover:text-foreground transition-colors"
                    >
                        {expanded ? <ChevronUp className="w-3 h-3" /> : <ChevronDown className="w-3 h-3" />}
                        {expanded ? 'Show less' : `Show ${possessionHistory.length - maxVisible} more`}
                    </button>
                )}
            </div>

            {/* Selected chain details */}
            {selectedChain !== null && (
                <ChainDetails chainId={selectedChain} />
            )}
        </div>
    );
}

interface ChainPillProps {
    chain: PossessionChain;
    isCurrent?: boolean;
    isSelected: boolean;
    onClick: () => void;
}

function ChainPill({ chain, isCurrent, isSelected, onClick }: ChainPillProps) {
    // Team color
    const teamColor = chain.team === 'TEAM_A'
        ? 'bg-blue-500'
        : 'bg-red-500';

    // Outcome styling
    const outcomeConfig: Record<string, { icon: React.ReactNode; ring: string }> = {
        'SHOT': { icon: <Target className="w-2.5 h-2.5" />, ring: 'ring-orange-400' },
        'GOAL': { icon: <Goal className="w-2.5 h-2.5" />, ring: 'ring-green-400' },
        'LOSS': { icon: null, ring: '' },
        'SET_PIECE': { icon: <AlertTriangle className="w-2.5 h-2.5" />, ring: 'ring-yellow-400' },
        'OUT_OF_PLAY': { icon: null, ring: '' },
        'ONGOING': { icon: null, ring: 'ring-white/50' },
    };

    const outcome = outcomeConfig[chain.outcome] || outcomeConfig['LOSS'];

    // Width based on duration (min 20px, max 80px)
    const durationS = (chain.durationMs || 1000) / 1000;
    const width = Math.min(80, Math.max(20, durationS * 3));

    return (
        <button
            onClick={onClick}
            className={cn(
                "h-7 rounded flex items-center justify-center gap-1 px-2 transition-all",
                teamColor,
                "hover:brightness-110",
                isCurrent && "animate-pulse ring-2 ring-white/50",
                isSelected && "ring-2 ring-white",
                outcome.ring && `ring-1 ${outcome.ring}`,
            )}
            style={{ minWidth: `${width}px` }}
            title={`Chain #${chain.id} - ${chain.team} - ${chain.passCount} passes`}
        >
            {/* Icons for special outcomes */}
            {chain.fromTransition && <Zap className="w-2.5 h-2.5 text-yellow-200" />}
            {outcome.icon && <span className="text-white">{outcome.icon}</span>}

            {/* Pass count */}
            <span className="text-[10px] font-bold text-white/90">
                {chain.passCount}
            </span>
        </button>
    );
}

function ChainDetails({ chainId }: { chainId: number }) {
    const { possessionHistory, currentPossession } = useMatchContext();

    const chain = currentPossession?.id === chainId
        ? currentPossession
        : possessionHistory.find(c => c.id === chainId);

    if (!chain) return null;

    const durationS = chain.durationMs ? (chain.durationMs / 1000).toFixed(1) : 'ongoing';

    return (
        <div className="px-4 py-3 bg-muted/20 border-t border-border/30">
            <div className="flex items-center justify-between mb-2">
                <span className="text-sm font-semibold">
                    Chain #{chain.id}
                </span>
                <span className={cn(
                    "text-xs px-2 py-0.5 rounded",
                    chain.team === 'TEAM_A' ? 'bg-blue-500/20 text-blue-300' : 'bg-red-500/20 text-red-300'
                )}>
                    {chain.team === 'TEAM_A' ? 'Home' : 'Away'}
                </span>
            </div>

            <div className="grid grid-cols-3 gap-2 text-xs">
                <div>
                    <span className="text-muted-foreground">Duration:</span>
                    <span className="ml-1 font-medium">{durationS}s</span>
                </div>
                <div>
                    <span className="text-muted-foreground">Passes:</span>
                    <span className="ml-1 font-medium">{chain.passCount}</span>
                </div>
                <div>
                    <span className="text-muted-foreground">Events:</span>
                    <span className="ml-1 font-medium">{chain.events.length}</span>
                </div>
            </div>

            {/* Flags */}
            <div className="flex flex-wrap gap-2 mt-2">
                {chain.fromTransition && (
                    <span className="text-[10px] px-1.5 py-0.5 rounded bg-yellow-500/20 text-yellow-300">
                        ‚ö° Transition
                    </span>
                )}
                {chain.enteredFinalThird && (
                    <span className="text-[10px] px-1.5 py-0.5 rounded bg-green-500/20 text-green-300">
                        ‚úì Final Third
                    </span>
                )}
                {chain.enteredBox && (
                    <span className="text-[10px] px-1.5 py-0.5 rounded bg-orange-500/20 text-orange-300">
                        üì¶ Box
                    </span>
                )}
                {chain.shotTaken && (
                    <span className="text-[10px] px-1.5 py-0.5 rounded bg-red-500/20 text-red-300">
                        üéØ Shot
                    </span>
                )}
                {chain.buildUpSpeed && (
                    <span className={cn(
                        "text-[10px] px-1.5 py-0.5 rounded",
                        chain.buildUpSpeed === 'FAST' && 'bg-cyan-500/20 text-cyan-300',
                        chain.buildUpSpeed === 'MEDIUM' && 'bg-gray-500/20 text-gray-300',
                        chain.buildUpSpeed === 'SLOW' && 'bg-purple-500/20 text-purple-300',
                    )}>
                        {chain.buildUpSpeed === 'FAST' ? 'üöÄ' : chain.buildUpSpeed === 'SLOW' ? 'üê¢' : '‚û°Ô∏è'} {chain.buildUpSpeed}
                    </span>
                )}
            </div>

            {/* Event sequence */}
            {chain.events.length > 0 && (
                <div className="mt-3 pt-2 border-t border-border/30">
                    <span className="text-xs text-muted-foreground">Events:</span>
                    <div className="flex flex-wrap gap-1 mt-1">
                        {chain.events.slice(-8).map((event, i) => (
                            <span
                                key={event.id}
                                className="text-[10px] px-1.5 py-0.5 rounded bg-muted text-muted-foreground"
                            >
                                {event.eventName.replace(/_/g, ' ')}
                            </span>
                        ))}
                        {chain.events.length > 8 && (
                            <span className="text-[10px] text-muted-foreground">
                                +{chain.events.length - 8} more
                            </span>
                        )}
                    </div>
                </div>
            )}
        </div>
    );
}

// Compact horizontal timeline
export function PossessionTimelineCompact({ className }: { className?: string }) {
    const { possessionHistory, currentPossession } = useMatchContext();

    const recentChains = [
        ...(currentPossession ? [{ ...currentPossession, isCurrent: true }] : []),
        ...possessionHistory.slice(-5).reverse(),
    ];

    return (
        <div className={cn("flex items-center gap-1", className)}>
            {recentChains.map((chain, i) => (
                <div
                    key={chain.id}
                    className={cn(
                        "h-4 rounded transition-all",
                        chain.team === 'TEAM_A' ? 'bg-blue-500' : 'bg-red-500',
                        'isCurrent' in chain && chain.isCurrent && 'animate-pulse'
                    )}
                    style={{
                        width: `${Math.max(8, Math.min(24, chain.passCount * 4))}px`,
                        opacity: 1 - (i * 0.15)
                    }}
                    title={`${chain.team} - ${chain.passCount} passes`}
                />
            ))}
        </div>
    );
}

export default PossessionTimeline;
</file>

<file path="src/components/PostMatchAnalysisPanel.tsx">
import React, { useState, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { Upload, Play, Settings, CheckCircle2, AlertCircle } from 'lucide-react';
import { API_BASE_URL, ANALYSIS_API_URL } from '@/utils/apiConfig';

interface PostMatchAnalysisPanelProps {
    onAnalysisComplete?: (results: any) => void;
}

type AnalysisStatus = 'idle' | 'uploading' | 'calibrating' | 'processing' | 'completed' | 'error';

export const PostMatchAnalysisPanel: React.FC<PostMatchAnalysisPanelProps> = ({
    onAnalysisComplete
}) => {
    const [status, setStatus] = useState<AnalysisStatus>('idle');
    const [progress, setProgress] = useState(0);
    const [videoFile, setVideoFile] = useState<File | null>(null);
    const [calibrationPoints, setCalibrationPoints] = useState<Array<[number, number]>>([]);
    const [jobId, setJobId] = useState<string | null>(null);
    const [errorMessage, setErrorMessage] = useState<string>('');
    const fileInputRef = useRef<HTMLInputElement>(null);

    const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file && file.type.startsWith('video/')) {
            setVideoFile(file);
            setStatus('calibrating');
        }
    };

    const handleStartAnalysis = async () => {
        if (!videoFile) return;

        setStatus('uploading');
        setProgress(0);
        setErrorMessage('');

        try {
            // Upload video and start analysis
            const formData = new FormData();
            formData.append('video', videoFile);
            formData.append('calibration', JSON.stringify(calibrationPoints));
            formData.append('models', JSON.stringify(['yolov10', 'rtdetr', 'deepsort']));

            const response = await fetch(`${ANALYSIS_API_URL}/analyze-video`, {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to start analysis');
            }

            const data = await response.json();
            setJobId(data.job_id);
            setStatus('processing');

            // Poll for status
            pollAnalysisStatus(data.job_id);

        } catch (error) {
            console.error('Analysis error:', error);
            setStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Unknown error');
        }
    };

    const pollAnalysisStatus = async (jobId: string) => {
        const interval = setInterval(async () => {
            try {
                const response = await fetch(`${ANALYSIS_API_URL}/analysis-status/${jobId}`);
                const data = await response.json();

                setProgress(data.progress || 0);

                if (data.status === 'completed') {
                    clearInterval(interval);
                    setStatus('completed');
                    if (onAnalysisComplete && data.results) {
                        onAnalysisComplete(data.results);
                    }
                } else if (data.status === 'failed') {
                    clearInterval(interval);
                    setStatus('error');
                    setErrorMessage(data.error || 'Analysis failed');
                }
            } catch (error) {
                console.error('Polling error:', error);
            }
        }, 1000); // Poll every second
    };

    return (
        <div className="space-y-4">
            {/* Header */}
            <div className="bg-card border border-border rounded-lg p-4">
                <div className="flex items-center justify-between mb-2">
                    <h3 className="text-lg font-bold flex items-center gap-2">
                        <span className="text-2xl">üìä</span>
                        Analyse POST-MATCH
                    </h3>
                    <Badge variant={
                        status === 'completed' ? 'default' :
                            status === 'processing' ? 'secondary' :
                                status === 'error' ? 'destructive' : 'outline'
                    }>
                        {status === 'idle' && 'Pr√™t'}
                        {status === 'uploading' && 'Upload...'}
                        {status === 'calibrating' && 'Calibration'}
                        {status === 'processing' && 'Analyse en cours'}
                        {status === 'completed' && 'Termin√©'}
                        {status === 'error' && 'Erreur'}
                    </Badge>
                </div>
            </div>

            {/* Step 1: Upload Video */}
            <div className="bg-card border border-border rounded-lg p-4">
                <div className="flex items-center gap-2 mb-3">
                    <div className={`w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold ${videoFile ? 'bg-green-500 text-white' : 'bg-muted text-muted-foreground'
                        }`}>
                        {videoFile ? '‚úì' : '1'}
                    </div>
                    <h4 className="font-semibold">Upload Vid√©o</h4>
                </div>

                {!videoFile ? (
                    <div
                        onClick={() => fileInputRef.current?.click()}
                        className="border-2 border-dashed border-border rounded-lg p-8 text-center cursor-pointer hover:border-primary transition-colors"
                    >
                        <Upload className="w-12 h-12 mx-auto mb-3 text-muted-foreground" />
                        <p className="text-sm font-medium mb-1">Cliquez pour uploader une vid√©o</p>
                        <p className="text-xs text-muted-foreground">MP4, AVI, MOV (max 2GB)</p>
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept="video/*"
                            onChange={handleFileSelect}
                            className="hidden"
                        />
                    </div>
                ) : (
                    <div className="flex items-center justify-between p-3 bg-muted rounded-lg">
                        <div className="flex items-center gap-3">
                            <CheckCircle2 className="w-5 h-5 text-green-500" />
                            <div>
                                <p className="text-sm font-medium">{videoFile.name}</p>
                                <p className="text-xs text-muted-foreground">
                                    {(videoFile.size / 1024 / 1024).toFixed(2)} MB
                                </p>
                            </div>
                        </div>
                        <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => {
                                setVideoFile(null);
                                setStatus('idle');
                            }}
                        >
                            Changer
                        </Button>
                    </div>
                )}
            </div>

            {/* Step 2: Calibration (simplified for now) */}
            {videoFile && status === 'calibrating' && (
                <div className="bg-card border border-border rounded-lg p-4">
                    <div className="flex items-center gap-2 mb-3">
                        <div className="w-6 h-6 rounded-full bg-primary text-primary-foreground flex items-center justify-center text-xs font-bold">
                            2
                        </div>
                        <h4 className="font-semibold">Calibration Terrain</h4>
                    </div>

                    <div className="bg-muted rounded-lg p-4 mb-3">
                        <p className="text-sm text-muted-foreground mb-2">
                            Cliquez sur les 4 coins du terrain dans la vid√©o pour calibrer les positions.
                        </p>
                        <div className="aspect-video bg-background rounded border border-border flex items-center justify-center">
                            <p className="text-xs text-muted-foreground">Aper√ßu vid√©o (√† impl√©menter)</p>
                        </div>
                    </div>

                    <Button
                        onClick={() => setStatus('idle')}
                        className="w-full"
                    >
                        Confirmer Calibration
                    </Button>
                </div>
            )}

            {/* Step 3: Start Analysis */}
            {videoFile && status !== 'calibrating' && status !== 'processing' && status !== 'completed' && (
                <div className="bg-card border border-border rounded-lg p-4">
                    <div className="flex items-center gap-2 mb-3">
                        <div className="w-6 h-6 rounded-full bg-muted text-muted-foreground flex items-center justify-center text-xs font-bold">
                            3
                        </div>
                        <h4 className="font-semibold">Lancer l'Analyse</h4>
                    </div>

                    <div className="space-y-3">
                        <div className="flex items-center justify-between p-3 bg-muted rounded-lg">
                            <span className="text-sm">Mod√®les de d√©tection</span>
                            <Badge variant="secondary">YOLOv10 + RT-DETR</Badge>
                        </div>

                        <div className="flex items-center justify-between p-3 bg-muted rounded-lg">
                            <span className="text-sm">Tracking</span>
                            <Badge variant="secondary">DeepSORT + ReID</Badge>
                        </div>

                        <div className="flex items-center justify-between p-3 bg-muted rounded-lg">
                            <span className="text-sm">M√©triques</span>
                            <Badge variant="secondary">xG, xThreat, VAEP</Badge>
                        </div>

                        <Button
                            onClick={handleStartAnalysis}
                            className="w-full"
                            size="lg"
                        >
                            <Play className="w-4 h-4 mr-2" />
                            D√©marrer l'Analyse
                        </Button>
                    </div>
                </div>
            )}

            {/* Processing Status */}
            {status === 'processing' && (
                <div className="bg-card border border-border rounded-lg p-4">
                    <div className="flex items-center gap-2 mb-4">
                        <div className="w-6 h-6 rounded-full bg-primary text-primary-foreground flex items-center justify-center">
                            <div className="animate-spin">‚öôÔ∏è</div>
                        </div>
                        <h4 className="font-semibold">Analyse en cours...</h4>
                    </div>

                    <div className="space-y-3">
                        <div>
                            <div className="flex justify-between text-sm mb-2">
                                <span>Progression</span>
                                <span className="font-mono">{progress}%</span>
                            </div>
                            <Progress value={progress} className="h-2" />
                        </div>

                        <div className="grid grid-cols-2 gap-2 text-xs">
                            <div className="p-2 bg-muted rounded">
                                <div className="text-muted-foreground">Frame</div>
                                <div className="font-mono">{Math.floor(progress * 30)}/3000</div>
                            </div>
                            <div className="p-2 bg-muted rounded">
                                <div className="text-muted-foreground">Temps restant</div>
                                <div className="font-mono">~{Math.floor((100 - progress) / 10)} min</div>
                            </div>
                        </div>

                        <div className="text-xs text-muted-foreground space-y-1">
                            <div className="flex items-center gap-2">
                                <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                                <span>D√©tection joueurs (YOLOv10)</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></div>
                                <span>Tracking identit√©s (DeepSORT)</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-2 h-2 rounded-full bg-purple-500"></div>
                                <span>Calcul m√©triques (en attente)</span>
                            </div>
                        </div>
                    </div>
                </div>
            )}

            {/* Completed Status */}
            {status === 'completed' && (
                <div className="bg-card border border-green-500 rounded-lg p-4">
                    <div className="flex items-center gap-2 mb-4">
                        <CheckCircle2 className="w-6 h-6 text-green-500" />
                        <h4 className="font-semibold text-green-500">Analyse Termin√©e !</h4>
                    </div>

                    <div className="grid grid-cols-3 gap-2 mb-4">
                        <div className="p-3 bg-muted rounded text-center">
                            <div className="text-2xl font-bold">3000</div>
                            <div className="text-xs text-muted-foreground">Frames</div>
                        </div>
                        <div className="p-3 bg-muted rounded text-center">
                            <div className="text-2xl font-bold">22</div>
                            <div className="text-xs text-muted-foreground">Joueurs</div>
                        </div>
                        <div className="p-3 bg-muted rounded text-center">
                            <div className="text-2xl font-bold">847</div>
                            <div className="text-xs text-muted-foreground">√âv√©nements</div>
                        </div>
                    </div>

                    <Button className="w-full" variant="default">
                        Voir les R√©sultats
                    </Button>
                </div>
            )}
        </div>
    );
};
</file>

<file path="src/components/ProtectedRoute.tsx">
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth, UserRole } from '@/contexts/AuthContext';

interface ProtectedRouteProps {
    children: React.ReactNode;
    allowedRoles?: UserRole[];
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children, allowedRoles }) => {
    const { isAuthenticated, user } = useAuth();
    const location = useLocation();

    if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
    }

    // Safety check: if we think we are authenticated but user data is missing/loading
    if (isAuthenticated && !user) {
        // You could return a loading spinner here, or assume invalid state and redirect
        // For now, let's redirect to login to force a clean state if it persists
        return <Navigate to="/login" replace />;
    }

    if (allowedRoles && user && !allowedRoles.includes(user.role)) {
        return <Navigate to="/" replace />;
    }

    return <>{children}</>;
};

export default ProtectedRoute;
</file>

<file path="src/components/QuickPlayerSelector.tsx">
import React from 'react';
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { PlayerPosition } from "@/utils/passPredictor";

interface QuickPlayerSelectorProps {
    isVisible: boolean;
    roster: PlayerPosition[];
    selectedIndex: number;
    team: "TEAM_A" | "TEAM_B";
}

export const QuickPlayerSelector = ({
    isVisible,
    roster,
    selectedIndex,
    team
}: QuickPlayerSelectorProps) => {
    if (!isVisible) return null;

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-in fade-in duration-200">
            {/* Modal Container - pointer events auto to allow interaction if mouse used, though mainly for visual */}
            <Card className="w-[800px] bg-zinc-900/95 border-zinc-700 p-6 shadow-2xl pointer-events-auto">
                <div className="text-center mb-6">
                    <h2 className="text-xl font-bold text-white uppercase tracking-wider">
                        Select Player <span className={team === "TEAM_A" ? "text-blue-400" : "text-red-400"}>({team === "TEAM_A" ? "Home" : "Away"})</span>
                    </h2>
                    <p className="text-zinc-400 text-sm">Use D-Pad to Select ‚Ä¢ A to Confirm ‚Ä¢ B to Cancel</p>
                </div>

                <div className="grid grid-cols-5 gap-3">
                    {roster.map((player, index) => (
                        <div
                            key={player.id}
                            className={`
                                relative p-3 rounded-lg border transition-all duration-200 flex flex-col items-center gap-2
                                ${index === selectedIndex
                                    ? "bg-white text-black border-white scale-105 shadow-[0_0_15px_rgba(255,255,255,0.3)] z-10"
                                    : "bg-zinc-800 text-zinc-300 border-zinc-700 opacity-80"
                                }
                            `}
                        >
                            <span className={`
                                text-2xl font-black 
                                ${index === selectedIndex ? "text-black" : "text-zinc-500"}
                            `}>
                                {player.number}
                            </span>
                            <span className="text-xs font-medium truncate w-full text-center">
                                {player.name}
                            </span>
                            <Badge
                                variant="outline"
                                className={`
                                    text-[10px] px-1 py-0 h-4 border-0
                                    ${index === selectedIndex ? "bg-black/10 text-black" : "bg-zinc-700 text-zinc-400"}
                                `}
                            >
                                {player.position}
                            </Badge>
                        </div>
                    ))}
                </div>
            </Card>
        </div>
    );
};
</file>

<file path="src/components/SequenceAssistant.tsx">
// src/components/SequenceAssistant.tsx
// AI prediction assistant overlay - shows predicted next events with confidence levels

import { useMatchContext } from '@/contexts/MatchContext';
import { Prediction, formatProbability } from '@/utils/SequencePredictor';
import { cn } from '@/lib/utils';
import { Brain, TrendingUp, Sparkles, ChevronRight } from 'lucide-react';

interface SequenceAssistantProps {
    className?: string;
    maxPredictions?: number;
    minConfidenceThreshold?: number; // 0-1, hide predictions below this
}

export function SequenceAssistant({
    className,
    maxPredictions = 3,
    minConfidenceThreshold = 0.1
}: SequenceAssistantProps) {
    const { predictions, learningStats } = useMatchContext();

    // Filter predictions by confidence threshold
    const visiblePredictions = predictions
        .filter(p => p.probability >= minConfidenceThreshold)
        .slice(0, maxPredictions);

    // Don't render if no meaningful predictions
    if (visiblePredictions.length === 0) {
        return (
            <div className={cn(
                "rounded-lg border border-border/30 bg-card/50 backdrop-blur-sm p-3",
                className
            )}>
                <div className="flex items-center gap-2 text-muted-foreground">
                    <Brain className="w-4 h-4" />
                    <span className="text-xs">Learning patterns...</span>
                </div>
                {learningStats && (
                    <div className="mt-2 text-xs text-muted-foreground/70">
                        {learningStats.totalEventsProcessed} events processed
                    </div>
                )}
            </div>
        );
    }

    // Get top prediction for highlighting
    const topPrediction = visiblePredictions[0];

    return (
        <div className={cn(
            "rounded-lg border border-border/50 bg-card/95 backdrop-blur-sm shadow-lg overflow-hidden",
            className
        )}>
            {/* Header */}
            <div className="px-3 py-2 bg-gradient-to-r from-purple-500/20 to-blue-500/20 border-b border-border/30">
                <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                        <Sparkles className="w-4 h-4 text-purple-400" />
                        <span className="text-sm font-semibold text-purple-200">Likely Next</span>
                    </div>
                    {learningStats && (
                        <span className="text-[10px] text-muted-foreground">
                            {learningStats.totalPatterns} patterns
                        </span>
                    )}
                </div>
            </div>

            {/* Predictions list */}
            <div className="p-2 space-y-1.5">
                {visiblePredictions.map((prediction, index) => (
                    <PredictionRow
                        key={prediction.eventName}
                        prediction={prediction}
                        isTop={index === 0}
                        rank={index + 1}
                    />
                ))}
            </div>

            {/* Quick hint */}
            {topPrediction && topPrediction.probability > 0.4 && (
                <div className="px-3 py-2 bg-purple-500/10 border-t border-border/30">
                    <div className="flex items-center gap-2 text-xs">
                        <ChevronRight className="w-3 h-3 text-purple-400" />
                        <span className="text-muted-foreground">
                            Press <kbd className="px-1.5 py-0.5 rounded bg-purple-500/20 text-purple-300 font-mono text-[10px]">
                                {topPrediction.buttonLabel}
                            </kbd> for {topPrediction.description}
                        </span>
                    </div>
                </div>
            )}
        </div>
    );
}

interface PredictionRowProps {
    prediction: Prediction;
    isTop: boolean;
    rank: number;
}

function PredictionRow({ prediction, isTop, rank }: PredictionRowProps) {
    // Confidence-based styling
    const confidenceColors = {
        HIGH: 'bg-green-500',
        MEDIUM: 'bg-yellow-500',
        LOW: 'bg-gray-500',
    };

    const probabilityWidth = Math.round(prediction.probability * 100);

    return (
        <div className={cn(
            "relative rounded-md overflow-hidden transition-all",
            isTop ? "ring-1 ring-purple-500/50" : ""
        )}>
            {/* Background progress bar */}
            <div
                className={cn(
                    "absolute inset-0 opacity-20",
                    isTop ? "bg-purple-500" : "bg-gray-500"
                )}
                style={{ width: `${probabilityWidth}%` }}
            />

            {/* Content */}
            <div className="relative flex items-center gap-2 px-2.5 py-2">
                {/* Rank badge */}
                <div className={cn(
                    "w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold",
                    isTop
                        ? "bg-purple-500 text-white"
                        : "bg-muted text-muted-foreground"
                )}>
                    {rank}
                </div>

                {/* Button label */}
                <kbd className={cn(
                    "px-2 py-1 rounded text-xs font-mono font-bold min-w-[40px] text-center",
                    isTop
                        ? "bg-purple-500/30 text-purple-200 ring-1 ring-purple-500/50"
                        : "bg-muted text-muted-foreground"
                )}>
                    {prediction.buttonLabel}
                </kbd>

                {/* Event description */}
                <span className={cn(
                    "flex-1 text-sm truncate",
                    isTop ? "text-foreground font-medium" : "text-muted-foreground"
                )}>
                    {prediction.description}
                </span>

                {/* Probability */}
                <div className="flex items-center gap-1.5">
                    <div className={cn(
                        "w-1.5 h-1.5 rounded-full",
                        confidenceColors[prediction.confidence]
                    )} />
                    <span className={cn(
                        "text-xs font-mono",
                        isTop ? "text-foreground" : "text-muted-foreground"
                    )}>
                        {formatProbability(prediction.probability)}
                    </span>
                </div>
            </div>
        </div>
    );
}

// Compact version for inline display
export function SequenceAssistantCompact({ className }: { className?: string }) {
    const { predictions } = useMatchContext();

    const topPrediction = predictions[0];

    if (!topPrediction || topPrediction.probability < 0.2) {
        return null;
    }

    return (
        <div className={cn(
            "inline-flex items-center gap-2 px-2 py-1 rounded-md bg-purple-500/10 border border-purple-500/30",
            className
        )}>
            <Sparkles className="w-3 h-3 text-purple-400" />
            <span className="text-xs text-purple-200">
                Next:
            </span>
            <kbd className="px-1.5 py-0.5 rounded bg-purple-500/20 text-purple-300 font-mono text-xs font-bold">
                {topPrediction.buttonLabel}
            </kbd>
            <span className="text-xs text-muted-foreground">
                ({formatProbability(topPrediction.probability)})
            </span>
        </div>
    );
}

// Learning stats display
export function PredictorStats({ className }: { className?: string }) {
    const { learningStats, resetPredictions } = useMatchContext();

    if (!learningStats) {
        return null;
    }

    return (
        <div className={cn(
            "rounded-lg border border-border/50 bg-card/95 p-3 space-y-2",
            className
        )}>
            <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                    <Brain className="w-4 h-4 text-purple-400" />
                    <span className="text-sm font-semibold">Pattern Learning</span>
                </div>
                <button
                    onClick={resetPredictions}
                    className="text-xs text-muted-foreground hover:text-foreground transition-colors"
                >
                    Reset
                </button>
            </div>

            <div className="grid grid-cols-2 gap-2 text-xs">
                <div>
                    <span className="text-muted-foreground">Patterns:</span>
                    <span className="ml-1 font-medium">{learningStats.totalPatterns}</span>
                </div>
                <div>
                    <span className="text-muted-foreground">Events:</span>
                    <span className="ml-1 font-medium">{learningStats.totalEventsProcessed}</span>
                </div>
            </div>

            {learningStats.topPatterns.length > 0 && (
                <div className="pt-2 border-t border-border/30">
                    <span className="text-xs text-muted-foreground">Top Patterns:</span>
                    <div className="mt-1 space-y-1">
                        {learningStats.topPatterns.slice(0, 3).map((pattern, i) => (
                            <div key={i} className="flex items-center justify-between text-xs">
                                <span className="font-mono text-purple-300 truncate max-w-[120px]">
                                    {pattern.sequence.join(' ‚Üí ')}
                                </span>
                                <span className="text-muted-foreground">
                                    ‚Üí {pattern.topFollower} ({formatProbability(pattern.topFollowerProbability)})
                                </span>
                            </div>
                        ))}
                    </div>
                </div>
            )}
        </div>
    );
}

export default SequenceAssistant;
</file>

<file path="src/components/SessionModeModal.tsx">
import React from 'react';
import { Users, User, ArrowRight } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";

interface SessionModeModalProps {
    onSelectMode: (mode: 'collab' | 'individual') => void;
}

export const SessionModeModal: React.FC<SessionModeModalProps> = ({ onSelectMode }) => {
    return (
        <div className="fixed inset-0 z-[100] bg-background/80 backdrop-blur-sm flex items-center justify-center p-4">
            <Card className="max-w-3xl w-full bg-card shadow-2xl border-primary/20 animate-in fade-in zoom-in duration-300">
                <CardHeader className="text-center pb-8 border-b border-border/50">
                    <CardTitle className="text-2xl md:text-3xl font-bold tracking-tight text-primary">
                        Select Session Mode
                    </CardTitle>
                    <CardDescription className="text-base mt-2">
                        Choose how you would like to work in this session.
                    </CardDescription>
                </CardHeader>
                <CardContent className="grid md:grid-cols-2 gap-6 p-8">

                    {/* Collaboration Mode */}
                    <button
                        className="group relative flex flex-col items-center justify-center p-8 h-64 border-2 border-border rounded-xl hover:border-primary/50 hover:bg-primary/5 transition-all duration-200 text-center space-y-4"
                        onClick={() => onSelectMode('collab')}
                    >
                        <div className="p-4 rounded-full bg-primary/10 text-primary group-hover:bg-primary group-hover:text-primary-foreground transition-colors duration-200">
                            <Users size={32} />
                        </div>
                        <div className="space-y-1">
                            <h3 className="text-xl font-bold group-hover:text-primary transition-colors">Collaboration</h3>
                            <p className="text-sm text-muted-foreground">
                                Join the Voice Room and collaborate with others in real-time.
                            </p>
                        </div>
                        <div className="absolute bottom-6 opacity-0 translate-y-2 group-hover:opacity-100 group-hover:translate-y-0 transition-all duration-200">
                            <span className="flex items-center gap-1 text-xs font-bold uppercase tracking-wider text-primary">
                                Start Session <ArrowRight size={12} />
                            </span>
                        </div>
                    </button>

                    {/* Individual Mode */}
                    <button
                        className="group relative flex flex-col items-center justify-center p-8 h-64 border-2 border-border rounded-xl hover:border-muted-foreground/50 hover:bg-secondary/50 transition-all duration-200 text-center space-y-4"
                        onClick={() => onSelectMode('individual')}
                    >
                        <div className="p-4 rounded-full bg-secondary text-secondary-foreground group-hover:bg-muted-foreground group-hover:text-white transition-colors duration-200">
                            <User size={32} />
                        </div>
                        <div className="space-y-1">
                            <h3 className="text-xl font-bold group-hover:text-foreground transition-colors">Individual Work</h3>
                            <p className="text-sm text-muted-foreground">
                                Work offline or independently without voice features.
                            </p>
                        </div>
                        <div className="absolute bottom-6 opacity-0 translate-y-2 group-hover:opacity-100 group-hover:translate-y-0 transition-all duration-200">
                            <span className="flex items-center gap-1 text-xs font-bold uppercase tracking-wider text-muted-foreground">
                                Enter Dashboard <ArrowRight size={12} />
                            </span>
                        </div>
                    </button>

                </CardContent>
            </Card>
        </div>
    );
};
</file>

<file path="src/components/SmartPlayerSelector.tsx">
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { PlayerPosition } from "@/utils/passPredictor";
import { ChevronRight, User } from "lucide-react";

interface SmartPlayerSelectorProps {
    currentBallHolder: PlayerPosition | null;
    predictedTargets: PlayerPosition[];
    selectedTargetIndex: number;
    isActive: boolean;
}

export const SmartPlayerSelector = ({
    currentBallHolder,
    predictedTargets,
    selectedTargetIndex,
    isActive
}: SmartPlayerSelectorProps) => {
    if (!isActive || !currentBallHolder) {
        return null;
    }

    const getPositionColor = (position: PlayerPosition["position"]) => {
        switch (position) {
            case "GK": return "bg-yellow-500";
            case "DEF": return "bg-blue-500";
            case "MID": return "bg-green-500";
            case "FWD": return "bg-red-500";
            default: return "bg-gray-500";
        }
    };

    const getTeamColor = (team: "TEAM_A" | "TEAM_B") => {
        return team === "TEAM_A" ? "bg-primary" : "bg-destructive";
    };

    return (
        <Card className="fixed top-4 right-4 bg-card/95 backdrop-blur border-2 shadow-xl z-50 min-w-[280px] max-w-[320px]">
            {/* Current Ball Holder */}
            <div className="p-3 border-b bg-muted/30">
                <div className="text-xs text-muted-foreground mb-1 flex items-center gap-1">
                    <User className="w-3 h-3" />
                    Ball Holder
                </div>
                <div className="flex items-center gap-2">
                    <div className={`w-2 h-2 rounded-full ${getTeamColor(currentBallHolder.team)}`} />
                    <div className="font-semibold text-sm">
                        #{currentBallHolder.number} {currentBallHolder.name}
                    </div>
                    <Badge variant="outline" className="text-xs">
                        {currentBallHolder.position}
                    </Badge>
                </div>
            </div>

            {/* Predicted Targets */}
            <div className="p-3">
                <div className="text-xs text-muted-foreground mb-2 font-medium">
                    Pass to:
                </div>

                {predictedTargets.length === 0 ? (
                    <div className="text-xs text-muted-foreground text-center py-4">
                        No predictions available
                    </div>
                ) : (
                    <div className="space-y-1">
                        {predictedTargets.map((player, index) => (
                            <div
                                key={player.id}
                                className={`flex items-center gap-2 p-2 rounded-md transition-all ${index === selectedTargetIndex
                                        ? "bg-primary text-primary-foreground shadow-md scale-105"
                                        : "bg-muted/40 hover:bg-muted/60"
                                    }`}
                            >
                                {index === selectedTargetIndex && (
                                    <ChevronRight className="w-4 h-4 flex-shrink-0" />
                                )}
                                <div className={`w-1.5 h-1.5 rounded-full flex-shrink-0 ${index === selectedTargetIndex
                                        ? "bg-primary-foreground"
                                        : getPositionColor(player.position)
                                    }`} />
                                <div className="flex-1 min-w-0">
                                    <div className="text-sm font-medium truncate">
                                        #{player.number} {player.name}
                                    </div>
                                </div>
                                <Badge
                                    variant={index === selectedTargetIndex ? "secondary" : "outline"}
                                    className="text-xs flex-shrink-0"
                                >
                                    {player.position}
                                </Badge>
                            </div>
                        ))}
                    </div>
                )}
            </div>

            {/* Instructions */}
            <div className="px-3 pb-3 pt-1 border-t">
                <div className="text-xs text-muted-foreground text-center">
                    D-pad ‚Üë‚Üì to select ‚Ä¢ A to confirm
                </div>
            </div>
        </Card>
    );
};
</file>

<file path="src/components/SpotterPingPanel.tsx">
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { useSocket as useSocketContext } from '@/contexts/SocketContext';
import { useMatchContext } from '@/contexts/MatchContext';
import { RadioTower, MapPin } from 'lucide-react';
import { toast } from 'sonner';

export const SpotterPingPanel = () => {
    const { socket } = useSocketContext();
    const { matchTime } = useMatchContext();
    const [target, setTarget] = useState<'HOME' | 'AWAY'>('HOME');

    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };

    const handlePing = () => {
        const timestamp = new Date().toISOString();
        const formattedMatchTime = formatTime(matchTime || 0);

        const pingEvent = {
            type: 'SPOTTER_PING',
            target,
            timestamp,
            matchTime: formattedMatchTime,
            id: Date.now()
        };

        socket?.emit('spotter-ping', pingEvent);
        toast.success(`Ping recorded at ${formattedMatchTime}`);

        // Add haptic feedback if supported
        if ('vibrate' in navigator) {
            navigator.vibrate(50);
        }
    };

    return (
        <div className="flex flex-col h-full bg-slate-950/80 backdrop-blur-3xl p-6 gap-8 items-center justify-center border-l border-white/5">
            <div className="text-center space-y-2">
                <div className="mx-auto w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center mb-2">
                    <RadioTower className="w-6 h-6 text-primary animate-pulse" />
                </div>
                <h2 className="text-xl font-bold uppercase tracking-tighter text-white">Spotter Assist</h2>
                <p className="text-xs text-muted-foreground uppercase tracking-widest font-medium">Voice is Primary ‚Ä¢ Tap for Timing</p>
            </div>

            <RadioGroup
                value={target}
                onValueChange={(val: any) => setTarget(val)}
                className="grid grid-cols-2 gap-4 w-full max-w-xs"
            >
                <div className="flex items-center space-x-2 bg-slate-900/50 p-4 rounded-xl border border-white/5 cursor-pointer hover:bg-slate-900 transition-colors">
                    <RadioGroupItem value="HOME" id="home" className="sr-only" />
                    <Label htmlFor="home" className={`w-full text-center font-bold cursor-pointer ${target === 'HOME' ? 'text-primary' : 'text-slate-500'}`}>HOME</Label>
                </div>
                <div className="flex items-center space-x-2 bg-slate-900/50 p-4 rounded-xl border border-white/5 cursor-pointer hover:bg-slate-900 transition-colors">
                    <RadioGroupItem value="AWAY" id="away" className="sr-only" />
                    <Label htmlFor="away" className={`w-full text-center font-bold cursor-pointer ${target === 'AWAY' ? 'text-destructive' : 'text-slate-500'}`}>AWAY</Label>
                </div>
            </RadioGroup>

            <Button
                onClick={handlePing}
                className="w-64 h-64 rounded-full border-[12px] border-white/10 bg-slate-900 hover:bg-slate-800 shadow-[0_0_50px_rgba(var(--primary),0.3)] group transition-all duration-300 active:scale-95 active:border-primary/50"
            >
                <div className="flex flex-col items-center gap-2">
                    <MapPin className="w-12 h-12 text-primary group-hover:scale-110 transition-transform" />
                    <span className="text-3xl font-black italic tracking-tighter text-white">PING</span>
                </div>
            </Button>

            <div className="text-[10px] text-slate-500 font-mono text-center max-w-[200px]">
                This will send a high-precision timestamp to the Logger for verification.
            </div>
        </div>
    );
};
</file>

<file path="src/components/StartingLineup.tsx">
import { Player } from "@/types/player";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Users, Shirt } from "lucide-react";

interface StartingLineupProps {
    players: Player[];
    teamName: string;
}

export const StartingLineup = ({ players, teamName }: StartingLineupProps) => {
    // Filter for starting XI if applicable, otherwise show all
    // For Algeria, we know the IDs: 1, 2, 5, 6, 7, 8, 9, 10, 11, 15, 22
    const ALGERIA_STARTERS = [1, 2, 5, 6, 7, 8, 9, 10, 11, 15, 22];

    const startingPlayers = teamName === "Algeria"
        ? players.filter(p => ALGERIA_STARTERS.includes(p.ID))
        : players.slice(0, 11); // Fallback: take first 11

    return (
        <Card className="h-full flex flex-col border-none bg-transparent shadow-none">
            <div className="flex items-center justify-between p-4 pb-2">
                <h3 className="text-lg font-bold flex items-center gap-2">
                    <Shirt className="w-5 h-5 text-primary" />
                    Starting XI
                </h3>
                <span className="text-xs font-bold px-2 py-1 rounded bg-primary/20 text-primary">
                    {teamName}
                </span>
            </div>

            <ScrollArea className="flex-1 px-4">
                <div className="grid grid-cols-1 gap-2 pb-4">
                    {startingPlayers.length === 0 ? (
                        <div className="text-center py-8 text-muted-foreground text-sm italic">
                            No players available.
                        </div>
                    ) : (
                        startingPlayers.map((player) => (
                            <div
                                key={player.ID}
                                className="flex items-center gap-3 p-2 rounded-lg bg-card/50 border border-border/50 hover:bg-card transition-colors"
                            >
                                <div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center font-bold text-xs shadow-sm border border-border">
                                    {player.Number || "-"}
                                </div>
                                <div className="flex flex-col">
                                    <span className="text-sm font-semibold leading-none">
                                        {player.Forename} {player.Surname}
                                    </span>
                                    {player.Position && (
                                        <span className="text-[10px] text-muted-foreground uppercase tracking-wider mt-0.5">
                                            {player.Position}
                                        </span>
                                    )}
                                </div>
                            </div>
                        ))
                    )}
                </div>
            </ScrollArea>
        </Card>
    );
};
</file>

<file path="src/components/StatisticsDashboard.tsx">
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { cn } from '@/lib/utils';
import { TrendingUp, TrendingDown, Activity, Clock, Zap, Target } from 'lucide-react';

interface LoggedEvent {
    eventName: string;
    timestamp: string;
    durationMs?: number;
    zone?: number;
    subType?: string;
}

interface StatisticsDashboardProps {
    events: LoggedEvent[];
    isFullPage?: boolean;
    isOverlay?: boolean;
}

export const StatisticsDashboard = ({ events, isFullPage = false, isOverlay = false }: StatisticsDashboardProps) => {
    const [isMinimized, setIsMinimized] = React.useState(false);

    // Calculate statistics
    const totalEvents = events.length;

    const passes = events.filter(e => e.eventName === "pass_start" || e.eventName === "pass_end").length;
    const successfulPasses = events.filter(e =>
        e.eventName === "Successful Pass" ||
        e.eventName === "PASS_SUCCESS" ||
        (e.eventName === "pass_end" && !e.subType?.includes("INCOMPLETE")) // Assuming subType might hold success info or just relying on explicit success events if they exist
    ).length;
    const failedPasses = 0;

    const shots = events.filter(e => e.eventName === "shot_start" || e.eventName === "shot_outcome").length;

    const possessionWon = events.filter(e => e.eventName === "interception" || e.eventName === "recovery").length;
    const possessionLost = events.filter(e => e.eventName === "turnover" || e.eventName === "loss").length;
    const possessionChanges = possessionWon + possessionLost;

    const fouls = events.filter(e => e.eventName === "foul" || e.eventName === "foul_committed").length;

    const duels = events.filter(e => e.eventName?.includes("duel")).length;
    const looseBalls = events.filter(e => e.eventName === "loose_ball").length;

    // Advanced Metrics
    const eventsWithZone = events.filter(e => e.zone && e.zone > 0);
    const leftZones = [1, 4, 7, 10, 13, 16];
    const centerZones = [2, 5, 8, 11, 14, 17];
    const rightZones = [3, 6, 9, 12, 15, 18];

    const leftCount = eventsWithZone.filter(e => leftZones.includes(e.zone!)).length;
    const centerCount = eventsWithZone.filter(e => centerZones.includes(e.zone!)).length;
    const rightCount = eventsWithZone.filter(e => rightZones.includes(e.zone!)).length;
    const totalZoneEvents = eventsWithZone.length || 1;

    const leftPct = ((leftCount / totalZoneEvents) * 100).toFixed(0);
    const centerPct = ((centerCount / totalZoneEvents) * 100).toFixed(0);
    const rightPct = ((rightCount / totalZoneEvents) * 100).toFixed(0);

    const shortPasses = events.filter(e => e.subType === "SHORT").length;
    const longPasses = events.filter(e => e.subType === "LONG").length;
    const buildupSequences = events.filter(e => e.eventName === "phase_buildup").length;

    const highPressCount = events.filter(e =>
        (e.eventName === "interception" || e.eventName === "recovery") &&
        e.zone && e.zone >= 13
    ).length;

    // Filter relevant stats for the overlay
    const overlayStats = [
        { title: "Passes", value: passes, color: "text-blue-400", subtext: `‚úì ${successfulPasses}` },
        { title: "Shots", value: shots, color: "text-orange-400" },
        { title: "Possession", value: possessionChanges, color: "text-purple-400" },
        { title: "Goals", value: events.filter(e => e.eventName === 'goal').length, color: "text-emerald-400" },
        { title: "Fouls", value: fouls, color: "text-yellow-400" }
    ];

    if (isOverlay) {
        if (isMinimized) {
            return (
                <div
                    className="absolute top-4 left-4 z-50 cursor-pointer group"
                    onClick={() => setIsMinimized(false)}
                >
                    <div className="bg-black/60 backdrop-blur-md border border-white/10 rounded-lg p-2 flex items-center gap-2 hover:bg-black/80 transition-all shadow-xl">
                        <Activity className="w-4 h-4 text-emerald-400" />
                        <span className="text-[10px] font-bold uppercase tracking-wider text-white">Stats</span>
                    </div>
                </div>
            );
        }

        return (
            <div className="absolute top-4 left-4 z-50 w-[240px] animate-in slide-in-from-left-4 duration-200">
                <div className="bg-black/80 backdrop-blur-md border border-white/10 rounded-xl overflow-hidden shadow-2xl">
                    {/* Overlay Header */}
                    <div className="flex items-center justify-between px-3 py-2 border-b border-white/10 bg-white/5">
                        <div className="flex items-center gap-2">
                            <Target className="w-3 h-3 text-emerald-400" />
                            <span className="text-[10px] font-black uppercase tracking-widest text-white">Live Stats</span>
                        </div>
                        <button
                            onClick={(e) => { e.stopPropagation(); setIsMinimized(true); }}
                            className="text-muted-foreground hover:text-white transition-colors"
                        >
                            <TrendingDown className="w-3 h-3 rotate-180" />
                        </button>
                    </div>

                    {/* Compact Overlay Content */}
                    <div className="p-2 space-y-1.5">
                        {overlayStats.map((stat) => (
                            <div key={stat.title} className="flex items-center justify-between p-1.5 rounded bg-white/5 border border-white/5">
                                <span className="text-[9px] uppercase text-muted-foreground font-bold tracking-wider">{stat.title}</span>
                                <div className="flex items-center gap-2">
                                    <span className={cn("text-sm font-black font-mono", stat.color)}>{stat.value}</span>
                                    {stat.subtext && <span className="text-[8px] text-muted-foreground/50">{stat.subtext}</span>}
                                </div>
                            </div>
                        ))}
                    </div>

                    {/* Quick Footer */}
                    <div className="px-3 py-1.5 bg-emerald-500/10 border-t border-white/5 flex justify-between items-center text-[9px]">
                        <span className="text-emerald-400 font-bold uppercase tracking-wider">Total Events</span>
                        <span className="text-white font-mono">{totalEvents}</span>
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="space-y-4">
            {isFullPage && (
                <div className="flex items-center justify-between pb-4 border-b border-white/5">
                    <div>
                        <h2 className="text-3xl font-black tracking-tight text-white uppercase flex items-center gap-3">
                            <Activity className="w-7 h-7 text-emerald-400" />
                            Match Analytics
                        </h2>
                        <p className="text-xs text-muted-foreground mt-1">Real-time performance tracking</p>
                    </div>
                    <div className="flex items-center gap-3 bg-gradient-to-r from-emerald-500/10 to-blue-500/10 px-4 py-3 rounded-lg border border-white/5">
                        <div className="text-center">
                            <div className="text-[10px] text-muted-foreground uppercase tracking-wider mb-1">Total Events</div>
                            <div className="text-2xl font-black text-emerald-400 font-mono">{totalEvents}</div>
                        </div>
                    </div>
                </div>
            )}

            {/* Main Statistics Grid */}
            <div>
                <SectionHeader title="Match Statistics" icon={Target} />
                <div className={`grid gap-2 ${isFullPage ? 'grid-cols-2 md:grid-cols-4 lg:grid-cols-7' : 'grid-cols-2 md:grid-cols-3 lg:grid-cols-7'}`}>
                    <StatCard
                        title="Passes"
                        value={passes}
                        subtext={`‚úì ${successfulPasses} | ‚úó ${failedPasses}`}
                        color="text-blue-400"
                        bgGradient="from-blue-500/10 to-blue-600/5"
                    />
                    <StatCard
                        title="Shots"
                        value={shots}
                        color="text-orange-400"
                        bgGradient="from-orange-500/10 to-orange-600/5"
                    />
                    <StatCard
                        title="Possession"
                        value={possessionChanges}
                        color="text-purple-400"
                        bgGradient="from-purple-500/10 to-purple-600/5"
                    />
                    <StatCard
                        title="Recoveries"
                        value={possessionWon}
                        subtext="Won"
                        color="text-green-400"
                        bgGradient="from-green-500/10 to-green-600/5"
                        trend="up"
                    />
                    <StatCard
                        title="Losses"
                        value={possessionLost}
                        subtext="Lost"
                        color="text-red-400"
                        bgGradient="from-red-500/10 to-red-600/5"
                        trend="down"
                    />
                    <StatCard
                        title="Fouls"
                        value={fouls}
                        color="text-yellow-400"
                        bgGradient="from-yellow-500/10 to-yellow-600/5"
                    />
                    <StatCard
                        title="Duels"
                        value={duels}
                        subtext={`50/50: ${looseBalls}`}
                        color="text-indigo-400"
                        bgGradient="from-indigo-500/10 to-indigo-600/5"
                    />
                </div>
            </div>



            {/* Advanced Analytics Cards */}
            {isFullPage && (
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 pt-2">
                    <AdvancedCard
                        title="Passing Circuits"
                        subtitle="Field distribution analysis"
                    >
                        <div className="space-y-4">
                            <div className="grid grid-cols-3 gap-3">
                                <div className="text-center">
                                    <div className="text-2xl font-black text-blue-400">{leftPct}%</div>
                                    <div className="text-[9px] text-muted-foreground uppercase tracking-wider mt-1">Left</div>
                                </div>
                                <div className="text-center">
                                    <div className="text-2xl font-black text-white">{centerPct}%</div>
                                    <div className="text-[9px] text-muted-foreground uppercase tracking-wider mt-1">Center</div>
                                </div>
                                <div className="text-center">
                                    <div className="text-2xl font-black text-red-400">{rightPct}%</div>
                                    <div className="text-[9px] text-muted-foreground uppercase tracking-wider mt-1">Right</div>
                                </div>
                            </div>
                            <div className="relative w-full h-4 bg-slate-900/60 rounded-full overflow-hidden shadow-inner border border-white/5">
                                <div className="absolute inset-0 flex">
                                    <div
                                        style={{ width: `${leftPct}%` }}
                                        className="h-full bg-gradient-to-r from-blue-500 to-blue-400 transition-all duration-700 ease-out"
                                    />
                                    <div
                                        style={{ width: `${centerPct}%` }}
                                        className="h-full bg-gradient-to-r from-white/40 to-white/30 transition-all duration-700 ease-out"
                                    />
                                    <div
                                        style={{ width: `${rightPct}%` }}
                                        className="h-full bg-gradient-to-r from-red-400 to-red-500 transition-all duration-700 ease-out"
                                    />
                                </div>
                            </div>
                        </div>
                    </AdvancedCard>

                    <AdvancedCard
                        title="Style of Play"
                        subtitle="Tactical approach metrics"
                    >
                        <div className="space-y-4">
                            <div className="grid grid-cols-2 gap-4">
                                <div className="bg-gradient-to-br from-blue-500/10 to-transparent p-3 rounded-lg border border-blue-500/20">
                                    <div className="text-[10px] uppercase text-blue-400 tracking-wider mb-1.5">Short Range</div>
                                    <div className="text-3xl font-black text-blue-400">{shortPasses}</div>
                                </div>
                                <div className="bg-gradient-to-br from-purple-500/10 to-transparent p-3 rounded-lg border border-purple-500/20">
                                    <div className="text-[10px] uppercase text-purple-400 tracking-wider mb-1.5">Long Range</div>
                                    <div className="text-3xl font-black text-purple-400">{longPasses}</div>
                                </div>
                            </div>
                            <div className="pt-3 border-t border-white/5 flex justify-between items-center">
                                <span className="text-[10px] uppercase text-muted-foreground tracking-wider">Buildup Phases</span>
                                <span className="text-xl font-black text-emerald-400">{buildupSequences}</span>
                            </div>
                        </div>
                    </AdvancedCard>

                    <AdvancedCard
                        title="Defensive Intensity"
                        subtitle="Pressing effectiveness"
                    >
                        <div className="space-y-3">
                            <div className="flex items-end gap-3">
                                <div className="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-br from-red-400 to-orange-400">
                                    {highPressCount}
                                </div>
                                <div className="pb-2">
                                    <TrendingUp className="w-6 h-6 text-red-400" />
                                </div>
                            </div>
                            <div className="text-[11px] uppercase text-muted-foreground tracking-wider">
                                High-Press Recoveries
                            </div>
                            <div className="text-[10px] text-muted-foreground/70 leading-relaxed pt-2 border-t border-white/5">
                                Counter-pressing effectiveness in the attacking third of the pitch.
                            </div>
                        </div>
                    </AdvancedCard>
                </div>
            )}
        </div>
    );
};

const SectionHeader = ({ title, subtitle, icon: Icon }: { title: string; subtitle?: string; icon?: any }) => (
    <div className="flex items-center gap-2 mb-3">
        {Icon && <Icon className="w-4 h-4 text-emerald-400" />}
        <div>
            <h3 className="text-[10px] font-black text-muted-foreground uppercase tracking-widest">
                {title}
            </h3>
            {subtitle && (
                <p className="text-[8px] text-muted-foreground/50 uppercase tracking-wider">{subtitle}</p>
            )}
        </div>
    </div>
);

const StatCard = ({
    title,
    value,
    subtext,
    color,
    bgGradient,
    trend,
    isTime
}: {
    title: string;
    value: string | number;
    subtext?: string;
    color: string;
    bgGradient?: string;
    trend?: 'up' | 'down';
    isTime?: boolean;
}) => (
    <Card className={cn(
        "relative p-3 bg-slate-900/50 border-white/10 backdrop-blur-sm",
        "transition-all duration-300 hover:scale-[1.02] hover:border-white/20",
        "hover:shadow-lg hover:shadow-black/20 group cursor-pointer overflow-hidden"
    )}>
        {/* Background Gradient Overlay */}
        <div className={cn(
            "absolute inset-0 bg-gradient-to-br opacity-0 group-hover:opacity-100 transition-opacity duration-300",
            bgGradient || "from-white/5 to-transparent"
        )} />

        {/* Animated Corner Accent */}
        <div className={cn(
            "absolute top-0 right-0 w-16 h-16 opacity-10 blur-2xl rounded-full",
            "translate-x-1/2 -translate-y-1/2 bg-current transition-all duration-300",
            "group-hover:opacity-20 group-hover:scale-150",
            color
        )} />

        <div className="relative z-10">
            <CardHeader className="p-0 mb-2">
                <div className="flex items-start justify-between">
                    <CardTitle className="text-[9px] text-muted-foreground/70 uppercase font-black tracking-[0.12em] group-hover:text-muted-foreground transition-colors leading-tight">
                        {title}
                    </CardTitle>
                    {trend && (
                        <div className={cn("mt-0.5", trend === 'up' ? 'text-green-400' : 'text-red-400')}>
                            {trend === 'up' ? <TrendingUp className="w-3 h-3" /> : <TrendingDown className="w-3 h-3" />}
                        </div>
                    )}
                    {isTime && <Clock className="w-3 h-3 text-muted-foreground/50 mt-0.5" />}
                </div>
            </CardHeader>

            <CardContent className="p-0">
                <div className={cn(
                    "text-2xl font-black tracking-tight transition-all duration-300",
                    "group-hover:scale-105 origin-left leading-none",
                    isTime ? "font-mono" : "",
                    color
                )}>
                    {value}
                </div>
                {subtext && (
                    <div className="text-[8px] text-muted-foreground/50 mt-1.5 font-medium uppercase tracking-wide group-hover:text-muted-foreground/70 transition-colors leading-tight">
                        {subtext}
                    </div>
                )}
            </CardContent>
        </div>
    </Card>
);

const AdvancedCard = ({
    title,
    subtitle,
    children
}: {
    title: string;
    subtitle?: string;
    children: React.ReactNode;
}) => (
    <Card className="p-5 bg-gradient-to-br from-slate-900/70 to-slate-900/40 border-white/10 backdrop-blur-md hover:border-white/20 transition-all duration-300 hover:shadow-xl hover:shadow-black/20">
        <CardHeader className="p-0 mb-4">
            <CardTitle className="text-[11px] text-white uppercase font-black tracking-widest">
                {title}
            </CardTitle>
            {subtitle && (
                <p className="text-[9px] text-muted-foreground/60 uppercase tracking-wider mt-1">
                    {subtitle}
                </p>
            )}
        </CardHeader>
        <CardContent className="p-0">
            {children}
        </CardContent>
    </Card>
);
</file>

<file path="src/components/TacticalAnalysisDashboard.tsx">
import { LoggedEvent } from "@/hooks/useGamepad";
import { analyzeTactics, TacticalAnalysis, DerivedEvent } from "@/utils/analysisEngine";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Progress } from "@/components/ui/progress";
import { Separator } from "@/components/ui/separator";
import { Button } from "@/components/ui/button";
import { Play, Clock, Filter, Sparkles, CheckSquare, Square, Lightbulb, Target, TrendingUp, Shield, Activity, Zap } from "lucide-react";
import { useState } from "react";
import { PlayerHeatmap } from "@/components/PlayerHeatmap";
import { VideoPlayer } from "@/components/VideoPlayer";
import { X } from "lucide-react";
import { PassingNetworkViz } from "@/components/PassingNetworkViz";

interface TacticalAnalysisDashboardProps {
    events: LoggedEvent[];
    onJumpToTime?: (time: number) => void;
    hasVideo?: boolean;
    videoFile?: File | null;
    teamNames?: { teamA: string, teamB: string };
    onRunClipAnalysis?: (clipStart: number, clipEnd: number) => Promise<void>;
}

export const TacticalAnalysisDashboard = ({
    events,
    onJumpToTime,
    hasVideo = false,
    videoFile = null,
    teamNames = { teamA: "Team A", teamB: "Team B" },
    onRunClipAnalysis
}: TacticalAnalysisDashboardProps) => {
    const analysis = analyzeTactics(events);
    const [clipFilter, setClipFilter] = useState<"ALL" | "POSSESSION" | "TRANSITION" | "HIGHLIGHT">("ALL");
    const [selectedClipIds, setSelectedClipIds] = useState<Set<string>>(new Set());

    // Clip Player State
    const [activeClip, setActiveClip] = useState<DerivedEvent | null>(null);
    const [isClipPlaying, setIsClipPlaying] = useState(false);
    const [clipSeekTime, setClipSeekTime] = useState<number | null>(null);

    if (events.length < 5) {
        return (
            <Card>
                <CardHeader>
                    <CardTitle>Tactical Analysis</CardTitle>
                    <CardDescription>Log more events (Pass, Possession Change) to see tactical insights.</CardDescription>
                </CardHeader>
            </Card>
        );
    }

    const filteredClips = analysis.derivedEvents.filter(e => {
        if (clipFilter === "ALL") return true;
        if (clipFilter === "POSSESSION") return e.type === "POSSESSION_SEQUENCE" || e.type === "LONG_BUILDUP";
        if (clipFilter === "TRANSITION") return e.type === "TRANSITION_SEQUENCE" || e.type === "COUNTER_ATTACK" || e.type === "HIGH_TURNOVER";
        if (clipFilter === "HIGHLIGHT") return e.type === "COUNTER_ATTACK" || e.type === "HIGH_TURNOVER" || e.type === "DIRECT_ATTACK";
        return true;
    });

    return (
        <Card className="w-full">
            <CardHeader>
                <CardTitle>Tactical Analysis</CardTitle>
                <CardDescription>Deep dive into possession, passing, and team stability.</CardDescription>
            </CardHeader>
            <CardContent>
                <Tabs defaultValue="possession" className="w-full">
                    <TabsList className="grid w-full grid-cols-8">
                        <TabsTrigger value="possession">Possession</TabsTrigger>
                        <TabsTrigger value="passing">Passing</TabsTrigger>
                        <TabsTrigger value="network">Network</TabsTrigger>
                        <TabsTrigger value="transitions">Transitions</TabsTrigger>
                        <TabsTrigger value="stability">Stability</TabsTrigger>
                        <TabsTrigger value="tempo">Tempo</TabsTrigger>
                        <TabsTrigger value="clips">Clips</TabsTrigger>
                        <TabsTrigger value="heatmaps">Heatmaps</TabsTrigger>
                        <TabsTrigger value="insights">Insights</TabsTrigger>
                    </TabsList>

                    {/* INSIGHTS TAB */}
                    <TabsContent value="insights" className="space-y-6 mt-4">
                        {/* KPIs */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div className="space-y-4">
                                <h3 className="font-semibold text-center flex items-center justify-center gap-2">
                                    <div className="w-3 h-3 rounded-full bg-primary" />
                                    {teamNames.teamA} KPIs
                                </h3>
                                <div className="grid grid-cols-2 gap-3">
                                    <KPICard title="Attack Eff." value={analysis.kpis.teamA.attackEfficiency} icon={<Target className="w-4 h-4" />} />
                                    <KPICard title="Defense" value={analysis.kpis.teamA.defenseSolidity} icon={<Shield className="w-4 h-4" />} />
                                    <KPICard title="Control" value={analysis.kpis.teamA.possessionControl} icon={<Activity className="w-4 h-4" />} />
                                    <KPICard title="Speed" value={analysis.kpis.teamA.transitionSpeed} icon={<Zap className="w-4 h-4" />} />
                                </div>
                                <div className="bg-muted/30 p-4 rounded-lg border">
                                    <h4 className="text-sm font-medium mb-3 flex items-center gap-2">
                                        <Lightbulb className="w-4 h-4 text-yellow-500" />
                                        AI Recommendations
                                    </h4>
                                    <ul className="space-y-2">
                                        {analysis.recommendations.teamA.map((rec, i) => (
                                            <li key={i} className="text-sm text-muted-foreground flex items-start gap-2">
                                                <span className="text-primary mt-1">‚Ä¢</span>
                                                {rec}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            </div>

                            <div className="space-y-4">
                                <h3 className="font-semibold text-center flex items-center justify-center gap-2">
                                    <div className="w-3 h-3 rounded-full bg-destructive" />
                                    {teamNames.teamB} KPIs
                                </h3>
                                <div className="grid grid-cols-2 gap-3">
                                    <KPICard title="Attack Eff." value={analysis.kpis.teamB.attackEfficiency} icon={<Target className="w-4 h-4" />} color="text-destructive" />
                                    <KPICard title="Defense" value={analysis.kpis.teamB.defenseSolidity} icon={<Shield className="w-4 h-4" />} color="text-destructive" />
                                    <KPICard title="Control" value={analysis.kpis.teamB.possessionControl} icon={<Activity className="w-4 h-4" />} color="text-destructive" />
                                    <KPICard title="Speed" value={analysis.kpis.teamB.transitionSpeed} icon={<Zap className="w-4 h-4" />} color="text-destructive" />
                                </div>
                                <div className="bg-muted/30 p-4 rounded-lg border">
                                    <h4 className="text-sm font-medium mb-3 flex items-center gap-2">
                                        <Lightbulb className="w-4 h-4 text-yellow-500" />
                                        AI Recommendations
                                    </h4>
                                    <ul className="space-y-2">
                                        {analysis.recommendations.teamB.map((rec, i) => (
                                            <li key={i} className="text-sm text-muted-foreground flex items-start gap-2">
                                                <span className="text-destructive mt-1">‚Ä¢</span>
                                                {rec}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </TabsContent>
                    <TabsContent value="possession" className="space-y-4 mt-4">
                        <div className="grid grid-cols-2 gap-4">
                            <TeamStatCard
                                title="Possession %"
                                teamA={analysis.possession.teamA.percentage}
                                teamB={analysis.possession.teamB.percentage}
                                suffix="%"
                                teamNames={teamNames}
                            />
                            <TeamStatCard
                                title="Avg Phase Duration"
                                teamA={analysis.possession.teamA.phases.avgDuration}
                                teamB={analysis.possession.teamB.phases.avgDuration}
                                suffix="s"
                                teamNames={teamNames}
                            />
                        </div>
                        <div className="grid grid-cols-2 gap-4">
                            <div className="space-y-2">
                                <h4 className="text-sm font-medium text-center">{teamNames.teamA} Phases</h4>
                                <PhaseBar stats={analysis.possession.teamA.phases.types} />
                            </div>
                            <div className="space-y-2">
                                <h4 className="text-sm font-medium text-center">{teamNames.teamB} Phases</h4>
                                <PhaseBar stats={analysis.possession.teamB.phases.types} />
                            </div>
                        </div>
                    </TabsContent>

                    {/* PASSING TAB */}
                    <TabsContent value="passing" className="space-y-4 mt-4">
                        <div className="grid grid-cols-2 gap-4">
                            <TeamStatCard
                                title="Passes per Possession"
                                teamA={analysis.passing.teamA.perPossession}
                                teamB={analysis.passing.teamB.perPossession}
                                teamNames={teamNames}
                            />
                            <TeamStatCard
                                title="Pass Accuracy (Est)"
                                teamA={analysis.passing.teamA.accuracy}
                                teamB={analysis.passing.teamB.accuracy}
                                suffix="%"
                                teamNames={teamNames}
                            />
                        </div>
                        <Separator />
                        <div className="grid grid-cols-2 gap-8">
                            <BuildUpStats team={teamNames.teamA} stats={analysis.passing.teamA.buildUp} />
                            <BuildUpStats team={teamNames.teamB} stats={analysis.passing.teamB.buildUp} />
                        </div>
                    </TabsContent>

                    {/* NETWORK TAB */}
                    <TabsContent value="network" className="space-y-4 mt-4">
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                            <PassingNetworkViz
                                network={analysis.passingNetworks.teamA as any}
                                teamName={teamNames.teamA}
                            />
                            <PassingNetworkViz
                                network={analysis.passingNetworks.teamB as any}
                                teamName={teamNames.teamB}
                            />
                        </div>
                    </TabsContent>

                    {/* TRANSITIONS TAB */}
                    <TabsContent value="transitions" className="space-y-4 mt-4">
                        <div className="grid grid-cols-2 gap-4">
                            <TeamStatCard
                                title="Counter Attacks"
                                teamA={analysis.transitions.teamA.counterAttacks}
                                teamB={analysis.transitions.teamB.counterAttacks}
                                teamNames={teamNames}
                            />
                            <TeamStatCard
                                title="Turnovers (Total)"
                                teamA={analysis.transitions.teamA.turnovers.total}
                                teamB={analysis.transitions.teamB.turnovers.total}
                                teamNames={teamNames}
                            />
                        </div>
                        <div className="grid grid-cols-2 gap-8 mt-4">
                            <TurnoverZones team={teamNames.teamA} stats={analysis.transitions.teamA.turnovers} />
                            <TurnoverZones team={teamNames.teamB} stats={analysis.transitions.teamB.turnovers} />
                        </div>
                    </TabsContent>

                    {/* STABILITY TAB */}
                    <TabsContent value="stability" className="space-y-4 mt-4">
                        <TeamStatCard
                            title="Press Resistance"
                            teamA={analysis.stability.teamA.pressResistance}
                            teamB={analysis.stability.teamB.pressResistance}
                            suffix="%"
                            description="% of possessions > 1 pass"
                            teamNames={teamNames}
                        />
                        <TeamStatCard
                            title="One-Pass Losses"
                            teamA={analysis.stability.teamA.onePassLosses}
                            teamB={analysis.stability.teamB.onePassLosses}
                            description="Possessions lost immediately"
                            teamNames={teamNames}
                        />
                    </TabsContent>

                    {/* TEMPO TAB */}
                    <TabsContent value="tempo" className="space-y-4 mt-4">
                        <TeamStatCard
                            title="Passes per Minute"
                            teamA={analysis.tempo.teamA.passesPerMinute}
                            teamB={analysis.tempo.teamB.passesPerMinute}
                            teamNames={teamNames}
                        />
                        <div className="grid grid-cols-2 gap-4">
                            <div className="p-4 border rounded bg-muted/20">
                                <h4 className="font-semibold mb-2 text-center">{teamNames.teamA} Style</h4>
                                <div className="flex justify-between text-sm">
                                    <span>Class:</span>
                                    <span className="font-bold">{analysis.style.teamA.classification}</span>
                                </div>
                                <div className="flex justify-between text-sm mt-1">
                                    <span>Directness:</span>
                                    <span>{analysis.style.teamA.directness.toFixed(0)}%</span>
                                </div>
                            </div>
                            <div className="p-4 border rounded bg-muted/20">
                                <h4 className="font-semibold mb-2 text-center">{teamNames.teamB} Style</h4>
                                <div className="flex justify-between text-sm">
                                    <span>Class:</span>
                                    <span className="font-bold">{analysis.style.teamB.classification}</span>
                                </div>
                                <div className="flex justify-between text-sm mt-1">
                                    <span>Directness:</span>
                                    <span>{analysis.style.teamB.directness.toFixed(0)}%</span>
                                </div>
                            </div>
                        </div>
                    </TabsContent>

                    {/* CLIPS TAB */}
                    <TabsContent value="clips" className="space-y-4 mt-4">
                        <div className="space-y-4">
                            {/* Dedicated Clip Player */}
                            {activeClip && videoFile && (
                                <div className="rounded-lg border bg-card overflow-hidden shadow-lg animate-in fade-in slide-in-from-top-4 duration-300">
                                    <div className="p-3 border-b flex items-center justify-between bg-muted/30">
                                        <div className="flex items-center gap-2">
                                            <div className={`w-2 h-2 rounded-full ${activeClip.team === 'TEAM_A' ? 'bg-primary' : activeClip.team === 'TEAM_B' ? 'bg-destructive' : 'bg-gray-400'}`} />
                                            <span className="font-semibold text-sm">Now Playing: {activeClip.name}</span>
                                            <span className="text-xs text-muted-foreground">({formatDuration(activeClip.endTime - activeClip.startTime)})</span>
                                        </div>
                                        <Button
                                            variant="ghost"
                                            size="sm"
                                            className="h-6 w-6 p-0 hover:bg-destructive/20 hover:text-destructive"
                                            onClick={() => {
                                                setActiveClip(null);
                                                setIsClipPlaying(false);
                                            }}
                                        >
                                            <X className="w-4 h-4" />
                                        </Button>
                                    </div>
                                    <div className="p-2 bg-black">
                                        <VideoPlayer
                                            videoFile={videoFile}
                                            events={[]}
                                            onTimeUpdate={(time) => {
                                                // Auto-pause at end of clip
                                                if (activeClip && isClipPlaying && time >= activeClip.endTime) {
                                                    setIsClipPlaying(false);
                                                }
                                            }}
                                            seekTo={clipSeekTime}
                                            isPlaying={isClipPlaying}
                                            onPlayPause={setIsClipPlaying}
                                            onSeekComplete={() => setClipSeekTime(null)}
                                        />
                                    </div>
                                </div>
                            )}

                            {/* Header with filters */}
                            <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3">
                                <div>
                                    <h3 className="text-lg font-semibold">Tactical Clips</h3>
                                    <p className="text-xs text-muted-foreground mt-0.5">
                                        {filteredClips.length} {filteredClips.length === 1 ? 'clip' : 'clips'} found
                                    </p>
                                </div>
                                <div className="flex gap-2 flex-wrap">
                                    <Button
                                        variant={clipFilter === "ALL" ? "default" : "outline"}
                                        size="sm"
                                        onClick={() => setClipFilter("ALL")}
                                    >
                                        All
                                    </Button>
                                    <Button
                                        variant={clipFilter === "POSSESSION" ? "default" : "outline"}
                                        size="sm"
                                        onClick={() => setClipFilter("POSSESSION")}
                                    >
                                        Possessions
                                    </Button>
                                    <Button
                                        variant={clipFilter === "TRANSITION" ? "default" : "outline"}
                                        size="sm"
                                        onClick={() => setClipFilter("TRANSITION")}
                                    >
                                        Transitions
                                    </Button>
                                    <Button
                                        variant={clipFilter === "HIGHLIGHT" ? "default" : "outline"}
                                        size="sm"
                                        onClick={() => setClipFilter("HIGHLIGHT")}
                                    >
                                        Highlights
                                    </Button>
                                </div>
                            </div>

                            {filteredClips.length === 0 ? (
                                <div className="flex flex-col items-center justify-center py-12 text-center">
                                    <div className="w-16 h-16 rounded-full bg-muted flex items-center justify-center mb-4">
                                        <Play className="w-8 h-8 text-muted-foreground" />
                                    </div>
                                    <p className="text-muted-foreground font-medium">No clips found for this category</p>
                                    <p className="text-xs text-muted-foreground mt-1">Try selecting a different filter</p>
                                </div>
                            ) : (
                                <>
                                    {/* Batch Actions Bar */}
                                    {selectedClipIds.size > 0 && onRunClipAnalysis && hasVideo && (
                                        <div className="mb-3 p-3 bg-primary/10 border border-primary/20 rounded-lg flex items-center justify-between">
                                            <div className="flex items-center gap-2">
                                                <CheckSquare className="w-4 h-4 text-primary" />
                                                <span className="text-sm font-medium">
                                                    {selectedClipIds.size} clip{selectedClipIds.size > 1 ? 's' : ''} selected
                                                </span>
                                            </div>
                                            <div className="flex gap-2">
                                                <Button
                                                    variant="outline"
                                                    size="sm"
                                                    onClick={() => setSelectedClipIds(new Set())}
                                                >
                                                    Clear
                                                </Button>
                                                <Button
                                                    size="sm"
                                                    onClick={async () => {
                                                        const selectedClips = filteredClips.filter(c => selectedClipIds.has(c.id));
                                                        if (selectedClips.length === 0) return;

                                                        // Create array of all selected clip ranges
                                                        const ranges = selectedClips.map(c => ({ start: c.startTime, end: c.endTime }));

                                                        // Sort and merge overlapping ranges
                                                        ranges.sort((a, b) => a.start - b.start);
                                                        const merged = [ranges[0]];
                                                        for (let i = 1; i < ranges.length; i++) {
                                                            const last = merged[merged.length - 1];
                                                            if (ranges[i].start <= last.end) {
                                                                last.end = Math.max(last.end, ranges[i].end);
                                                            } else {
                                                                merged.push(ranges[i]);
                                                            }
                                                        }

                                                        // Run analysis on the first merged range (or all if you want)
                                                        await onRunClipAnalysis(merged[0].start, merged[merged.length - 1].end);
                                                        setSelectedClipIds(new Set());
                                                    }}
                                                >
                                                    <Sparkles className="w-4 h-4 mr-1.5" />
                                                    Analyze Selected
                                                </Button>
                                            </div>
                                        </div>
                                    )}

                                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 max-h-[500px] overflow-y-auto pr-2">
                                        {filteredClips.map((event) => {
                                            const isSelected = selectedClipIds.has(event.id);
                                            return (
                                                <div
                                                    key={event.id}
                                                    className={`group relative border rounded-lg overflow-hidden bg-card hover:shadow-lg transition-all duration-200 ${activeClip?.id === event.id ? 'ring-2 ring-primary' : ''
                                                        } ${isSelected ? 'ring-2 ring-blue-500' : ''
                                                        }`}
                                                >
                                                    {/* Thumbnail area with gradient overlay */}
                                                    <div className="relative h-32 bg-gradient-to-br from-muted/50 to-muted flex items-center justify-center overflow-hidden">
                                                        {/* Selection Checkbox */}
                                                        {onRunClipAnalysis && hasVideo && (
                                                            <div className="absolute top-2 left-2 z-10">
                                                                <Button
                                                                    variant="ghost"
                                                                    size="icon"
                                                                    className="w-6 h-6 rounded bg-white/90 hover:bg-white p-0"
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        setSelectedClipIds(prev => {
                                                                            const newSet = new Set(prev);
                                                                            if (newSet.has(event.id)) {
                                                                                newSet.delete(event.id);
                                                                            } else {
                                                                                newSet.add(event.id);
                                                                            }
                                                                            return newSet;
                                                                        });
                                                                    }}
                                                                >
                                                                    {isSelected ? (
                                                                        <CheckSquare className="w-4 h-4 text-blue-600" />
                                                                    ) : (
                                                                        <Square className="w-4 h-4 text-gray-600" />
                                                                    )}
                                                                </Button>
                                                            </div>
                                                        )}

                                                        {/* Team color accent bar */}
                                                        <div className={`absolute top-0 left-0 right-0 h-1 ${event.team === 'TEAM_A' ? 'bg-primary' : event.team === 'TEAM_B' ? 'bg-destructive' : 'bg-gray-400'}`} />

                                                        {/* Play overlay */}
                                                        <div className="absolute inset-0 bg-black/20 group-hover:bg-black/40 transition-colors flex items-center justify-center">
                                                            <Button
                                                                variant="ghost"
                                                                size="icon"
                                                                className="w-12 h-12 rounded-full bg-white/90 hover:bg-white hover:scale-110 transition-all flex items-center justify-center shadow-lg"
                                                                onClick={() => {
                                                                    if (hasVideo) {
                                                                        setActiveClip(event);
                                                                        setClipSeekTime(event.startTime);
                                                                        setIsClipPlaying(true);
                                                                    } else if (onJumpToTime) {
                                                                        onJumpToTime(event.startTime);
                                                                    }
                                                                }}
                                                            >
                                                                <Play className="w-6 h-6 text-gray-900 ml-0.5" />
                                                            </Button>
                                                        </div>

                                                        {/* Duration badge */}
                                                        <div className="absolute bottom-2 right-2 px-2 py-0.5 rounded bg-black/70 text-white text-xs font-mono">
                                                            {formatDuration(event.endTime - event.startTime)}
                                                        </div>

                                                        {/* Type badge */}
                                                        <div className="absolute top-3 left-3 px-2 py-1 rounded-md bg-black/70 text-white text-[10px] font-semibold uppercase tracking-wide">
                                                            {event.type.replace('_', ' ')}
                                                        </div>
                                                    </div>

                                                    {/* Content area */}
                                                    <div className="p-3 space-y-2">
                                                        {/* Title and team */}
                                                        <div className="flex items-start justify-between gap-2">
                                                            <div className="flex-1 min-w-0">
                                                                <h4 className="font-semibold text-sm truncate">{event.name}</h4>
                                                                <p className="text-xs text-muted-foreground line-clamp-2 mt-0.5">
                                                                    {event.description}
                                                                </p>
                                                            </div>
                                                            <div className={`w-3 h-3 rounded-full flex-shrink-0 mt-1 ${event.team === 'TEAM_A' ? 'bg-primary' : event.team === 'TEAM_B' ? 'bg-destructive' : 'bg-gray-400'}`} />
                                                        </div>

                                                        {/* Metadata row */}
                                                        <div className="flex items-center justify-between pt-2 border-t">
                                                            <div className="flex items-center gap-1 text-xs text-muted-foreground">
                                                                <Clock className="w-3 h-3" />
                                                                <span className="font-mono">{formatTime(event.startTime)}</span>
                                                            </div>

                                                            <div className="flex gap-1">
                                                                <Button
                                                                    variant={activeClip?.id === event.id ? "default" : "ghost"}
                                                                    size="sm"
                                                                    className="h-7 px-3 text-xs font-medium"
                                                                    disabled={!hasVideo}
                                                                    title={!hasVideo ? "Upload a video first to play clips" : "Play this clip"}
                                                                    onClick={() => {
                                                                        if (hasVideo) {
                                                                            setActiveClip(event);
                                                                            setClipSeekTime(event.startTime);
                                                                            setIsClipPlaying(true);
                                                                        } else if (onJumpToTime) {
                                                                            onJumpToTime(event.startTime);
                                                                        }
                                                                    }}
                                                                >
                                                                    {activeClip?.id === event.id && isClipPlaying ? (
                                                                        <>
                                                                            <div className="w-2 h-2 bg-white rounded-full animate-pulse mr-1.5" />
                                                                            Playing
                                                                        </>
                                                                    ) : (
                                                                        <>
                                                                            <Play className="w-3 h-3 mr-1.5" />
                                                                            Play
                                                                        </>
                                                                    )}
                                                                </Button>
                                                                {onRunClipAnalysis && hasVideo && (
                                                                    <Button
                                                                        variant="outline"
                                                                        size="sm"
                                                                        className="h-7 px-2 text-xs"
                                                                        title="Run AI analysis on this clip only"
                                                                        onClick={() => onRunClipAnalysis(event.startTime, event.endTime)}
                                                                    >
                                                                        <Sparkles className="w-3 h-3" />
                                                                    </Button>
                                                                )}
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </>
                            )}
                        </div>
                    </TabsContent>

                    {/* HEATMAPS TAB */}
                    <TabsContent value="heatmaps" className="mt-4">
                        <PlayerHeatmap videoFile={videoFile} teamNames={teamNames} />
                    </TabsContent>
                </Tabs>
            </CardContent >
        </Card >
    );
};

// --- Sub-components ---

const TeamStatCard = ({ title, teamA, teamB, suffix = "", description, teamNames }: { title: string, teamA: number, teamB: number, suffix?: string, description?: string, teamNames: { teamA: string, teamB: string } }) => (
    <div className="p-4 border rounded-lg bg-card">
        <h3 className="text-sm font-medium text-muted-foreground mb-2 text-center">{title}</h3>
        <div className="flex justify-between items-end">
            <div className="text-center w-1/2 border-r">
                <div className="text-2xl font-bold text-primary">{teamA.toFixed(1)}{suffix}</div>
                <div className="text-xs text-muted-foreground">{teamNames.teamA}</div>
            </div>
            <div className="text-center w-1/2">
                <div className="text-2xl font-bold text-destructive">{teamB.toFixed(1)}{suffix}</div>
                <div className="text-xs text-muted-foreground">{teamNames.teamB}</div>
            </div>
        </div>
        {description && <p className="text-xs text-center mt-2 text-muted-foreground">{description}</p>}
    </div>
);

const PhaseBar = ({ stats }: { stats: { short: number, medium: number, long: number } }) => {
    const total = stats.short + stats.medium + stats.long || 1;
    return (
        <div className="flex h-4 w-full rounded-full overflow-hidden">
            <div style={{ width: `${(stats.short / total) * 100}%` }} className="bg-red-400" title={`Short: ${stats.short}`} />
            <div style={{ width: `${(stats.medium / total) * 100}%` }} className="bg-yellow-400" title={`Medium: ${stats.medium}`} />
            <div style={{ width: `${(stats.long / total) * 100}%` }} className="bg-green-400" title={`Long: ${stats.long}`} />
        </div>
    );
};

const BuildUpStats = ({ team, stats }: { team: string, stats: { short: number, medium: number, long: number } }) => (
    <div className="space-y-2">
        <h4 className="text-sm font-medium">{team} Build-up</h4>
        <div className="space-y-1 text-sm">
            <div className="flex justify-between"><span>Short (1-3):</span> <span className="font-mono">{stats.short}</span></div>
            <div className="flex justify-between"><span>Medium (4-10):</span> <span className="font-mono">{stats.medium}</span></div>
            <div className="flex justify-between"><span>Long (10+):</span> <span className="font-mono">{stats.long}</span></div>
        </div>
    </div>
);

const TurnoverZones = ({ team, stats }: { team: string, stats: { high: number, mid: number, low: number } }) => (
    <div className="space-y-2">
        <h4 className="text-sm font-medium">{team} Turnovers</h4>
        <div className="space-y-1 text-sm">
            <div className="flex justify-between"><span>High (Zone 3):</span> <span className="font-mono">{stats.high}</span></div>
            <div className="flex justify-between"><span>Mid (Zone 2):</span> <span className="font-mono">{stats.mid}</span></div>
            <div className="flex justify-between"><span>Low (Zone 1):</span> <span className="font-mono">{stats.low}</span></div>
        </div>
    </div>
);

const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
};

const formatDuration = (seconds: number) => {
    const secs = Math.floor(seconds);
    if (secs < 60) {
        return `${secs}s`;
    }
    const mins = Math.floor(secs / 60);
    const remainingSecs = secs % 60;
    return `${mins}:${remainingSecs.toString().padStart(2, '0')}`;
};

const KPICard = ({ title, value, icon, color = "text-primary" }: { title: string, value: number, icon: React.ReactNode, color?: string }) => (
    <div className="p-3 bg-card border rounded-lg shadow-sm">
        <div className="flex items-center justify-between mb-1">
            <span className="text-xs text-muted-foreground font-medium">{title}</span>
            <span className={`${color} opacity-80`}>{icon}</span>
        </div>
        <div className="flex items-end gap-2">
            <span className={`text-xl font-bold ${color}`}>{value.toFixed(0)}</span>
            <div className="h-1.5 flex-1 bg-muted rounded-full mb-1.5 overflow-hidden">
                <div className={`h-full ${color === "text-primary" ? "bg-primary" : "bg-destructive"}`} style={{ width: `${value}%` }} />
            </div>
        </div>
    </div>
);
</file>

<file path="src/components/TeamGrid.tsx">
import { Card } from "@/components/ui/card";
import { Users } from "lucide-react";

interface TeamGridProps {
  teams: string[];
  selectedTeam?: string;
  onSelectTeam: (teamName: string) => void;
}

export const TeamGrid = ({ teams, selectedTeam, onSelectTeam }: TeamGridProps) => {
  if (teams.length === 0) {
    return (
      <div className="text-center p-8 text-muted-foreground">
        No teams available. Please upload a team roster.
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-semibold text-foreground">Select a Team</h2>
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
        {teams.map((teamName) => (
          <Card
            key={teamName}
            className={`p-6 cursor-pointer transition-colors flex items-center gap-4 group border-2 ${selectedTeam === teamName ? 'border-primary bg-primary/5' : 'border-border hover:border-primary/50'}`}
            onClick={() => onSelectTeam(teamName)}
          >
            <div className="p-3 rounded-full bg-primary/10 group-hover:bg-primary/20 transition-colors">
              <Users className="w-6 h-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold text-lg">{teamName}</h3>
              <p className="text-sm text-muted-foreground">Click to view roster</p>
            </div>
          </Card>
        ))}
      </div>
    </div>
  );
};
</file>

<file path="src/components/TrackingModeSelector.tsx">
import React from 'react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';

export type TrackingMode = 'LIVE' | 'POST_MATCH';

interface TrackingModeSelectorProps {
    mode: TrackingMode;
    onModeChange: (mode: TrackingMode) => void;
    disabled?: boolean;
}

export const TrackingModeSelector: React.FC<TrackingModeSelectorProps> = ({
    mode,
    onModeChange,
    disabled = false
}) => {
    return (
        <div className="bg-card border border-border rounded-lg p-4 shadow-lg">
            <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-bold text-foreground">Mode de Tracking</h3>
                <Badge variant={mode === 'LIVE' ? 'default' : 'secondary'}>
                    {mode === 'LIVE' ? 'üü¢ LIVE' : 'üìä POST-MATCH'}
                </Badge>
            </div>

            <div className="grid grid-cols-2 gap-3">
                {/* LIVE Mode */}
                <Button
                    variant={mode === 'LIVE' ? 'default' : 'outline'}
                    onClick={() => onModeChange('LIVE')}
                    disabled={disabled}
                    className={`h-auto flex-col items-start p-4 ${mode === 'LIVE' ? 'ring-2 ring-primary' : ''
                        }`}
                >
                    <div className="flex items-center gap-2 mb-2">
                        <span className="text-2xl">üéÆ</span>
                        <span className="font-bold text-base">LIVE</span>
                    </div>
                    <div className="text-xs text-left space-y-1 opacity-90">
                        <div className="flex items-center gap-1">
                            <span className="text-green-500">‚úì</span>
                            <span>Tagging temps r√©el</span>
                        </div>
                        <div className="flex items-center gap-1">
                            <span className="text-green-500">‚úì</span>
                            <span>Stats simples</span>
                        </div>
                        <div className="flex items-center gap-1">
                            <span className="text-green-500">‚úì</span>
                            <span>Grille 18 zones</span>
                        </div>
                        <div className="flex items-center gap-1">
                            <span className="text-red-500">‚úó</span>
                            <span>Tracking XY</span>
                        </div>
                        <div className="flex items-center gap-1">
                            <span className="text-red-500">‚úó</span>
                            <span>M√©triques avanc√©es</span>
                        </div>
                    </div>
                </Button>

                {/* POST-MATCH Mode */}
                <Button
                    variant={mode === 'POST_MATCH' ? 'default' : 'outline'}
                    onClick={() => onModeChange('POST_MATCH')}
                    disabled={disabled}
                    className={`h-auto flex-col items-start p-4 ${mode === 'POST_MATCH' ? 'ring-2 ring-primary' : ''
                        }`}
                >
                    <div className="flex items-center gap-2 mb-2">
                        <span className="text-2xl">üìä</span>
                        <span className="font-bold text-base">POST-MATCH</span>
                        <Badge variant="secondary" className="text-[10px] px-1 py-0">BETA</Badge>
                    </div>
                    <div className="text-xs text-left space-y-1 opacity-90">
                        <div className="flex items-center gap-1">
                            <span className="text-green-500">‚úì</span>
                            <span>Tracking automatique</span>
                        </div>
                        <div className="flex items-center gap-1">
                            <span className="text-green-500">‚úì</span>
                            <span>Positions XY pr√©cises</span>
                        </div>
                        <div className="flex items-center gap-1">
                            <span className="text-green-500">‚úì</span>
                            <span>xG, xThreat, VAEP</span>
                        </div>
                        <div className="flex items-center gap-1">
                            <span className="text-green-500">‚úì</span>
                            <span>Heatmaps auto</span>
                        </div>
                        <div className="flex items-center gap-1">
                            <span className="text-green-500">‚úì</span>
                            <span>Export complet</span>
                        </div>
                    </div>
                </Button>
            </div>

            {/* Mode Description */}
            <div className="mt-4 p-3 bg-muted rounded-md">
                <p className="text-xs text-muted-foreground">
                    {mode === 'LIVE' ? (
                        <>
                            <strong>Mode LIVE :</strong> Tagging manuel en temps r√©el pendant le match.
                            Id√©al pour le coaching en direct et les d√©cisions tactiques imm√©diates.
                        </>
                    ) : (
                        <>
                            <strong>Mode POST-MATCH :</strong> Analyse vid√©o compl√®te avec tracking automatique.
                            G√©n√®re des m√©triques avanc√©es (xG, xThreat, VAEP) et des heatmaps d√©taill√©es.
                        </>
                    )}
                </p>
            </div>
        </div>
    );
};
</file>

<file path="src/components/ui/accordion.tsx">
import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item ref={ref} className={cn("border-b", className)} {...props} />
));
AccordionItem.displayName = "AccordionItem";

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };
</file>

<file path="src/components/ui/alert-dialog.tsx">
import * as React from "react";
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...props} />
);
AlertDialogHeader.displayName = "AlertDialogHeader";

const AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
);
AlertDialogFooter.displayName = "AlertDialogFooter";

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title ref={ref} className={cn("text-lg font-semibold", className)} {...props} />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
AlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(buttonVariants({ variant: "outline" }), "mt-2 sm:mt-0", className)}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div ref={ref} role="alert" className={cn(alertVariants({ variant }), className)} {...props} />
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h5 ref={ref} className={cn("mb-1 font-medium leading-none tracking-tight", className)} {...props} />
  ),
);
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("text-sm [&_p]:leading-relaxed", className)} {...props} />
  ),
);
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };
</file>

<file path="src/components/ui/aspect-ratio.tsx">
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio";

const AspectRatio = AspectRatioPrimitive.Root;

export { AspectRatio };
</file>

<file path="src/components/ui/avatar.tsx">
import * as React from "react";
import * as AvatarPrimitive from "@radix-ui/react-avatar";

import { cn } from "@/lib/utils";

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn("relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full", className)}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image ref={ref} className={cn("aspect-square h-full w-full", className)} {...props} />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn("flex h-full w-full items-center justify-center rounded-full bg-muted", className)}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarImage, AvatarFallback };
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />;
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/breadcrumb.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { ChevronRight, MoreHorizontal } from "lucide-react";

import { cn } from "@/lib/utils";

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode;
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />);
Breadcrumb.displayName = "Breadcrumb";

const BreadcrumbList = React.forwardRef<HTMLOListElement, React.ComponentPropsWithoutRef<"ol">>(
  ({ className, ...props }, ref) => (
    <ol
      ref={ref}
      className={cn(
        "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
        className,
      )}
      {...props}
    />
  ),
);
BreadcrumbList.displayName = "BreadcrumbList";

const BreadcrumbItem = React.forwardRef<HTMLLIElement, React.ComponentPropsWithoutRef<"li">>(
  ({ className, ...props }, ref) => (
    <li ref={ref} className={cn("inline-flex items-center gap-1.5", className)} {...props} />
  ),
);
BreadcrumbItem.displayName = "BreadcrumbItem";

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean;
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a";

  return <Comp ref={ref} className={cn("transition-colors hover:text-foreground", className)} {...props} />;
});
BreadcrumbLink.displayName = "BreadcrumbLink";

const BreadcrumbPage = React.forwardRef<HTMLSpanElement, React.ComponentPropsWithoutRef<"span">>(
  ({ className, ...props }, ref) => (
    <span
      ref={ref}
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("font-normal text-foreground", className)}
      {...props}
    />
  ),
);
BreadcrumbPage.displayName = "BreadcrumbPage";

const BreadcrumbSeparator = ({ children, className, ...props }: React.ComponentProps<"li">) => (
  <li role="presentation" aria-hidden="true" className={cn("[&>svg]:size-3.5", className)} {...props}>
    {children ?? <ChevronRight />}
  </li>
);
BreadcrumbSeparator.displayName = "BreadcrumbSeparator";

const BreadcrumbEllipsis = ({ className, ...props }: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
);
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis";

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />;
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="src/components/ui/calendar.tsx">
import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({ className, classNames, showOutsideDays = true, ...props }: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(buttonVariants({ variant: "ghost" }), "h-9 w-9 p-0 font-normal aria-selected:opacity-100"),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ..._props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ..._props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("rounded-lg flex flex-col justify-between border bg-card text-card-foreground shadow-sm", className)} {...props} />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex flex-col space-y-1.5 p-6", className)} {...props} />
  ),
);
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h3 ref={ref} className={cn("text-2xl font-semibold leading-none tracking-tight", className)} {...props} />
  ),
);
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
  ),
);
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />,
);
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex items-center p-6 pt-0", className)} {...props} />
  ),
);
CardFooter.displayName = "CardFooter";

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };
</file>

<file path="src/components/ui/carousel.tsx">
import * as React from "react";
import useEmblaCarousel, { type UseEmblaCarouselType } from "embla-carousel-react";
import { ArrowLeft, ArrowRight } from "lucide-react";

import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: "horizontal" | "vertical";
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />");
  }

  return context;
}

const Carousel = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement> & CarouselProps>(
  ({ orientation = "horizontal", opts, setApi, plugins, className, children, ...props }, ref) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins,
    );
    const [canScrollPrev, setCanScrollPrev] = React.useState(false);
    const [canScrollNext, setCanScrollNext] = React.useState(false);

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return;
      }

      setCanScrollPrev(api.canScrollPrev());
      setCanScrollNext(api.canScrollNext());
    }, []);

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev();
    }, [api]);

    const scrollNext = React.useCallback(() => {
      api?.scrollNext();
    }, [api]);

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext],
    );

    React.useEffect(() => {
      if (!api || !setApi) {
        return;
      }

      setApi(api);
    }, [api, setApi]);

    React.useEffect(() => {
      if (!api) {
        return;
      }

      onSelect(api);
      api.on("reInit", onSelect);
      api.on("select", onSelect);

      return () => {
        api?.off("select", onSelect);
      };
    }, [api, onSelect]);

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation: orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    );
  },
);
Carousel.displayName = "Carousel";

const CarouselContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const { carouselRef, orientation } = useCarousel();

    return (
      <div ref={carouselRef} className="overflow-hidden">
        <div
          ref={ref}
          className={cn("flex", orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col", className)}
          {...props}
        />
      </div>
    );
  },
);
CarouselContent.displayName = "CarouselContent";

const CarouselItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const { orientation } = useCarousel();

    return (
      <div
        ref={ref}
        role="group"
        aria-roledescription="slide"
        className={cn("min-w-0 shrink-0 grow-0 basis-full", orientation === "horizontal" ? "pl-4" : "pt-4", className)}
        {...props}
      />
    );
  },
);
CarouselItem.displayName = "CarouselItem";

const CarouselPrevious = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
  ({ className, variant = "outline", size = "icon", ...props }, ref) => {
    const { orientation, scrollPrev, canScrollPrev } = useCarousel();

    return (
      <Button
        ref={ref}
        variant={variant}
        size={size}
        className={cn(
          "absolute h-8 w-8 rounded-full",
          orientation === "horizontal"
            ? "-left-12 top-1/2 -translate-y-1/2"
            : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
          className,
        )}
        disabled={!canScrollPrev}
        onClick={scrollPrev}
        {...props}
      >
        <ArrowLeft className="h-4 w-4" />
        <span className="sr-only">Previous slide</span>
      </Button>
    );
  },
);
CarouselPrevious.displayName = "CarouselPrevious";

const CarouselNext = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
  ({ className, variant = "outline", size = "icon", ...props }, ref) => {
    const { orientation, scrollNext, canScrollNext } = useCarousel();

    return (
      <Button
        ref={ref}
        variant={variant}
        size={size}
        className={cn(
          "absolute h-8 w-8 rounded-full",
          orientation === "horizontal"
            ? "-right-12 top-1/2 -translate-y-1/2"
            : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
          className,
        )}
        disabled={!canScrollNext}
        onClick={scrollNext}
        {...props}
      >
        <ArrowRight className="h-4 w-4" />
        <span className="sr-only">Next slide</span>
      </Button>
    );
  },
);
CarouselNext.displayName = "CarouselNext";

export { type CarouselApi, Carousel, CarouselContent, CarouselItem, CarouselPrevious, CarouselNext };
</file>

<file path="src/components/ui/chart.tsx">
import * as React from "react";
import * as RechartsPrimitive from "recharts";

import { cn } from "@/lib/utils";

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const;

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode;
    icon?: React.ComponentType;
  } & ({ color?: string; theme?: never } | { color?: never; theme: Record<keyof typeof THEMES, string> });
};

type ChartContextProps = {
  config: ChartConfig;
};

const ChartContext = React.createContext<ChartContextProps | null>(null);

function useChart() {
  const context = React.useContext(ChartContext);

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />");
  }

  return context;
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig;
    children: React.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>["children"];
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId();
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`;

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className,
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
});
ChartContainer.displayName = "Chart";

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(([_, config]) => config.theme || config.color);

  if (!colorConfig.length) {
    return null;
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color = itemConfig.theme?.[theme as keyof typeof itemConfig.theme] || itemConfig.color;
    return color ? `  --color-${key}: ${color};` : null;
  })
  .join("\n")}
}
`,
          )
          .join("\n"),
      }}
    />
  );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean;
      hideIndicator?: boolean;
      indicator?: "line" | "dot" | "dashed";
      nameKey?: string;
      labelKey?: string;
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref,
  ) => {
    const { config } = useChart();

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null;
      }

      const [item] = payload;
      const key = `${labelKey || item.dataKey || item.name || "value"}`;
      const itemConfig = getPayloadConfigFromPayload(config, item, key);
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label;

      if (labelFormatter) {
        return <div className={cn("font-medium", labelClassName)}>{labelFormatter(value, payload)}</div>;
      }

      if (!value) {
        return null;
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>;
    }, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey]);

    if (!active || !payload?.length) {
      return null;
    }

    const nestLabel = payload.length === 1 && indicator !== "dot";

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className,
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`;
            const itemConfig = getPayloadConfigFromPayload(config, item, key);
            const indicatorColor = color || item.payload.fill || item.color;

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center",
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn("shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]", {
                            "h-2.5 w-2.5": indicator === "dot",
                            "w-1": indicator === "line",
                            "w-0 border-[1.5px] border-dashed bg-transparent": indicator === "dashed",
                            "my-0.5": nestLabel && indicator === "dashed",
                          })}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center",
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">{itemConfig?.label || item.name}</span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            );
          })}
        </div>
      </div>
    );
  },
);
ChartTooltipContent.displayName = "ChartTooltip";

const ChartLegend = RechartsPrimitive.Legend;

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean;
      nameKey?: string;
    }
>(({ className, hideIcon = false, payload, verticalAlign = "bottom", nameKey }, ref) => {
  const { config } = useChart();

  if (!payload?.length) {
    return null;
  }

  return (
    <div
      ref={ref}
      className={cn("flex items-center justify-center gap-4", verticalAlign === "top" ? "pb-3" : "pt-3", className)}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`;
        const itemConfig = getPayloadConfigFromPayload(config, item, key);

        return (
          <div
            key={item.value}
            className={cn("flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground")}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        );
      })}
    </div>
  );
});
ChartLegendContent.displayName = "ChartLegend";

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(config: ChartConfig, payload: unknown, key: string) {
  if (typeof payload !== "object" || payload === null) {
    return undefined;
  }

  const payloadPayload =
    "payload" in payload && typeof payload.payload === "object" && payload.payload !== null
      ? payload.payload
      : undefined;

  let configLabelKey: string = key;

  if (key in payload && typeof payload[key as keyof typeof payload] === "string") {
    configLabelKey = payload[key as keyof typeof payload] as string;
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[key as keyof typeof payloadPayload] as string;
  }

  return configLabelKey in config ? config[configLabelKey] : config[key as keyof typeof config];
}

export { ChartContainer, ChartTooltip, ChartTooltipContent, ChartLegend, ChartLegendContent, ChartStyle };
</file>

<file path="src/components/ui/checkbox.tsx">
import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className={cn("flex items-center justify-center text-current")}>
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="src/components/ui/collapsible.tsx">
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleTrigger, CollapsibleContent };
</file>

<file path="src/components/ui/command.tsx">
import * as React from "react";
import { type DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { Search } from "lucide-react";

import { cn } from "@/lib/utils";
import { Dialog, DialogContent } from "@/components/ui/dialog";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className,
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => <CommandPrimitive.Empty ref={ref} className="py-6 text-center text-sm" {...props} />);

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className,
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator ref={ref} className={cn("-mx-1 h-px bg-border", className)} {...props} />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className,
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)} {...props} />;
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};
</file>

<file path="src/components/ui/context-menu.tsx">
import * as React from "react";
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[state=open]:bg-accent data-[state=open]:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName = ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold text-foreground", inset && "pl-8", className)}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-border", className)} {...props} />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)} {...props} />;
};
ContextMenuShortcut.displayName = "ContextMenuShortcut";

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};
</file>

<file path="src/components/ui/dialog.tsx">
import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-accent data-[state=open]:text-muted-foreground hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)} {...props} />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};
</file>

<file path="src/components/ui/drawer.tsx">
import * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";

import { cn } from "@/lib/utils";

const Drawer = ({ shouldScaleBackground = true, ...props }: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root shouldScaleBackground={shouldScaleBackground} {...props} />
);
Drawer.displayName = "Drawer";

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay ref={ref} className={cn("fixed inset-0 z-50 bg-black/80", className)} {...props} />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className,
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
));
DrawerContent.displayName = "DrawerContent";

const DrawerHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)} {...props} />
);
DrawerHeader.displayName = "DrawerHeader";

const DrawerFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("mt-auto flex flex-col gap-2 p-4", className)} {...props} />
);
DrawerFooter.displayName = "DrawerFooter";

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
};
</file>

<file path="src/components/ui/dropdown-menu.tsx">
import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[state=open]:bg-accent focus:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest opacity-60", className)} {...props} />;
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="src/components/ui/form.tsx">
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import { Controller, ControllerProps, FieldPath, FieldValues, FormProvider, useFormContext } from "react-hook-form";

import { cn } from "@/lib/utils";
import { Label } from "@/components/ui/label";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>({} as FormFieldContextValue);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>({} as FormItemContextValue);

const FormItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const id = React.useId();

    return (
      <FormItemContext.Provider value={{ id }}>
        <div ref={ref} className={cn("space-y-2", className)} {...props} />
      </FormItemContext.Provider>
    );
  },
);
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return <Label ref={ref} className={cn(error && "text-destructive", className)} htmlFor={formItemId} {...props} />;
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<React.ElementRef<typeof Slot>, React.ComponentPropsWithoutRef<typeof Slot>>(
  ({ ...props }, ref) => {
    const { error, formItemId, formDescriptionId, formMessageId } = useFormField();

    return (
      <Slot
        ref={ref}
        id={formItemId}
        aria-describedby={!error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`}
        aria-invalid={!!error}
        {...props}
      />
    );
  },
);
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => {
    const { formDescriptionId } = useFormField();

    return <p ref={ref} id={formDescriptionId} className={cn("text-sm text-muted-foreground", className)} {...props} />;
  },
);
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, children, ...props }, ref) => {
    const { error, formMessageId } = useFormField();
    const body = error ? String(error?.message) : children;

    if (!body) {
      return null;
    }

    return (
      <p ref={ref} id={formMessageId} className={cn("text-sm font-medium text-destructive", className)} {...props}>
        {body}
      </p>
    );
  },
);
FormMessage.displayName = "FormMessage";

export { useFormField, Form, FormItem, FormLabel, FormControl, FormDescription, FormMessage, FormField };
</file>

<file path="src/components/ui/hover-card.tsx">
import * as React from "react";
import * as HoverCardPrimitive from "@radix-ui/react-hover-card";

import { cn } from "@/lib/utils";

const HoverCard = HoverCardPrimitive.Root;

const HoverCardTrigger = HoverCardPrimitive.Trigger;

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName;

export { HoverCard, HoverCardTrigger, HoverCardContent };
</file>

<file path="src/components/ui/input-otp.tsx">
import * as React from "react";
import { OTPInput, OTPInputContext } from "input-otp";
import { Dot } from "lucide-react";

import { cn } from "@/lib/utils";

const InputOTP = React.forwardRef<React.ElementRef<typeof OTPInput>, React.ComponentPropsWithoutRef<typeof OTPInput>>(
  ({ className, containerClassName, ...props }, ref) => (
    <OTPInput
      ref={ref}
      containerClassName={cn("flex items-center gap-2 has-[:disabled]:opacity-50", containerClassName)}
      className={cn("disabled:cursor-not-allowed", className)}
      {...props}
    />
  ),
);
InputOTP.displayName = "InputOTP";

const InputOTPGroup = React.forwardRef<React.ElementRef<"div">, React.ComponentPropsWithoutRef<"div">>(
  ({ className, ...props }, ref) => <div ref={ref} className={cn("flex items-center", className)} {...props} />,
);
InputOTPGroup.displayName = "InputOTPGroup";

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext);
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index];

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className,
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink h-4 w-px bg-foreground duration-1000" />
        </div>
      )}
    </div>
  );
});
InputOTPSlot.displayName = "InputOTPSlot";

const InputOTPSeparator = React.forwardRef<React.ElementRef<"div">, React.ComponentPropsWithoutRef<"div">>(
  ({ ...props }, ref) => (
    <div ref={ref} role="separator" {...props}>
      <Dot />
    </div>
  ),
);
InputOTPSeparator.displayName = "InputOTPSeparator";

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator };
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="src/components/ui/label.tsx">
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70");

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="src/components/ui/menubar.tsx">
import * as React from "react";
import * as MenubarPrimitive from "@radix-ui/react-menubar";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const MenubarMenu = MenubarPrimitive.Menu;

const MenubarGroup = MenubarPrimitive.Group;

const MenubarPortal = MenubarPrimitive.Portal;

const MenubarSub = MenubarPrimitive.Sub;

const MenubarRadioGroup = MenubarPrimitive.RadioGroup;

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn("flex h-10 items-center space-x-1 rounded-md border bg-background p-1", className)}
    {...props}
  />
));
Menubar.displayName = MenubarPrimitive.Root.displayName;

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none data-[state=open]:bg-accent data-[state=open]:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  />
));
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName;

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[state=open]:bg-accent data-[state=open]:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
));
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName;

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName;

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(({ className, align = "start", alignOffset = -4, sideOffset = 8, ...props }, ref) => (
  <MenubarPrimitive.Portal>
    <MenubarPrimitive.Content
      ref={ref}
      align={align}
      alignOffset={alignOffset}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </MenubarPrimitive.Portal>
));
MenubarContent.displayName = MenubarPrimitive.Content.displayName;

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
MenubarItem.displayName = MenubarPrimitive.Item.displayName;

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
));
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName;

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
));
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName;

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
));
MenubarLabel.displayName = MenubarPrimitive.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
));
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName;

const MenubarShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)} {...props} />;
};
MenubarShortcut.displayname = "MenubarShortcut";

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
};
</file>

<file path="src/components/ui/navigation-menu.tsx">
import * as React from "react";
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu";
import { cva } from "class-variance-authority";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn("relative z-10 flex max-w-max flex-1 items-center justify-center", className)}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn("group flex flex-1 list-none items-center justify-center space-x-1", className)}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50",
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto",
      className,
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className,
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName = NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className,
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName = NavigationMenuPrimitive.Indicator.displayName;

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
};
</file>

<file path="src/components/ui/pagination.tsx">
import * as React from "react";
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react";

import { cn } from "@/lib/utils";
import { ButtonProps, buttonVariants } from "@/components/ui/button";

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
);
Pagination.displayName = "Pagination";

const PaginationContent = React.forwardRef<HTMLUListElement, React.ComponentProps<"ul">>(
  ({ className, ...props }, ref) => (
    <ul ref={ref} className={cn("flex flex-row items-center gap-1", className)} {...props} />
  ),
);
PaginationContent.displayName = "PaginationContent";

const PaginationItem = React.forwardRef<HTMLLIElement, React.ComponentProps<"li">>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
));
PaginationItem.displayName = "PaginationItem";

type PaginationLinkProps = {
  isActive?: boolean;
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">;

const PaginationLink = ({ className, isActive, size = "icon", ...props }: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className,
    )}
    {...props}
  />
);
PaginationLink.displayName = "PaginationLink";

const PaginationPrevious = ({ className, ...props }: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink aria-label="Go to previous page" size="default" className={cn("gap-1 pl-2.5", className)} {...props}>
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
);
PaginationPrevious.displayName = "PaginationPrevious";

const PaginationNext = ({ className, ...props }: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink aria-label="Go to next page" size="default" className={cn("gap-1 pr-2.5", className)} {...props}>
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
);
PaginationNext.displayName = "PaginationNext";

const PaginationEllipsis = ({ className, ...props }: React.ComponentProps<"span">) => (
  <span aria-hidden className={cn("flex h-9 w-9 items-center justify-center", className)} {...props}>
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
);
PaginationEllipsis.displayName = "PaginationEllipsis";

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
};
</file>

<file path="src/components/ui/popover.tsx">
import * as React from "react";
import * as PopoverPrimitive from "@radix-ui/react-popover";

import { cn } from "@/lib/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };
</file>

<file path="src/components/ui/progress.tsx">
import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn("relative h-4 w-full overflow-hidden rounded-full bg-secondary", className)}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };
</file>

<file path="src/components/ui/radio-group.tsx">
import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return <RadioGroupPrimitive.Root className={cn("grid gap-2", className)} {...props} ref={ref} />;
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };
</file>

<file path="src/components/ui/resizable.tsx">
import { GripVertical } from "lucide-react";
import * as ResizablePrimitive from "react-resizable-panels";

import { cn } from "@/lib/utils";

const ResizablePanelGroup = ({ className, ...props }: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", className)}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className,
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizablePanelGroup, ResizablePanel, ResizableHandle };
</file>

<file path="src/components/ui/scroll-area.tsx">
import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";

import { cn } from "@/lib/utils";

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root ref={ref} className={cn("relative overflow-hidden", className)} {...props}>
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">{children}</ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };
</file>

<file path="src/components/ui/select.tsx">
import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label ref={ref} className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)} {...props} />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="src/components/ui/separator.tsx">
import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

import { cn } from "@/lib/utils";

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(({ className, orientation = "horizontal", decorative = true, ...props }, ref) => (
  <SeparatorPrimitive.Root
    ref={ref}
    decorative={decorative}
    orientation={orientation}
    className={cn("shrink-0 bg-border", orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]", className)}
    {...props}
  />
));
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };
</file>

<file path="src/components/ui/sheet.tsx">
import * as SheetPrimitive from "@radix-ui/react-dialog";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<React.ElementRef<typeof SheetPrimitive.Content>, SheetContentProps>(
  ({ side = "right", className, children, ...props }, ref) => (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content ref={ref} className={cn(sheetVariants({ side }), className)} {...props}>
        {children}
        <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-secondary hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none">
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  ),
);
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...props} />
);
SheetHeader.displayName = "SheetHeader";

const SheetFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
);
SheetFooter.displayName = "SheetFooter";

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title ref={ref} className={cn("text-lg font-semibold text-foreground", className)} {...props} />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetOverlay,
  SheetPortal,
  SheetTitle,
  SheetTrigger,
};
</file>

<file path="src/components/ui/sidebar.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { VariantProps, cva } from "class-variance-authority";
import { PanelLeft } from "lucide-react";

import { useIsMobile } from "@/hooks/use-mobile";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { Sheet, SheetContent } from "@/components/ui/sheet";
import { Skeleton } from "@/components/ui/skeleton";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

const SIDEBAR_COOKIE_NAME = "sidebar:state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContext = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContext | null>(null);

function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean;
    open?: boolean;
    onOpenChange?: (open: boolean) => void;
  }
>(({ defaultOpen = true, open: openProp, onOpenChange: setOpenProp, className, style, children, ...props }, ref) => {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open],
  );

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
  }, [isMobile, setOpen, setOpenMobile]);

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {
        event.preventDefault();
        toggleSidebar();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar]);

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed";

  const contextValue = React.useMemo<SidebarContext>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar],
  );

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn("group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar", className)}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
});
SidebarProvider.displayName = "SidebarProvider";

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right";
    variant?: "sidebar" | "floating" | "inset";
    collapsible?: "offcanvas" | "icon" | "none";
  }
>(({ side = "left", variant = "sidebar", collapsible = "offcanvas", className, children, ...props }, ref) => {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

  if (collapsible === "none") {
    return (
      <div
        className={cn("flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground", className)}
        ref={ref}
        {...props}
      >
        {children}
      </div>
    );
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-mobile="true"
          className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }

  return (
    <div
      ref={ref}
      className="group peer hidden text-sidebar-foreground md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        className={cn(
          "relative h-svh w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
            : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]",
        )}
      />
      <div
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
            : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className,
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
        >
          {children}
        </div>
      </div>
    </div>
  );
});
Sidebar.displayName = "Sidebar";

const SidebarTrigger = React.forwardRef<React.ElementRef<typeof Button>, React.ComponentProps<typeof Button>>(
  ({ className, onClick, ...props }, ref) => {
    const { toggleSidebar } = useSidebar();

    return (
      <Button
        ref={ref}
        data-sidebar="trigger"
        variant="ghost"
        size="icon"
        className={cn("h-7 w-7", className)}
        onClick={(event) => {
          onClick?.(event);
          toggleSidebar();
        }}
        {...props}
      >
        <PanelLeft />
        <span className="sr-only">Toggle Sidebar</span>
      </Button>
    );
  },
);
SidebarTrigger.displayName = "SidebarTrigger";

const SidebarRail = React.forwardRef<HTMLButtonElement, React.ComponentProps<"button">>(
  ({ className, ...props }, ref) => {
    const { toggleSidebar } = useSidebar();

    return (
      <button
        ref={ref}
        data-sidebar="rail"
        aria-label="Toggle Sidebar"
        tabIndex={-1}
        onClick={toggleSidebar}
        title="Toggle Sidebar"
        className={cn(
          "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] group-data-[side=left]:-right-4 group-data-[side=right]:left-0 hover:after:bg-sidebar-border sm:flex",
          "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
          "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
          "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
          "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
          "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarRail.displayName = "SidebarRail";

const SidebarInset = React.forwardRef<HTMLDivElement, React.ComponentProps<"main">>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className,
      )}
      {...props}
    />
  );
});
SidebarInset.displayName = "SidebarInset";

const SidebarInput = React.forwardRef<React.ElementRef<typeof Input>, React.ComponentProps<typeof Input>>(
  ({ className, ...props }, ref) => {
    return (
      <Input
        ref={ref}
        data-sidebar="input"
        className={cn(
          "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarInput.displayName = "SidebarInput";

const SidebarHeader = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return <div ref={ref} data-sidebar="header" className={cn("flex flex-col gap-2 p-2", className)} {...props} />;
});
SidebarHeader.displayName = "SidebarHeader";

const SidebarFooter = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return <div ref={ref} data-sidebar="footer" className={cn("flex flex-col gap-2 p-2", className)} {...props} />;
});
SidebarFooter.displayName = "SidebarFooter";

const SidebarSeparator = React.forwardRef<React.ElementRef<typeof Separator>, React.ComponentProps<typeof Separator>>(
  ({ className, ...props }, ref) => {
    return (
      <Separator
        ref={ref}
        data-sidebar="separator"
        className={cn("mx-2 w-auto bg-sidebar-border", className)}
        {...props}
      />
    );
  },
);
SidebarSeparator.displayName = "SidebarSeparator";

const SidebarContent = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className,
      )}
      {...props}
    />
  );
});
SidebarContent.displayName = "SidebarContent";

const SidebarGroup = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  );
});
SidebarGroup.displayName = "SidebarGroup";

const SidebarGroupLabel = React.forwardRef<HTMLDivElement, React.ComponentProps<"div"> & { asChild?: boolean }>(
  ({ className, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "div";

    return (
      <Comp
        ref={ref}
        data-sidebar="group-label"
        className={cn(
          "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarGroupLabel.displayName = "SidebarGroupLabel";

const SidebarGroupAction = React.forwardRef<HTMLButtonElement, React.ComponentProps<"button"> & { asChild?: boolean }>(
  ({ className, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";

    return (
      <Comp
        ref={ref}
        data-sidebar="group-action"
        className={cn(
          "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          // Increases the hit area of the button on mobile.
          "after:absolute after:-inset-2 after:md:hidden",
          "group-data-[collapsible=icon]:hidden",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarGroupAction.displayName = "SidebarGroupAction";

const SidebarGroupContent = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(
  ({ className, ...props }, ref) => (
    <div ref={ref} data-sidebar="group-content" className={cn("w-full text-sm", className)} {...props} />
  ),
);
SidebarGroupContent.displayName = "SidebarGroupContent";

const SidebarMenu = React.forwardRef<HTMLUListElement, React.ComponentProps<"ul">>(({ className, ...props }, ref) => (
  <ul ref={ref} data-sidebar="menu" className={cn("flex w-full min-w-0 flex-col gap-1", className)} {...props} />
));
SidebarMenu.displayName = "SidebarMenu";

const SidebarMenuItem = React.forwardRef<HTMLLIElement, React.ComponentProps<"li">>(({ className, ...props }, ref) => (
  <li ref={ref} data-sidebar="menu-item" className={cn("group/menu-item relative", className)} {...props} />
));
SidebarMenuItem.displayName = "SidebarMenuItem";

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean;
    isActive?: boolean;
    tooltip?: string | React.ComponentProps<typeof TooltipContent>;
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(({ asChild = false, isActive = false, variant = "default", size = "default", tooltip, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "button";
  const { isMobile, state } = useSidebar();

  const button = (
    <Comp
      ref={ref}
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );

  if (!tooltip) {
    return button;
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    };
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent side="right" align="center" hidden={state !== "collapsed" || isMobile} {...tooltip} />
    </Tooltip>
  );
});
SidebarMenuButton.displayName = "SidebarMenuButton";

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean;
    showOnHover?: boolean;
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform peer-hover/menu-button:text-sidebar-accent-foreground hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className,
      )}
      {...props}
    />
  );
});
SidebarMenuAction.displayName = "SidebarMenuAction";

const SidebarMenuBadge = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      data-sidebar="menu-badge"
      className={cn(
        "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  ),
);
SidebarMenuBadge.displayName = "SidebarMenuBadge";

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean;
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && <Skeleton className="size-4 rounded-md" data-sidebar="menu-skeleton-icon" />}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  );
});
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton";

const SidebarMenuSub = React.forwardRef<HTMLUListElement, React.ComponentProps<"ul">>(
  ({ className, ...props }, ref) => (
    <ul
      ref={ref}
      data-sidebar="menu-sub"
      className={cn(
        "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  ),
);
SidebarMenuSub.displayName = "SidebarMenuSub";

const SidebarMenuSubItem = React.forwardRef<HTMLLIElement, React.ComponentProps<"li">>(({ ...props }, ref) => (
  <li ref={ref} {...props} />
));
SidebarMenuSubItem.displayName = "SidebarMenuSubItem";

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean;
    size?: "sm" | "md";
    isActive?: boolean;
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring aria-disabled:pointer-events-none aria-disabled:opacity-50 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
});
SidebarMenuSubButton.displayName = "SidebarMenuSubButton";

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils";

function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={cn("animate-pulse rounded-md bg-muted", className)} {...props} />;
}

export { Skeleton };
</file>

<file path="src/components/ui/slider.tsx">
import * as React from "react";
import * as SliderPrimitive from "@radix-ui/react-slider";

import { cn } from "@/lib/utils";

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn("relative flex w-full touch-none select-none items-center", className)}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };
</file>

<file path="src/components/ui/sonner.tsx">
import { useTheme } from "next-themes";
import { Toaster as Sonner, toast } from "sonner";

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  );
};

export { Toaster, toast };
</file>

<file path="src/components/ui/switch.tsx">
import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";

import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50",
      className,
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0",
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };
</file>

<file path="src/components/ui/table.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(
  ({ className, ...props }, ref) => (
    <div className="relative w-full overflow-auto">
      <table ref={ref} className={cn("w-full caption-bottom text-sm", className)} {...props} />
    </div>
  ),
);
Table.displayName = "Table";

const TableHeader = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />,
);
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tbody ref={ref} className={cn("[&_tr:last-child]:border-0", className)} {...props} />
  ),
);
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tfoot ref={ref} className={cn("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className)} {...props} />
  ),
);
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>(
  ({ className, ...props }, ref) => (
    <tr
      ref={ref}
      className={cn("border-b transition-colors data-[state=selected]:bg-muted hover:bg-muted/50", className)}
      {...props}
    />
  ),
);
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<HTMLTableCellElement, React.ThHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <th
      ref={ref}
      className={cn(
        "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
        className,
      )}
      {...props}
    />
  ),
);
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<HTMLTableCellElement, React.TdHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <td ref={ref} className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)} {...props} />
  ),
);
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<HTMLTableCaptionElement, React.HTMLAttributes<HTMLTableCaptionElement>>(
  ({ className, ...props }, ref) => (
    <caption ref={ref} className={cn("mt-4 text-sm text-muted-foreground", className)} {...props} />
  ),
);
TableCaption.displayName = "TableCaption";

export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption };
</file>

<file path="src/components/ui/tabs.tsx">
import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = "Textarea";

export { Textarea };
</file>

<file path="src/components/ui/TipbarButton.tsx">
// src/components/ui/TipbarButton.tsx - Compact tipbar button component
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { LucideIcon } from 'lucide-react';
import { cn } from '@/lib/utils';

interface TipbarButtonProps {
    icon: LucideIcon;
    tooltip: string;
    onClick?: () => void;
    active?: boolean;
    variant?: 'default' | 'destructive' | 'outline' | 'secondary';
    disabled?: boolean;
    className?: string;
    badge?: string | number;
    animate?: boolean;
}

export function TipbarButton({
    icon: Icon,
    tooltip,
    onClick,
    active = false,
    variant = 'outline',
    disabled = false,
    className,
    badge,
    animate = false,
}: TipbarButtonProps) {
    return (
        <TooltipProvider delayDuration={300}>
            <Tooltip>
                <TooltipTrigger asChild>
                    <Button
                        variant={active ? 'default' : variant}
                        size="sm"
                        onClick={onClick}
                        disabled={disabled}
                        className={cn(
                            'h-8 w-8 p-0 relative transition-all hover:scale-105',
                            active && 'ring-2 ring-primary ring-offset-2',
                            className
                        )}
                    >
                        <Icon className={cn('h-4 w-4', animate && 'animate-pulse')} />
                        {badge !== undefined && (
                            <span className="absolute -top-1 -right-1 h-4 w-4 rounded-full bg-primary text-[10px] font-bold flex items-center justify-center text-primary-foreground">
                                {badge}
                            </span>
                        )}
                    </Button>
                </TooltipTrigger>
                <TooltipContent side="bottom" className="text-xs">
                    <p>{tooltip}</p>
                </TooltipContent>
            </Tooltip>
        </TooltipProvider>
    );
}
</file>

<file path="src/components/ui/TipbarGroup.tsx">
// src/components/ui/TipbarGroup.tsx - Container for grouped tipbar buttons
import { cn } from '@/lib/utils';
import { ReactNode } from 'react';

interface TipbarGroupProps {
    children: ReactNode;
    label?: string;
    className?: string;
}

export function TipbarGroup({ children, label, className }: TipbarGroupProps) {
    return (
        <div className={cn('flex items-center gap-1', className)}>
            {label && (
                <span className="text-[10px] text-muted-foreground uppercase tracking-wider mr-1 hidden lg:inline">
                    {label}
                </span>
            )}
            <div className="flex items-center gap-1 px-2 py-1 rounded-md bg-muted/30 border border-border/50">
                {children}
            </div>
        </div>
    );
}

interface TipbarSeparatorProps {
    className?: string;
}

export function TipbarSeparator({ className }: TipbarSeparatorProps) {
    return <div className={cn('h-4 w-px bg-border', className)} />;
}
</file>

<file path="src/components/ui/toast.tsx">
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return <ToastPrimitives.Root ref={ref} className={cn(toastVariants({ variant }), className)} {...props} />;
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50",
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title ref={ref} className={cn("text-sm font-semibold", className)} {...props} />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description ref={ref} className={cn("text-sm opacity-90", className)} {...props} />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};
</file>

<file path="src/components/ui/toaster.tsx">
import { useToast } from "@/hooks/use-toast";
import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from "@/components/ui/toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && <ToastDescription>{description}</ToastDescription>}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}
</file>

<file path="src/components/ui/toggle-group.tsx">
import * as React from "react";
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group";
import { type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";
import { toggleVariants } from "@/components/ui/toggle";

const ToggleGroupContext = React.createContext<VariantProps<typeof toggleVariants>>({
  size: "default",
  variant: "default",
});

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> & VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root ref={ref} className={cn("flex items-center justify-center gap-1", className)} {...props}>
    <ToggleGroupContext.Provider value={{ variant, size }}>{children}</ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
));

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName;

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> & VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className,
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
});

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName;

export { ToggleGroup, ToggleGroupItem };
</file>

<file path="src/components/ui/toggle.tsx">
import * as React from "react";
import * as TogglePrimitive from "@radix-ui/react-toggle";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> & VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root ref={ref} className={cn(toggleVariants({ variant, size, className }))} {...props} />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };
</file>

<file path="src/components/ui/tooltip.tsx">
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
</file>

<file path="src/components/ui/use-toast.ts">
import { useToast, toast } from "@/hooks/use-toast";

export { useToast, toast };
</file>

<file path="src/components/ValidationSuite.tsx">
import React, { useState, useMemo } from 'react';
import { LoggedEvent } from '@/hooks/useGamepad';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/hooks/use-toast';
import { ANALYSIS_API_URL, API_BASE_URL, API_HEADERS } from '@/utils/apiConfig';
import {
    CheckCircle2,
    AlertCircle,
    History,
    Edit3,
    CheckCircle,
    XSquare,
    Filter,
    Search,
    ArrowRight,
    ShieldCheck,
    AlertTriangle,
    ExternalLink,
    ChevronRight,
    Users,
    Loader2,
    CheckSquare,
    Activity,
    Link2Off,
    Workflow
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { EVENT_DEFINITIONS } from '@/data/eventDefinitions';
import { useEventConfig } from '@/contexts/EventConfigContext';
import { generateEventFilename } from '@/utils/eventNaming';

interface ValidationSuiteProps {
    events: LoggedEvent[];
    availablePlayers?: { id: number; name: string }[];
    videoFile: File | null;
    matchName: string;
    onUpdateEvent: (updatedEvent: LoggedEvent) => void;
    onAddEvent: (newEvent: LoggedEvent) => void;
    onSeekToEvent: (time: number) => void;
}

export const ValidationSuite: React.FC<ValidationSuiteProps> = ({
    events,
    availablePlayers = [],
    videoFile,
    matchName,
    onUpdateEvent,
    onAddEvent,
    onSeekToEvent
}) => {
    const { toast } = useToast();
    const [selectedEventId, setSelectedEventId] = useState<number | null>(null);
    const [filter, setFilter] = useState<'all' | 'pending' | 'validated' | 'incomplete'>('all');
    const [searchQuery, setSearchQuery] = useState('');
    const [sendingClipId, setSendingClipId] = useState<number | null>(null);
    const { events: eventsConfig } = useEventConfig();
    const availableEvents = eventsConfig.length > 0 ? eventsConfig : EVENT_DEFINITIONS;

    // Color mapping for event types
    const getEventColor = (eventName: string) => {
        const name = eventName.toLowerCase();
        if (name.includes('goal')) return 'bg-green-500/20 text-green-600 border-green-500/30';
        if (name.includes('pass')) return 'bg-blue-500/20 text-blue-600 border-blue-500/30';
        if (name.includes('foul') || name.includes('card')) return 'bg-red-500/20 text-red-600 border-red-500/30';
        if (name.includes('offside')) return 'bg-orange-500/20 text-orange-600 border-orange-500/30';
        if (name.includes('defense') || name.includes('press')) return 'bg-purple-500/20 text-purple-600 border-purple-500/30';
        return 'bg-muted text-muted-foreground border-border';
    };

    const stats = useMemo(() => {
        const total = events.length;
        const validated = events.filter(e => e.isValidated).length;
        const missingPlayer = events.filter(e => !e.player).length;
        const lowQuality = events.filter(e => e.qualityRating && e.qualityRating < 2).length;

        // Calculate orphaned passes
        const orphanedPasses = events.filter((e, idx) => {
            if (e.eventName !== 'pass_start') return false;
            // Events AFTER in time are at indices 0 to idx-1 (nearest is idx-1)
            const nextEvent = events.slice(0, idx).reverse().find(next =>
                ['pass_end', 'pass_start', 'turnover'].includes(next.eventName)
            );
            return !nextEvent || nextEvent.eventName !== 'pass_end';
        }).length;

        return { total, validated, missingPlayer, lowQuality, orphanedPasses };
    }, [events]);

    const filteredEvents = useMemo(() => {
        return events.filter(e => {
            const isOrphaned = e.eventName === 'pass_start' && (() => {
                const idx = events.findIndex(event => event.id === e.id);
                const nextEvent = events.slice(0, idx).reverse().find(next =>
                    ['pass_end', 'pass_start', 'turnover'].includes(next.eventName)
                );
                return !nextEvent || nextEvent.eventName !== 'pass_end';
            })();

            const matchesFilter = filter === 'all' ||
                (filter === 'pending' && !e.isValidated) ||
                (filter === 'validated' && e.isValidated) ||
                (filter === 'incomplete' && isOrphaned);
            const matchesSearch = (e.eventName || '').toLowerCase().includes(searchQuery.toLowerCase()) ||
                (e.player?.name || '').toLowerCase().includes(searchQuery.toLowerCase());
            return matchesFilter && matchesSearch;
        });
    }, [events, filter, searchQuery]);

    const selectedEvent = events.find(e => e.id === selectedEventId);

    const handleExtractSequence = async (event: LoggedEvent) => {
        if (!videoFile || event.videoTime === undefined) return;

        try {
            toast({ title: "Extracting Clip...", description: `Saving sequence for ${event.eventName}` });

            // Lookup Event Definition from Dynamic Config
            const matchDate = matchName.match(/\d{4}-\d{2}-\d{2}/)?.[0] || new Date().toISOString().split('T')[0];
            const relativePath = generateEventFilename(event, matchDate, availableEvents as any);

            // Remove leading slash if present to ensure it's treated as relative by the server
            const outputRelativePath = relativePath.startsWith('/') ? relativePath.slice(1) : relativePath;

            const definition = availableEvents.find(def => def.eventName === event.eventName);
            // Use config defaultDuration (max) or fallback
            // defaultDuration might be [min, max], we use max for clip length. StartTime handles pre-roll.
            const duration = (definition as any)?.defaultDuration ? (definition as any).defaultDuration[1] : ((definition as any)?.clipDuration || 10);

            // Default preRoll if not sending explicit timestamp (though we send startTime)
            const preRoll = 5;

            const response = await fetch(`${API_BASE_URL}/api/extract-clip`, {
                method: 'POST',
                headers: API_HEADERS,
                body: JSON.stringify({
                    videoPath: `./public/uploads/${videoFile.name}`,
                    startTime: Math.max(0, event.videoTime - preRoll),
                    duration: duration,
                    outputRelativePath: outputRelativePath,
                    // Legacy fields backup
                    eventType: event.eventName,
                    eventName: `${event.team || 'Match'}_${event.player?.name || 'Player'}`
                })
            });

            const data = await response.json();
            if (data.success) {
                toast({ title: "Clip Extracted", description: "Saved to " + data.url });
            } else {
                throw new Error(data.error);
            }
        } catch (e) {
            console.error(e);
            toast({ title: "Extraction Failed", description: "Could not save clip.", variant: "destructive" });
        }
    };

    const handleToggleValidation = (event: LoggedEvent) => {
        const isValid = !event.isValidated;
        onUpdateEvent({
            ...event,
            isValidated: isValid,
            reviewedBy: 'Early Tester'
        });

        if (isValid) {
            handleExtractSequence(event);
        }
    };

    const handleBulkVerify = () => {
        const pending = filteredEvents.filter(e => !e.isValidated);
        if (pending.length === 0) return;

        pending.forEach(event => {
            onUpdateEvent({
                ...event,
                isValidated: true,
                reviewedBy: 'Lead Analyst'
            });
            // Auto-extract for bulk might be too heavy? Let's do it for now or maybe skip.
            // handleExtractSequence(event); 
        });

        toast({
            title: "Bulk Verification Complete",
            description: `Validated ${pending.length} events.`
        });
    };

    const handleSendToCrowd = async (event: LoggedEvent) => {
        if (!videoFile) {
            toast({
                title: "Error",
                description: "Load a video file first.",
                variant: "destructive"
            });
            return;
        }

        const tacticalEvents = ['goal', 'shot', 'foul', 'offside', 'penalty', 'corner', 'red_card', 'yellow_card', 'pass_start', 'handball'];
        const isTactical = tacticalEvents.some(te => event.eventName.toLowerCase().includes(te));

        if (!isTactical) {
            toast({
                title: "Not a Tactical Event",
                description: "Only critical tactical events (Goals, Fouls, Shots, etc.) are sent to the crowd.",
                variant: "destructive"
            });
            return;
        }

        setSendingClipId(event.id);
        try {
            const formData = new FormData();
            formData.append('video', videoFile);
            formData.append('timestamp_seconds', (event.videoTime || 0).toString());
            formData.append('match_name', matchName);
            formData.append('event_type', event.eventName);
            formData.append('window_seconds', '8.0'); // Targeted clip

            const response = await fetch(`${ANALYSIS_API_URL}/api/crowd/request-review-upload`, {
                method: 'POST',
                headers: { 'ngrok-skip-browser-warning': 'true' },
                body: formData
            });

            const data = await response.json();
            if (data.success) {
                toast({
                    title: "Sent to Crowd!",
                    description: `Analyst request for '${event.eventName}' broadcasted to fans.`
                });
                onUpdateEvent({
                    ...event,
                    validationNotes: (event.validationNotes || '') + "\n[Crowd Review Requested]"
                });
            } else {
                throw new Error(data.error);
            }
        } catch (error) {
            toast({
                title: "Request Failed",
                description: error instanceof Error ? error.message : "Failed to sync with crowd API",
                variant: "destructive"
            });
        } finally {
            setSendingClipId(null);
        }
    };

    const handleResolvePass = (event: LoggedEvent) => {
        if (event.videoTime !== undefined) {
            onSeekToEvent(event.videoTime);
            setSelectedEventId(event.id);
        }
    };

    const handleCreatePassEnd = (parentEvent: LoggedEvent) => {
        const newEvent: LoggedEvent = {
            id: Number(`${Date.now()}${Math.floor(Math.random() * 1000)}`),
            timestamp: new Date().toISOString(),
            eventName: "pass_end",
            team: parentEvent.team,
            buttonLabel: "Validation Fix",
            matchTime: parentEvent.matchTime,
            videoTime: parentEvent.videoTime !== undefined ? parentEvent.videoTime + 2 : undefined, // +2s offset as a reasonable default
            player: parentEvent.player, // Initially same player, intended to be changed by analyst
            mode: parentEvent.mode,
            isValidated: true,
            reviewedBy: 'Lead Analyst (Manual Fix)'
        };
        onAddEvent(newEvent);
        toast({
            title: "Pass End Registered",
            description: "A pass_end event has been inserted after the start point."
        });
    };

    return (
        <div className="flex flex-col h-full gap-4 text-sm">
            {/* 1. TOP STATS BAR */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
                <Card className="p-2 bg-card/50 border-2 border-primary/20 flex flex-col gap-1">
                    <span className="text-[9px] text-muted-foreground uppercase font-bold">Validation Progress</span>
                    <div className="flex items-end gap-2">
                        <span className="text-lg font-black">{stats.validated}</span>
                        <span className="text-muted-foreground mb-1 text-[10px]">/ {stats.total}</span>
                        <Badge className="ml-auto mb-0" variant="outline">{Math.round((stats.validated / stats.total) * 100 || 0)}%</Badge>
                    </div>
                </Card>

                <Card className="p-2 bg-yellow-500/5 border-2 border-yellow-500/20 flex flex-col gap-1">
                    <span className="text-[9px] text-yellow-600 uppercase font-bold flex items-center gap-1">
                        <AlertCircle className="w-3 h-3" /> Missing Players
                    </span>
                    <span className="text-lg font-black text-yellow-600">{stats.missingPlayer}</span>
                </Card>

                <Card className="p-2 bg-blue-500/5 border-2 border-blue-500/20 flex flex-col gap-1">
                    <span className="text-[9px] text-blue-600 uppercase font-bold flex items-center gap-1">
                        <ShieldCheck className="w-3 h-3" /> QA Passed
                    </span>
                    <span className="text-lg font-black text-blue-600">{stats.validated}</span>
                </Card>

                <Card className="p-2 bg-destructive/5 border-2 border-destructive/20 flex flex-col gap-1">
                    <span className="text-[9px] text-destructive uppercase font-bold flex items-center gap-1">
                        <AlertTriangle className="w-3 h-3" /> Flagged (Low Qual)
                    </span>
                    <span className="text-lg font-black text-destructive">{stats.lowQuality}</span>
                </Card>

                <Card className="p-2 bg-orange-500/5 border-2 border-orange-500/20 flex flex-col gap-1">
                    <span className="text-[9px] text-orange-600 uppercase font-bold flex items-center gap-1">
                        <Link2Off className="w-3 h-3" /> Incomplete Passes
                    </span>
                    <span className="text-lg font-black text-orange-600">{stats.orphanedPasses}</span>
                </Card>
            </div>

            <div className="flex gap-4 flex-1 min-h-0">
                {/* 2. EVENT REVIEW LIST */}
                <Card className="w-full md:w-2/3 flex flex-col overflow-hidden bg-card/30 backdrop-blur-md border-border/50">
                    <div className="p-4 border-b flex flex-wrap items-center justify-between gap-4 bg-muted/20">
                        <div className="flex items-center gap-2 bg-background p-1 rounded-lg border">
                            <Button
                                variant={filter === 'all' ? 'secondary' : 'ghost'}
                                size="sm"
                                className="h-7 text-xs"
                                onClick={() => setFilter('all')}
                            >
                                All
                            </Button>
                            <Button
                                variant={filter === 'pending' ? 'secondary' : 'ghost'}
                                size="sm"
                                className="h-7 text-xs"
                                onClick={() => setFilter('pending')}
                            >
                                Pending
                            </Button>
                            <Button
                                variant={filter === 'validated' ? 'secondary' : 'ghost'}
                                size="sm"
                                className="h-7 text-xs"
                                onClick={() => setFilter('validated')}
                            >
                                Validated
                            </Button>
                            <Button
                                variant={filter === 'incomplete' ? 'secondary' : 'ghost'}
                                size="sm"
                                className="h-7 text-xs"
                                onClick={() => setFilter('incomplete')}
                            >
                                Incomplete
                            </Button>
                        </div>

                        <div className="flex-1 relative min-w-[200px]">
                            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
                            <Input
                                placeholder="Search events or players..."
                                className="pl-9 h-9 text-xs bg-background"
                                value={searchQuery}
                                onChange={(e) => setSearchQuery(e.target.value)}
                            />
                        </div>

                        <Button
                            variant="outline"
                            size="sm"
                            className="h-9 gap-2 border-primary/30 hover:bg-primary/5"
                            onClick={handleBulkVerify}
                        >
                            <CheckSquare className="w-4 h-4 text-primary" />
                            Verify All ({filteredEvents.filter(e => !e.isValidated).length})
                        </Button>
                    </div>

                    <ScrollArea className="flex-1">
                        <div className="divide-y divide-border/50">
                            {filteredEvents.map(event => (
                                <div
                                    key={event.id}
                                    onClick={() => setSelectedEventId(event.id)}
                                    className={cn(
                                        "p-3 flex items-center gap-4 hover:bg-primary/5 transition-all cursor-pointer group",
                                        selectedEventId === event.id && "bg-primary/10 border-r-4 border-r-primary shadow-inner"
                                    )}
                                >
                                    <div className={cn(
                                        "w-2 h-2 rounded-full shrink-0",
                                        event.isValidated ? "bg-green-500" : (
                                            event.eventName === 'pass_start' && (() => {
                                                const idx = events.findIndex(e => e.id === event.id);
                                                const nextEvent = events.slice(0, idx).reverse().find(next =>
                                                    ['pass_end', 'pass_start', 'turnover'].includes(next.eventName)
                                                );
                                                return !nextEvent || nextEvent.eventName !== 'pass_end';
                                            })() ? "bg-orange-500 animate-bounce" : "bg-yellow-500 animate-pulse"
                                        )
                                    )} />

                                    <div className="flex-1 min-w-0">
                                        <div className="flex items-center gap-2 flex-wrap">
                                            <Badge variant="outline" className={cn("text-[10px] px-1.5 font-bold uppercase", getEventColor(event.eventName))}>
                                                {event.eventName}
                                            </Badge>
                                            {event.psychology && (
                                                <span className={cn(
                                                    "text-[8px] px-1 rounded-sm font-black uppercase text-white",
                                                    event.psychology === 'SPIRIT' ? "bg-orange-600" :
                                                        event.psychology === 'EGO' ? "bg-blue-600" :
                                                            event.psychology === 'FEAR' ? "bg-amber-600" :
                                                                "bg-neutral-600"
                                                )}>
                                                    {event.psychology}
                                                </span>
                                            )}
                                            {event.semanticIndicator && (
                                                <span className="text-[8px] px-1 rounded-sm bg-primary/20 text-primary border border-primary/30 font-bold uppercase truncate max-w-[80px]">
                                                    {event.semanticIndicator}
                                                </span>
                                            )}
                                            {event.eventName === 'pass_start' && (() => {
                                                const idx = events.findIndex(e => e.id === event.id);
                                                const nextEvent = events.slice(0, idx).reverse().find(next =>
                                                    ['pass_end', 'pass_start', 'turnover'].includes(next.eventName)
                                                );
                                                return !nextEvent || nextEvent.eventName !== 'pass_end';
                                            })() && (
                                                    <Badge variant="destructive" className="text-[8px] h-4 flex items-center gap-1 font-black">
                                                        <Link2Off className="w-2 h-2" /> MISSING END
                                                    </Badge>
                                                )}
                                            <span className="text-[10px] opacity-70 font-mono ml-auto">@{event.matchTime}</span>
                                        </div>
                                        <div className="text-xs font-medium mt-1 truncate">
                                            {event.player?.name || <span className="text-destructive italic">Anonymous Player</span>}
                                            <span className="text-muted-foreground mx-1">‚Ä¢</span>
                                            <span className="text-muted-foreground">{event.corridor || 'Zone N/A'}</span>
                                        </div>
                                    </div>

                                    <div className="flex items-center gap-1.5 opacity-0 group-hover:opacity-100 transition-opacity shrink-0">
                                        <Button
                                            variant="ghost"
                                            size="icon"
                                            className="h-8 w-8 hover:bg-background"
                                            title="Sync Player"
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                if (event.videoTime !== undefined) onSeekToEvent(event.videoTime);
                                            }}
                                        >
                                            <ExternalLink className="w-4 h-4" />
                                        </Button>

                                        <Button
                                            variant="ghost"
                                            size="icon"
                                            className={cn("h-8 w-8 hover:bg-blue-500/10 hover:text-blue-600", sendingClipId === event.id && "animate-spin")}
                                            title="Send to Fan Voting"
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                handleSendToCrowd(event);
                                            }}
                                            disabled={sendingClipId !== null}
                                        >
                                            {sendingClipId === event.id ? <Loader2 className="w-4 h-4" /> : <Users className="w-4 h-4" />}
                                        </Button>

                                        {event.eventName === 'pass_start' && (() => {
                                            const idx = events.findIndex(e => e.id === event.id);
                                            const nextEvent = events.slice(idx + 1).find(next =>
                                                ['pass_end', 'pass_start', 'turnover'].includes(next.eventName)
                                            );
                                            return !nextEvent || nextEvent.eventName !== 'pass_end';
                                        })() && (
                                                <Button
                                                    variant="outline"
                                                    size="sm"
                                                    className="h-7 px-2 text-[10px] bg-orange-500/10 text-orange-600 border-orange-500/30 hover:bg-orange-500/20"
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        handleResolvePass(event);
                                                    }}
                                                >
                                                    RESOLVE
                                                </Button>
                                            )}

                                        <Button
                                            variant={event.isValidated ? "ghost" : "default"}
                                            size="sm"
                                            className="h-7 px-3 text-[10px] font-bold"
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                handleToggleValidation(event);
                                            }}
                                        >
                                            {event.isValidated ? "REFUTE" : "VERIFY"}
                                        </Button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </ScrollArea>
                </Card>

                {/* 3. EVENT DETAILS & CORRECTION */}
                <div className="hidden md:flex w-1/3 flex-col gap-4">
                    <Card className="flex-1 p-4 bg-card shadow-xl border-2 border-primary/5 flex flex-col">
                        {selectedEvent ? (
                            <div className="space-y-4 flex-1 flex flex-col">
                                <div className="flex items-center justify-between pb-2 border-b">
                                    <h4 className="font-bold flex items-center gap-2 uppercase tracking-tighter text-xs">
                                        <Edit3 className="w-4 h-4 text-primary" /> Event Correction
                                    </h4>
                                    <Badge className="bg-primary/10 text-primary border-primary/20 text-[9px]">ID: {selectedEvent.id.toString().slice(-6)}</Badge>
                                </div>

                                <ScrollArea className="flex-1 pr-2">
                                    <div className="space-y-4">
                                        <div className="grid grid-cols-2 gap-3">
                                            <div className="space-y-1">
                                                <label className="text-[10px] text-muted-foreground uppercase font-black">Event Type</label>
                                                <select
                                                    className="w-full h-8 bg-muted/30 rounded-md text-xs border border-border px-2"
                                                    value={selectedEvent.eventName}
                                                    onChange={(e) => {
                                                        const newName = e.target.value;
                                                        const def = availableEvents.find(d => d.eventName === newName);
                                                        onUpdateEvent({
                                                            ...selectedEvent,
                                                            eventName: newName,
                                                            validationNotes: (selectedEvent.validationNotes || '')
                                                        });
                                                    }}
                                                >
                                                    <option value={selectedEvent.eventName}>{selectedEvent.eventName} (Current)</option>
                                                    {Array.from(new Set(availableEvents.map(d => d.category))).map(category => (
                                                        <optgroup key={category} label={category}>
                                                            {availableEvents.filter(d => d.category === category).map(def => (
                                                                <option key={def.id} value={def.eventName}>
                                                                    {def.eventName}
                                                                </option>
                                                            ))}
                                                        </optgroup>
                                                    ))}
                                                </select>
                                            </div>
                                            <div className="space-y-1">
                                                <label className="text-[10px] text-muted-foreground uppercase font-black">Position (TS)</label>
                                                <Input defaultValue={selectedEvent.matchTime} className="h-8 text-xs bg-muted/30" />
                                            </div>
                                        </div>

                                        <div className="space-y-1">
                                            <label className="text-[10px] text-muted-foreground uppercase font-black">Assign Actor</label>
                                            <select
                                                className="w-full h-8 bg-muted/30 rounded-md text-xs border border-border px-2 focus:ring-1 ring-primary"
                                                value={selectedEvent.player?.id || ''}
                                                onChange={(e) => {
                                                    const playerId = parseInt(e.target.value);
                                                    const player = availablePlayers.find(p => p.id === playerId);
                                                    if (player) {
                                                        onUpdateEvent({
                                                            ...selectedEvent,
                                                            player: { id: player.id, name: player.name }
                                                        });
                                                    }
                                                }}
                                            >
                                                <option value="">Select Local Player...</option>
                                                {availablePlayers.map(p => (
                                                    <option key={p.id} value={p.id}>{p.name}</option>
                                                ))}
                                            </select>
                                        </div>

                                        <div className="grid grid-cols-2 gap-3">
                                            <div className="space-y-1">
                                                <label className="text-[10px] text-muted-foreground uppercase font-black">Quality Vetting</label>
                                                <select
                                                    className="w-full h-8 bg-muted/30 rounded-md text-xs border border-border px-2"
                                                    defaultValue={selectedEvent.qualityRating}
                                                >
                                                    {[1, 2, 3, 4, 5].map(v => (
                                                        <option key={v} value={v}>Lvl {v} - {v > 3 ? 'High' : 'Low'}</option>
                                                    ))}
                                                </select>
                                            </div>
                                            <div className="space-y-1">
                                                <label className="text-[10px] text-muted-foreground uppercase font-black">Tempo</label>
                                                <Badge variant="secondary" className="h-8 w-full justify-center text-[10px] bg-muted/50">{selectedEvent.tempo || 'MODERATE'}</Badge>
                                            </div>
                                        </div>

                                        <div className="space-y-1 pt-2 border-t border-dashed">
                                            <label className="text-[10px] text-primary uppercase font-black flex items-center gap-1">
                                                <Activity className="w-3 h-3" /> Semantic Intelligence Layer
                                            </label>

                                            <div className="grid grid-cols-2 gap-3 mt-2">
                                                <div className="space-y-1">
                                                    <label className="text-[9px] text-muted-foreground uppercase font-bold">Tactical Indicator</label>
                                                    <select
                                                        className="w-full h-8 bg-primary/5 rounded-md text-[10px] border border-primary/20 px-2"
                                                        value={selectedEvent.semanticIndicator || ''}
                                                        onChange={(e) => onUpdateEvent({ ...selectedEvent, semanticIndicator: e.target.value })}
                                                    >
                                                        <option value="">None</option>
                                                        <option value="Defensive Block Height">Defensive Block Height</option>
                                                        <option value="Momentum Shift">Momentum Shift</option>
                                                        <option value="Width/Depth Ratio">Width/Depth Ratio</option>
                                                        <option value="Transition Vulnerability">Transition Vulnerability</option>
                                                        <option value="Decision Efficiency">Decision Efficiency</option>
                                                    </select>
                                                </div>
                                                <div className="space-y-1">
                                                    <label className="text-[9px] text-muted-foreground uppercase font-bold">Psychology</label>
                                                    <select
                                                        className="w-full h-8 bg-orange-500/5 rounded-md text-[10px] border border-orange-500/20 px-2"
                                                        value={selectedEvent.psychology || ''}
                                                        onChange={(e) => onUpdateEvent({ ...selectedEvent, psychology: e.target.value as any })}
                                                    >
                                                        <option value="">Neutral</option>
                                                        <option value="SPIRIT">Spirit üî• (Duels/Recoveries)</option>
                                                        <option value="EGO">Ego üíé (Selfish Actions)</option>
                                                        <option value="FEAR">Fear üò® (Backpasses)</option>
                                                        <option value="COMA">Coma üò¥ (Simple Losses)</option>
                                                    </select>
                                                </div>
                                            </div>

                                            <div className="grid grid-cols-2 gap-3 mt-2">
                                                <div className="space-y-1">
                                                    <label className="text-[9px] text-muted-foreground uppercase font-bold">Intensity / Impact</label>
                                                    <div className="flex gap-1">
                                                        {['LOW', 'MEDIUM', 'HIGH'].map((level) => (
                                                            <Button
                                                                key={level}
                                                                variant={selectedEvent.intensity === level ? 'default' : 'outline'}
                                                                size="sm"
                                                                className="flex-1 h-7 text-[9px] px-0"
                                                                onClick={() => onUpdateEvent({ ...selectedEvent, intensity: level as any })}
                                                            >
                                                                {level}
                                                            </Button>
                                                        ))}
                                                    </div>
                                                </div>
                                                <div className="space-y-1">
                                                    <label className="text-[9px] text-muted-foreground uppercase font-bold">Contextual Factor</label>
                                                    <select
                                                        className="w-full h-8 bg-muted/30 rounded-md text-[10px] border border-border px-2"
                                                        value={selectedEvent.contextualFactor || ''}
                                                        onChange={(e) => onUpdateEvent({ ...selectedEvent, contextualFactor: e.target.value })}
                                                    >
                                                        <option value="">Normal Play</option>
                                                        <option value="Post-Goal">Post-Goal Balance</option>
                                                        <option value="Ref Decision">Ref Decision Impact</option>
                                                        <option value="Final Minutes">Clutch / Final Minutes</option>
                                                        <option value="Symmetry Break">Symmetry Break</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>

                                        <div className="space-y-1 border-t border-dashed pt-2">
                                            <label className="text-[10px] text-muted-foreground uppercase font-black">Editorial Notes</label>
                                            <Textarea
                                                placeholder="Describe corrections, context, or visual details..."
                                                className="min-h-[80px] text-xs bg-muted/10 resize-none"
                                                defaultValue={selectedEvent.validationNotes}
                                                onBlur={(e) => onUpdateEvent({ ...selectedEvent, validationNotes: e.target.value })}
                                            />
                                        </div>
                                    </div>
                                </ScrollArea>

                                <div className="pt-4 flex gap-2 border-t mt-auto">
                                    {selectedEvent.eventName === 'pass_start' && (() => {
                                        const idx = events.findIndex(e => e.id === selectedEvent.id);
                                        // Events AFTER in time are at indices 0 to idx-1 (nearest is idx-1)
                                        const nextEvent = events.slice(0, idx).reverse().find(next =>
                                            ['pass_end', 'pass_start', 'turnover'].includes(next.eventName)
                                        );
                                        return !nextEvent || nextEvent.eventName !== 'pass_end';
                                    })() && (
                                            <Button
                                                variant="secondary"
                                                className="flex-1 h-10 gap-2 font-bold uppercase tracking-widest text-[10px] bg-orange-500/10 text-orange-600 border-orange-500/20 hover:bg-orange-500/20"
                                                onClick={() => handleCreatePassEnd(selectedEvent)}
                                            >
                                                <Workflow className="w-4 h-4" /> Register Reception
                                            </Button>
                                        )}
                                    <Button variant="default" className="flex-1 h-10 gap-2 font-bold uppercase tracking-widest text-[10px]" onClick={() => {
                                        toast({ title: "Draft Saved", description: "Changes recorded locally." });
                                    }}>
                                        <CheckCircle className="w-4 h-4" /> Save Metadata
                                    </Button>
                                    <Button variant="outline" size="icon" className="h-10 w-10 text-destructive hover:bg-destructive/10">
                                        <XSquare className="w-5 h-5" />
                                    </Button>
                                </div>
                            </div>
                        ) : (
                            <div className="h-full flex flex-col items-center justify-center text-muted-foreground italic gap-2 text-center">
                                <div className="w-16 h-16 rounded-full bg-muted/30 flex items-center justify-center border-2 border-dashed border-border mb-2">
                                    <ChevronRight className="w-8 h-8 opacity-20" />
                                </div>
                                <span className="text-xs uppercase font-bold tracking-widest opacity-50">Validation Queue Idle</span>
                                <span className="text-[10px]">Select an event from the left list<br />to modify its properties.</span>
                            </div>
                        )}
                    </Card>

                    {/* 4. RECENT CORRECTIONS (Audit Trail) */}
                    <Card className="h-40 flex flex-col overflow-hidden bg-muted/20 border-border/50">
                        <div className="p-2 px-3 border-b bg-muted/50 flex items-center justify-between">
                            <span className="text-[10px] font-black uppercase text-secondary-foreground flex items-center gap-1">
                                <History className="w-3 h-3" /> QA Audit Trail
                            </span>
                            <span className="text-[9px] font-medium opacity-60 italic">{matchName}</span>
                        </div>
                        <ScrollArea className="flex-1">
                            <div className="p-2 flex flex-col gap-1.5">
                                {events.filter(e => e.isValidated).slice(-3).map(e => (
                                    <div key={e.id} className="text-[10px] bg-background/50 p-2 rounded border border-border/30 shadow-sm flex items-center gap-2">
                                        <CheckCircle2 className="w-3 h-3 text-green-500" />
                                        <div className="flex-1 min-w-0">
                                            <span className="font-bold">{e.eventName}</span> verified by {e.reviewedBy || 'System'}
                                        </div>
                                    </div>
                                ))}
                                {events.filter(e => e.isValidated).length === 0 && (
                                    <div className="text-[10px] text-center opacity-40 py-4">No validation activity logs.</div>
                                )}
                            </div>
                        </ScrollArea>
                    </Card>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/components/VideoEditor/VideoEditorSidebar.tsx">
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { ScrollArea } from '@/components/ui/scroll-area';
import {
    MousePointer2,
    ArrowRight,
    Circle,
    Square,
    Type,
    User,
    Trash2,
    Undo,
    Download,
    Upload,
    Video,
    Scissors
} from 'lucide-react';
import { AnnotationType } from '@/hooks/useAnnotations';

export type DrawingTool = AnnotationType | 'select';

interface VideoEditorSidebarProps {
    activeTool: DrawingTool;
    onToolChange: (tool: DrawingTool) => void;
    color: string;
    onColorChange: (color: string) => void;
    strokeWidth: number;
    onStrokeWidthChange: (width: number) => void;
    onClear: () => void;
    onUndo: () => void;
    onExport: () => void;
    onImport: (file: File) => void;
    events?: any[]; // Replace with correct type
}

export const VideoEditorSidebar: React.FC<VideoEditorSidebarProps> = ({
    activeTool,
    onToolChange,
    color,
    onColorChange,
    strokeWidth,
    onStrokeWidthChange,
    onClear,
    onUndo,
    onExport,
    onImport,
    events = []
}) => {
    const [showColorPicker, setShowColorPicker] = useState(false);

    const tools: Array<{ id: DrawingTool; icon: React.ReactNode; label: string }> = [
        { id: 'select', icon: <MousePointer2 className="w-4 h-4" />, label: 'Select' },
        { id: 'arrow', icon: <ArrowRight className="w-4 h-4" />, label: 'Arrow' },
        { id: 'circle', icon: <Circle className="w-4 h-4" />, label: 'Circle' },
        { id: 'rectangle', icon: <Square className="w-4 h-4" />, label: 'Rectangle' },
        { id: 'text', icon: <Type className="w-4 h-4" />, label: 'Text' },
        { id: 'player-track', icon: <User className="w-4 h-4" />, label: 'Track Player' },
    ];

    const presetColors = [
        '#FF0000', // Red
        '#00FF00', // Green
        '#0000FF', // Blue
        '#FFFF00', // Yellow
        '#FF00FF', // Magenta
        '#00FFFF', // Cyan
        '#FFFFFF', // White
        '#000000', // Black
    ];

    const handleFileImport = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            onImport(file);
        }
    };

    return (
        <div className="flex flex-col h-full bg-card border-r border-border">
            {/* Header */}
            <div className="p-4 border-b border-border flex items-center gap-2">
                <Video className="w-5 h-5 text-primary" />
                <h2 className="font-bold text-lg">Video Editor</h2>
            </div>

            <ScrollArea className="flex-1">
                <div className="p-4 space-y-6">

                    {/* Tools Section */}
                    <div className="space-y-3">
                        <h3 className="text-xs font-semibold text-muted-foreground uppercase tracking-wider">Tools</h3>
                        <div className="grid grid-cols-3 gap-2">
                            {tools.map((tool) => (
                                <Button
                                    key={tool.id}
                                    variant={activeTool === tool.id ? 'default' : 'outline'}
                                    size="sm"
                                    onClick={() => onToolChange(tool.id)}
                                    className={`w-full justify-start gap-2 ${activeTool === tool.id ? '' : 'text-muted-foreground'}`}
                                >
                                    {tool.icon}
                                    <span className="text-xs">{tool.label}</span>
                                </Button>
                            ))}
                        </div>
                    </div>

                    {/* Styling Section */}
                    <div className="space-y-3">
                        <h3 className="text-xs font-semibold text-muted-foreground uppercase tracking-wider">Style</h3>
                        <div className="flex items-center gap-4">
                            {/* Color Picker */}
                            <div className="relative">
                                <button
                                    onClick={() => setShowColorPicker(!showColorPicker)}
                                    className="w-8 h-8 rounded-full border-2 border-border shadow-sm transition-transform hover:scale-110"
                                    style={{ backgroundColor: color }}
                                    title="Active Color"
                                />
                                {showColorPicker && (
                                    <div className="absolute top-10 left-0 z-50 bg-popover border border-border p-3 rounded-xl grid grid-cols-4 gap-2 shadow-xl w-48">
                                        {presetColors.map((c) => (
                                            <button
                                                key={c}
                                                onClick={() => {
                                                    onColorChange(c);
                                                    setShowColorPicker(false);
                                                }}
                                                className="w-8 h-8 rounded-full border border-border hover:scale-110 transition-transform shadow-sm"
                                                style={{ backgroundColor: c }}
                                            />
                                        ))}
                                    </div>
                                )}
                            </div>

                            {/* Stroke Width Slider */}
                            <div className="flex-1 space-y-1">
                                <div className="flex justify-between text-xs text-muted-foreground">
                                    <span>Thickness</span>
                                    <span>{strokeWidth}px</span>
                                </div>
                                <input
                                    type="range"
                                    min="1"
                                    max="10"
                                    value={strokeWidth}
                                    onChange={(e) => onStrokeWidthChange(Number(e.target.value))}
                                    className="w-full h-1 bg-secondary rounded-lg appearance-none cursor-pointer accent-primary"
                                />
                            </div>
                        </div>
                    </div>

                    {/* Actions Section */}
                    <div className="space-y-3">
                        <h3 className="text-xs font-semibold text-muted-foreground uppercase tracking-wider">Actions</h3>
                        <div className="flex gap-2">
                            <Button variant="outline" size="sm" onClick={onUndo} className="flex-1 gap-2">
                                <Undo className="w-4 h-4" /> Undo
                            </Button>
                            <Button variant="outline" size="sm" onClick={onClear} className="flex-1 gap-2 text-destructive hover:text-destructive">
                                <Trash2 className="w-4 h-4" /> Clear
                            </Button>
                        </div>
                        <div className="flex gap-2">
                            <Button variant="secondary" size="sm" onClick={onExport} className="flex-1 gap-2">
                                <Download className="w-4 h-4" /> Export
                            </Button>
                            <label className="flex-1">
                                <Button variant="secondary" size="sm" className="w-full gap-2 pointer-events-none" asChild>
                                    <div>
                                        <Upload className="w-4 h-4" /> Import
                                    </div>
                                </Button>
                                <input
                                    type="file"
                                    accept=".json"
                                    onChange={handleFileImport}
                                    className="hidden"
                                />
                            </label>
                        </div>
                    </div>

                    {/* Clips Section (Placeholder) */}
                    <div className="space-y-3 pt-4 border-t border-border">
                        <div className="flex items-center justify-between">
                            <h3 className="text-xs font-semibold text-muted-foreground uppercase tracking-wider">Clips</h3>
                            <Button variant="ghost" size="icon" className="h-6 w-6">
                                <Scissors className="w-3 h-3" />
                            </Button>
                        </div>
                        <div className="text-center py-8 text-sm text-muted-foreground bg-secondary/20 rounded-lg border border-dashed border-border">
                            No clips created yet
                        </div>
                    </div>

                </div>
            </ScrollArea>
        </div>
    );
};
</file>

<file path="src/components/VideoManager.tsx">
import React, { useEffect, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Play, FileVideo, Calendar, Clock, RefreshCw, Layers } from 'lucide-react';
import { API_BASE_URL } from '@/utils/apiConfig';
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

interface VideoFile {
    filename: string;
    path: string;
    url: string;
    date: string;
    size: number;
}

export const VideoManager = () => {
    const [videos, setVideos] = useState<VideoFile[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [selectedVideo, setSelectedVideo] = useState<VideoFile | null>(null);

    const fetchVideos = async () => {
        setIsLoading(true);
        try {
            const res = await fetch(`${API_BASE_URL}/api/videos`);
            if (res.ok) {
                const data = await res.json();
                setVideos(data);
            }
        } catch (error) {
            console.error("Failed to fetch videos:", error);
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        fetchVideos();
    }, []);

    const formatSize = (bytes: number) => {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    };

    const renderVideoGrid = (
        videoList: VideoFile[],
        loading: boolean,
        onSelect: (v: VideoFile) => void,
        fmtSize: (b: number) => string
    ) => {
        if (videoList.length === 0 && !loading) {
            return (
                <div className="flex flex-col items-center justify-center h-40 text-slate-500 text-xs">
                    <FileVideo className="w-8 h-8 mb-2 opacity-20" />
                    No extracted clips found.
                </div>
            );
        }

        return (
            <div className="grid grid-cols-2 lg:grid-cols-3 gap-3">
                {videoList.map((video) => (
                    <Dialog key={video.path}>
                        <DialogTrigger asChild>
                            <div
                                className="group relative aspect-video bg-black/40 rounded-lg border border-white/5 overflow-hidden cursor-pointer hover:border-purple-500/50 transition-all hover:scale-[1.02]"
                                onClick={() => onSelect(video)}
                            >
                                <div className="absolute inset-0 flex items-center justify-center bg-black/20 group-hover:bg-black/40 transition-colors">
                                    <div className="w-8 h-8 rounded-full bg-purple-600/80 flex items-center justify-center shadow-lg transform group-hover:scale-110 transition-transform">
                                        <Play className="w-4 h-4 text-white fill-current" />
                                    </div>
                                </div>

                                <div className="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/90 to-transparent">
                                    <p className="text-[10px] font-bold text-white truncate">{video.filename}</p>
                                    <div className="flex items-center justify-between text-[9px] text-slate-400 mt-0.5">
                                        <span className="flex items-center gap-1">
                                            <Calendar className="w-2 h-2" />
                                            {new Date(video.date).toLocaleDateString()}
                                        </span>
                                        <span>{fmtSize(video.size)}</span>
                                    </div>
                                </div>
                            </div>
                        </DialogTrigger>
                        <DialogContent className="max-w-4xl bg-black border-white/10 p-1">
                            <DialogHeader className="p-4 absolute top-0 left-0 z-10 w-full bg-gradient-to-b from-black/80 to-transparent pointer-events-none">
                                <DialogTitle className="text-white text-sm font-mono shadow-black drop-shadow-md">
                                    {video.filename}
                                </DialogTitle>
                            </DialogHeader>
                            <div className="aspect-video w-full bg-black flex items-center justify-center overflow-hidden rounded-sm">
                                <video
                                    src={`${API_BASE_URL}${video.url}`}
                                    controls
                                    autoPlay
                                    className="w-full h-full object-contain"
                                />
                            </div>
                            <div className="p-2 flex justify-between text-xs text-slate-400 font-mono bg-slate-900/50">
                                <span>{new Date(video.date).toLocaleString()}</span>
                                <span>{fmtSize(video.size)}</span>
                            </div>
                        </DialogContent>
                    </Dialog>
                ))}
            </div>
        );
    };

    return (
        <Card className="h-full bg-slate-950 border-white/10 flex flex-col">
            <CardHeader className="p-4 border-b border-white/10 bg-slate-900/50 flex flex-row items-center justify-between">
                <CardTitle className="text-sm font-bold flex items-center gap-2 text-white">
                    <FileVideo className="w-4 h-4 text-purple-400" />
                    Video Library
                    <Badge variant="outline" className="ml-2 bg-purple-500/10 text-purple-400 border-purple-500/20">
                        {videos.length}
                    </Badge>
                </CardTitle>
                <Button variant="ghost" size="icon" className="h-6 w-6" onClick={fetchVideos} disabled={isLoading}>
                    <RefreshCw className={`w-3.5 h-3.5 ${isLoading ? 'animate-spin' : ''}`} />
                </Button>
            </CardHeader>
            <CardContent className="p-0 flex-1 min-h-0 bg-slate-950/30">
                <Tabs defaultValue="all" className="h-full flex flex-col">
                    <div className="px-4 py-3 border-b border-white/5 flex items-center gap-2 overflow-x-auto no-scrollbar bg-slate-900/20">
                        <Layers className="w-4 h-4 text-muted-foreground mr-2 shrink-0" />
                        <TabsList className="bg-transparent p-0 h-auto gap-2">
                            <TabsTrigger value="all" className="data-[state=active]:bg-purple-500/20 data-[state=active]:text-purple-300 border border-transparent data-[state=active]:border-purple-500/20 rounded-md px-3 py-1.5 h-auto text-xs">
                                All Clips
                            </TabsTrigger>
                            {Array.from(new Set(videos.map(v => v.path.split(/[/\\]/)[0]))).filter(c => c && !c.endsWith('.mp4')).sort().map(category => (
                                <TabsTrigger key={category} value={category} className="data-[state=active]:bg-blue-500/20 data-[state=active]:text-blue-300 border border-transparent data-[state=active]:border-blue-500/20 rounded-md px-3 py-1.5 h-auto text-xs uppercase">
                                    {category}
                                </TabsTrigger>
                            ))}
                        </TabsList>
                    </div>

                    <ScrollArea className="flex-1 p-4">
                        <TabsContent value="all" className="m-0 mt-0">
                            {renderVideoGrid(videos, isLoading, setSelectedVideo, formatSize)}
                        </TabsContent>
                        {Array.from(new Set(videos.map(v => v.path.split(/[/\\]/)[0]))).map(category => (
                            <TabsContent key={category} value={category} className="m-0 mt-0">
                                {renderVideoGrid(videos.filter(v => v.path.startsWith(category)), isLoading, setSelectedVideo, formatSize)}
                            </TabsContent>
                        ))}
                    </ScrollArea>
                </Tabs>
            </CardContent>
        </Card>
    );
};
</file>

<file path="src/components/VideoPlayer_backup.tsx">
// This is a backup - the main file needs manual fixing due to syntax errors
</file>

<file path="src/components/VideoPlayer/AnalysisVideoPlayer.tsx">
import { useRef, useEffect, useState } from "react";
import { VideoOverlay } from "./VideoOverlay";
import { LoggedEvent } from "@/hooks/useGamepad";
import { TeamRoster } from "@/types/player";
import { API_BASE_URL } from "@/utils/apiConfig";

interface AnalysisVideoPlayerProps {
    videoFile: File | null;
    videoUrl: string | null;
    currentTime: number;
    isPlaying: boolean;
    analysisResults: any;
    eventNotifications?: Array<{ id: number; event: LoggedEvent; timestamp: number }>;
    teams?: Map<string, TeamRoster>;
    selectedTeam?: string;
    teamNames?: { teamA: string; teamB: string };
}

export const AnalysisVideoPlayer = ({
    videoFile,
    videoUrl: remoteVideoUrl,
    currentTime,
    isPlaying,
    analysisResults,
    eventNotifications = [],
    teams,
    selectedTeam,
    teamNames
}: AnalysisVideoPlayerProps) => {
    const videoRef = useRef<HTMLVideoElement>(null);
    const [localVideoUrl, setLocalVideoUrl] = useState<string | null>(null);
    const [visiblePlayers, setVisiblePlayers] = useState<any[]>([]);

    // Handle video URL
    useEffect(() => {
        if (videoFile) {
            const url = URL.createObjectURL(videoFile);
            setLocalVideoUrl(url);
            return () => URL.revokeObjectURL(url);
        }
    }, [videoFile]);

    const activeUrl = localVideoUrl || (remoteVideoUrl ? `${API_BASE_URL}${remoteVideoUrl}` : null);

    // Sync playback state
    useEffect(() => {
        if (!videoRef.current) return;

        if (isPlaying) {
            videoRef.current.play().catch(e => console.log('Play failed:', e));
        } else {
            videoRef.current.pause();
        }
    }, [isPlaying]);

    // Sync current time
    useEffect(() => {
        if (!videoRef.current) return;

        const diff = Math.abs(videoRef.current.currentTime - currentTime);
        if (diff > 0.5) { // Only sync if difference > 0.5s
            videoRef.current.currentTime = currentTime;
        }
    }, [currentTime]);

    // Calculate visible players
    useEffect(() => {
        if (!analysisResults?.tracks) return;

        const fps = analysisResults.metadata?.fps || 30;
        const currentFrame = Math.floor(currentTime * fps);

        const players: any[] = [];
        Object.entries(analysisResults.tracks).forEach(([id, track]: [string, any]) => {
            const point = track.find((p: any) => p.frame === currentFrame);
            if (point) {
                players.push({
                    id: parseInt(id),
                    x: (point.x / (analysisResults.metadata?.width || 1920)) * 100,
                    y: (point.y / (analysisResults.metadata?.height || 1080)) * 100,
                    team: point.team === 'team_a' ? 'A' : (point.team === 'team_b' ? 'B' : point.team),
                    confidence: point.confidence,
                    speed: point.velocity,
                    is_sprinting: point.is_sprinting
                });
            }
        });

        setVisiblePlayers(players);
    }, [currentTime, analysisResults]);

    return (
        <div className="relative w-full h-full bg-black">
            {/* Video */}
            <video
                ref={videoRef}
                className="w-full h-full object-contain"
                src={activeUrl || undefined}
                muted // Muted to avoid echo
            />

            {/* Analysis Overlays - Always Enabled */}
            <VideoOverlay
                zoomLevel={1}
                eventNotifications={eventNotifications}
                showRoster={false}
                teams={teams}
                selectedTeam={selectedTeam}
                teamNames={teamNames}
                onCloseRoster={() => { }}
                visiblePlayers={visiblePlayers}
                passingPredictions={analysisResults?.passing_predictions || []}
                tacticalAlerts={analysisResults?.tactical_alerts || []}
                showHeatmap={true} // Always show heatmap
            />

            {/* Label */}
            <div className="absolute top-2 left-2 bg-black/70 text-white px-2 py-1 rounded text-xs font-semibold z-10">
                AI ANALYSIS VIEW
            </div>
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/AnnotatedVideoPlayer.tsx">
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { VideoPlayer } from './index';
import { useAnnotations } from '@/hooks/useAnnotations';
import { AnnotationCanvas } from './AnnotationCanvas';
import { AnnotationInteractionLayer } from './AnnotationInteractionLayer';
import { DrawingTool } from './AnnotationToolbar';
import { PlayerTracker } from './PlayerTracker';
import { CalibrationInterface } from './CalibrationInterface';
import { Button } from '@/components/ui/button';
import { Pen, X } from 'lucide-react';
import { LoggedEvent, QuickSelectorState } from '@/hooks/useGamepad';
import { TeamRoster } from '@/types/player';
import { TacticalAnnotationSidebar } from './TacticalAnnotationSidebar';
import { cn } from '@/lib/utils';
import { LayoutConfig } from '@/hooks/useDashboardLayout';

interface AnnotatedVideoPlayerProps {
    videoFile: File | null;
    videoUrl?: string | null;
    events: LoggedEvent[];
    onTimeUpdate: (currentTime: number) => void;
    onEventMarkerClick?: (event: LoggedEvent) => void;
    seekTo?: number | null;
    isPlaying?: boolean;
    onPlayPause?: (isPlaying: boolean) => void;
    onSeekComplete?: () => void;
    onSeek?: (time: number) => void;
    axes?: number[];
    buttons?: GamepadButton[];
    teams?: Map<string, TeamRoster>;
    selectedTeam?: string;
    teamNames?: { teamA: string; teamB: string };
    onPlayerSelect?: (playerId: number) => void;
    trackingData?: any; // AI tracking data
    quickSelectorState?: QuickSelectorState;
    timelineVariant?: 'minimal' | 'pro';
    showLiveToasts?: boolean;
    analysisMode?: 'LIVE' | 'POST_MATCH';
    isEditMode?: boolean;
    layoutConfig?: LayoutConfig;
    onToggleVisibility?: (id: string) => void;
}

export const AnnotatedVideoPlayer: React.FC<AnnotatedVideoPlayerProps> = (props) => {
    const [currentTime, setCurrentTime] = useState(0);
    const [showAnnotationMode, setShowAnnotationMode] = useState(false);
    const [showPlayerTracker, setShowPlayerTracker] = useState(false);
    const [activeTool, setActiveTool] = useState<DrawingTool>('select');
    const [annotationColor, setAnnotationColor] = useState('#FF0000');
    const [annotationStrokeWidth, setAnnotationStrokeWidth] = useState(3);
    const [trackingData, setTrackingData] = useState<any>(props.trackingData);
    const [showCalibration, setShowCalibration] = useState(false);
    const [videoDimensions, setVideoDimensions] = useState({ width: 1920, height: 1080 });
    const [localVideoUrl, setLocalVideoUrl] = useState<string | null>(null);
    const containerRef = useRef<HTMLDivElement>(null);

    // Extract actual video/image dimensions from the file and create local URL
    useEffect(() => {
        if (!props.videoFile) {
            setLocalVideoUrl(null);
            return;
        }

        const isImage = props.videoFile.type.startsWith('image/');
        const url = URL.createObjectURL(props.videoFile);
        setLocalVideoUrl(url); // Store the URL for CalibrationInterface

        if (isImage) {
            const img = new Image();
            img.onload = () => {
                setVideoDimensions({ width: img.naturalWidth, height: img.naturalHeight });
            };
            img.src = url;
        } else {
            const video = document.createElement('video');
            video.onloadedmetadata = () => {
                setVideoDimensions({ width: video.videoWidth, height: video.videoHeight });
            };
            video.src = url;
        }

        // Cleanup: revoke URL when file changes or component unmounts
        return () => {
            URL.revokeObjectURL(url);
        };
    }, [props.videoFile]);

    // Sync tracking data from props
    useEffect(() => {
        if (props.trackingData) {
            setTrackingData(props.trackingData);
        }
    }, [props.trackingData]);

    const {
        annotations,
        activeAnnotations,
        calibration,
        addAnnotation,
        deleteAnnotation,
        clearAnnotations,
        addCalibrationPair,
        removeLastCalibrationPair,
        setCalibrationPairs,
        clearCalibration,
        exportAnnotations,
        importAnnotations,
    } = useAnnotations(currentTime);

    const handleTimeUpdate = useCallback((time: number) => {
        setCurrentTime(time);
        props.onTimeUpdate(time);
    }, [props.onTimeUpdate]);

    const handleExport = () => {
        const json = exportAnnotations();
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'annotations.json';
        a.click();
        URL.revokeObjectURL(url);
    };

    const handleImport = (file: File) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const json = e.target?.result as string;
            importAnnotations(json);
        };
        reader.readAsText(file);
    };

    const handleTrackPlayer = (playerId: number, points: Array<{ time: number; x: number; y: number }>) => {
        addAnnotation({
            type: 'player-track',
            startTime: points[0].time,
            endTime: points[points.length - 1].time,
            data: {
                playerId,
                points,
                manual: true,
            },
            style: {
                color: annotationColor,
                strokeWidth: annotationStrokeWidth,
                opacity: 0.8,
            },
        });
        setShowPlayerTracker(false);
    };

    const handleUndo = () => {
        if (annotations.length > 0) {
            deleteAnnotation(annotations[annotations.length - 1].id);
        }
    };

    return (
        <div ref={containerRef} className="relative w-full h-full">
            {/* Base Video Player */}
            <VideoPlayer
                {...props}
                currentTime={currentTime}
                timelineVariant={props.timelineVariant}
                onTimeUpdate={handleTimeUpdate}
                onAnalysisComplete={(data) => setTrackingData(data)}
                showLiveToasts={props.showLiveToasts}
                analysisMode={props.analysisMode}
                isEditMode={props.isEditMode}
                layoutConfig={props.layoutConfig}
                onToggleVisibility={props.onToggleVisibility}
            />

            {/* Annotation Canvas Overlay (Existing Annotations) */}
            {showAnnotationMode && (
                <AnnotationCanvas
                    annotations={activeAnnotations}
                    videoWidth={videoDimensions.width}
                    videoHeight={videoDimensions.height}
                    calibrationMatrix={calibration.matrix}
                    calibrationPoints={calibration.pairs.map(p => p.src)}
                    onAnnotationClick={(id) => console.log('Clicked annotation:', id)}
                />
            )}

            {/* Interaction Layer (Drawing) */}
            {showAnnotationMode && activeTool !== 'select' && activeTool !== 'calibration' && !showPlayerTracker && (
                <AnnotationInteractionLayer
                    activeTool={activeTool}
                    color={annotationColor}
                    strokeWidth={annotationStrokeWidth}
                    videoWidth={videoDimensions.width}
                    videoHeight={videoDimensions.height}
                    currentTime={currentTime}
                    calibration={calibration}
                    onAddAnnotation={addAnnotation}
                />
            )}

            {/* Calibration Interface Modal */}
            {showCalibration && (
                <CalibrationInterface
                    videoUrl={localVideoUrl || props.videoUrl}
                    isImage={props.videoFile?.type.startsWith('image/') ?? false}
                    currentTime={currentTime}
                    currentPairs={calibration.pairs}
                    onAddPair={addCalibrationPair}
                    onRemoveLast={removeLastCalibrationPair}
                    onClear={clearCalibration}
                    onClose={() => setShowCalibration(false)}
                />
            )}

            {/* Player Tracker */}
            {showPlayerTracker && (
                <PlayerTracker
                    trackingData={trackingData}
                    currentTime={currentTime}
                    videoWidth={1920}
                    videoHeight={1080}
                    onTrackPlayer={handleTrackPlayer}
                    onClose={() => setShowPlayerTracker(false)}
                />
            )}

            {/* Annotation Sidebar */}
            {showAnnotationMode && !showPlayerTracker && (
                <TacticalAnnotationSidebar
                    activeTool={activeTool}
                    onToolChange={(tool) => {
                        if (tool === 'calibration') {
                            setShowCalibration(true);
                        } else {
                            setActiveTool(tool);
                            if (tool === 'player-track') {
                                setShowPlayerTracker(true);
                            }
                        }
                    }}
                    color={annotationColor}
                    onColorChange={setAnnotationColor}
                    strokeWidth={annotationStrokeWidth}
                    onStrokeWidthChange={setAnnotationStrokeWidth}
                    onClear={clearAnnotations}
                    onUndo={handleUndo}
                    onExport={handleExport}
                    onImport={handleImport}
                />
            )}

            {/* Annotation Mode Toggle - Redesigned */}
            {!showCalibration && !showPlayerTracker && (
                <Button
                    variant={showAnnotationMode ? 'default' : 'secondary'}
                    onClick={() => setShowAnnotationMode(!showAnnotationMode)}
                    className={cn(
                        "absolute top-6 left-1/2 -translate-x-1/2 z-40 h-10 px-4 rounded-xl font-bold uppercase tracking-widest text-[10px] transition-all border",
                        showAnnotationMode
                            ? "bg-red-500 hover:bg-red-600 border-red-400 text-white shadow-lg shadow-red-500/20"
                            : "bg-slate-900/80 hover:bg-slate-800 border-white/10 text-white backdrop-blur-md"
                    )}
                >
                    {showAnnotationMode ? (
                        <>
                            <X className="w-4 h-4 mr-2" />
                            Exit Design Mode
                        </>
                    ) : (
                        <>
                            <Pen className="w-4 h-4 mr-2 text-cyan-400" />
                            Tactical Layers
                        </>
                    )}
                </Button>
            )}
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/AnnotationCanvas.tsx">
import React from 'react';
import { Annotation, Point } from '@/hooks/useAnnotations';
import { HomographyMatrix, invertHomography, transformPoint } from '@/utils/homography';

interface AnnotationCanvasProps {
    annotations: Annotation[];
    videoWidth: number;
    videoHeight: number;
    calibrationMatrix?: HomographyMatrix | null;
    calibrationPoints?: Point[];
    onAnnotationClick?: (id: string) => void;
}

export const AnnotationCanvas: React.FC<AnnotationCanvasProps> = ({
    annotations,
    videoWidth,
    videoHeight,
    calibrationMatrix,
    calibrationPoints,
    onAnnotationClick,
}) => {
    const renderAnnotation = (annotation: Annotation) => {
        const { id, type, style } = annotation;
        const commonProps = {
            stroke: style.color,
            strokeWidth: style.strokeWidth,
            opacity: style.opacity,
            fill: 'none',
            strokeDasharray: style.dashed ? '8,4' : 'none',
            className: style.glow ? 'drop-shadow-[0_0_8px_rgba(255,255,255,0.8)]' : '',
            onClick: () => onAnnotationClick?.(id),
            style: { cursor: onAnnotationClick ? 'pointer' : 'default' },
        };

        const invMatrix = calibrationMatrix ? invertHomography(calibrationMatrix) : null;

        /** Helper to get screen point from pitch coords */
        const getScreenPoint = (p: Point): Point => {
            if (!invMatrix) return p;
            return transformPoint(p, invMatrix);
        };

        /** Helper to render a perspective-correct circle (ellipse) on the pitch */
        const renderPerspectiveCircle = (cx: number, cy: number, radiusMeters: number, fill?: boolean) => {
            if (!invMatrix) {
                // Fallback: simple circle with approximate pixel radius
                const pixelRadius = radiusMeters * 10; // Standardized scale factor
                return <circle key={id} cx={cx} cy={cy} r={pixelRadius} {...commonProps} fill={fill ? style.color : 'none'} fillOpacity={fill ? (style.fillOpacity || 0.2) : 0} />;
            }

            const points: Point[] = [];
            const segments = 32;
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const px = cx + radiusMeters * Math.cos(angle);
                const py = cy + radiusMeters * Math.sin(angle);
                points.push(getScreenPoint({ x: px, y: py }));
            }
            const d = `M ${points[0].x} ${points[0].y} ` + points.slice(1).map(p => `L ${p.x} ${p.y}`).join(' ');
            return <path key={id} d={d} {...commonProps} fill={fill ? style.color : 'none'} fillOpacity={fill ? (style.fillOpacity || 0.2) : 0} />;
        };

        switch (type) {
            case 'arrow': {
                let { x1, y1, x2, y2 } = annotation.data;

                if (annotation.pitchCoords && annotation.pitchCoords.endX !== undefined && annotation.pitchCoords.endY !== undefined && invMatrix) {
                    const pt1 = getScreenPoint({ x: annotation.pitchCoords.x, y: annotation.pitchCoords.y });
                    const pt2 = getScreenPoint({ x: annotation.pitchCoords.endX, y: annotation.pitchCoords.endY });
                    x1 = pt1.x; y1 = pt1.y; x2 = pt2.x; y2 = pt2.y;
                }

                const angle = Math.atan2(y2 - y1, x2 - x1);
                const arrowLength = 15;
                const arrowAngle = Math.PI / 6;

                return (
                    <g key={id} {...commonProps}>
                        <line x1={x1} y1={y1} x2={x2} y2={y2} />
                        <line
                            x1={x2}
                            y1={y2}
                            x2={x2 - arrowLength * Math.cos(angle - arrowAngle)}
                            y2={y2 - arrowLength * Math.sin(angle - arrowAngle)}
                        />
                        <line
                            x1={x2}
                            y1={y2}
                            x2={x2 - arrowLength * Math.cos(angle + arrowAngle)}
                            y2={y2 - arrowLength * Math.sin(angle + arrowAngle)}
                        />
                    </g>
                );
            }

            case 'circle': {
                if (annotation.pitchCoords && invMatrix) {
                    // Radius is stored in pixels, convert to meters (assuming 10 pixels = 1 meter)
                    const radiusMeters = annotation.data.radius / 10;
                    return renderPerspectiveCircle(annotation.pitchCoords.x, annotation.pitchCoords.y, radiusMeters, true);
                }

                return (
                    <circle
                        key={id}
                        {...commonProps}
                        cx={annotation.data.cx}
                        cy={annotation.data.cy}
                        r={annotation.data.radius}
                        fill={style.color}
                        fillOpacity={style.fillOpacity || 0.1}
                    />
                );
            }

            case 'spotlight': {
                const { radius } = annotation.data;
                const px = annotation.pitchCoords?.x || 0;
                const py = annotation.pitchCoords?.y || 0;

                if (!invMatrix) return null;

                const baseCenter = getScreenPoint({ x: px, y: py });
                // Convert radius to meters for consistent rendering
                const radiusMeters = radius / 10;
                const groundRing = renderPerspectiveCircle(px, py, radiusMeters, true);

                // Visual height approximation
                const topCenter = { x: baseCenter.x, y: baseCenter.y - 100 };

                return (
                    <g key={id}>
                        <defs>
                            <linearGradient id={`grad-${id}`} x1="0%" y1="100%" x2="0%" y2="0%">
                                <stop offset="0%" stopColor={style.color} stopOpacity={0.6} />
                                <stop offset="100%" stopColor={style.color} stopOpacity={0} />
                            </linearGradient>
                        </defs>
                        {groundRing}
                        <path
                            d={`M ${baseCenter.x - 30} ${baseCenter.y} L ${topCenter.x - 20} ${topCenter.y} L ${topCenter.x + 20} ${topCenter.y} L ${baseCenter.x + 30} ${baseCenter.y} Z`}
                            fill={`url(#grad-${id})`}
                            stroke="none"
                            style={{ filter: 'blur(4px)' }}
                        />
                    </g>
                );
            }

            case 'zone': {
                const { points } = annotation.data;
                let screenPoints = points;

                if (annotation.pitchCoords?.points && invMatrix) {
                    screenPoints = annotation.pitchCoords.points.map(p => getScreenPoint(p));
                }

                if (screenPoints.length < 3) return null;

                const d = `M ${screenPoints[0].x} ${screenPoints[0].y} ` + screenPoints.slice(1).map(p => `L ${p.x} ${p.y}`).join(' ') + ' Z';

                return (
                    <path
                        key={id}
                        {...commonProps}
                        d={d}
                        fill={style.color}
                        fillOpacity={style.fillOpacity || 0.3}
                        strokeDasharray={style.dashed ? '10,5' : 'none'}
                    />
                );
            }

            case 'marker': {
                let { x, y, label } = annotation.data;
                if (annotation.pitchCoords && invMatrix) {
                    const pt = getScreenPoint({ x: annotation.pitchCoords.x, y: annotation.pitchCoords.y });
                    x = pt.x; y = pt.y;
                }
                return (
                    <g key={id} {...commonProps}>
                        <circle cx={x} cy={y} r={6} fill={style.color} stroke="white" strokeWidth="2" />
                        {label && (
                            <text
                                x={x}
                                y={y - 12}
                                fill="white"
                                fontSize="12"
                                fontWeight="bold"
                                textAnchor="middle"
                                style={{ filter: 'drop-shadow(0 0 4px black)' }}
                            >
                                {label}
                            </text>
                        )}
                    </g>
                );
            }

            case 'rectangle': {
                let { x, y, width, height } = annotation.data;

                if (annotation.pitchCoords && annotation.pitchCoords.endX !== undefined && annotation.pitchCoords.endY !== undefined && invMatrix) {
                    const pt1 = getScreenPoint({ x: annotation.pitchCoords.x, y: annotation.pitchCoords.y });
                    const pt2 = getScreenPoint({ x: annotation.pitchCoords.endX, y: annotation.pitchCoords.endY });
                    x = Math.min(pt1.x, pt2.x);
                    y = Math.min(pt1.y, pt2.y);
                    width = Math.abs(pt2.x - pt1.x);
                    height = Math.abs(pt2.y - pt1.y);
                }

                return (
                    <rect
                        key={id}
                        {...commonProps}
                        x={x}
                        y={y}
                        width={width}
                        height={height}
                        fill={style.color}
                        fillOpacity={style.fillOpacity || 0.1}
                    />
                );
            }

            case 'text': {
                const { x, y, text, fontSize } = annotation.data;
                return (
                    <text
                        key={id}
                        {...commonProps}
                        x={x}
                        y={y}
                        fontSize={fontSize}
                        fill={style.color}
                        stroke="none"
                        fontFamily="Arial, sans-serif"
                        fontWeight="bold"
                        textAnchor="middle"
                    >
                        {text}
                    </text>
                );
            }

            case 'player-track': {
                const { points } = annotation.data;
                if (points.length < 2) return null;

                const pathData = points
                    .map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`)
                    .join(' ');

                return (
                    <g key={id} {...commonProps}>
                        <path d={pathData} fill="none" />
                        {points.map((p, i) => (
                            <circle
                                key={`${id}-point-${i}`}
                                cx={p.x}
                                cy={p.y}
                                r={3}
                                fill={style.color}
                                opacity={style.opacity}
                            />
                        ))}
                    </g>
                );
            }

            case 'ruler': {
                let { x1, y1, x2, y2 } = annotation.data;
                let distMeters: string;

                if (annotation.pitchCoords && annotation.pitchCoords.endX !== undefined && annotation.pitchCoords.endY !== undefined && invMatrix) {
                    const pt1 = getScreenPoint({ x: annotation.pitchCoords.x, y: annotation.pitchCoords.y });
                    const pt2 = getScreenPoint({ x: annotation.pitchCoords.endX, y: annotation.pitchCoords.endY });
                    x1 = pt1.x; y1 = pt1.y; x2 = pt2.x; y2 = pt2.y;

                    const dx = annotation.pitchCoords.endX - annotation.pitchCoords.x;
                    const dy = annotation.pitchCoords.endY - annotation.pitchCoords.y;
                    distMeters = Math.sqrt(dx * dx + dy * dy).toFixed(1);
                } else {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const distPx = Math.sqrt(dx * dx + dy * dy);
                    // Use consistent scale factor
                    distMeters = (distPx / 10).toFixed(1);
                }

                return (
                    <g key={id} {...commonProps}>
                        <line x1={x1} y1={y1} x2={x2} y2={y2} strokeDasharray="5,5" />
                        <circle cx={x1} cy={y1} r={4} fill={style.color} />
                        <circle cx={x2} cy={y2} r={4} fill={style.color} />

                        <text
                            x={(x1 + x2) / 2}
                            y={(y1 + y2) / 2 - 12}
                            fill="black"
                            fontSize="14"
                            fontWeight="bold"
                            textAnchor="middle"
                            style={{ filter: 'drop-shadow(0 0 2px white)' }}
                        >
                            {distMeters}m
                        </text>
                        <text
                            x={(x1 + x2) / 2}
                            y={(y1 + y2) / 2 - 12}
                            fill={style.color}
                            fontSize="14"
                            fontWeight="bold"
                            textAnchor="middle"
                        >
                            {distMeters}m
                        </text>
                    </g>
                );
            }

            default:
                return null;
        }
    };

    return (
        <div className="absolute inset-0 pointer-events-none flex items-center justify-center">
            <svg
                className="max-w-full max-h-full"
                viewBox={`0 0 ${videoWidth} ${videoHeight}`}
                preserveAspectRatio="xMidYMid meet"
                style={{
                    pointerEvents: onAnnotationClick ? 'auto' : 'none',
                    aspectRatio: `${videoWidth} / ${videoHeight}`,
                    width: '100%',
                    height: '100%',
                    objectFit: 'contain'
                }}
            >
                {annotations.map(renderAnnotation)}

                {calibrationPoints && calibrationPoints.map((p, i) => (
                    <g key={`calib-pt-${i}`}>
                        <circle
                            cx={p.x}
                            cy={p.y}
                            r={4}
                            fill="#eab308"
                            stroke="white"
                            strokeWidth="1.5"
                        />
                        <text
                            x={p.x}
                            y={p.y + 15}
                            fill="#eab308"
                            fontSize="10"
                            fontWeight="bold"
                            textAnchor="middle"
                            style={{ filter: 'drop-shadow(0 0 2px black)' }}
                        >
                            PT {i + 1}
                        </text>
                    </g>
                ))}
            </svg>
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/AnnotationInteractionLayer.tsx">
import React, { useState, useRef } from 'react';
import { Annotation, AnnotationStyle } from '@/hooks/useAnnotations';
import { AnnotationCanvas } from './AnnotationCanvas';
import { DrawingTool } from './AnnotationToolbar';
import { transformPoint, Point, HomographyMatrix } from '@/utils/homography';
import { screenToVideo } from '@/utils/coords';

interface AnnotationInteractionLayerProps {
    activeTool: DrawingTool;
    color: string;
    strokeWidth: number;
    videoWidth: number;
    videoHeight: number;
    currentTime: number;
    calibration: { pairs: Array<{ src: Point; dst: Point }>; matrix: HomographyMatrix | null };
    onAddAnnotation: (annotation: Omit<Annotation, 'id'>) => void;
}

export const AnnotationInteractionLayer: React.FC<AnnotationInteractionLayerProps> = ({
    activeTool, color, strokeWidth, videoWidth, videoHeight, currentTime, calibration, onAddAnnotation
}) => {
    const [isDrawing, setIsDrawing] = useState(false);
    const [startPoint, setStartPoint] = useState<Point | null>(null);
    const [currentPoint, setCurrentPoint] = useState<Point | null>(null);
    const containerRef = useRef<HTMLDivElement>(null);

    const handleMouseDown = (e: React.MouseEvent) => {
        console.log('InteractionLayer: MouseDown', { activeTool, clientX: e.clientX, clientY: e.clientY });
        if (activeTool === 'select' || activeTool === 'calibration') return;

        const rect = containerRef.current!.getBoundingClientRect();
        const coords = screenToVideo(e.clientX, e.clientY, rect, videoWidth, videoHeight);
        console.log('InteractionLayer: calculated coords', coords);

        if (coords.isOutOfBounds) {
            console.log('InteractionLayer: Out of bounds');
            return;
        }
        setStartPoint(coords);
        setCurrentPoint(coords);
        setIsDrawing(true);
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDrawing || !startPoint) return;
        const coords = screenToVideo(e.clientX, e.clientY, containerRef.current!.getBoundingClientRect(), videoWidth, videoHeight);
        // console.log('Drawing move...', coords);
        setCurrentPoint(coords);
    };

    const handleMouseUp = () => {
        if (!isDrawing || !startPoint || !currentPoint) return;

        // Broadcast styles by default for demo/integrated feel
        const style: AnnotationStyle = {
            color,
            strokeWidth,
            opacity: 1,
            fillOpacity: 0.25,
            glow: activeTool === 'spotlight' || activeTool === 'arrow',
            dashed: activeTool === 'ruler'
        };

        let annotation: any = null;
        let pitchCoords: any = null;

        if (calibration.matrix) {
            const p1 = transformPoint(startPoint, calibration.matrix);
            const p2 = transformPoint(currentPoint, calibration.matrix);

            if (activeTool === 'arrow') {
                annotation = { type: 'arrow', data: { x1: startPoint.x, y1: startPoint.y, x2: currentPoint.x, y2: currentPoint.y } };
                pitchCoords = { x: p1.x, y: p1.y, endX: p2.x, endY: p2.y };
            } else if (activeTool === 'circle') {
                const radiusMeters = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                annotation = { type: 'circle', data: { cx: startPoint.x, cy: startPoint.y, radius: radiusMeters * 10 } };
                pitchCoords = { x: p1.x, y: p1.y };
            } else if (activeTool === 'spotlight') {
                const radiusMeters = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                annotation = { type: 'spotlight', data: { cx: startPoint.x, cy: startPoint.y, radius: radiusMeters * 12 } };
                pitchCoords = { x: p1.x, y: p1.y };
            } else if (activeTool === 'zone') {
                // Create a rectangle in pitch space
                const xMin = Math.min(p1.x, p2.x);
                const xMax = Math.max(p1.x, p2.x);
                const yMin = Math.min(p1.y, p2.y);
                const yMax = Math.max(p1.y, p2.y);
                const rectPoints = [
                    { x: xMin, y: yMin },
                    { x: xMax, y: yMin },
                    { x: xMax, y: yMax },
                    { x: xMin, y: yMax }
                ];
                annotation = { type: 'zone', data: { points: [] } };
                pitchCoords = { points: rectPoints };
            } else if (activeTool === 'marker') {
                annotation = { type: 'marker', data: { x: currentPoint.x, y: currentPoint.y, label: "INFO" } };
                pitchCoords = { x: p2.x, y: p2.y };
            }
        }

        if (annotation) {
            onAddAnnotation({
                ...annotation,
                startTime: currentTime,
                endTime: currentTime + 8,
                style,
                pitchCoords
            });
        }

        setIsDrawing(false);
        setStartPoint(null);
    };

    // Generate preview annotation while dragging
    const previewAnnotation = React.useMemo(() => {
        if (!isDrawing || !startPoint || !currentPoint) return null;

        const style: AnnotationStyle = {
            color,
            strokeWidth,
            opacity: 0.7, // Slightly transparent during draw
            fillOpacity: 0.2,
            glow: activeTool === 'spotlight' || activeTool === 'arrow',
            dashed: activeTool === 'ruler'
        };

        let data: any = {};
        let pitchCoords: any = null;

        if (calibration.matrix) {
            const p1 = transformPoint(startPoint, calibration.matrix);
            const p2 = transformPoint(currentPoint, calibration.matrix);

            if (activeTool === 'arrow') {
                data = { x1: startPoint.x, y1: startPoint.y, x2: currentPoint.x, y2: currentPoint.y };
                pitchCoords = { x: p1.x, y: p1.y, endX: p2.x, endY: p2.y };
            } else if (activeTool === 'circle') {
                const radiusMeters = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                data = { cx: startPoint.x, cy: startPoint.y, radius: radiusMeters * 10 }; // Approx pixel fallback
                pitchCoords = { x: p1.x, y: p1.y };
            } else if (activeTool === 'spotlight') {
                const radiusMeters = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                data = { cx: startPoint.x, cy: startPoint.y, radius: radiusMeters * 12 };
                pitchCoords = { x: p1.x, y: p1.y };
            } else if (activeTool === 'zone') {
                // Zone preview - simple rect for now
                const xMin = Math.min(p1.x, p2.x);
                const xMax = Math.max(p1.x, p2.x);
                const yMin = Math.min(p1.y, p2.y);
                const yMax = Math.max(p1.y, p2.y);
                const rectPoints = [
                    { x: xMin, y: yMin },
                    { x: xMax, y: yMin },
                    { x: xMax, y: yMax },
                    { x: xMin, y: yMax }
                ];
                data = { points: [] }; // Points will be computed by canvas from pitchCoords
                pitchCoords = { points: rectPoints };
            } else if (activeTool === 'marker') {
                data = { x: currentPoint.x, y: currentPoint.y, label: "INFO" };
                pitchCoords = { x: p2.x, y: p2.y };
            } else if (activeTool === 'ruler') {
                data = { x1: startPoint.x, y1: startPoint.y, x2: currentPoint.x, y2: currentPoint.y };
                pitchCoords = { x: p1.x, y: p1.y, endX: p2.x, endY: p2.y };
            }
        } else {
            // Fallback for non-calibrated (pixel space)
            if (activeTool === 'arrow') data = { x1: startPoint.x, y1: startPoint.y, x2: currentPoint.x, y2: currentPoint.y };
            else if (activeTool === 'circle') data = { cx: startPoint.x, cy: startPoint.y, radius: Math.hypot(currentPoint.x - startPoint.x, currentPoint.y - startPoint.y) };
            else if (activeTool === 'ruler') data = { x1: startPoint.x, y1: startPoint.y, x2: currentPoint.x, y2: currentPoint.y };
        }

        if (Object.keys(data).length === 0 && !pitchCoords) return null;

        return {
            id: 'preview',
            type: activeTool as Annotation['type'],
            data,
            style,
            pitchCoords,
            startTime: 0,
            endTime: 0
        } as Annotation;

    }, [isDrawing, startPoint, currentPoint, activeTool, color, strokeWidth, calibration.matrix]);

    return (
        <div ref={containerRef} className="absolute inset-0 z-[100] cursor-crosshair" onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp}>
            {/* Canvas for rendering drawings - calibration points now rendered by AnnotationCanvas */}
            <AnnotationCanvas
                annotations={previewAnnotation ? [previewAnnotation] : []}
                videoWidth={videoWidth}
                videoHeight={videoHeight}
                calibrationPoints={calibration.pairs.map(p => p.src)}
                calibrationMatrix={calibration.matrix}
            />
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/AnnotationToolbar.tsx">
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import {
    MousePointer2,
    ArrowRight,
    Circle,
    Square,
    Type,
    User,
    Trash2,
    Undo,
    Download,
    Upload,
    Ruler,
    Crosshair,
    Target
} from 'lucide-react';
import { AnnotationType } from '@/hooks/useAnnotations';

export type DrawingTool = AnnotationType | 'select' | 'calibration';

interface AnnotationToolbarProps {
    activeTool: DrawingTool;
    onToolChange: (tool: DrawingTool) => void;
    color: string;
    onColorChange: (color: string) => void;
    strokeWidth: number;
    onStrokeWidthChange: (width: number) => void;
    onClear: () => void;
    onUndo: () => void;
    onExport: () => void;
    onImport: (file: File) => void;
}

export const AnnotationToolbar: React.FC<AnnotationToolbarProps> = ({
    activeTool,
    onToolChange,
    color,
    onColorChange,
    strokeWidth,
    onStrokeWidthChange,
    onClear,
    onUndo,
    onExport,
    onImport,
}) => {
    const [showColorPicker, setShowColorPicker] = useState(false);

    const tools: Array<{ id: DrawingTool; icon: React.ReactNode; label: string }> = [
        { id: 'select', icon: <MousePointer2 className="w-4 h-4" />, label: 'Select' },
        { id: 'spotlight', icon: <Crosshair className="w-4 h-4 text-cyan-400" />, label: 'Spotlight' },
        { id: 'zone', icon: <Square className="w-4 h-4" />, label: 'Zone area' },
        { id: 'arrow', icon: <ArrowRight className="w-4 h-4" />, label: 'Arrow/Line' },
        { id: 'ruler', icon: <Ruler className="w-4 h-4" />, label: 'Distance Ruler' },
        { id: 'circle', icon: <Circle className="w-4 h-4" />, label: 'Circle' },
        { id: 'marker', icon: <User className="w-4 h-4" />, label: 'Marker' },
        { id: 'text', icon: <Type className="w-4 h-4" />, label: 'Text' },
        { id: 'calibration', icon: <Target className="w-4 h-4 text-yellow-500" />, label: 'Pitch Calibration' },
    ];

    const presetColors = [
        '#FF0000', // Red
        '#00FF00', // Green
        '#22d3ee', // Cyan (Neon)
        '#FFFF00', // Yellow
        '#FF00FF', // Magenta
        '#FFFFFF', // White
        '#FB923C', // Orange
        '#000000', // Black
    ];

    const handleFileImport = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            onImport(file);
        }
    };

    return (
        <div className="absolute top-16 right-4 bottom-24 bg-black/90 backdrop-blur-md rounded-xl p-3 flex flex-col items-center gap-4 z-50 border border-white/10 shadow-2xl overflow-y-auto custom-scrollbar max-w-[64px]">
            {/* Drawing Tools */}
            <div className="flex flex-col gap-2 w-full border-b border-white/10 pb-4">
                <span className="text-[10px] uppercase text-white/40 font-bold tracking-wider text-center">Tools</span>
                {tools.map((tool) => (
                    <Button
                        key={tool.id}
                        variant={activeTool === tool.id ? 'default' : 'ghost'}
                        size="icon"
                        onClick={() => onToolChange(tool.id)}
                        className={`h-10 w-10 transition-all ${activeTool === tool.id ? 'bg-primary text-primary-foreground shadow-lg scale-105' : 'text-white/70 hover:text-white hover:bg-white/10'}`}
                        title={tool.label}
                    >
                        {tool.icon}
                    </Button>
                ))}
            </div>

            {/* Properties */}
            <div className="flex flex-col gap-3 w-full border-b border-white/10 pb-4 items-center">
                <span className="text-[10px] uppercase text-white/40 font-bold tracking-wider text-center">Style</span>

                {/* Color Picker Trigger */}
                <div className="relative">
                    <button
                        onClick={() => setShowColorPicker(!showColorPicker)}
                        className="w-8 h-8 rounded-full border-2 border-white/20 shadow-inner transition-transform hover:scale-110"
                        style={{ backgroundColor: color }}
                        title="Color"
                    />
                    {showColorPicker && (
                        <div className="absolute right-full mr-4 top-1/2 transform -translate-y-1/2 bg-black/95 border border-white/10 p-3 rounded-xl grid grid-cols-4 gap-2 shadow-xl w-48">
                            {presetColors.map((c) => (
                                <button
                                    key={c}
                                    onClick={() => {
                                        onColorChange(c);
                                        setShowColorPicker(false);
                                    }}
                                    className="w-8 h-8 rounded-full border border-white/10 hover:scale-110 transition-transform shadow-sm"
                                    style={{ backgroundColor: c }}
                                />
                            ))}
                        </div>
                    )}
                </div>

                {/* Broadcast Style Toggles (Simplified representation - in real app we'd need props for these) */}
                <div className="flex flex-col gap-2">
                    <div className="w-8 h-8 rounded bg-white/5 border border-white/10 flex items-center justify-center cursor-pointer hover:bg-white/10" title="Toggle Dash">
                        <span className="text-[8px] font-bold text-white/40">DASH</span>
                    </div>
                    <div className="w-8 h-8 rounded bg-white/5 border border-white/10 flex items-center justify-center cursor-pointer hover:bg-white/10" title="Toggle Glow">
                        <span className="text-[8px] font-bold text-cyan-400">GLOW</span>
                    </div>
                </div>

                {/* Stroke Width */}
                <div className="flex flex-col items-center gap-1 w-full px-1">
                    <input
                        type="range"
                        min="1"
                        max="10"
                        value={strokeWidth}
                        onChange={(e) => onStrokeWidthChange(Number(e.target.value))}
                        className="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer accent-primary"
                        title={`Width: ${strokeWidth}px`}
                    />
                </div>
            </div>

            {/* Actions */}
            <div className="flex flex-col gap-2 w-full">
                <span className="text-[10px] uppercase text-white/40 font-bold tracking-wider text-center">Actions</span>
                <div className="grid grid-cols-2 gap-2">
                    <Button
                        variant="ghost"
                        size="icon"
                        onClick={onUndo}
                        className="h-8 w-8 text-white/70 hover:text-white hover:bg-white/10"
                        title="Undo"
                    >
                        <Undo className="w-4 h-4" />
                    </Button>
                    <Button
                        variant="ghost"
                        size="icon"
                        onClick={onClear}
                        className="h-8 w-8 text-red-400 hover:text-red-300 hover:bg-red-900/20"
                        title="Clear All"
                    >
                        <Trash2 className="w-4 h-4" />
                    </Button>
                    <Button
                        variant="ghost"
                        size="icon"
                        onClick={onExport}
                        className="h-8 w-8 text-white/70 hover:text-white hover:bg-white/10"
                        title="Export"
                    >
                        <Download className="w-4 h-4" />
                    </Button>
                    <label className="h-8 w-8 flex items-center justify-center text-white/70 hover:text-white hover:bg-white/10 rounded-md cursor-pointer transition-colors" title="Import">
                        <Upload className="w-4 h-4" />
                        <input
                            type="file"
                            accept=".json"
                            onChange={handleFileImport}
                            className="hidden"
                        />
                    </label>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/CalibrationInterface.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { useMatchContext } from '@/contexts/MatchContext';
import { Card } from '@/components/ui/card';
import { X, RotateCcw, Undo2, Wand2, Loader2, AlertCircle } from 'lucide-react';
import PitchMap from '../PitchMap';
import { Point, screenToVideo, videoToCSS } from '@/utils/coords';
import {
    detectPitchKeypoints,
    detectPlayers,
    keypointsToCalibrationPairs,
    getKeypointName,
    fileToBase64,
    CalibrationPair,
    DetectedPlayer
} from '@/utils/roboflowApi';

interface CalibrationInterfaceProps {
    videoUrl?: string | null;
    isImage?: boolean;
    currentTime?: number;
    onAddPair: (src: Point, dst: Point) => void;
    onRemoveLast: () => void;
    onClear: () => void;
    onClose: () => void;
    currentPairs: Array<{ src: Point; dst: Point }>;
    onAutoDetect?: (pairs: Array<{ src: Point; dst: Point }>) => void;
}

export const CalibrationInterface: React.FC<CalibrationInterfaceProps> = ({
    videoUrl, isImage = false, currentTime = 0, onAddPair, onRemoveLast, onClear, onClose, currentPairs, onAutoDetect
}) => {
    const [pendingSrc, setPendingSrc] = useState<Point | null>(null);
    const [videoDims, setVideoDims] = useState({ w: 0, h: 0 });
    const [isDetecting, setIsDetecting] = useState(false);
    const { setRealtimeDetections } = useMatchContext();
    const [detectionError, setDetectionError] = useState<string | null>(null);
    const [autoDetectedPairs, setAutoDetectedPairs] = useState<CalibrationPair[]>([]);
    const [detectedPlayers, setDetectedPlayers] = useState<DetectedPlayer[]>([]);
    const [useHighContrast, setUseHighContrast] = useState(false);

    const videoRef = useRef<HTMLVideoElement>(null);
    const imgRef = useRef<HTMLImageElement>(null);
    const containerRef = useRef<HTMLDivElement>(null);

    const handleLoadedMetadata = (e: React.SyntheticEvent<HTMLVideoElement>) => {
        setVideoDims({ w: e.currentTarget.videoWidth, h: e.currentTarget.videoHeight });
        e.currentTarget.currentTime = currentTime;
    };

    const handleImageLoad = (e: React.SyntheticEvent<HTMLImageElement>) => {
        setVideoDims({ w: e.currentTarget.naturalWidth, h: e.currentTarget.naturalHeight });
    };

    // Synchronize video currentTime
    useEffect(() => {
        if (!isImage && videoRef.current && currentTime !== undefined) {
            videoRef.current.currentTime = currentTime;
        }
    }, [currentTime, isImage]);

    // Auto-trigger player detection when we have enough pairs
    useEffect(() => {
        if (currentPairs.length >= 4 && detectedPlayers.length === 0 && !isDetecting) {
            runPlayerDetection();
        }
    }, [currentPairs.length]);

    const captureFrame = async (): Promise<string> => {
        const canvas = document.createElement('canvas');
        if (isImage && imgRef.current) {
            canvas.width = imgRef.current.naturalWidth;
            canvas.height = imgRef.current.naturalHeight;
            const ctx = canvas.getContext('2d');
            if (!ctx) throw new Error('Could not get canvas context');
            ctx.drawImage(imgRef.current, 0, 0);
        } else if (videoRef.current) {
            canvas.width = videoRef.current.videoWidth;
            canvas.height = videoRef.current.videoHeight;
            const ctx = canvas.getContext('2d');
            if (!ctx) throw new Error('Could not get canvas context');
            ctx.drawImage(videoRef.current, 0, 0);
        } else {
            throw new Error('No media element available');
        }
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        return dataUrl.split(',')[1];
    };

    const runPlayerDetection = async (pairs = currentPairs) => {
        if (!videoUrl || pairs.length < 4) return;
        try {
            const imageBase64 = await captureFrame();
            const playerResult = await detectPlayers(imageBase64, undefined, useHighContrast);
            if (playerResult.success) {
                setDetectedPlayers(playerResult.players);
                setRealtimeDetections(playerResult.players);
            }
        } catch (e) {
            console.warn('On-demand player detection failed:', e);
        }
    };

    const handleVideoClick = (e: React.MouseEvent) => {
        if (!containerRef.current || videoDims.w === 0) return;
        const coords = screenToVideo(e.clientX, e.clientY, containerRef.current.getBoundingClientRect(), videoDims.w, videoDims.h);
        if (!coords.isOutOfBounds) setPendingSrc({ x: coords.x, y: coords.y });
    };

    const handleAutoDetect = async () => {
        setIsDetecting(true);
        setDetectionError(null);
        try {
            const imageBase64 = await captureFrame();
            const result = await detectPitchKeypoints(imageBase64);

            if (!result.predictions || result.predictions.length === 0) {
                setDetectionError('No pitch keypoints detected. Try with a clearer view of the pitch.');
                return;
            }

            const pairs = keypointsToCalibrationPairs(result.predictions, 0.3);
            if (pairs.length === 0) {
                setDetectionError('Detected keypoints could not be mapped to pitch coordinates.');
                return;
            }

            setAutoDetectedPairs(pairs);
            pairs.forEach(pair => onAddPair(pair.src, pair.dst));

            // Also detect players
            const playerResult = await detectPlayers(imageBase64, undefined, useHighContrast);
            if (playerResult.success) {
                setDetectedPlayers(playerResult.players);
                setRealtimeDetections(playerResult.players);
            }

            if (onAutoDetect) {
                onAutoDetect(pairs.map(p => ({ src: p.src, dst: p.dst })));
            }
        } catch (error) {
            console.error('Auto-detection failed:', error);
            setDetectionError(error instanceof Error ? error.message : 'Detection failed. Check API configuration.');
        } finally {
            setIsDetecting(false);
        }
    };

    const renderDot = (pt: Point, label: string | number, colorClass: string, confidence?: number) => {
        if (!containerRef.current || videoDims.w === 0) return null;
        const style = videoToCSS(pt, containerRef.current.getBoundingClientRect(), videoDims.w, videoDims.h);
        return (
            <div
                key={`${pt.x}-${pt.y}-${label}`}
                className={`absolute w-5 h-5 ${colorClass} rounded-full border border-white flex items-center justify-center text-[9px] font-bold shadow-lg -translate-x-1/2 -translate-y-1/2 z-20`}
                style={style}
                title={confidence ? `Confidence: ${(confidence * 100).toFixed(0)}%` : undefined}
            >
                {label}
            </div>
        );
    };

    const isAutoDetected = (pair: { src: Point; dst: Point }) => {
        return autoDetectedPairs.some(ap =>
            Math.abs(ap.src.x - pair.src.x) < 5 && Math.abs(ap.src.y - pair.src.y) < 5
        );
    };

    return (
        <div className="fixed inset-0 z-[100] bg-black/90 flex items-center justify-center p-8 backdrop-blur-md">
            <Card className="w-full max-w-6xl bg-zinc-950 border-zinc-800 text-white overflow-hidden flex flex-col h-[85vh]">
                <div className="p-4 border-b border-zinc-800 flex justify-between items-center">
                    <div className="flex items-center gap-4">
                        <h2 className="text-xl font-bold">Calibration Step {currentPairs.length + 1}</h2>
                        {autoDetectedPairs.length > 0 && (
                            <span className="text-xs bg-green-600/20 text-green-400 px-2 py-1 rounded-full">
                                {autoDetectedPairs.length} auto-detected
                            </span>
                        )}
                    </div>
                    <div className="flex items-center gap-3">
                        <div className="flex items-center gap-2 mr-2 px-3 py-1.5 bg-zinc-900 rounded-md border border-zinc-800">
                            <input
                                type="checkbox"
                                id="high-contrast"
                                checked={useHighContrast}
                                onChange={(e) => setUseHighContrast(e.target.checked)}
                                className="w-4 h-4 rounded border-zinc-700 bg-zinc-800 text-blue-600 focus:ring-blue-500"
                            />
                            <label htmlFor="high-contrast" className="text-xs font-medium text-zinc-300 cursor-pointer">
                                High Contrast Teams
                            </label>
                        </div>
                        <div className="flex gap-2">
                            <Button
                                variant="default"
                                size="sm"
                                onClick={handleAutoDetect}
                                disabled={isDetecting || !videoUrl}
                                className="bg-purple-600 hover:bg-purple-700"
                            >
                                {isDetecting ? (
                                    <>
                                        <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                                        Detecting...
                                    </>
                                ) : (
                                    <>
                                        <Wand2 className="w-4 h-4 mr-2" />
                                        Auto-Detect
                                    </>
                                )}
                            </Button>
                            <Button variant="outline" size="sm" onClick={onRemoveLast} disabled={currentPairs.length === 0}>
                                <Undo2 className="w-4 h-4 mr-2" /> Undo
                            </Button>
                            <Button variant="outline" size="sm" onClick={() => { onClear(); setAutoDetectedPairs([]); setDetectedPlayers([]); }}>
                                <RotateCcw className="w-4 h-4 mr-2" /> Reset
                            </Button>
                            <Button variant="ghost" size="icon" onClick={onClose}>
                                <X className="w-5 h-5" />
                            </Button>
                        </div>
                    </div>
                </div>

                {detectionError && (
                    <div className="mx-6 mt-4 p-3 bg-red-900/30 border border-red-700 rounded-lg flex items-center gap-3">
                        <AlertCircle className="w-5 h-5 text-red-400 shrink-0" />
                        <div className="flex-1">
                            <p className="text-sm text-red-300">{detectionError}</p>
                        </div>
                        <Button variant="ghost" size="sm" onClick={() => setDetectionError(null)}>
                            <X className="w-4 h-4" />
                        </Button>
                    </div>
                )}

                <div className="flex-1 flex gap-6 p-6 overflow-hidden bg-black/50">
                    <div ref={containerRef} className="relative flex-1 bg-zinc-900 rounded-xl overflow-hidden cursor-crosshair border border-zinc-800" onClick={handleVideoClick}>
                        {videoUrl && (isImage
                            ? <img ref={imgRef} src={videoUrl} onLoad={handleImageLoad} className="w-full h-full object-contain pointer-events-none" alt="Calibration" crossOrigin="anonymous" />
                            : <video ref={videoRef} src={videoUrl} onLoadedMetadata={handleLoadedMetadata} className="w-full h-full object-contain pointer-events-none" crossOrigin="anonymous" />
                        )}

                        {isDetecting && (
                            <div className="absolute inset-0 bg-black/60 flex items-center justify-center z-30">
                                <div className="text-center">
                                    <Loader2 className="w-12 h-12 text-purple-400 animate-spin mx-auto mb-3" />
                                    <p className="text-white font-medium">Detecting pitch keypoints...</p>
                                    <p className="text-zinc-400 text-sm">Using Roboflow AI</p>
                                </div>
                            </div>
                        )}

                        {pendingSrc && renderDot(pendingSrc, "!", "bg-yellow-500 animate-pulse")}
                        {currentPairs.map((pair, i) => {
                            const isAuto = isAutoDetected(pair);
                            return renderDot(
                                pair.src,
                                i + 1,
                                isAuto ? "bg-green-500" : "bg-blue-600",
                                isAuto ? autoDetectedPairs.find(ap => Math.abs(ap.src.x - pair.src.x) < 5)?.confidence : undefined
                            );
                        })}
                    </div>
                    <div className="w-[420px] flex flex-col gap-4">
                        <PitchMap
                            className="flex-1"
                            onPointClick={(dst) => {
                                if (pendingSrc) {
                                    onAddPair(pendingSrc, dst);
                                    setPendingSrc(null);
                                }
                            }}
                            calibrationPoints={currentPairs.map((p, i) => ({ pitch: p.dst, label: i + 1 }))}
                            playerPositions={detectedPlayers.map(p => ({
                                x: p.pitch_coords ? p.pitch_coords[0] : -1,
                                y: p.pitch_coords ? p.pitch_coords[1] : -1,
                                team: p.team
                            })).filter(p => p.x !== -1)}
                        />

                        <div className="bg-zinc-900/50 rounded-lg p-3 text-xs">
                            <p className="text-zinc-400 mb-2 font-medium">Legend:</p>
                            <div className="flex gap-4">
                                <div className="flex items-center gap-2">
                                    <div className="w-3 h-3 bg-green-500 rounded-full border border-white"></div>
                                    <span className="text-zinc-300">Auto</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <div className="w-3 h-3 bg-blue-600 rounded-full border border-white"></div>
                                    <span className="text-zinc-300">Manual</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <div className="w-3 h-3 bg-yellow-500 rounded-full border border-white"></div>
                                    <span className="text-zinc-300">Pending</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div className="p-4 bg-zinc-950 border-t border-zinc-800 flex justify-between items-center">
                    <p className="text-xs text-zinc-500">
                        {currentPairs.length >= 4
                            ? `‚úì ${currentPairs.length} points mapped - calibration ready`
                            : `Need at least 4 points (${4 - currentPairs.length} more required)`
                        }
                    </p>
                    <Button disabled={currentPairs.length < 4} onClick={onClose} className="px-12 bg-blue-600 hover:bg-blue-700">
                        Save Calibration
                    </Button>
                </div>
            </Card>
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/index.tsx">
import { useRef, useEffect, useState, useCallback } from "react";
import { API_BASE_URL, ANALYSIS_API_URL } from "@/utils/apiConfig";
import { Button } from "@/components/ui/button";
import MappingOverlay from "../MappingOverlay";
import { ZoomIn, ZoomOut, RotateCcw, Sparkles, Settings, Flame, SkipBack, SkipForward } from "lucide-react";
import { LoggedEvent } from "@/hooks/useGamepad";
import { TeamRoster } from "@/types/player";
import { useToast } from "@/hooks/use-toast";
import { VideoOverlay } from "./VideoOverlay";
import { QuickPlayerSelector } from "../QuickPlayerSelector";
import { QuickSelectorState } from "@/hooks/useGamepad";
import { Timeline } from "./Timeline";
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { LiveEventToast } from "../Index/LiveEventToast";
import { StatisticsDashboard } from "../StatisticsDashboard";
import { DashboardWidget } from "../common/DashboardWidget";
import { LayoutConfig } from "@/hooks/useDashboardLayout";

interface VideoPlayerProps {
    videoFile: File | null;
    videoUrl?: string | null; // For remote video URLs
    events: LoggedEvent[];
    onTimeUpdate: (currentTime: number) => void;
    onEventMarkerClick?: (event: LoggedEvent) => void;
    seekTo?: number | null;
    isPlaying?: boolean;
    onPlayPause?: (isPlaying: boolean) => void;
    onSeekComplete?: () => void;
    onSeek?: (time: number) => void;
    axes?: number[];
    buttons?: GamepadButton[];
    teams?: Map<string, TeamRoster>;
    selectedTeam?: string;
    teamNames?: { teamA: string, teamB: string };
    onPlayerSelect?: (playerId: number) => void;
    onAnalysisComplete?: (data: any) => void;
    quickSelectorState?: QuickSelectorState;
    currentTime?: number; // Added prop
    timelineVariant?: 'minimal' | 'pro';
    showLiveToasts?: boolean;
    analysisMode?: 'LIVE' | 'POST_MATCH'; // Controls D-Pad behavior
    isEditMode?: boolean;
    layoutConfig?: LayoutConfig;
    onToggleVisibility?: (id: string) => void;
}

export const VideoPlayer = ({
    videoFile,
    videoUrl: remoteVideoUrl,
    events,
    onTimeUpdate,
    seekTo,
    isPlaying: externalIsPlaying,
    onPlayPause,
    onSeekComplete,
    onSeek,
    axes,
    buttons,
    teams,
    selectedTeam,
    teamNames,
    onPlayerSelect,
    onAnalysisComplete,
    quickSelectorState,
    currentTime = 0, // Default
    timelineVariant = 'minimal',
    showLiveToasts = true,
    analysisMode, // Destructure analysisMode
    isEditMode = false,
    layoutConfig = {},
    onToggleVisibility
}: VideoPlayerProps) => {
    const videoRef = useRef<HTMLVideoElement>(null);
    const prevStartButtonState = useRef(false);
    const prevViewButtonState = useRef(false);
    const prevLeftButtonState = useRef(false);
    const prevRightButtonState = useRef(false);
    const { toast } = useToast();

    const fullscreenContainerRef = useRef<HTMLDivElement>(null);

    // State
    const [zoomLevel, setZoomLevel] = useState(1);
    const [pan, setPan] = useState({ x: 0, y: 0 });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const [duration, setDuration] = useState(0);

    const [videoUrl, setVideoUrl] = useState<string | null>(null);
    const [eventNotifications, setEventNotifications] = useState<Array<{ id: number; event: LoggedEvent; timestamp: number }>>([]);
    const [showRoster, setShowRoster] = useState(false);
    const [trackingData, setTrackingData] = useState<any>(null);
    const [visiblePlayers, setVisiblePlayers] = useState<any[]>([]);
    const [remoteUrl, setRemoteUrl] = useState("");
    const [showSettings, setShowSettings] = useState(false);
    const [analyzeFullVideo, setAnalyzeFullVideo] = useState(false);
    const [generateVideo, setGenerateVideo] = useState(false);
    const [showHeatmap, setShowHeatmap] = useState(false);
    const [passingPredictions, setPassingPredictions] = useState<any[]>([]);
    const [tacticalAlerts, setTacticalAlerts] = useState<any[]>([]);

    const [isFullscreen, setIsFullscreen] = useState(false); // Track full screen state

    const isImage = videoFile?.type.startsWith('image/');

    // Load video URL
    useEffect(() => {
        if (videoFile) {
            const url = URL.createObjectURL(videoFile);
            setVideoUrl(url);
            return () => URL.revokeObjectURL(url);
        } else if (remoteVideoUrl) {
            // Use remote URL from server
            setVideoUrl(`${API_BASE_URL}${remoteVideoUrl}`);
        }
    }, [videoFile, remoteVideoUrl]);

    // Fullscreen listener
    useEffect(() => {
        const handleFullscreenChange = () => {
            setIsFullscreen(!!document.fullscreenElement);
        };
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
    }, []);

    // Handle seekTo prop
    useEffect(() => {
        if (seekTo !== null && seekTo !== undefined && videoRef.current) {
            if (Number.isFinite(seekTo)) {
                console.log(`üé• Seeking to: ${seekTo}`);
                videoRef.current.currentTime = seekTo;
                onSeekComplete?.();
            } else {
                console.warn("‚ö†Ô∏è Ignored seekTo with non-finite value:", seekTo);
            }
        }
    }, [seekTo, onSeekComplete]);

    // Update visible players based on current time
    useEffect(() => {
        if (!trackingData?.tracks || !videoRef.current) return;

        const updatePlayers = () => {
            const currentTime = videoRef.current!.currentTime;
            const fps = trackingData.metadata?.fps || 30;
            const currentFrame = Math.floor(currentTime * fps);

            const players: any[] = [];
            Object.entries(trackingData.tracks).forEach(([id, track]: [string, any]) => {
                const point = track.find((p: any) => p.frame === currentFrame);
                if (point) {
                    players.push({
                        id: parseInt(id),
                        x: (point.x / (trackingData.metadata?.width || 1920)) * 100,
                        y: (point.y / (trackingData.metadata?.height || 1080)) * 100,
                        team: point.team,
                        confidence: point.confidence,
                        speed: point.velocity,
                        is_sprinting: point.is_sprinting
                    });
                }
            });

            setVisiblePlayers(players);
        };

        const interval = setInterval(updatePlayers, 100);
        return () => clearInterval(interval);
    }, [trackingData]);

    const handleRunAnalysis = async () => {
        if (!videoFile) {
            toast({
                title: "Analysis Failed",
                description: "Please load a video first.",
                variant: "destructive"
            });
            return;
        }

        toast({
            title: "Starting Analysis",
            description: analyzeFullVideo ? "Analyzing entire video..." : `Analyzing ${events.length} event clips.`,
        });

        const formData = new FormData();
        formData.append('video', videoFile);

        if (!analyzeFullVideo && events.length > 0) {
            const clips = events.map(e => ({
                start: Math.max(0, (e.videoTime || 0) - 5),
                end: (e.videoTime || 0) + 5
            }));
            formData.append('clips', JSON.stringify(clips));
        }

        if (generateVideo) {
            formData.append('generate_annotated_video', 'true');
        }

        const headers: Record<string, string> = {};
        if (remoteUrl) {
            headers['x-remote-url'] = remoteUrl;
        }

        try {
            const response = await fetch(`${ANALYSIS_API_URL}/api/analyze-match`, {
                method: 'POST',
                headers,
                body: formData
            });

            const data = await response.json();

            if (data.success) {
                setTrackingData(data.results);
                onAnalysisComplete?.(data.results);

                if (data.results.passing_predictions) {
                    setPassingPredictions(data.results.passing_predictions);
                }
                if (data.results.tactical_alerts) {
                    const alerts = data.results.tactical_alerts.map((a: any, idx: number) => ({
                        ...a,
                        id: Number(`${Date.now()}${Math.floor(Math.random() * 1000)}${idx}`),
                        timestamp: Date.now()
                    }));
                    setTacticalAlerts(alerts);
                }

                let description = `Tracked ${Object.keys(data.results.tracks || {}).length} players.`;
                if (data.results.metadata?.annotated_video) {
                    description += ` Video saved: ${data.results.metadata.annotated_video} `;
                }

                toast({
                    title: "Analysis Complete",
                    description,
                });
            } else {
                throw new Error(data.error || 'Analysis failed');
            }
        } catch (error) {
            console.error(error);
            toast({
                title: "Error",
                description: "Failed to run analysis. Check console.",
                variant: "destructive"
            });
        }
    };

    const handleStepFrame = useCallback((direction: 'forward' | 'backward') => {
        if (!videoRef.current) return;

        // Only step frames when video is paused to avoid playback disruption
        if (!videoRef.current.paused) {
            console.info('üé• Frame step skipped - video is playing');
            return;
        }

        // Default to 25fps if no metadata (0.04s per frame)
        const frameDuration = trackingData?.metadata?.fps ? (1 / trackingData.metadata.fps) : 0.04;

        const newTime = direction === 'forward'
            ? videoRef.current.currentTime + frameDuration
            : videoRef.current.currentTime - frameDuration;

        if (Number.isFinite(newTime)) {
            videoRef.current.currentTime = Math.max(0, Math.min(newTime, videoRef.current.duration));
            onTimeUpdate(videoRef.current.currentTime);
        }
    }, [onTimeUpdate, trackingData?.metadata?.fps]);

    // Zoom and Pan Handlers
    const handleZoomIn = () => setZoomLevel(prev => Math.min(prev + 0.5, 4));
    const handleZoomOut = () => {
        setZoomLevel(prev => {
            const newZoom = Math.max(prev - 0.5, 1);
            if (newZoom === 1) setPan({ x: 0, y: 0 }); // Reset pan on full zoom out
            return newZoom;
        });
    };
    const handleResetZoom = () => {
        setZoomLevel(1);
        setPan({ x: 0, y: 0 });
    };

    const handleMouseDown = (e: React.MouseEvent) => {
        if (zoomLevel > 1) {
            setIsDragging(true);
            setDragStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
        }
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (isDragging && zoomLevel > 1) {
            setPan({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y
            });
        }
    };

    const handleMouseUp = () => setIsDragging(false);
    const handleMouseLeave = () => setIsDragging(false);

    // Gamepad Zoom/Pan Controls
    useEffect(() => {
        if (!buttons || !axes) return;

        // SKIP if Quick Selector is Open (D-Pad is used for grid)
        if (quickSelectorState?.isOpen) return;

        // R2 (button 7) = Zoom In, L2 (button 6) = Zoom Out
        const r2 = buttons[7];
        const l2 = buttons[6];

        if (r2?.pressed) {
            handleZoomIn();
        }
        if (l2?.pressed) {
            handleZoomOut();
        }

        // Right Stick (axes 2, 3) for panning when zoomed
        if (zoomLevel > 1 && axes.length >= 4) {
            const rightStickX = axes[2];
            const rightStickY = axes[3];
            const threshold = 0.2;

            if (Math.abs(rightStickX) > threshold || Math.abs(rightStickY) > threshold) {
                setPan(prev => ({
                    x: prev.x + rightStickX * 10,
                    y: prev.y + rightStickY * 10
                }));
            }
        }

        // START Button (9) for Play/Pause
        const startButton = buttons[9];
        if (startButton?.pressed && !prevStartButtonState.current) {
            onPlayPause?.(!externalIsPlaying);
            toast({
                title: !externalIsPlaying ? "‚ñ∂ Playing" : "‚è∏ Paused",
                duration: 1000,
            });
        }
        prevStartButtonState.current = startButton?.pressed || false;

        // VIEW Button (8) for Fullscreen Toggle
        const viewButton = buttons[8];
        if (viewButton?.pressed && !prevViewButtonState.current) {
            if (!document.fullscreenElement) {
                fullscreenContainerRef.current?.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable fullscreen: ${err.message} `);
                });
            } else {
                document.exitFullscreen();
            }
        }
        prevViewButtonState.current = viewButton?.pressed || false;

        // D-Pad Frame Stepping - ONLY in POST_MATCH mode AND when video is paused
        // In LIVE mode, D-Pad is reserved for event tagging
        const allowFrameStep = analysisMode === 'POST_MATCH' && !externalIsPlaying;

        if (allowFrameStep) {
            // D-Pad Left (14) = Prev Frame
            const leftButton = buttons[14];
            if (leftButton?.pressed && !prevLeftButtonState.current) {
                handleStepFrame('backward');
            }
            prevLeftButtonState.current = leftButton?.pressed || false;

            // D-Pad Right (15) = Next Frame
            const rightButton = buttons[15];
            if (rightButton?.pressed && !prevRightButtonState.current) {
                handleStepFrame('forward');
            }
            prevRightButtonState.current = rightButton?.pressed || false;
        } else {
            // Reset state refs and skip expensive seek logic during active playback
            if (prevLeftButtonState.current) prevLeftButtonState.current = false;
            if (prevRightButtonState.current) prevRightButtonState.current = false;
        }

        // Left Stick (Axis 0) - Shuttle Control (Speed & Rewind) - Optimized
        if (axes.length >= 1) {
            const shuttleX = axes[0];
            const shuttleThreshold = 0.25; // Slightly higher threshold to avoid drift lag

            if (Math.abs(shuttleX) > shuttleThreshold) {
                if (videoRef.current) {
                    if (shuttleX > 0) {
                        // Fast Forward (Variable Speed)
                        const rate = 1 + (shuttleX - shuttleThreshold) * 3; // Scale 1x to ~3.5x
                        if (Math.abs(videoRef.current.playbackRate - rate) > 0.1) {
                            videoRef.current.playbackRate = rate;
                        }
                        if (videoRef.current.paused) {
                            videoRef.current.play();
                            onPlayPause?.(true);
                        }
                    } else if (!externalIsPlaying) {
                        // Rewind (Manual Seek) - Only if NOT actively playing from external state
                        // Step backward based on deflection
                        const step = (Math.abs(shuttleX) - shuttleThreshold) * 0.1; // Reduced step for smoother scrub
                        const newTime = Math.max(0, videoRef.current.currentTime - step);
                        if (Math.abs(videoRef.current.currentTime - newTime) > 0.01) {
                            videoRef.current.currentTime = newTime;
                        }
                    }
                }
            } else {
                // Reset Rate in Neutral
                if (videoRef.current && videoRef.current.playbackRate !== 1) {
                    videoRef.current.playbackRate = 1;
                }
            }
        }

    }, [buttons, axes, zoomLevel, externalIsPlaying, onPlayPause, quickSelectorState, handleStepFrame, analysisMode]);

    // Sync external play/pause state with video element
    useEffect(() => {
        if (!videoRef.current || !videoUrl) return;

        const playVideo = async () => {
            try {
                if (externalIsPlaying && videoRef.current?.paused) {
                    await videoRef.current.play();
                } else if (!externalIsPlaying && !videoRef.current?.paused) {
                    videoRef.current?.pause();
                }
            } catch (e) {
                console.error("Play/Pause failed:", e);
            }
        };

        playVideo();
    }, [externalIsPlaying, videoUrl]);

    return (
        <div
            ref={fullscreenContainerRef}
            className="relative group bg-black rounded-lg overflow-hidden shadow-xl ring-1 ring-white/10 h-full flex items-center justify-center transition-all duration-300"
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseLeave}
            style={{ cursor: zoomLevel > 1 ? (isDragging ? 'grabbing' : 'grab') : 'default' }}
        >
            {/* Quick Player Selector - Now inside the fullscreen container */}
            {quickSelectorState && (
                <QuickPlayerSelector
                    isVisible={quickSelectorState.isOpen}
                    roster={quickSelectorState.roster}
                    selectedIndex={quickSelectorState.selectedIndex}
                    team={quickSelectorState.team}
                />
            )}

            {/* Only show Overlay in Fullscreen */}
            {isFullscreen && <MappingOverlay />}

            <div
                className={`relative w-full h-full transition-transform duration-200 ease-out`}
                style={{
                    transform: `scale(${zoomLevel}) translate(${pan.x}px, ${pan.y}px)`,
                    cursor: zoomLevel > 1 ? 'move' : 'default'
                }}
            >
                {/* Content: Video or Image */}
                {isImage ? (
                    <img
                        src={videoUrl || undefined}
                        className="w-full h-full object-contain pointer-events-none"
                        alt="Match capture"
                    />
                ) : (
                    <video
                        ref={videoRef}
                        className="w-full h-full object-contain"
                        src={videoUrl || undefined}
                        controls={false} // Disable native controls in favor of Timeline
                        onLoadedMetadata={(e) => setDuration(e.currentTarget.duration)}
                        onTimeUpdate={(e) => onTimeUpdate(e.currentTarget.currentTime)}
                        onPlay={() => onPlayPause?.(true)}
                        onPause={() => onPlayPause?.(false)}
                        onSeeked={(e) => onSeek?.(e.currentTarget.currentTime)}
                    />
                )}

                {/* Overlay */}
                <VideoOverlay
                    zoomLevel={zoomLevel}
                    eventNotifications={eventNotifications}
                    showRoster={showRoster}
                    teams={teams}
                    selectedTeam={selectedTeam}
                    teamNames={teamNames}
                    onCloseRoster={() => setShowRoster(false)}
                    visiblePlayers={visiblePlayers}
                    passingPredictions={passingPredictions}
                    tacticalAlerts={tacticalAlerts}
                    showHeatmap={showHeatmap}
                    onPlayerSelect={onPlayerSelect}
                />

                {/* Statistics Dashboard Overlay - Visible in Fullscreen */}
                <DashboardWidget
                    id="live-stats"
                    label="Live Stats Overlay"
                    isEditMode={isEditMode}
                    isHidden={layoutConfig['live-stats']?.hidden}
                    onToggleVisibility={onToggleVisibility}
                    className="absolute top-4 left-4 z-[45] pointer-events-auto"
                >
                    <StatisticsDashboard events={events} isOverlay={true} />
                </DashboardWidget>
            </div>

            {/* Zoom & Frame Controls - Only helpful for video if step frame, but zoom good for both */}
            {videoUrl && (
                <div className="absolute top-4 left-4 flex flex-col gap-2 z-50">
                    <div className="flex gap-1 bg-black/50 p-1 rounded-lg backdrop-blur-sm">
                        <Button variant="ghost" size="icon" onClick={handleZoomIn} className="h-8 w-8 text-white hover:bg-white/20" title="Zoom In">
                            <ZoomIn className="h-4 w-4" />
                        </Button>
                        <Button variant="ghost" size="icon" onClick={handleZoomOut} className="h-8 w-8 text-white hover:bg-white/20" title="Zoom Out">
                            <ZoomOut className="h-4 w-4" />
                        </Button>
                        <Button variant="ghost" size="icon" onClick={handleResetZoom} className="h-8 w-8 text-white hover:bg-white/20" title="Reset Zoom">
                            <RotateCcw className="h-4 w-4" />
                        </Button>
                        {!isImage && (
                            <>
                                <div className="w-px bg-white/20 mx-1" />
                                <Button variant="ghost" size="icon" onClick={() => handleStepFrame('backward')} className="h-8 w-8 text-white hover:bg-white/20" title="Prev Frame">
                                    <SkipBack className="h-4 w-4" />
                                </Button>
                                <Button variant="ghost" size="icon" onClick={() => handleStepFrame('forward')} className="h-8 w-8 text-white hover:bg-white/20" title="Next Frame">
                                    <SkipForward className="h-4 w-4" />
                                </Button>
                            </>
                        )}
                    </div>
                    {zoomLevel > 1 && (
                        <div className="bg-black/50 px-2 py-1 rounded text-xs text-white text-center backdrop-blur-sm">
                            {Math.round(zoomLevel * 100)}%
                        </div>
                    )}
                </div>
            )}

            {/* Toolbar - Only visible if media is loaded */}
            {videoUrl && (
                <div className="absolute bottom-24 left-4 flex gap-2">
                    <Button
                        variant={showHeatmap ? "default" : "ghost"}
                        size="sm"
                        onClick={() => setShowHeatmap(!showHeatmap)}
                        className="gap-1 bg-black/50 hover:bg-black/70 text-white"
                    >
                        <Flame className="h-4 w-4 text-orange-400" />
                        <span className="hidden sm:inline">Heatmap</span>
                    </Button>
                </div>
            )}

            {/* Settings Panel */}
            {showSettings && (
                <div className="absolute top-4 right-4 p-3 bg-card rounded-lg border space-y-3 max-w-sm z-50">
                    <div className="flex items-center justify-between">
                        <h3 className="font-semibold text-sm">Analysis Settings</h3>
                        <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => setShowSettings(false)}
                        >
                            √ó
                        </Button>
                    </div>

                    <div>
                        <label className="text-xs font-medium text-muted-foreground block mb-1">
                            Analysis Mode
                        </label>
                        <div className="flex items-center gap-2">
                            <input
                                type="checkbox"
                                id="fullVideo"
                                checked={analyzeFullVideo}
                                onChange={(e) => setAnalyzeFullVideo(e.target.checked)}
                                className="h-4 w-4"
                            />
                            <label htmlFor="fullVideo" className="text-sm cursor-pointer select-none">
                                Analyze Full Video (Realtime Tracking)
                            </label>
                        </div>
                    </div>

                    <div>
                        <label className="text-xs font-medium text-muted-foreground block mb-1">
                            Video Generation
                        </label>
                        <div className="flex items-center gap-2">
                            <input
                                type="checkbox"
                                id="generateVideo"
                                checked={generateVideo}
                                onChange={(e) => setGenerateVideo(e.target.checked)}
                                className="h-4 w-4"
                            />
                            <label htmlFor="generateVideo" className="text-sm cursor-pointer select-none">
                                Generate Annotated Video File
                            </label>
                        </div>
                    </div>

                    <div>
                        <label className="text-xs font-medium text-muted-foreground block mb-1">
                            Remote Server URL (RunPod / Kaggle)
                        </label>
                        <div className="flex gap-2">
                            <input
                                type="text"
                                placeholder="https://xyz.ngrok-free.app"
                                value={remoteUrl}
                                onChange={(e) => setRemoteUrl(e.target.value)}
                                className="flex-1 text-sm bg-background border rounded px-2 py-1"
                            />
                        </div>
                        <p className="text-[10px] text-muted-foreground mt-1">
                            Leave empty for local processing.
                        </p>
                    </div>

                    <Button
                        onClick={handleRunAnalysis}
                        disabled={!videoFile}
                        className="w-full"
                    >
                        <Sparkles className="w-4 h-4 mr-2" />
                        Run Analysis
                    </Button>
                </div>
            )}

            {/* Settings Toggle */}
            <Button
                variant="secondary"
                size="icon"
                onClick={() => setShowSettings(!showSettings)}
                className="absolute top-4 right-4 z-40"
            >
                <Settings className="w-4 h-4" />
            </Button>

            {/* Professional Timeline */}
            {!isImage && (
                <div className="absolute bottom-0 left-0 w-full z-[60]">
                    <Timeline
                        duration={duration}
                        currentTime={currentTime}
                        events={events}
                        variant={timelineVariant}
                        onSeek={(time) => {
                            if (Number.isFinite(time)) {
                                if (videoRef.current) {
                                    videoRef.current.currentTime = time;
                                }
                                onSeek?.(time);
                            } else {
                                console.warn("‚ö†Ô∏è Ignored Timeline seek with non-finite value:", time);
                            }
                        }}
                    />
                </div>
            )}

            {/* Toasts for Fullscreen - only visible when this container is fullscreened */}
            {isFullscreen && (
                <>
                    {showLiveToasts && <LiveEventToast events={events} />}
                    <Toaster />
                    <Sonner />
                </>
            )}
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/index.tsx.backup">
import { useRef, useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Play, Pause, Volume2, VolumeX, Maximize, SkipBack, SkipForward, Users, Scan, Upload, Target, ZoomIn } from "lucide-react";
import { LoggedEvent } from "@/hooks/useGamepad";
import { TeamRoster } from "@/types/player";
import { PitchMap } from "@/components/PitchMap";
import { computeHomography, transformPoint, Point, transformPointInverse } from "@/utils/calibration";
import { useToast } from "@/hooks/use-toast";

interface VideoPlayerProps {
    videoFile: File | null;
    events: LoggedEvent[];
    onTimeUpdate: (currentTime: number) => void;
    onEventMarkerClick?: (event: LoggedEvent) => void;
    seekTo?: number | null;
    isPlaying?: boolean;
    onPlayPause?: (isPlaying: boolean) => void;
    onSeekComplete?: () => void;
    axes?: number[];
    buttons?: GamepadButton[];
    teams?: Map<string, TeamRoster>;
    selectedTeam?: string;
    teamNames?: { teamA: string, teamB: string };
}

interface CalibrationPoint {
    id: number;
    video: Point | null;
    pitch: Point | null;
}

interface TrackingData {
    positions: Array<{
        frame: number;
        timestamp: number;
        x: number;
        y: number;
        team: string;
        confidence: number;
    }>;
    video_info: any;
}

export const VideoPlayer = ({ videoFile, events, onTimeUpdate, onEventMarkerClick, seekTo, isPlaying: externalIsPlaying, onPlayPause, onSeekComplete, axes, buttons, teams, selectedTeam, teamNames }: VideoPlayerProps) => {
    const videoRef = useRef<HTMLVideoElement>(null);
    const fullscreenContainerRef = useRef<HTMLDivElement>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const [localIsPlaying, setLocalIsPlaying] = useState(false);
    const { toast } = useToast();

    const isPlaying = externalIsPlaying !== undefined ? externalIsPlaying : localIsPlaying;

    const [currentTime, setCurrentTime] = useState(0);
    const [duration, setDuration] = useState(0);
    const [volume, setVolume] = useState(1);
    const [isMuted, setIsMuted] = useState(false);
    const [playbackRate, setPlaybackRate] = useState(1);
    const [videoUrl, setVideoUrl] = useState<string | null>(null);

    const [eventNotifications, setEventNotifications] = useState<Array<{ id: number, event: LoggedEvent, timestamp: number }>>([]);
    const [showRoster, setShowRoster] = useState(false);

    // Calibration State
    const [isCalibrationMode, setIsCalibrationMode] = useState(false);
    const [calibrationPoints, setCalibrationPoints] = useState<CalibrationPoint[]>([]);
    const [activePointId, setActivePointId] = useState<number | null>(null);
    const [homographyMatrix, setHomographyMatrix] = useState<number[] | null>(null);

    // Tracking Data State
    const [trackingData, setTrackingData] = useState<TrackingData | null>(null);
    const [visiblePlayers, setVisiblePlayers] = useState<Array<{ x: number; y: number; team: string }>>([]);

    // Auto-Zoom State
    const [autoZoomEnabled, setAutoZoomEnabled] = useState(false);

    // Controller Cursor State
    const [videoCursor, setVideoCursor] = useState<Point>({ x: 50, y: 50 });
    const lastButtonState = useRef<boolean>(false);

    const playPauseButtonRef = useRef(false);
    const fullscreenButtonRef = useRef(false);
    const fullscreenAltButtonRef = useRef(false);

    useEffect(() => {
        if (videoFile) {
            const url = URL.createObjectURL(videoFile);
            setVideoUrl(url);
            return () => URL.revokeObjectURL(url);
        } else {
            setVideoUrl(null);
        }
    }, [videoFile]);

    useEffect(() => {
        const video = videoRef.current;
        if (!video) return;

        if (isPlaying && video.paused) {
            video.play().catch(e => console.error("Play failed:", e));
        } else if (!isPlaying && !video.paused) {
            video.pause();
        }
    }, [isPlaying]);

    useEffect(() => {
        if (seekTo !== undefined && seekTo !== null && videoRef.current) {
            videoRef.current.currentTime = seekTo;
            setCurrentTime(seekTo);
            if (onSeekComplete) onSeekComplete();
        }
    }, [seekTo, onSeekComplete]);

    useEffect(() => {
        const video = videoRef.current;
        if (!video) return;

        const handleTimeUpdate = () => {
            setCurrentTime(video.currentTime);
            onTimeUpdate(video.currentTime);
        };

        const handleLoadedMetadata = () => {
            setDuration(video.duration);
        };

        const handleEnded = () => {
            if (onPlayPause) onPlayPause(false);
            else setLocalIsPlaying(false);
        };

        const handlePlay = () => {
            if (onPlayPause) onPlayPause(true);
            else setLocalIsPlaying(true);
        };

        const handlePause = () => {
            if (onPlayPause) onPlayPause(false);
            else setLocalIsPlaying(false);
        };

        video.addEventListener('timeupdate', handleTimeUpdate);
        video.addEventListener('loadedmetadata', handleLoadedMetadata);
        video.addEventListener('ended', handleEnded);
        video.addEventListener('play', handlePlay);
        video.addEventListener('pause', handlePause);

        return () => {
            video.removeEventListener('timeupdate', handleTimeUpdate);
            video.removeEventListener('loadedmetadata', handleLoadedMetadata);
            video.removeEventListener('ended', handleEnded);
            video.removeEventListener('play', handlePlay);
            video.removeEventListener('pause', handlePause);
        };
    }, [onTimeUpdate, onPlayPause]);

    useEffect(() => {
        if (events.length > 0) {
            const latestEvent = events[0];
            const now = Date.now();

            setEventNotifications(prev => {
                if (prev.some(n => n.event.id === latestEvent.id)) {
                    return prev;
                }

                return [{
                    id: now,
                    event: latestEvent,
                    timestamp: now
                }, ...prev];
            });
        }
    }, [events]);

    useEffect(() => {
        const interval = setInterval(() => {
            const now = Date.now();
            setEventNotifications(prev =>
                prev.filter(n => now - n.timestamp < 3000)
            );
        }, 100);

        return () => clearInterval(interval);
    }, []);

    const togglePlay = () => {
        const video = videoRef.current;
        if (!video) return;

        const newState = !isPlaying;
        if (onPlayPause) {
            onPlayPause(newState);
        } else {
            setLocalIsPlaying(newState);
        }

        if (newState) {
            video.play();
        } else {
            video.pause();
        }
    };

    const handleSeek = (e: React.ChangeEvent<HTMLInputElement>) => {
        const video = videoRef.current;
        if (!video) return;

        const time = parseFloat(e.target.value);
        video.currentTime = time;
        setCurrentTime(time);
    };

    const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const video = videoRef.current;
        if (!video) return;

        const vol = parseFloat(e.target.value);
        video.volume = vol;
        setVolume(vol);
        setIsMuted(vol === 0);
    };

    const toggleMute = () => {
        const video = videoRef.current;
        if (!video) return;

        video.muted = !isMuted;
        setIsMuted(!isMuted);
    };

    const changePlaybackRate = () => {
        const video = videoRef.current;
        if (!video) return;

        const rates = [0.5, 0.75, 1, 1.25, 1.5, 2];
        const currentIndex = rates.indexOf(playbackRate);
        const nextRate = rates[(currentIndex + 1) % rates.length];
        video.playbackRate = nextRate;
        setPlaybackRate(nextRate);
    };

    const toggleFullscreen = () => {
        const container = fullscreenContainerRef.current;
        if (!container) return;

        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            container.requestFullscreen();
        }
    };

    const skipTime = (seconds: number) => {
        const video = videoRef.current;
        if (!video) return;

        video.currentTime = Math.max(0, Math.min(duration, currentTime + seconds));
    };

    const jumpToEvent = (event: LoggedEvent) => {
        const video = videoRef.current;
        if (!video || !event.videoTime) return;

        video.currentTime = event.videoTime;
        setCurrentTime(event.videoTime);
        if (onEventMarkerClick) {
            onEventMarkerClick(event);
        }
    };

    const formatTime = (seconds: number) => {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        if (hrs > 0) {
            return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    const [zoomLevel, setZoomLevel] = useState(1);
    const [panPosition, setPanPosition] = useState({ x: 0, y: 0 });

    useEffect(() => {
        if (!axes || !buttons) return;

        // Play/Pause button (button 4 = LB)
        const playPauseButton = buttons[4];
        if (playPauseButton && playPauseButton.pressed && !playPauseButtonRef.current) {
            togglePlay();
        }
        playPauseButtonRef.current = playPauseButton?.pressed || false;

        // Fullscreen toggle (button 9 = Start)
        const fullscreenButton = buttons[9];
        if (fullscreenButton && fullscreenButton.pressed && !fullscreenButtonRef.current) {
            toggleFullscreen();
        }
        fullscreenButtonRef.current = fullscreenButton?.pressed || false;

        // Fullscreen toggle alternative (button 8 = Select/Back)
        const fullscreenAltButton = buttons[8];
        if (fullscreenAltButton && fullscreenAltButton.pressed && !fullscreenAltButtonRef.current) {
            toggleFullscreen();
        }
        fullscreenAltButtonRef.current = fullscreenAltButton?.pressed || false;

        const zoomOutVal = buttons[6]?.value || 0;
        const zoomInVal = buttons[7]?.value || 0;

        if (zoomInVal > 0.1 || zoomOutVal > 0.1) {
            setZoomLevel(prev => {
                const speed = 0.03;
                const change = (zoomInVal * speed) - (zoomOutVal * speed);
                const newZoom = Math.max(1, Math.min(5, prev + change));
                return newZoom;
            });
        }

        const xVal = axes[0] || 0;
        const yVal = axes[1] || 0;
        const deadzone = 0.15;

        if (Math.abs(xVal) > deadzone || Math.abs(yVal) > deadzone) {
            setPanPosition(prev => {
                if (zoomLevel <= 1) return { x: 0, y: 0 };

                const speed = 1.5;
                const newX = prev.x - (xVal * speed);
                const newY = prev.y - (yVal * speed);

                const limit = 50 * (1 - 1 / zoomLevel);

                return {
                    x: Math.max(-limit, Math.min(limit, newX)),
                    y: Math.max(-limit, Math.min(limit, newY))
                };
            });
        } else if (zoomLevel <= 1.05) {
            setPanPosition({ x: 0, y: 0 });
        }

    }, [axes, buttons, zoomLevel]);

    // Controller Input Loop for Calibration Cursor
    useEffect(() => {
        if (!axes || !isCalibrationMode) return;

        const deadzone = 0.1;
        const maxSpeed = 2.0; // Max speed multiplier

        const rawX = Math.abs(axes[0]) > deadzone ? axes[0] : 0;
        const rawY = Math.abs(axes[1]) > deadzone ? axes[1] : 0;

        // Quadratic curve for precision: (input^2) * sign * speed
        // This allows fine control at low tilt and fast movement at full tilt
        const xInput = Math.sign(rawX) * Math.pow(Math.abs(rawX), 2.5) * maxSpeed;
        const yInput = Math.sign(rawY) * Math.pow(Math.abs(rawY), 2.5) * maxSpeed;

        if (xInput !== 0 || yInput !== 0) {
            setVideoCursor(prev => {
                let newX = prev.x + xInput;
                let newY = prev.y + yInput;

                // Clamp to 0-100
                newX = Math.max(0, Math.min(100, newX));
                newY = Math.max(0, Math.min(100, newY));

                return { x: newX, y: newY };
            });
        }

        // Handle Button A (Index 0) for clicking
        if (buttons && buttons[0]) {
            if (buttons[0].pressed && !lastButtonState.current) {
                // Button Down Event
                handleVideoClick({
                    stopPropagation: () => { },
                    currentTarget: videoRef.current,
                    clientX: 0, // Dummy
                    clientY: 0, // Dummy
                } as any, true);
            }
            lastButtonState.current = buttons[0].pressed;
        }

    }, [axes, buttons, isCalibrationMode]);

    // Calibration Logic
    const handleVideoMouseMove = (e: React.MouseEvent<HTMLVideoElement>) => {
        if (!isCalibrationMode) return;
        const rect = e.currentTarget.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        setVideoCursor({ x, y });
    };

    const handleVideoClick = (e: React.MouseEvent<HTMLVideoElement> | any, isControllerInput = false) => {
        if (!isCalibrationMode || !videoRef.current) {
            togglePlay();
            return;
        }

        if (e.stopPropagation) e.stopPropagation();

        let x, y;

        if (isControllerInput) {
            x = videoCursor.x;
            y = videoCursor.y;
        } else {
            // For mouse clicks, we can trust the current videoCursor state 
            // because we are now updating it on mouse move.
            // But to be safe and precise, let's recalculate if it's a real mouse event
            if (e.clientX) {
                const rect = e.currentTarget.getBoundingClientRect();
                x = ((e.clientX - rect.left) / rect.width) * 100;
                y = ((e.clientY - rect.top) / rect.height) * 100;
                setVideoCursor({ x, y });
            } else {
                x = videoCursor.x;
                y = videoCursor.y;
            }
        }

        // Add new point
        const newId = calibrationPoints.length + 1;
        setCalibrationPoints(prev => [...prev, { id: newId, video: { x, y }, pitch: null }]);
        setActivePointId(newId);
    };

    const handlePitchPointClick = (point: Point) => {
        if (!activePointId) return;

        setCalibrationPoints(prev => prev.map(p =>
            p.id === activePointId ? { ...p, pitch: point } : p
        ));

        // Auto-advance to next point if it exists and has no pitch point, or just clear active
        const nextPoint = calibrationPoints.find(p => p.id === activePointId + 1);
        if (nextPoint) {
            setActivePointId(nextPoint.id);
        } else {
            setActivePointId(null);
        }
    };

    const computeCalibration = () => {
        const validPoints = calibrationPoints.filter(p => p.video && p.pitch);
        if (validPoints.length < 4) {
            toast({
                title: "Calibration Failed",
                description: "Need at least 4 points with both video and pitch coordinates.",
                variant: "destructive"
            });
            return;
        }

        const src = validPoints.map(p => p.video!);
        const dst = validPoints.map(p => p.pitch!);

        const matrix = computeHomography(src, dst);
        if (matrix) {
            setHomographyMatrix(matrix);
            toast({
                title: "Calibration Successful",
                description: "Field mapping computed successfully.",
            });
            setIsCalibrationMode(false);
        } else {
            toast({
                title: "Calibration Failed",
                description: "Could not compute valid homography matrix.",
                variant: "destructive"
            });
        }
    };

    const handleTrackingUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = JSON.parse(event.target?.result as string);
                setTrackingData(data);
                toast({
                    title: "Tracking Data Loaded",
                    description: `Loaded ${data.positions.length} positions.`,
                });
            } catch (err) {
                console.error(err);
                toast({
                    title: "Upload Failed",
                    description: "Invalid JSON file.",
                    variant: "destructive"
                });
            }
        };
        reader.readAsText(file);
    };

    // Update visible players based on current time
    useEffect(() => {
        if (!trackingData || !homographyMatrix) return;

        // Find positions for current time (within small window)
        const currentPositions = trackingData.positions.filter(p =>
            Math.abs(p.timestamp - currentTime) < 0.1 // 100ms window
        );

        const transformed = currentPositions.map(p => {
            // Transform video coordinates (0-100) to pitch coordinates
            const pt = transformPoint(homographyMatrix, { x: p.x, y: p.y });
            return { ...pt, team: p.team };
        });

        setVisiblePlayers(transformed);

    }, [currentTime, trackingData, homographyMatrix]);

    // Video-Based Auto-Zoom (analyzes video frames - no calibration needed)
    useEffect(() => {
        if (!autoZoomEnabled || !videoRef.current || !canvasRef.current) {
            // Reset zoom if auto-zoom is disabled
            if (!autoZoomEnabled && zoomLevel !== 1) {
                setZoomLevel(1);
                setPanPosition({ x: 0, y: 0 });
            }
            return;
        }

        const analyzeFrame = () => {
            const canvas = canvasRef.current;
            const video = videoRef.current;
            if (!canvas || !video || video.paused || video.ended) return;

            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            // Sample at low resolution for performance
            canvas.width = 320;
            canvas.height = 180;

            try {
                ctx.drawImage(video, 0, 0, 320, 180);
                const imageData = ctx.getImageData(0, 0, 320, 180);
                const pixels = imageData.data;

                let greenPixels = 0;
                const totalPixels = pixels.length / 4;

                // Track non-green pixels (players, ball, etc.) for focus detection
                let focusX = 0;
                let focusY = 0;
                let focusCount = 0;

                // Detect green field pixels and non-green focus points
                for (let i = 0; i < pixels.length; i += 4) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];

                    // Calculate position in frame
                    const pixelIndex = i / 4;
                    const x = (pixelIndex % 320) / 320; // 0-1
                    const y = Math.floor(pixelIndex / 320) / 180; // 0-1

                    // IGNORE TOP 30% of frame (crowd/stands area)
                    if (y < 0.3) continue;

                    // Green detection: g > r && g > b && g > threshold
                    if (g > r && g > b && g > 60) {
                        greenPixels++;
                    } else {
                        // Non-green pixel (potential player/ball)
                        // Only consider pixels in the field area (lower 70% of frame)

                        // Weight brighter pixels more (likely to be players/ball)
                        const brightness = (r + g + b) / 3;

                        // Filter: bright enough but not too bright (avoid ads/graphics)
                        if (brightness > 80 && brightness < 240) {
                            focusX += x * brightness;
                            focusY += y * brightness;
                            focusCount += brightness;
                        }
                    }
                }

                const fieldRatio = greenPixels / totalPixels;

                // Calculate focus point (center of action)
                let targetX = 50; // Default center
                let targetY = 50;

                if (focusCount > 0) {
                    targetX = (focusX / focusCount) * 100; // Convert to 0-100
                    targetY = (focusY / focusCount) * 100;
                }

                // High field ratio = wide shot = zoom in
                if (fieldRatio > 0.4) {
                    setZoomLevel(2.5);
                    // Pan to focus point
                    setPanPosition({
                        x: (50 - targetX) * 1.5,
                        y: (50 - targetY) * 1.5
                    });
                } else if (fieldRatio > 0.25) {
                    setZoomLevel(1.8);
                    setPanPosition({
                        x: (50 - targetX) * 0.8,
                        y: (50 - targetY) * 0.8
                    });
                } else {
                    setZoomLevel(1);
                    setPanPosition({ x: 0, y: 0 });
                }
            } catch (err) {
                console.error('Frame analysis error:', err);
            }
        };

        // Analyze frames every 500ms
        const interval = setInterval(analyzeFrame, 500);

        // Initial analysis
        analyzeFrame();

        return () => clearInterval(interval);
    }, [autoZoomEnabled, isPlaying]);

    const toggleCalibrationMode = () => {
        if (!isCalibrationMode) {
            setZoomLevel(1);
            setPanPosition({ x: 0, y: 0 });
        }
        setIsCalibrationMode(!isCalibrationMode);
    };

    if (!videoUrl) {
        return (
            <div className="w-full aspect-video bg-muted rounded-lg flex items-center justify-center">
                <p className="text-muted-foreground">No video loaded</p>
            </div>
        );
    }

    return (
        <div className="w-full space-y-2">
            {/* Main Container - Ref moved here for Fullscreen */}
            <div
                ref={fullscreenContainerRef}
                className={`flex gap-4 bg-background ${document.fullscreenElement ? 'p-4 h-screen items-center justify-center' : ''}`}
            >
                {/* Video Container */}
                <div className={`relative bg-black rounded-lg overflow-hidden group transition-all duration-300 ${isCalibrationMode ? 'w-2/3' : 'w-full'}`}>
                    <div className={`w-full ${document.fullscreenElement && !isCalibrationMode ? 'h-full' : 'aspect-video'} overflow-hidden relative`}>
                        <video
                            ref={videoRef}
                            src={videoUrl}
                            className={`w-full h-full object-contain will-change-transform ${isCalibrationMode ? 'cursor-crosshair' : ''}`}
                            style={{
                                transform: `scale(${zoomLevel}) translate(${panPosition.x}%, ${panPosition.y}%)`,
                                transition: 'transform 0.15s cubic-bezier(0.4, 0, 0.2, 1)'
                            }}
                            onClick={handleVideoClick}
                            onMouseMove={handleVideoMouseMove}
                        />

                        {/* Hidden Canvas for Frame Analysis */}
                        <canvas ref={canvasRef} className="hidden" />

                        {/* Virtual Cursor for Controller */}
                        {isCalibrationMode && (
                            <div
                                className="absolute w-6 h-6 -ml-3 -mt-3 pointer-events-none z-50 transition-transform duration-75"
                                style={{
                                    left: `${videoCursor.x}%`,
                                    top: `${videoCursor.y}%`,
                                    color: '#ef4444' // Red cursor
                                }}
                            >
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                    <line x1="12" y1="0" x2="12" y2="24" />
                                    <line x1="0" y1="12" x2="24" y2="12" />
                                </svg>
                            </div>
                        )}

                        {/* Calibration Markers on Video */}
                        {isCalibrationMode && calibrationPoints.map((p) => p.video && (
                            <div
                                key={p.id}
                                className={`absolute w-4 h-4 -ml-2 -mt-2 rounded-full flex items-center justify-center text-[10px] font-bold border border-white shadow-sm pointer-events-none z-20
                                    ${activePointId === p.id ? 'bg-yellow-500 text-black scale-125' : 'bg-blue-500 text-white'}`}
                                style={{ left: `${p.video.x}%`, top: `${p.video.y}%` }}
                            >
                                {p.id}
                            </div>
                        ))}

                        {zoomLevel > 1 && (
                            <div className="absolute top-2 right-2 bg-black/50 text-white px-2 py-1 rounded text-xs font-mono pointer-events-none z-20">
                                {zoomLevel.toFixed(1)}x
                            </div>
                        )}

                        {!isCalibrationMode && (
                            <div className="absolute top-4 left-1/2 -translate-x-1/2 pointer-events-none z-30 space-y-2 w-96">
                                {eventNotifications.map((notification) => {
                                    const age = Date.now() - notification.timestamp;
                                    const opacity = Math.max(0, 1 - (age / 3000));
                                    const translateY = (age / 3000) * -20;

                                    return (
                                        <div
                                            key={notification.id}
                                            className="bg-black/80 backdrop-blur-sm text-white px-4 py-3 rounded-lg border-l-4 border-primary shadow-lg"
                                            style={{
                                                opacity,
                                                transform: `translateY(${translateY}px)`,
                                                transition: 'opacity 0.1s, transform 0.1s'
                                            }}
                                        >
                                            <div className="flex items-center gap-3">
                                                <div className="flex-1">
                                                    <div className="font-bold text-lg">{notification.event.eventName}</div>
                                                    <div className="text-sm text-gray-300 flex items-center gap-2">
                                                        <span>
                                                            {notification.event.team === "TEAM_A"
                                                                ? (teamNames?.teamA || "Team A")
                                                                : (teamNames?.teamB || "Team B")}
                                                        </span>
                                                        {notification.event.player && (
                                                            <span>‚Ä¢ {notification.event.player.name}</span>
                                                        )}
                                                        {notification.event.matchTime && (
                                                            <span>‚Ä¢ {notification.event.matchTime}</span>
                                                        )}
                                                    </div>
                                                </div>
                                                {notification.event.isCalculated && (
                                                    <div className="text-xs bg-primary/20 text-primary px-2 py-1 rounded">
                                                        AUTO
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}

                        {showRoster && teams && selectedTeam && teams.get(selectedTeam) && !isCalibrationMode && (
                            <>
                                <button
                                    onClick={() => setShowRoster(false)}
                                    className="absolute top-2 right-2 h-6 w-6 flex items-center justify-center bg-black/30 hover:bg-black/50 rounded-full text-white/60 hover:text-white transition-colors z-40 pointer-events-auto"
                                >
                                    √ó
                                </button>

                                {/* Starting XI - Vertical on Left */}
                                <div className="absolute top-4 left-4 bottom-4 flex flex-col gap-2 pointer-events-none z-30">
                                    {(() => {
                                        const startingNumbers = [1, 2, 5, 6, 7, 8, 9, 10, 11, 15, 22];
                                        return teams.get(selectedTeam)?.PlayerData
                                            .filter(p => startingNumbers.includes(p.Number || 0))
                                            .sort((a, b) => {
                                                const aIndex = startingNumbers.indexOf(a.Number || 0);
                                                const bIndex = startingNumbers.indexOf(b.Number || 0);
                                                return aIndex - bIndex;
                                            })
                                            .slice(0, 11)
                                            .map((player) => (
                                                <div
                                                    key={player.ID}
                                                    className="bg-black/20 backdrop-blur-sm rounded-md p-1.5 hover:bg-black/30 transition-all border border-white/10 hover:border-primary/30 pointer-events-auto"
                                                >
                                                    <div className="flex flex-col items-center gap-0.5">
                                                        <div className="w-7 h-7 bg-primary/20 rounded-full flex items-center justify-center font-bold text-primary text-xs">
                                                            {player.Number || '?'}
                                                        </div>
                                                        <div className="text-center">
                                                            <div className="font-semibold text-[9px] text-white/90">
                                                                {player.Surname}
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            ));
                                    })()}
                                </div>

                                {/* Substitutes - Vertical on Right */}
                                {(() => {
                                    const startingNumbers = [1, 2, 5, 6, 7, 8, 9, 10, 11, 15, 22];
                                    const subs = teams.get(selectedTeam)?.PlayerData
                                        .filter(p => !startingNumbers.includes(p.Number || 0))
                                        .sort((a, b) => (a.Number || 99) - (b.Number || 99))
                                        .slice(0, 7);

                                    return subs && subs.length > 0 && (
                                        <div className="absolute top-4 right-4 bottom-4 flex flex-col gap-2 pointer-events-none z-30">
                                            {subs.map((player) => (
                                                <div
                                                    key={player.ID}
                                                    className="bg-black/15 backdrop-blur-sm rounded-md p-1.5 hover:bg-black/25 transition-all border border-white/5 hover:border-white/15 pointer-events-auto"
                                                >
                                                    <div className="flex flex-col items-center gap-0.5">
                                                        <div className="w-6 h-6 bg-gray-500/20 rounded-full flex items-center justify-center font-bold text-gray-300 text-[10px]">
                                                            {player.Number || '?'}
                                                        </div>
                                                        <div className="text-center">
                                                            <div className="font-medium text-[8px] text-white/70">
                                                                {player.Surname}
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    );
                                })()}
                            </>
                        )}
                    </div>

                    <div className="absolute bottom-0 left-0 right-0 h-1 bg-transparent pointer-events-none z-10">
                        {events.filter(e => e.videoTime).map((event, index) => {
                            const position = ((event.videoTime! / duration) * 100);
                            return (
                                <div
                                    key={`${event.id}-${event.videoTime}-${index}`}
                                    className="absolute w-1 h-3 bg-red-500 cursor-pointer pointer-events-auto bottom-0"
                                    style={{ left: `${position}%` }}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        jumpToEvent(event);
                                    }}
                                    title={`${event.eventName} - ${formatTime(event.videoTime!)}`}
                                />
                            );
                        })}
                    </div>
                </div>

                {/* Calibration Side Panel */}
                {isCalibrationMode && (
                    <div className="w-1/3 space-y-4 bg-card p-4 rounded-lg border overflow-y-auto max-h-screen">
                        <h3 className="font-semibold flex items-center gap-2">
                            <Scan className="w-4 h-4" />
                            Pitch Calibration
                        </h3>
                        <p className="text-xs text-muted-foreground">
                            Use Controller Left Stick to move cursor.<br />
                            Press 'A' (Cross) to select point.<br />
                            Or use mouse.
                        </p>

                        <PitchMap
                            onPointClick={handlePitchPointClick}
                            selectedPoint={activePointId ? calibrationPoints.find(p => p.id === activePointId)?.pitch : null}
                            calibrationPoints={calibrationPoints.filter(p => p.pitch).map(p => ({ pitch: p.pitch!, label: p.id }))}
                            playerPositions={visiblePlayers}
                        />

                        <div className="flex flex-col gap-2">
                            <div className="flex gap-2">
                                <Button size="sm" onClick={computeCalibration} className="flex-1">
                                    Apply Calibration
                                </Button>
                                <Button size="sm" variant="outline" onClick={() => {
                                    setCalibrationPoints([]);
                                    setActivePointId(null);
                                    setHomographyMatrix(null);
                                }}>
                                    Reset
                                </Button>
                            </div>

                            <div className="relative">
                                <input
                                    type="file"
                                    accept=".json"
                                    onChange={handleTrackingUpload}
                                    className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                                />
                                <Button size="sm" variant="secondary" className="w-full">
                                    <Upload className="w-4 h-4 mr-2" />
                                    Upload Tracking Data
                                </Button>
                            </div>
                        </div>

                        <div className="space-y-1 max-h-40 overflow-y-auto text-xs">
                            {calibrationPoints.map(p => (
                                <div
                                    key={p.id}
                                    className={`flex justify-between items-center p-2 rounded cursor-pointer ${activePointId === p.id ? 'bg-accent' : 'hover:bg-accent/50'}`}
                                    onClick={() => setActivePointId(p.id)}
                                >
                                    <span>Point {p.id}</span>
                                    <div className="flex gap-2 text-[10px] text-muted-foreground">
                                        <span className={p.video ? 'text-green-500' : ''}>Video {p.video ? '‚úì' : '‚úó'}</span>
                                        <span className={p.pitch ? 'text-green-500' : ''}>Pitch {p.pitch ? '‚úì' : '‚úó'}</span>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                )}
            </div>

            {/* Controls Bar */}
            <div className="space-y-2 p-2 bg-card rounded-lg border">
                <div className="flex items-center gap-2">
                    <span className="text-xs text-muted-foreground min-w-[45px]">
                        {formatTime(currentTime)}
                    </span>
                    <input
                        type="range"
                        min="0"
                        max={duration || 0}
                        value={currentTime}
                        onChange={handleSeek}
                        className="flex-1 h-1 bg-muted rounded-lg appearance-none cursor-pointer"
                        style={{
                            background: `linear-gradient(to right, hsl(var(--primary)) 0%, hsl(var(--primary)) ${(currentTime / duration) * 100}%, hsl(var(--muted)) ${(currentTime / duration) * 100}%, hsl(var(--muted)) 100%)`
                        }}
                    />
                    <span className="text-xs text-muted-foreground min-w-[45px]">
                        {formatTime(duration)}
                    </span>
                </div>

                <div className="flex items-center justify-between gap-2">
                    <div className="flex items-center gap-1">
                        <Button variant="ghost" size="sm" onClick={() => skipTime(-10)} title="Back 10s">
                            <SkipBack className="h-4 w-4" />
                        </Button>
                        <Button variant="ghost" size="sm" onClick={togglePlay}>
                            {isPlaying ? <Pause className="h-4 w-4" /> : <Play className="h-4 w-4" />}
                        </Button>
                        <Button variant="ghost" size="sm" onClick={() => skipTime(10)} title="Forward 10s">
                            <SkipForward className="h-4 w-4" />
                        </Button>
                    </div>

                    <div className="flex items-center gap-2">
                        <Button
                            variant={isCalibrationMode ? "default" : "secondary"}
                            size="sm"
                            onClick={toggleCalibrationMode}
                            title="Calibration Mode"
                            className="gap-1"
                        >
                            <Scan className="h-4 w-4" />
                            <span className="hidden sm:inline">Calibrate</span>
                        </Button>

                        <Button
                            variant={autoZoomEnabled ? "default" : "ghost"}
                            size="sm"
                            onClick={() => setAutoZoomEnabled(!autoZoomEnabled)}
                            title="Auto-Zoom based on camera distance"
                            className="gap-1"
                        >
                            <ZoomIn className="h-4 w-4" />
                            <span className="hidden sm:inline">Auto Zoom</span>
                        </Button>

                        {teams && selectedTeam && teams.get(selectedTeam) && (
                            <Button
                                variant={showRoster ? "default" : "ghost"}
                                size="sm"
                                onClick={() => setShowRoster(!showRoster)}
                                title="Toggle Team Roster"
                            >
                                <Users className="h-4 w-4" />
                            </Button>
                        )}

                        <Button
                            variant="ghost"
                            size="sm"
                            onClick={changePlaybackRate}
                            className="text-xs min-w-[45px]"
                            title="Playback speed"
                        >
                            {playbackRate}x
                        </Button>

                        <div className="flex items-center gap-1">
                            <Button variant="ghost" size="sm" onClick={toggleMute}>
                                {isMuted ? <VolumeX className="h-4 w-4" /> : <Volume2 className="h-4 w-4" />}
                            </Button>
                            <input
                                type="range"
                                min="0"
                                max="1"
                                step="0.1"
                                value={isMuted ? 0 : volume}
                                onChange={handleVolumeChange}
                                className="w-16 h-1 bg-muted rounded-lg appearance-none cursor-pointer hidden md:block"
                            />
                        </div>

                        <Button variant="ghost" size="sm" onClick={toggleFullscreen} title="Fullscreen">
                            <Maximize className="h-4 w-4" />
                        </Button>
                    </div>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/PlayerTracker.tsx">
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { X, Target } from 'lucide-react';

interface PlayerTrackerProps {
    trackingData: any; // AI tracking data from analysis
    currentTime: number;
    videoWidth: number;
    videoHeight: number;
    onTrackPlayer: (playerId: number, points: Array<{ time: number; x: number; y: number }>) => void;
    onClose: () => void;
}

export const PlayerTracker: React.FC<PlayerTrackerProps> = ({
    trackingData,
    currentTime,
    videoWidth,
    videoHeight,
    onTrackPlayer,
    onClose,
}) => {
    const [selectedPlayerId, setSelectedPlayerId] = useState<number | null>(null);
    const [manualMode, setManualMode] = useState(false);
    const [manualPoints, setManualPoints] = useState<Array<{ time: number; x: number; y: number }>>([]);

    // Get current frame players from AI tracking data
    const getCurrentPlayers = () => {
        if (!trackingData?.tracks) return [];

        const fps = trackingData.metadata?.fps || 30;
        const currentFrame = Math.floor(currentTime * fps);

        const players: Array<{ id: number; x: number; y: number; team: string }> = [];

        Object.entries(trackingData.tracks).forEach(([id, track]: [string, any]) => {
            const point = track.find((p: any) => p.frame === currentFrame);
            if (point) {
                players.push({
                    id: parseInt(id),
                    x: point.x,
                    y: point.y,
                    team: point.team,
                });
            }
        });

        return players;
    };

    const handlePlayerSelect = (playerId: number) => {
        if (!trackingData?.tracks) return;

        const track = trackingData.tracks[playerId];
        if (!track) return;

        // Convert AI track to annotation format
        const points = track.map((p: any) => ({
            time: p.timestamp,
            x: p.x,
            y: p.y,
        }));

        setSelectedPlayerId(playerId);
        onTrackPlayer(playerId, points);
    };

    const handleManualClick = (e: React.MouseEvent<SVGElement>) => {
        if (!manualMode) return;

        const svg = e.currentTarget;
        const rect = svg.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * videoWidth;
        const y = ((e.clientY - rect.top) / rect.height) * videoHeight;

        const newPoint = { time: currentTime, x, y };
        const updatedPoints = [...manualPoints, newPoint];
        setManualPoints(updatedPoints);
    };

    const handleSaveManualTrack = () => {
        if (manualPoints.length < 2) return;

        const playerId = Date.now(); // Generate unique ID for manual track
        onTrackPlayer(playerId, manualPoints);
        setManualPoints([]);
        setManualMode(false);
    };

    const currentPlayers = getCurrentPlayers();

    return (
        <div className="absolute top-0 left-0 w-full h-full z-40">
            {/* Control Panel */}
            <div className="absolute top-4 right-4 bg-black/80 backdrop-blur-sm rounded-lg p-3 space-y-2">
                <div className="flex items-center justify-between mb-2">
                    <h3 className="text-white font-semibold text-sm">Player Tracker</h3>
                    <Button
                        variant="ghost"
                        size="icon"
                        onClick={onClose}
                        className="h-6 w-6 text-white hover:bg-white/20"
                    >
                        <X className="w-4 h-4" />
                    </Button>
                </div>

                {/* Mode Toggle */}
                <div className="flex gap-2">
                    <Button
                        variant={!manualMode ? 'default' : 'ghost'}
                        size="sm"
                        onClick={() => setManualMode(false)}
                        className="flex-1 text-xs"
                    >
                        AI Track
                    </Button>
                    <Button
                        variant={manualMode ? 'default' : 'ghost'}
                        size="sm"
                        onClick={() => setManualMode(true)}
                        className="flex-1 text-xs"
                    >
                        Manual
                    </Button>
                </div>

                {/* AI Mode: Player List */}
                {!manualMode && (
                    <div className="max-h-48 overflow-y-auto space-y-1">
                        <p className="text-white/70 text-xs mb-1">Select a player:</p>
                        {currentPlayers.map((player) => (
                            <button
                                key={player.id}
                                onClick={() => handlePlayerSelect(player.id)}
                                className={`w-full px-2 py-1 rounded text-xs text-left ${selectedPlayerId === player.id
                                        ? 'bg-blue-500 text-white'
                                        : 'bg-white/10 text-white hover:bg-white/20'
                                    }`}
                            >
                                Player {player.id} ({player.team})
                            </button>
                        ))}
                        {currentPlayers.length === 0 && (
                            <p className="text-white/50 text-xs">No players detected at this time</p>
                        )}
                    </div>
                )}

                {/* Manual Mode: Instructions */}
                {manualMode && (
                    <div className="space-y-2">
                        <p className="text-white/70 text-xs">
                            Click on the player to track them. Navigate frame-by-frame and click again.
                        </p>
                        <p className="text-white text-xs">
                            Points: {manualPoints.length}
                        </p>
                        <div className="flex gap-2">
                            <Button
                                size="sm"
                                onClick={handleSaveManualTrack}
                                disabled={manualPoints.length < 2}
                                className="flex-1 text-xs"
                            >
                                Save Track
                            </Button>
                            <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => setManualPoints([])}
                                className="flex-1 text-xs"
                            >
                                Clear
                            </Button>
                        </div>
                    </div>
                )}
            </div>

            {/* Clickable Overlay for Manual Mode */}
            {manualMode && (
                <svg
                    className="absolute top-0 left-0 w-full h-full cursor-crosshair"
                    viewBox={`0 0 ${videoWidth} ${videoHeight}`}
                    preserveAspectRatio="xMidYMid meet"
                    onClick={handleManualClick}
                >
                    {/* Show manual points */}
                    {manualPoints.map((p, i) => (
                        <circle
                            key={i}
                            cx={p.x}
                            cy={p.y}
                            r={5}
                            fill="#00FF00"
                            stroke="#FFFFFF"
                            strokeWidth={2}
                        />
                    ))}
                </svg>
            )}

            {/* AI Mode: Highlight Current Players */}
            {!manualMode && (
                <svg
                    className="absolute top-0 left-0 w-full h-full pointer-events-none"
                    viewBox={`0 0 ${videoWidth} ${videoHeight}`}
                    preserveAspectRatio="xMidYMid meet"
                >
                    {currentPlayers.map((player) => (
                        <g key={player.id}>
                            <circle
                                cx={player.x}
                                cy={player.y}
                                r={20}
                                fill="none"
                                stroke={selectedPlayerId === player.id ? '#00FF00' : '#FFFF00'}
                                strokeWidth={2}
                                opacity={0.7}
                            />
                            <Target
                                x={player.x - 10}
                                y={player.y - 10}
                                width={20}
                                height={20}
                                className="text-yellow-400"
                            />
                        </g>
                    ))}
                </svg>
            )}
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/TacticalAnnotationSidebar.tsx">
import React from 'react';
import { Button } from '@/components/ui/button';
import {
    MousePointer2,
    ArrowRight,
    Circle,
    Square,
    Type,
    User,
    Trash2,
    Undo,
    Download,
    Upload,
    Ruler,
    Target,
    Crosshair,
    Zap,
    Map
} from 'lucide-react';
import { AnnotationType } from '@/hooks/useAnnotations';
import { DrawingTool } from './AnnotationToolbar';
import { cn } from '@/lib/utils';

interface TacticalAnnotationSidebarProps {
    activeTool: DrawingTool;
    onToolChange: (tool: DrawingTool) => void;
    color: string;
    onColorChange: (color: string) => void;
    strokeWidth: number;
    onStrokeWidthChange: (width: number) => void;
    onClear: () => void;
    onUndo: () => void;
    onExport: () => void;
    onImport: (file: File) => void;
}

export const TacticalAnnotationSidebar: React.FC<TacticalAnnotationSidebarProps> = ({
    activeTool,
    onToolChange,
    color,
    onColorChange,
    strokeWidth,
    onStrokeWidthChange,
    onClear,
    onUndo,
    onExport,
    onImport,
}) => {
    const toolGroups = [
        {
            name: "Selection",
            tools: [
                { id: 'select', icon: <MousePointer2 className="w-4 h-4" />, label: 'Selection' },
                { id: 'calibration', icon: <Target className="w-4 h-4 text-yellow-500" />, label: 'Calibration' },
            ]
        },
        {
            name: "Tactical Tools",
            tools: [
                { id: 'spotlight', icon: <Crosshair className="w-4 h-4 text-cyan-400" />, label: 'Spotlight' },
                { id: 'zone', icon: <Map className="w-4 h-4" />, label: 'Tactical Zone' },
                { id: 'arrow', icon: <ArrowRight className="w-4 h-4" />, label: 'Tactical Line' },
                { id: 'ruler', icon: <Ruler className="w-4 h-4" />, label: 'Distance' },
            ]
        },
        {
            name: "Shapes & Text",
            tools: [
                { id: 'circle', icon: <Circle className="w-4 h-4" />, label: 'Circle' },
                { id: 'marker', icon: <User className="w-4 h-4 text-orange-400" />, label: 'Player Marker' },
                { id: 'text', icon: <Type className="w-4 h-4" />, label: 'Annotation' },
            ]
        }
    ];

    const broadcastColors = [
        { name: 'Power Red', hex: '#FF3B30' },
        { name: 'Neon Green', hex: '#34C759' },
        { name: 'Tactical Blue', hex: '#007AFF' },
        { name: 'Safety Yellow', hex: '#FFD60A' },
        { name: 'Cyber Cyan', hex: '#00FBFF' },
        { name: 'Direct Orange', hex: '#FF9F0A' },
        { name: 'Clean White', hex: '#FFFFFF' },
        { name: 'Stealth Black', hex: '#000000' },
    ];

    return (
        <div className="absolute top-16 right-4 bottom-24 bg-slate-900/40 backdrop-blur-2xl rounded-2xl p-4 flex flex-col gap-6 z-50 border border-white/10 shadow-2xl overflow-y-auto custom-scrollbar w-[80px] select-none hover:w-[220px] transition-all duration-300 group/sidebar">
            <div className="flex items-center gap-3 px-2 mb-2">
                <div className="h-8 w-8 rounded-lg bg-cyan-500/20 flex items-center justify-center border border-cyan-500/30">
                    <Zap className="h-4 w-4 text-cyan-400" />
                </div>
                <span className="text-xs font-black uppercase tracking-widest text-white opacity-0 group-hover/sidebar:opacity-100 transition-opacity whitespace-nowrap">Tactical OS</span>
            </div>

            {toolGroups.map((group, idx) => (
                <div key={idx} className="flex flex-col gap-2">
                    <span className="text-[10px] uppercase text-white/40 font-black tracking-widest px-2 opacity-0 group-hover/sidebar:opacity-100 transition-opacity">
                        {group.name}
                    </span>
                    <div className="flex flex-col gap-1">
                        {group.tools.map((tool) => (
                            <Button
                                key={tool.id}
                                variant={activeTool === tool.id ? 'default' : 'ghost'}
                                size="sm"
                                onClick={() => onToolChange(tool.id as DrawingTool)}
                                className={cn(
                                    "h-10 justify-start px-3 transition-all rounded-xl",
                                    activeTool === tool.id
                                        ? "bg-cyan-500 text-white shadow-lg shadow-cyan-500/20 scale-[1.02]"
                                        : "text-slate-400 hover:text-white hover:bg-white/5"
                                )}
                            >
                                <div className="min-w-[24px] flex justify-center">
                                    {tool.icon}
                                </div>
                                <span className="ml-3 text-xs font-bold opacity-0 group-hover/sidebar:opacity-100 transition-opacity whitespace-nowrap">
                                    {tool.label}
                                </span>
                            </Button>
                        ))}
                    </div>
                </div>
            ))}

            <div className="flex flex-col gap-3 pt-4 border-t border-white/5">
                <span className="text-[10px] uppercase text-white/40 font-black tracking-widest px-2 opacity-0 group-hover/sidebar:opacity-100 transition-opacity">
                    Palette
                </span>
                <div className="grid grid-cols-2 group-hover/sidebar:grid-cols-4 gap-2 px-1">
                    {broadcastColors.map((c) => (
                        <button
                            key={c.hex}
                            onClick={() => onColorChange(c.hex)}
                            className={cn(
                                "w-6 h-6 rounded-full border-2 transition-transform hover:scale-125",
                                color === c.hex ? "border-white scale-110 shadow-lg" : "border-white/10"
                            )}
                            style={{ backgroundColor: c.hex }}
                            title={c.name}
                        />
                    ))}
                </div>
            </div>

            <div className="flex flex-col gap-3 pt-4 border-t border-white/5">
                <span className="text-[10px] uppercase text-white/40 font-black tracking-widest px-2 opacity-0 group-hover/sidebar:opacity-100 transition-opacity">
                    Thickness
                </span>
                <input
                    type="range"
                    min="1"
                    max="12"
                    step="1"
                    value={strokeWidth}
                    onChange={(e) => onStrokeWidthChange(Number(e.target.value))}
                    className="w-full h-1 bg-white/10 rounded-lg appearance-none cursor-pointer accent-cyan-400"
                />
            </div>

            <div className="mt-auto flex flex-col gap-2 border-t border-white/5 pt-4">
                <div className="flex gap-1 group-hover/sidebar:flex-row flex-col items-center group-hover/sidebar:justify-between">
                    <Button variant="ghost" size="icon" onClick={onUndo} className="h-8 w-8 text-slate-400 hover:text-white rounded-lg">
                        <Undo className="h-4 w-4" />
                    </Button>
                    <Button variant="ghost" size="icon" onClick={onClear} className="h-8 w-8 text-red-400 hover:bg-red-400/10 rounded-lg">
                        <Trash2 className="h-4 w-4" />
                    </Button>
                    <Button variant="ghost" size="icon" onClick={onExport} className="h-8 w-8 text-slate-400 hover:text-white rounded-lg">
                        <Download className="h-4 w-4" />
                    </Button>
                    <label className="h-8 w-8 flex items-center justify-center text-slate-400 hover:text-white cursor-pointer rounded-lg hover:bg-white/5">
                        <Upload className="h-4 w-4" />
                        <input type="file" accept=".json" onChange={(e) => onImport(e.target.files![0])} className="hidden" />
                    </label>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/TacticalPitchView.tsx">
import React, { useMemo } from 'react';
import PitchMap from '../PitchMap';
import { transformPoint, HomographyMatrix } from '@/utils/homography';

interface TacticalPitchViewProps {
    trackingData: any;
    currentTime: number;
    calibrationMatrix: HomographyMatrix | null;
    realtimeDetections?: any[];
    className?: string;
    teamNames?: { teamA: string; teamB: string };
}

export const TacticalPitchView: React.FC<TacticalPitchViewProps> = ({
    trackingData,
    currentTime,
    calibrationMatrix,
    realtimeDetections,
    className = '',
    teamNames = { teamA: 'Team A', teamB: 'Team B' }
}) => {
    // Project all players for the current frame
    const projectedPlayers = useMemo(() => {
        if (!trackingData?.tracks || !calibrationMatrix) return [];

        const fps = trackingData.metadata?.fps || 30;
        const currentFrame = Math.floor(currentTime * fps);
        const players: any[] = [];

        Object.entries(trackingData.tracks).forEach(([id, track]: [string, any]) => {
            const point = track.find((p: any) => p.frame === currentFrame);
            if (point) {
                // Determine base point (feet) for projection
                // If AI provides bbox [x1, y1, x2, y2], bottom center is ((x1+x2)/2, y2)
                // If it provides x, y, we hope it's already the bottom center or we approximate
                let basePoint = { x: point.x, y: point.y };

                if (point.bbox && Array.isArray(point.bbox) && point.bbox.length === 4) {
                    const [x1, y1, x2, y2] = point.bbox;
                    basePoint = { x: (x1 + x2) / 2, y: y2 };
                }

                // Transform it to pitch coordinates (0-105, 0-68)
                const projected = transformPoint(basePoint, calibrationMatrix);

                // Keep it within pitch bounds for visual safety
                players.push({
                    id: parseInt(id),
                    x: Math.max(0, Math.min(105, projected.x)),
                    y: Math.max(0, Math.min(68, projected.y)),
                    team: point.team === 'team_a' ? 'A' : (point.team === 'team_b' ? 'B' : (point.team === 'ball' ? 'BALL' : 'neutral')),
                    name: point.player_id ? `P${point.player_id}` : undefined,
                    isBall: point.team === 'ball'
                });
            }
        });

        return players;
    }, [trackingData, currentTime, calibrationMatrix]);

    // Use realtime detections if available and no tracking trackingData
    const playersToDisplay = useMemo(() => {
        if (projectedPlayers && projectedPlayers.length > 0) return projectedPlayers;
        if (!realtimeDetections || !calibrationMatrix) return [];

        return realtimeDetections.map((p, idx) => {
            // Assume p has x, y in pixels
            const projected = transformPoint({ x: p.x, y: p.y }, calibrationMatrix);
            return {
                id: p.id || idx,
                x: Math.max(0, Math.min(105, projected.x)),
                y: Math.max(0, Math.min(68, projected.y)),
                team: p.team === 'BALL' ? 'BALL' : (p.team === 'A' ? 'A' : (p.team === 'B' ? 'B' : 'neutral')),
                isBall: p.team === 'BALL'
            };
        });
    }, [projectedPlayers, realtimeDetections, calibrationMatrix]);

    return (
        <div className={`flex flex-col h-full bg-card rounded-xl border border-border/50 shadow-lg overflow-hidden ${className}`}>
            <div className="flex items-center justify-between px-4 py-2 border-b bg-muted/30">
                <div className="flex items-center gap-2">
                    <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse" />
                    <span className="text-xs font-bold uppercase tracking-wider">Tactical View (2D)</span>
                </div>
                <div className="flex gap-4">
                    <div className="flex items-center gap-1.5">
                        <div className="w-2 h-2 rounded-full bg-[#ef4444]" />
                        <span className="text-[10px] font-medium opacity-70">{teamNames.teamA}</span>
                    </div>
                    <div className="flex items-center gap-1.5">
                        <div className="w-2 h-2 rounded-full bg-[#3b82f6]" />
                        <span className="text-[10px] font-medium opacity-70">{teamNames.teamB}</span>
                    </div>
                </div>
            </div>

            <div className="flex-1 p-4 flex items-center justify-center min-h-0 bg-secondary/10">
                <PitchMap
                    playerPositions={playersToDisplay}
                    className="w-full max-h-full"
                    showLandmarks={false}
                />
            </div>

            {!calibrationMatrix && (
                <div className="absolute inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-6 text-center z-50">
                    <div className="max-w-[200px] space-y-2">
                        <p className="text-sm font-bold text-white">Calibration Required</p>
                        <p className="text-[10px] text-white/70">
                            Please use the "Auto-Detect" or manual calibration tool to enable the 2D tactical projection.
                        </p>
                    </div>
                </div>
            )}
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/Timeline.tsx">
import React, { useRef, useMemo, useState, useEffect } from 'react';
import { LoggedEvent } from '@/hooks/useGamepad';
import {
    Circle, Target, Shield, AlertTriangle, XCircle, Trophy,
    ArrowRight, Activity, Flag, ZoomIn, ZoomOut
} from 'lucide-react';

interface TimelineProps {
    duration: number;
    currentTime: number;
    events: LoggedEvent[];
    onSeek: (time: number) => void;
    variant?: 'minimal' | 'pro';
}

const TRACKS = [
    { id: 'goals', label: 'Goals & Shots', types: ['goal', 'shot', 'save'], color: 'bg-red-500', height: 40 },
    { id: 'passing', label: 'Passing', types: ['pass'], color: 'bg-blue-500', height: 30 },
    { id: 'defense', label: 'Defense', types: ['interception', 'tackle', 'foul', 'duel'], color: 'bg-orange-500', height: 30 },
    { id: 'other', label: 'Other', types: ['turnover', 'offside', 'loose_ball'], color: 'bg-zinc-500', height: 30 },
];

export const Timeline: React.FC<TimelineProps> = ({ duration, currentTime, events, onSeek, variant = 'pro' }) => {
    const timelineRef = useRef<HTMLDivElement>(null);
    const [isHovering, setIsHovering] = useState(false);
    const [zoom, setZoom] = useState(1);

    const handleMouseDown = (e: React.MouseEvent) => {
        if (!timelineRef.current || duration === 0) return;

        const updateTime = (clientX: number) => {
            const rect = timelineRef.current!.getBoundingClientRect();
            // Calculate strictly based on the timeline width (which is expanded when zoomed)
            const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
            const percentage = x / rect.width;
            onSeek(percentage * duration);
        };

        updateTime(e.clientX);

        const handleMouseMove = (mmE: MouseEvent) => {
            mmE.preventDefault();
            updateTime(mmE.clientX);
        };

        const handleMouseUp = () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    };

    const formatTime = (seconds: number) => {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    };

    // Group events into tracks
    const eventTracks = useMemo(() => {
        const grouped: Record<string, LoggedEvent[]> = {
            goals: [],
            passing: [],
            defense: [],
            other: []
        };

        events.forEach(e => {
            const name = e.eventName?.toLowerCase() || "";
            if (!e.videoTime) return;

            let placed = false;
            for (const track of TRACKS) {
                if (track.types.some(t => name.includes(t))) {
                    grouped[track.id].push(e);
                    placed = true;
                    break;
                }
            }
            if (!placed) grouped.other.push(e);
        });

        return grouped;
    }, [events]);

    const getEventIcon = (eventName: string) => {
        const name = eventName.toLowerCase();
        if (name.includes('pass')) return <ArrowRight className="w-3 h-3 text-blue-200" />;
        if (name.includes('shot')) return <Target className="w-3 h-3 text-red-200" />;
        if (name.includes('goal')) return <Trophy className="w-3 h-3 text-yellow-200" />;
        if (name.includes('foul')) return <AlertTriangle className="w-3 h-3 text-orange-200" />;
        if (name.includes('interception')) return <Shield className="w-3 h-3 text-green-200" />;
        if (name.includes('turnover')) return <XCircle className="w-3 h-3 text-gray-300" />;
        return <Circle className="w-2 h-2 text-white/50" />;
    };

    // Generate Ruler Ticks - Adaptive based on zoom
    const rulerTicks = useMemo(() => {
        if (!duration) return [];
        const baseStep = duration > 600 ? 60 : 10;
        // Increase density when zoomed in
        const step = zoom > 2 ? (baseStep / 2) : baseStep;

        const ticks = [];
        for (let t = 0; t <= duration; t += step) {
            ticks.push({ time: t, label: formatTime(t), left: (t / duration) * 100 });
        }
        return ticks;
    }, [duration, zoom]);

    if (variant === 'minimal') {
        return (
            <div
                ref={timelineRef}
                className="w-full h-8 bg-black/60 backdrop-blur-md border-t border-white/10 relative group cursor-pointer flex items-center px-4 select-none"
                onMouseDown={handleMouseDown}
                onMouseEnter={() => setIsHovering(true)}
                onMouseLeave={() => setIsHovering(false)}
            >
                {/* Progress Rail */}
                <div className="absolute left-0 right-0 top-1/2 h-1 bg-primary-500/20 -translate-y-1/2 rounded-full mx-4 overflow-visible">
                    <div
                        className="h-full bg-primary rounded-full relative"
                        style={{ width: `${(currentTime / (duration || 1)) * 100}%` }}
                    >
                        <div className="absolute right-0 top-1/2 w-3 h-3 bg-white rounded-full -translate-y-1/2 shadow transition-transform scale-0 group-hover:scale-100" />
                    </div>
                </div>

                {/* Simple Event Dots */}
                {events.map(event => {
                    const pos = ((event.videoTime || 0) / (duration || 1)) * 100;
                    if (pos < 0 || pos > 100) return null;
                    return (
                        <div
                            key={event.id}
                            className="absolute top-1/2 w-1.5 h-1.5 rounded-full -translate-y-1/2 -ml-[3px] bg-white/60 pointer-events-none"
                            style={{ left: `${pos}%` }}
                        />
                    );
                })}
            </div>
        );
    }

    return (
        <div
            className="w-full bg-zinc-950 border-t border-zinc-800 flex flex-col select-none relative group h-48"
            onMouseEnter={() => setIsHovering(true)}
            onMouseLeave={() => setIsHovering(false)}
        >
            {/* Zoom Controls */}
            <div className="absolute top-2 right-2 z-50 flex items-center gap-1 bg-black/80 rounded p-1 border border-white/10 shadow-lg">
                <button
                    onClick={() => setZoom(z => Math.max(1, z - 0.5))}
                    className="p-1 hover:bg-white/20 rounded text-white disabled:opacity-50"
                    disabled={zoom <= 1}
                    title="Zoom Out"
                >
                    <ZoomOut className="w-3 h-3" />
                </button>
                <span className="text-[10px] font-mono w-8 text-center text-white">{Math.round(zoom * 100)}%</span>
                <button
                    onClick={() => setZoom(z => Math.min(10, z + 0.5))}
                    className="p-1 hover:bg-white/20 rounded text-white"
                    title="Zoom In"
                >
                    <ZoomIn className="w-3 h-3" />
                </button>
            </div>

            {/* Scrollable Container */}
            <div className="flex-1 w-full overflow-x-auto overflow-y-hidden relative custom-scrollbar">
                {/* Scaled Content Wrapper */}
                <div
                    style={{ width: `${zoom * 100}%` }}
                    className="h-full flex flex-col relative transition-all duration-200 ease-out"
                >
                    {/* Top Ruler */}
                    <div className="h-6 bg-zinc-900 border-b border-zinc-800 relative w-full overflow-hidden text-[10px] text-zinc-500 font-mono flex-shrink-0">
                        {rulerTicks.map((tick) => (
                            <div
                                key={tick.time}
                                className="absolute top-0 h-full border-l border-zinc-700 pl-1 pt-1"
                                style={{ left: `${tick.left}%` }}
                            >
                                {tick.label}
                            </div>
                        ))}
                    </div>

                    {/* Tracks Area */}
                    <div
                        ref={timelineRef}
                        className="flex-1 relative w-full cursor-crosshair bg-zinc-900/50"
                        onMouseDown={handleMouseDown}
                    >
                        {/* Horizontal Grid Lines */}
                        {TRACKS.map((track, idx) => (
                            <div
                                key={track.id}
                                className="w-full border-b border-zinc-800 relative box-border flex items-center px-2"
                                style={{ height: `${track.height}px` }}
                            >
                                {/* Track Label (Sticky Left) */}
                                <div className="sticky left-2 text-[10px] font-bold text-zinc-600 uppercase tracking-wider pointer-events-none z-10 w-20 bg-zinc-900/50 backdrop-blur-sm px-1 rounded">
                                    {track.label}
                                </div>

                                {/* Events in this track */}
                                {eventTracks[track.id]?.map((event) => {
                                    const position = ((event.videoTime || 0) / (duration || 1)) * 100;
                                    return (
                                        <div
                                            key={event.id}
                                            className={`absolute top-1 bottom-1 w-1 min-w-[4px] rounded-sm hover:w-6 hover:z-20 transition-all cursor-pointer group/event flex items-center justify-center ${track.color.replace('bg-', 'bg-opacity-60 bg-')}`}
                                            style={{ left: `${position}%` }}
                                            title={`${event.eventName} @ ${formatTime(event.videoTime || 0)}`}
                                        >
                                            {/* Expanded view on hover */}
                                            <div className="hidden group-hover/event:flex w-full h-full items-center justify-center bg-black/80 rounded border border-white/20">
                                                {getEventIcon(event.eventName)}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        ))}

                        {/* Playhead Line (Full Height) */}
                        <div
                            className="absolute top-0 bottom-0 w-px bg-red-500 z-30 pointer-events-none shadow-[0_0_10px_rgba(239,68,68,0.5)]"
                            style={{ left: `${(currentTime / (duration || 1)) * 100}%` }}
                        >
                            <div className="absolute -top-3 -translate-x-1/2 text-[9px] bg-red-600 text-white px-1 rounded-sm font-mono whitespace-nowrap z-40">
                                {formatTime(currentTime)}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/VideoControls.tsx">
import { Button } from "@/components/ui/button";
import { Play, Pause, Volume2, VolumeX, SkipBack, SkipForward } from "lucide-react";

interface VideoControlsProps {
    isPlaying: boolean;
    currentTime: number;
    duration: number;
    volume: number;
    isMuted: boolean;
    playbackRate: number;
    togglePlay: () => void;
    handleSeek: (e: React.ChangeEvent<HTMLInputElement>) => void;
    handleVolumeChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    toggleMute: () => void;
    changePlaybackRate: () => void;
    skipTime: (seconds: number) => void;
    formatTime: (seconds: number) => string;
}

export const VideoControls = ({
    isPlaying,
    currentTime,
    duration,
    volume,
    isMuted,
    playbackRate,
    togglePlay,
    handleSeek,
    handleVolumeChange,
    toggleMute,
    changePlaybackRate,
    skipTime,
    formatTime
}: VideoControlsProps) => {
    return (
        <div className="space-y-2 p-2 bg-card rounded-lg border">
            <div className="flex items-center gap-2">
                <span className="text-xs text-muted-foreground min-w-[45px]">
                    {formatTime(currentTime)}
                </span>
                <input
                    type="range"
                    min="0"
                    max={duration || 0}
                    value={currentTime}
                    onChange={handleSeek}
                    className="flex-1 h-1 bg-muted rounded-lg appearance-none cursor-pointer"
                    style={{
                        background: `linear-gradient(to right, hsl(var(--primary)) 0%, hsl(var(--primary)) ${(currentTime / duration) * 100}%, hsl(var(--muted)) ${(currentTime / duration) * 100}%, hsl(var(--muted)) 100%)`
                    }}
                />
                <span className="text-xs text-muted-foreground min-w-[45px]">
                    {formatTime(duration)}
                </span>
            </div>

            <div className="flex items-center justify-between gap-2">
                <div className="flex items-center gap-1">
                    <Button variant="ghost" size="sm" onClick={() => skipTime(-10)} title="Back 10s">
                        <SkipBack className="h-4 w-4" />
                    </Button>
                    <Button variant="ghost" size="sm" onClick={togglePlay}>
                        {isPlaying ? <Pause className="h-4 w-4" /> : <Play className="h-4 w-4" />}
                    </Button>
                    <Button variant="ghost" size="sm" onClick={() => skipTime(10)} title="Forward 10s">
                        <SkipForward className="h-4 w-4" />
                    </Button>
                </div>

                <div className="flex items-center gap-2">
                    <Button variant="ghost" size="sm" onClick={toggleMute}>
                        {isMuted ? <VolumeX className="h-4 w-4" /> : <Volume2 className="h-4 w-4" />}
                    </Button>
                    <input
                        type="range"
                        min="0"
                        max="1"
                        step="0.1"
                        value={volume}
                        onChange={handleVolumeChange}
                        className="w-20 h-1"
                    />
                    <Button variant="ghost" size="sm" onClick={changePlaybackRate}>
                        <span className="text-xs">{playbackRate}x</span>
                    </Button>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/components/VideoPlayer/VideoOverlay.tsx">
import { LoggedEvent } from "@/hooks/useGamepad";
import { TeamRoster } from "@/types/player";

interface VisiblePlayer {
    x: number;
    y: number;
    team: string;
    confidence: number;
    speed?: number; // m/s
    is_sprinting?: boolean;
    id?: number;
}

interface PassingPrediction {
    ball_carrier_id: number;
    receiver_id: number;
    probability: number;
    receiver_position: [number, number]; // x, y in %
}

interface TacticalAlert {
    id: number;
    event_type: string;
    team: string;
    severity: string;
    description: string;
    timestamp: number;
}

interface VideoOverlayProps {
    zoomLevel: number;
    eventNotifications: Array<{ id: number; event: LoggedEvent; timestamp: number }>;
    showRoster: boolean;
    teams?: Map<string, TeamRoster>;
    selectedTeam?: string;
    teamNames?: { teamA: string; teamB: string };
    onCloseRoster: () => void;
    visiblePlayers?: VisiblePlayer[];
    passingPredictions?: PassingPrediction[];
    tacticalAlerts?: TacticalAlert[];
    showHeatmap?: boolean;
}

export const VideoOverlay = ({
    zoomLevel,
    eventNotifications,
    showRoster,
    teams,
    selectedTeam,
    teamNames,
    onCloseRoster,
    onPlayerSelect,
    visiblePlayers = [],
    passingPredictions = [],
    tacticalAlerts = [],
    showHeatmap = false
}: VideoOverlayProps & { onPlayerSelect?: (playerId: number) => void }) => {
    return (
        <>
            {/* Zoom Indicator */}
            {zoomLevel > 1 && (
                <div className="absolute top-2 right-2 bg-black/50 text-white px-2 py-1 rounded text-xs font-mono pointer-events-none z-20">
                    {zoomLevel.toFixed(1)}x
                </div>
            )}

            {/* Realtime Player Overlays */}
            {visiblePlayers.map((player, idx) => {
                const isBall = player.team === 'BALL';

                return (
                    <div
                        key={`${player.id}-${idx}`}
                        className="absolute pointer-events-none transition-all duration-75"
                        style={{
                            left: `${player.x}%`,
                            top: `${player.y}%`,
                            transform: isBall ? 'translate(-50%, -50%)' : 'translate(-50%, -100%)', // Ball centered, players at feet
                            zIndex: isBall ? 50 : 10 // Ball on top
                        }}
                    >
                        {isBall ? (
                            // Ball Marker
                            <div className="w-3 h-3 bg-yellow-400 rounded-full border border-black shadow-lg animate-pulse" />
                        ) : (
                            // Player Marker
                            <div className={`
                                w-4 h-4 rounded-full border-2 shadow-sm flex items-center justify-center
                                ${player.team === 'A' ? 'bg-red-500/50 border-red-400' : 'bg-blue-500/50 border-blue-400'}
                                ${player.is_sprinting ? 'animate-pulse ring-2 ring-yellow-400' : ''}
                            `}>
                                <div className="w-1 h-1 bg-white rounded-full" />
                            </div>
                        )}

                        {/* Speed Label */}
                        {player.speed && player.speed > (isBall ? 2 : 7.2) && (
                            <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1 bg-black/60 text-white text-[8px] px-1 rounded whitespace-nowrap backdrop-blur-sm">
                                {(player.speed * 3.6).toFixed(1)} km/h
                            </div>
                        )}
                    </div>
                );
            })}

            {/* Passing Prediction Lines */}
            {passingPredictions.map((pred, idx) => {
                const carrier = visiblePlayers.find(p => p.id === pred.ball_carrier_id);
                const receiver = visiblePlayers.find(p => p.id === pred.receiver_id);

                if (!carrier || !receiver || pred.probability < 0.4) return null;

                return (
                    <svg
                        key={`pass-${idx}`}
                        className="absolute inset-0 pointer-events-none"
                        style={{ width: '100%', height: '100%', zIndex: 5 }}
                    >
                        <line
                            x1={`${carrier.x}%`}
                            y1={`${carrier.y}%`}
                            x2={`${receiver.x}%`}
                            y2={`${receiver.y}%`}
                            stroke="rgba(255, 255, 0, 0.6)"
                            strokeWidth="2"
                            strokeDasharray="5,5"
                            opacity={pred.probability}
                        />
                        <circle
                            cx={`${receiver.x}%`}
                            cy={`${receiver.y}%`}
                            r="8"
                            fill="rgba(255, 255, 0, 0.3)"
                            stroke="rgba(255, 255, 0, 0.8)"
                            strokeWidth="2"
                        />
                    </svg>
                );
            })}

            {/* Heatmap Overlay */}
            {showHeatmap && visiblePlayers.length > 0 && (
                <div className="absolute inset-0 pointer-events-none" style={{ zIndex: 3 }}>
                    {visiblePlayers
                        .filter(p => p.team !== 'BALL')
                        .map((player, idx) => (
                            <div
                                key={`heat-${idx}`}
                                className="absolute rounded-full"
                                style={{
                                    left: `${player.x}%`,
                                    top: `${player.y}%`,
                                    width: '60px',
                                    height: '60px',
                                    transform: 'translate(-50%, -50%)',
                                    background: `radial-gradient(circle, ${player.team === 'A' ? 'rgba(255,0,0,0.3)' : 'rgba(0,0,255,0.3)'} 0%, transparent 70%)`,
                                    filter: 'blur(8px)'
                                }}
                            />
                        ))}
                </div>
            )}

            {/* Tactical Alerts */}
            <div className="absolute top-20 right-4 pointer-events-none z-30 space-y-2 w-72">
                {tacticalAlerts.slice(-3).map((alert) => (
                    <div
                        key={alert.id}
                        className={`bg-black/80 backdrop-blur-sm text-white px-3 py-2 rounded-lg border-l-4 shadow-lg animate-in slide-in-from-right
                            ${alert.severity === 'high' ? 'border-red-500' : alert.severity === 'medium' ? 'border-yellow-500' : 'border-blue-500'}`}
                    >
                        <div className="flex items-center gap-2">
                            <div className="flex-1">
                                <div className="font-bold text-xs uppercase">{alert.event_type.replace('_', ' ')}</div>
                                <div className="text-[10px] text-gray-300">{alert.description}</div>
                            </div>
                            <div className={`text-[10px] px-1.5 py-0.5 rounded
                                ${alert.severity === 'high' ? 'bg-red-500/20 text-red-300' :
                                    alert.severity === 'medium' ? 'bg-yellow-500/20 text-yellow-300' :
                                        'bg-blue-500/20 text-blue-300'}`}>
                                {alert.team}
                            </div>
                        </div>
                    </div>
                ))}
            </div>

            {/* Event Notifications */}
            <div className="absolute top-4 left-1/2 -translate-x-1/2 pointer-events-none z-30 space-y-2 w-96">
                {eventNotifications.map((notification) => {
                    const age = Date.now() - notification.timestamp;
                    const opacity = Math.max(0, 1 - (age / 3000));
                    const translateY = (age / 3000) * -20;

                    return (
                        <div
                            key={notification.id}
                            className="bg-black/80 backdrop-blur-sm text-white px-4 py-3 rounded-lg border-l-4 border-primary shadow-lg"
                            style={{
                                opacity,
                                transform: `translateY(${translateY}px)`,
                                transition: 'opacity 0.1s, transform 0.1s'
                            }}
                        >
                            <div className="flex items-center gap-3">
                                <div className="flex-1">
                                    <div className="font-bold text-lg">{notification.event.eventName}</div>
                                    <div className="text-sm text-gray-300 flex items-center gap-2">
                                        <span>
                                            {notification.event.team === "TEAM_A"
                                                ? (teamNames?.teamA || "Team A")
                                                : (teamNames?.teamB || "Team B")}
                                        </span>
                                        {notification.event.player && (
                                            <span>‚Ä¢ {notification.event.player.name}</span>
                                        )}
                                        {notification.event.matchTime && (
                                            <span>‚Ä¢ {notification.event.matchTime}</span>
                                        )}
                                    </div>
                                </div>
                                {notification.event.isCalculated && (
                                    <div className="text-xs bg-primary/20 text-primary px-2 py-1 rounded">
                                        AUTO
                                    </div>
                                )}
                            </div>
                        </div>
                    );
                })}
            </div>

            {/* Roster Display */}
            {showRoster && teams && selectedTeam && teams.get(selectedTeam) && (
                <>
                    <button
                        onClick={onCloseRoster}
                        className="absolute top-2 right-2 h-6 w-6 flex items-center justify-center bg-black/30 hover:bg-black/50 rounded-full text-white/60 hover:text-white transition-colors z-40 pointer-events-auto"
                    >
                        √ó
                    </button>

                    {/* Starting XI */}
                    <div className="absolute top-4 left-4 bottom-4 flex flex-col gap-2 pointer-events-none z-30">
                        {(() => {
                            const startingNumbers = [1, 2, 5, 6, 7, 8, 9, 10, 11, 15, 22];
                            return teams.get(selectedTeam)?.PlayerData
                                .filter(p => startingNumbers.includes(p.Number || 0))
                                .sort((a, b) => {
                                    const aIndex = startingNumbers.indexOf(a.Number || 0);
                                    const bIndex = startingNumbers.indexOf(b.Number || 0);
                                    return aIndex - bIndex;
                                })
                                .slice(0, 11)
                                .map((player) => (
                                    <div
                                        key={player.ID}
                                        onClick={() => onPlayerSelect?.(player.ID)}
                                        className="bg-black/20 backdrop-blur-sm rounded-md p-1.5 hover:bg-black/30 transition-all border border-white/10 hover:border-primary/30 pointer-events-auto cursor-pointer hover:scale-105 active:scale-95"
                                    >
                                        <div className="flex flex-col items-center gap-0.5">
                                            <div className="w-7 h-7 bg-primary/20 rounded-full flex items-center justify-center font-bold text-primary text-xs">
                                                {player.Number || '?'}
                                            </div>
                                            <div className="text-center">
                                                <div className="font-semibold text-[9px] text-white/90">
                                                    {player.Surname}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                ));
                        })()}
                    </div>

                    {/* Substitutes */}
                    {(() => {
                        const startingNumbers = [1, 2, 5, 6, 7, 8, 9, 10, 11, 15, 22];
                        const subs = teams.get(selectedTeam)?.PlayerData
                            .filter(p => !startingNumbers.includes(p.Number || 0))
                            .sort((a, b) => (a.Number || 99) - (b.Number || 99))
                            .slice(0, 7);

                        return subs && subs.length > 0 && (
                            <div className="absolute top-4 right-4 bottom-4 flex flex-col gap-2 pointer-events-none z-30">
                                {subs.map((player) => (
                                    <div
                                        key={player.ID}
                                        onClick={() => onPlayerSelect?.(player.ID)}
                                        className="bg-black/15 backdrop-blur-sm rounded-md p-1.5 hover:bg-black/25 transition-all border border-white/5 hover:border-white/15 pointer-events-auto cursor-pointer hover:scale-105 active:scale-95"
                                    >
                                        <div className="flex flex-col items-center gap-0.5">
                                            <div className="w-6 h-6 bg-gray-500/20 rounded-full flex items-center justify-center font-bold text-gray-300 text-[10px]">
                                                {player.Number || '?'}
                                            </div>
                                            <div className="text-center">
                                                <div className="font-medium text-[8px] text-white/70">
                                                    {player.Surname}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        );
                    })()}
                </>
            )}
        </>
    );
};
</file>

<file path="src/components/VideoUpload.tsx">
import { useRef } from "react";
import { Button } from "@/components/ui/button";
import { Upload, X, Video } from "lucide-react";
import { useToast } from "@/hooks/use-toast";

interface VideoUploadProps {
    onVideoUpload: (file: File) => void;
    currentVideo: File | null;
    onClearVideo: () => void;
}

export const VideoUpload = ({ onVideoUpload, currentVideo, onClearVideo }: VideoUploadProps) => {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const { toast } = useToast();

    const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            validateAndUpload(file);
        }
    };

    const validateAndUpload = (file: File) => {
        // Check if it's a video or image file
        if (!file.type.startsWith('video/') && !file.type.startsWith('image/')) {
            toast({
                title: "Invalid File",
                description: "Please select a valid video or image file",
                variant: "destructive"
            });
            return;
        }

        // Check file size (max 2GB)
        const maxSize = 2 * 1024 * 1024 * 1024; // 2GB
        if (file.size > maxSize) {
            toast({
                title: "File Too Large",
                description: "Video file must be less than 2GB",
                variant: "destructive"
            });
            return;
        }

        onVideoUpload(file);
        toast({
            title: "Video Loaded",
            description: `${file.name} ready for analysis`
        });
    };

    const handleDrop = (e: React.DragEvent) => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];
        if (file) {
            validateAndUpload(file);
        }
    };

    const handleDragOver = (e: React.DragEvent) => {
        e.preventDefault();
    };

    return (
        <div className="flex items-center gap-2">
            {!currentVideo ? (
                <>
                    <input
                        ref={fileInputRef}
                        type="file"
                        accept="video/*,image/*"
                        onChange={handleFileSelect}
                        className="hidden"
                    />
                    <Button
                        variant="outline"
                        size="sm"
                        onClick={() => fileInputRef.current?.click()}
                        onDrop={handleDrop}
                        onDragOver={handleDragOver}
                        className="gap-1 text-xs"
                        title="Upload match video/image"
                    >
                        <Upload className="h-3 w-3 md:h-4 md:w-4" />
                        <span className="hidden sm:inline">Upload Media</span>
                    </Button>
                </>
            ) : (
                <div className="flex items-center gap-1">
                    <Video className="h-3 w-3 md:h-4 md:w-4 text-green-500" />
                    <span className="text-xs hidden md:inline max-w-[100px] truncate" title={currentVideo.name}>
                        {currentVideo.name}
                    </span>
                    <Button
                        variant="ghost"
                        size="sm"
                        onClick={onClearVideo}
                        className="h-6 w-6 p-0"
                        title="Clear video"
                    >
                        <X className="h-3 w-3" />
                    </Button>
                </div>
            )}
        </div>
    );
};
</file>

<file path="src/components/ZoneGrid.tsx">
import React, { useRef, useState, useMemo, useEffect } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import {
    OrbitControls,
    PerspectiveCamera,
    Environment,
    ContactShadows,
    Html,
    Sparkles,
    Text,
    useCursor
} from '@react-three/drei';
import { EffectComposer, Bloom, Noise, Vignette } from '@react-three/postprocessing';
import * as THREE from 'three';

// --- Configuration & Types ---
interface ZoneGridProps {
    currentZone: number;
    onZoneClick?: (zoneId: number) => void;
}

const THEME = {
    grass: '#1a472a',
    grassDark: '#143821',
    lines: '#ffffff',
    activeZone: '#00ff88',    // Neon Green
    hoverZone: '#00ccff',     // Cyan
    inactiveZone: '#ffffff',
    neonBlue: '#3b82f6',
    neonRed: '#ef4444'
};

// --- Sub-Components ---

// 1. The Holographic Zone Marker
const HolographicZone = ({
    position,
    zoneId,
    label,
    isActive,
    onClick
}: {
    position: [number, number, number];
    zoneId: number;
    label: string;
    isActive: boolean;
    onClick: (id: number) => void;
}) => {
    const meshRef = useRef<THREE.Mesh>(null);
    const [hovered, setHovered] = useState(false);
    useCursor(hovered);

    // Animation loop for pulsing effect
    useFrame((state) => {
        if (!meshRef.current) return;

        // Bobbing motion
        const t = state.clock.getElapsedTime();
        meshRef.current.position.y = position[1] + (isActive ? 0.2 : 0.05) + Math.sin(t * 2 + zoneId) * 0.05;

        // Rotation for active state
        if (isActive) {
            meshRef.current.rotation.y += 0.01;
        } else {
            meshRef.current.rotation.y = 0;
        }
    });

    const targetColor = isActive ? THEME.activeZone : hovered ? THEME.hoverZone : THEME.inactiveZone;

    return (
        <group position={position}>
            {/* The Base Glow Pad */}
            <mesh
                ref={meshRef}
                onClick={(e) => { e.stopPropagation(); onClick(zoneId); }}
                onPointerOver={() => setHovered(true)}
                onPointerOut={() => setHovered(false)}
            >
                <cylinderGeometry args={[0.5, 0.5, 0.1, 32]} />
                <meshStandardMaterial
                    color={targetColor}
                    transparent
                    opacity={isActive ? 0.8 : hovered ? 0.4 : 0.1}
                    emissive={targetColor}
                    emissiveIntensity={isActive ? 2 : hovered ? 1 : 0}
                    metalness={0.8}
                    roughness={0.2}
                />
            </mesh>

            {/* Vertical Beam (Only when active) */}
            {isActive && (
                <mesh position={[0, 1, 0]}>
                    <cylinderGeometry args={[0.5, 0.5, 2, 32, 1, true]} />
                    <meshStandardMaterial
                        color={THEME.activeZone}
                        transparent
                        opacity={0.15}
                        side={THREE.DoubleSide}
                        blending={THREE.AdditiveBlending}
                        depthWrite={false}
                    />
                </mesh>
            )}

            {/* Floating 3D Text Label */}
            <Html position={[0, isActive ? 2.5 : 1, 0]} center sprite distanceFactor={10}>
                <div className={`
                    pointer-events-none select-none font-mono font-bold transition-all duration-300
                    ${isActive ? 'scale-125 text-green-400 text-glow' : 'scale-100 text-white/50'}
                `}
                    style={{ textShadow: isActive ? '0 0 10px rgba(0,255,136,0.8)' : 'none' }}>
                    {label}
                </div>
            </Html>
        </group>
    );
};

// 2. Realistic Grass Pitch
const PitchSurface = () => {
    // Procedural lines for the "mowed lawn" look
    const texture = useMemo(() => {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const context = canvas.getContext('2d');
        if (context) {
            context.fillStyle = THEME.grass;
            context.fillRect(0, 0, 1024, 1024);

            // Draw stripes
            context.fillStyle = THEME.grassDark;
            for (let i = 0; i < 20; i++) {
                if (i % 2 === 0) {
                    context.fillRect(0, i * (1024 / 20), 1024, 1024 / 20);
                }
            }
        }
        return new THREE.CanvasTexture(canvas);
    }, []);

    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    return (
        <group>
            {/* Main Grass */}
            <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
                <planeGeometry args={[7, 10]} />
                <meshStandardMaterial
                    map={texture}
                    roughness={0.8}
                    color="#ffffff"
                />
            </mesh>

            {/* White Lines (Using slight elevation to prevent z-fighting) */}
            <group position={[0, 0.01, 0]}>
                {/* Outer Border */}
                <mesh rotation={[-Math.PI / 2, 0, 0]}>
                    <ringGeometry args={[0, 5, 4, 1]} />
                    {/* Simplified for demo, usually we'd draw lines specifically */}
                </mesh>

                {/* Actual Lines Construction */}
                <Line position={[0, 0, 0]} args={[5.2, 8.2]} thickness={0.05} /> {/* Touchlines */}
                <Line position={[0, 0, 0]} args={[5.2, 0.05]} thickness={0.05} /> {/* Center Line */}

                {/* Center Circle */}
                <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, 0.02, 0]}>
                    <ringGeometry args={[0.8, 0.85, 64]} />
                    <meshBasicMaterial color="white" transparent opacity={0.8} />
                </mesh>

                {/* Boxes */}
                <BoxLine position={[0, -3.6]} width={2.5} height={1} />
                <BoxLine position={[0, 3.6]} width={2.5} height={1} />
            </group>
        </group>
    );
};

// Helper for drawing pitch lines
const Line = ({ position, args, thickness }: any) => (
    <mesh position={position} rotation={[-Math.PI / 2, 0, 0]}>
        <planeGeometry args={args} />
        <meshBasicMaterial color="none" />
        {/* Just a placeholder logic, simpler to do borders with separate meshes */}
        <lineSegments>
            <edgesGeometry args={[new THREE.PlaneGeometry(args[0], args[1])]} />
            <lineBasicMaterial color="white" linewidth={2} opacity={0.6} transparent />
        </lineSegments>
    </mesh>
);

const BoxLine = ({ position, width, height }: { position: [number, number], width: number, height: number }) => (
    <mesh position={[position[0], 0.02, position[1]]} rotation={[-Math.PI / 2, 0, 0]}>
        <planeGeometry args={[width, height]} />
        <meshBasicMaterial color="white" wireframe />
    </mesh>
);

// 3. The Goal (Schematic Style)
const GoalPost = ({ position, rotation = 0 }: { position: [number, number, number], rotation?: number }) => (
    <group position={position} rotation={[0, rotation, 0]}>
        {/* Posts */}
        <mesh position={[-1, 0.5, 0]}>
            <cylinderGeometry args={[0.05, 0.05, 1]} />
            <meshStandardMaterial color="white" />
        </mesh>
        <mesh position={[1, 0.5, 0]}>
            <cylinderGeometry args={[0.05, 0.05, 1]} />
            <meshStandardMaterial color="white" />
        </mesh>
        {/* Crossbar */}
        <mesh position={[0, 1, 0]} rotation={[0, 0, Math.PI / 2]}>
            <cylinderGeometry args={[0.05, 0.05, 2]} />
            <meshStandardMaterial color="white" />
        </mesh>
        {/* Net (Holographic) */}
        <mesh position={[0, 0.5, -0.5]}>
            <boxGeometry args={[2, 1, 1]} />
            <meshBasicMaterial color="white" wireframe opacity={0.1} transparent />
        </mesh>
    </group>
);


// --- Main Scene Component ---
const TacticalScene = ({ currentZone, onZoneClick }: ZoneGridProps) => {
    // Generate zone data
    const zones = useMemo(() => {
        const z = [];
        let id = 1;
        for (let row = 0; row < 6; row++) {
            for (let col = 0; col < 3; col++) {
                z.push({
                    id: id++,
                    pos: [(col - 1) * 1.5, 0, (row - 2.5) * 1.3] as [number, number, number],
                    label: `Z${id}` // Simplified label
                });
            }
        }
        return z;
    }, []);

    return (
        <>
            {/* Cinematic Controls */}
            <OrbitControls
                minPolarAngle={0}
                maxPolarAngle={Math.PI / 2.5} // Prevent going under the pitch
                maxDistance={12}
                minDistance={4}
                enablePan={false}
                autoRotate={false} // Enable for idle screen effect
            />

            <PerspectiveCamera makeDefault position={[0, 6, 8]} fov={45} />

            {/* --- LIGHTING (Stadium Night Match) --- */}
            <ambientLight intensity={0.2} color="#ccddff" />

            {/* Floodlights */}
            <spotLight
                position={[10, 15, 10]}
                angle={0.3}
                penumbra={1}
                intensity={2}
                color="#ffffff"
                castShadow
                shadow-mapSize={[1024, 1024]}
            />
            <spotLight
                position={[-10, 15, -10]}
                angle={0.3}
                penumbra={1}
                intensity={1}
                color="#aaccff"
            />

            {/* --- ENVIRONMENT --- */}
            <Environment preset="city" />
            <fog attach="fog" args={['#050505', 5, 25]} /> {/* Distance fog for depth */}

            {/* Floating Dust Particles (Atmosphere) */}
            <Sparkles count={50} scale={10} size={4} speed={0.4} opacity={0.5} color="#ffffff" />

            {/* --- OBJECTS --- */}
            <group position={[0, -0.5, 0]}>
                <PitchSurface />

                {/* Goals */}
                <GoalPost position={[0, 0, -4]} />
                <GoalPost position={[0, 0, 4]} rotation={Math.PI} />

                {/* Tactical Zones */}
                {zones.map((zone) => (
                    <HolographicZone
                        key={zone.id}
                        position={zone.pos}
                        zoneId={zone.id}
                        label={zone.label}
                        isActive={currentZone === zone.id}
                        onClick={onZoneClick || (() => { })}
                    />
                ))}
            </group>

            {/* Soft contact shadows to ground objects */}
            <ContactShadows resolution={1024} scale={20} blur={2} opacity={0.5} far={10} color="#000000" />

            {/* --- POST PROCESSING (The "TV" Look) --- */}
            <EffectComposer enableNormalPass>
                <Bloom luminanceThreshold={1} mipmapBlur intensity={1.5} radius={0.4} />
                <Noise opacity={0.05} />
                <Vignette eskil={false} offset={0.1} darkness={1.1} />
            </EffectComposer>
        </>
    );
};


// --- Exported Component ---
export const ZoneGrid: React.FC<ZoneGridProps> = ({ currentZone, onZoneClick }) => {
    return (
        <div className="relative w-full max-w-2xl mx-auto rounded-2xl overflow-hidden shadow-2xl border border-gray-800 bg-gray-950">
            {/* HUD Header */}
            {/* <div className="absolute top-0 left-0 right-0 z-10 p-4 flex justify-between items-start pointer-events-none">
                <div className="flex flex-col">
                    <span className="text-[10px] text-green-500 font-mono animate-pulse tracking-widest">LIVE FEED</span>
                    <h2 className="text-white font-black text-2xl tracking-tighter italic">TACTICAL CAM</h2>
                </div>
                <div className="bg-black/50 backdrop-blur border border-white/10 px-3 py-1 rounded text-right">
                    <div className="text-[10px] text-gray-400">CURRENT ZONE</div>
                    <div className="text-xl font-mono text-green-400 font-bold">{currentZone || '--'}</div>
                </div>
            </div> */}

            {/* Main Canvas */}
            <div className="h-[500px] w-full cursor-move">
                <Canvas shadows dpr={[1, 2]}>
                    <TacticalScene currentZone={currentZone} onZoneClick={onZoneClick} />
                </Canvas>
            </div>

            {/* HUD Footer */}
            <div className="absolute bottom-0 w-full bg-gradient-to-t from-black via-black/80 to-transparent p-4 pointer-events-none">
                <div className="flex gap-4 justify-center">
                    <div className="flex items-center gap-2">
                        <div className="w-2 h-2 rounded-full bg-green-500 shadow-[0_0_10px_#22c55e]"></div>
                        <span className="text-[10px] text-gray-300 font-mono">SELECTED</span>
                    </div>
                    <div className="flex items-center gap-2">
                        <div className="w-2 h-2 rounded-full bg-blue-500 shadow-[0_0_10px_#3b82f6]"></div>
                        <span className="text-[10px] text-gray-300 font-mono">NEUTRAL</span>
                    </div>
                </div>
            </div>

            {/* Scanlines Effect Overlay (CSS) */}
            <div className="absolute inset-0 pointer-events-none bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-20 mix-blend-overlay"></div>
            <div className="absolute inset-0 pointer-events-none" style={{
                background: 'linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06))',
                backgroundSize: '100% 2px, 3px 100%'
            }}></div>
        </div>
    );
};
</file>

<file path="src/components/ZoneIndicator.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
import { PitchThird, ThirdsZoneState } from '@/hooks/useGamepad';

interface ZoneIndicatorProps {
    thirdsZone: ThirdsZoneState;
    className?: string;
}

// Zone labels for display (optional)
const ZONE_LABELS = [
    '', // 0 index placeholder
    '1', '2', '3', '4', '5', '6',       // Defense
    '7', '8', '9', '10', '11', '12',    // Midfield
    '13', '14', '15', '16', '17', '18'  // Attack
];

/**
 * ZoneIndicator - Compact 6x3 mini-map showing active third and preview zone
 * 
 * Layout (from left to right = Defense -> Attack):
 * 
 *  Defense (LT)   |    Midfield    |   Attack (RT)
 *  [1] [2] [3]    |  [7] [8] [9]   | [13][14][15]
 *  [4] [5] [6]    | [10][11][12]   | [16][17][18]
 */
export const ZoneIndicator: React.FC<ZoneIndicatorProps> = ({ thirdsZone, className }) => {
    const { activeThird, previewZone, confirmedZone } = thirdsZone;

    // Generate zone grid (3 columns for thirds, 6 zones each = 2 rows x 3 cols per third)
    const renderZone = (zone: number) => {
        const isActive = previewZone === zone;
        const isConfirmed = confirmedZone === zone;

        // Determine which third this zone belongs to
        const zoneThird: PitchThird = zone <= 6 ? 'DEFENSE' : zone <= 12 ? 'MIDFIELD' : 'ATTACK';
        const isInActiveThird = zoneThird === activeThird;

        return (
            <div
                key={zone}
                className={cn(
                    "w-6 h-5 flex items-center justify-center text-[8px] font-bold rounded-sm transition-all duration-150",
                    // Base styling
                    "bg-black/40 border border-white/10",
                    // Active third highlight
                    isInActiveThird && "border-primary/50 bg-primary/10",
                    // Preview zone (stick pointing here)
                    isActive && "bg-primary border-primary text-primary-foreground scale-110 shadow-lg shadow-primary/30 z-10",
                    // Confirmed zone
                    isConfirmed && !isActive && "bg-green-500/30 border-green-500/50 text-green-400"
                )}
            >
                {zone}
            </div>
        );
    };

    const renderThird = (third: PitchThird, startZone: number, label: string) => {
        const isActive = activeThird === third;

        return (
            <div className="flex flex-col items-center gap-0.5">
                <span className={cn(
                    "text-[7px] font-black uppercase tracking-wider transition-colors",
                    isActive ? "text-primary" : "text-muted-foreground/50"
                )}>
                    {label}
                </span>
                <div className="grid grid-cols-3 gap-0.5">
                    {/* Row 1: Top zones */}
                    {renderZone(startZone)}
                    {renderZone(startZone + 1)}
                    {renderZone(startZone + 2)}
                    {/* Row 2: Bottom zones */}
                    {renderZone(startZone + 3)}
                    {renderZone(startZone + 4)}
                    {renderZone(startZone + 5)}
                </div>
            </div>
        );
    };

    return (
        <div className={cn(
            "flex items-center gap-1 p-2 rounded-lg bg-black/60 backdrop-blur-md border border-white/10 shadow-xl",
            className
        )}>
            {/* Defense Third */}
            {renderThird('DEFENSE', 1, 'LT: DEF')}

            {/* Divider */}
            <div className="w-px h-10 bg-white/10" />

            {/* Midfield Third */}
            {renderThird('MIDFIELD', 7, 'MID')}

            {/* Divider */}
            <div className="w-px h-10 bg-white/10" />

            {/* Attack Third */}
            {renderThird('ATTACK', 13, 'RT: ATK')}
        </div>
    );
};
</file>

<file path="src/components/ZoneSelectorOverlay.tsx">
import { LoggedEvent } from '@/hooks/useGamepad';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { MapPin, X, ChevronRight, Layout } from 'lucide-react';

interface ZoneSelectorOverlayProps {
    selectedZone: number;
    onConfirm: (zone: number) => void;
    onCancel: () => void;
    eventName?: string;
    pendingEvents: LoggedEvent[];
    onSelectEvent: (event: LoggedEvent) => void;
}

const ZoneSelectorOverlay: React.FC<ZoneSelectorOverlayProps> = ({
    selectedZone,
    onConfirm,
    onCancel,
    eventName,
    pendingEvents,
    onSelectEvent
}) => {
    // 3 columns x 6 rows = 18 zones (Standard Tacta Grid)
    const zones = Array.from({ length: 18 }, (_, i) => i + 1);

    return (
        <div className="fixed inset-0 z-[100] flex bg-zinc-950/90 backdrop-blur-md animate-in fade-in duration-300 overflow-hidden">
            {/* Left Sidebar: Pending Events */}
            <div className="w-[350px] border-r border-white/10 bg-black/40 p-6 flex flex-col h-full shadow-2xl">
                <div className="flex items-center gap-3 mb-8">
                    <div className="p-2 bg-amber-500/10 rounded-lg">
                        <Layout className="w-5 h-5 text-amber-500" />
                    </div>
                    <div>
                        <h2 className="text-xl font-bold text-white tracking-tight">EN ATTENTE</h2>
                        <p className="text-[10px] text-amber-500 font-bold uppercase tracking-widest opacity-70">Assignation de zone</p>
                    </div>
                </div>

                <ScrollArea className="flex-1 -mx-2 px-2">
                    <div className="space-y-3">
                        {pendingEvents.length === 0 ? (
                            <div className="text-center py-20 opacity-30">
                                <MapPin className="w-12 h-12 mx-auto mb-4" />
                                <p className="text-xs uppercase tracking-widest font-bold">Aucun √©v√©nement</p>
                            </div>
                        ) : (
                            pendingEvents.map((event) => (
                                <button
                                    key={event.id}
                                    onClick={() => onSelectEvent(event)}
                                    className={`w-full group relative flex flex-col gap-1 p-4 rounded-xl border transition-all text-left
                                        ${eventName === event.eventName && pendingEvents.find(e => e.eventName === eventName)?.id === event.id
                                            ? 'bg-amber-500/10 border-amber-500/50 shadow-lg shadow-amber-500/5'
                                            : 'bg-white/5 border-white/10 hover:border-white/20 hover:bg-white/[0.07]'}
                                    `}
                                >
                                    <div className="flex items-center justify-between">
                                        <Badge variant="outline" className={`text-[9px] h-4 px-1.5 ${event.team === 'TEAM_A' ? 'border-red-500/40 text-red-500' : 'border-blue-500/40 text-blue-500'}`}>
                                            {event.team === 'TEAM_A' ? 'TEAM A' : 'TEAM B'}
                                        </Badge>
                                        <span className="text-[9px] font-mono opacity-50 text-white">
                                            {new Date(event.timestamp).toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })}
                                        </span>
                                    </div>
                                    <span className="text-sm font-bold text-zinc-100 truncate mt-1">
                                        {event.eventName.replace(/_/g, ' ').toUpperCase()}
                                    </span>
                                </button>
                            ))
                        )}
                    </div>
                </ScrollArea>

                <div className="mt-8 p-4 bg-white/5 rounded-xl border border-white/10">
                    <div className="flex flex-col gap-3">
                        <div className="flex items-center justify-between text-[10px] font-bold text-zinc-400">
                            <span>üéÆ NAVIGUER</span>
                            <span className="text-zinc-500 italic">D-PAD</span>
                        </div>
                        <div className="flex items-center justify-between text-[10px] font-bold text-green-500">
                            <span>‚úÖ CONFIRMER</span>
                            <span>BUTTON A</span>
                        </div>
                        <div className="flex items-center justify-between text-[10px] font-bold text-red-500">
                            <span>‚ùå ANNULER</span>
                            <span>BUTTON B</span>
                        </div>
                    </div>
                </div>
            </div>

            {/* Right: Pitch Overlay */}
            <div className="flex-1 relative flex items-center justify-center p-12 bg-[radial-gradient(circle_at_center,rgba(59,130,246,0.05)_0%,transparent_100%)]">
                <div className="absolute top-12 left-1/2 -translate-x-1/2 text-center pointer-events-none">
                    <h1 className="text-4xl font-black text-white mb-2 tracking-tighter opacity-20">ZONE SELECTOR</h1>
                    <div className="h-1 w-24 bg-amber-500/30 mx-auto rounded-full" />
                </div>

                {/* Pitch Construction */}
                <div className="relative w-full max-w-2xl aspect-[3/4] bg-emerald-950/20 rounded-[2rem] border-4 border-white/20 p-8 shadow-[0_0_100px_rgba(0,0,0,0.5)]">
                    {/* Pitch Lines */}
                    <div className="absolute inset-8 border-2 border-white/20 rounded-sm pointer-events-none">
                        <div className="absolute top-1/2 left-0 right-0 h-0.5 bg-white/10" />
                        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-32 h-32 border-2 border-white/10 rounded-full" />
                    </div>

                    {/* Zone Grid */}
                    <div className="grid grid-cols-3 gap-2 h-full relative z-10">
                        {zones.map((zone) => (
                            <button
                                key={zone}
                                onClick={() => onConfirm(zone)}
                                className={`
                                    flex items-center justify-center rounded-xl border-2 text-3xl font-black transition-all duration-300
                                    ${selectedZone === zone
                                        ? 'bg-amber-500 border-white text-black scale-105 rotate-2 shadow-[0_0_40px_rgba(245,158,11,0.4)]'
                                        : 'bg-white/5 border-white/10 text-white/20 hover:bg-white/10 hover:border-white/30 hover:text-white/40'}
                                `}
                            >
                                {zone}
                            </button>
                        ))}
                    </div>
                </div>

                {/* Exit Button */}
                <button
                    onClick={onCancel}
                    className="absolute top-8 right-8 p-4 bg-white/5 hover:bg-red-500/20 text-white rounded-full transition-colors border border-white/10 group"
                >
                    <X className="w-8 h-8 group-hover:scale-110 transition-transform" />
                </button>
            </div>
        </div>
    );
};

export default ZoneSelectorOverlay;
</file>

<file path="src/config/eventRegistry.ts">
export type GamepadModifier = 'RT' | 'LT' | 'RB' | 'LB' | 'View' | 'Menu' | 'D-Up' | 'D-Down' | 'D-Left' | 'D-Right';

export interface GamepadMapping {
    buttonIndex: number;
    modifier?: GamepadModifier;
    isHold?: boolean;
    mode?: 'LIVE' | 'POST' | 'BOTH';
}

export interface EventDefinition {
    id: number;
    category: string;
    eventName: string;
    label: string; // Display name
    defaultDuration: [number, number]; // [min, max] in seconds
    trigger: string;
    endCondition?: string;
    isRealTime: boolean;
    isPostMatch?: boolean;
    folderPath?: string;
    filenameConvention?: string;
    requiresZone?: boolean;
    requiresDuration?: boolean;
    clippingEnabled?: boolean;
    gamepadMappings?: GamepadMapping[];
}

export const EVENT_REGISTRY: EventDefinition[] = [
    // 0. Core Gamepad & UI Events
    {
        id: 1001,
        category: "Core",
        eventName: "ui_confirm",
        label: "Confirm / A",
        defaultDuration: [0, 0],
        trigger: "Bouton A",
        endCondition: "Instantan√©",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/",
        filenameConvention: "UI.mp4",
        gamepadMappings: [{ buttonIndex: 0, mode: 'BOTH' }]
    },
    {
        id: 1002,
        category: "Core",
        eventName: "ui_cancel",
        label: "Cancel / B",
        defaultDuration: [0, 0],
        trigger: "Bouton B",
        endCondition: "Instantan√©",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/",
        filenameConvention: "UI.mp4",
        gamepadMappings: [{ buttonIndex: 1, mode: 'BOTH' }]
    },
    {
        id: 1003,
        category: "Core",
        eventName: "pass_start",
        label: "Pass Start / X",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "Bouton X",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Pass/",
        filenameConvention: "PASS_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 2, mode: 'BOTH' }]
    },
    {
        id: 1004,
        category: "Core",
        eventName: "shot_start",
        label: "Shot Start / Y",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "Bouton Y",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Shot/",
        filenameConvention: "SHOT_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 3, mode: 'BOTH' }]
    },
    {
        id: 1005,
        category: "Core",
        eventName: "turnover",
        label: "Perte / Turnover",
        defaultDuration: [5, 12],
        trigger: "Bouton LB",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Turnover/",
        filenameConvention: "TURNOVER_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 4, mode: 'LIVE' }]
    },
    {
        id: 1006,
        category: "Core",
        eventName: "carry_start",
        label: "Carry / Hold RB",
        defaultDuration: [5, 12],
        trigger: "Hold RB",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Carry/",
        filenameConvention: "CARRY_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 5, isHold: true, mode: 'LIVE' }]
    },
    {
        id: 1007,
        category: "Core",
        eventName: "clearance",
        label: "D√©gagement / LB+Y",
        defaultDuration: [5, 12],
        trigger: "LB+Y",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Clearance/",
        filenameConvention: "CLEARANCE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 3, modifier: 'LB', mode: 'LIVE' }]
    },
    {
        id: 1008,
        category: "Core",
        eventName: "dribble_attempt",
        label: "Dribble / RB+X",
        defaultDuration: [5, 12],
        trigger: "RB+X",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Dribble/",
        filenameConvention: "DRIBBLE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 2, modifier: 'RB', mode: 'LIVE' }]
    },
    {
        id: 1009,
        category: "Core",
        eventName: "tag_start",
        label: "Generic Tag / Menu",
        defaultDuration: [5, 12],
        trigger: "Bouton Menu",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Tags/",
        filenameConvention: "TAG_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 9, mode: 'LIVE' }]
    },
    {
        id: 1010,
        category: "Core",
        eventName: "press_trap",
        label: "Press Trap / L3",
        defaultDuration: [5, 12],
        trigger: "Bouton L3",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Tactical/",
        filenameConvention: "PRESS_TRAP_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 10, mode: 'LIVE' }]
    },
    {
        id: 1011,
        category: "Core",
        eventName: "dangerous_attack",
        label: "Dangerous / R3",
        defaultDuration: [5, 12],
        trigger: "Bouton R3",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Tactical/",
        filenameConvention: "DANGER_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 11, mode: 'LIVE' }]
    },
    {
        id: 1012,
        category: "Core",
        eventName: "pressing_trigger",
        label: "Press Trigger / D-Up",
        defaultDuration: [5, 12],
        trigger: "D-Pad Up",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Tactical/",
        filenameConvention: "PRESS_TRIGGER_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 12, mode: 'LIVE' }]
    },
    {
        id: 1013,
        category: "Core",
        eventName: "phase_lowblock",
        label: "Low Block / D-Down",
        defaultDuration: [5, 12],
        trigger: "D-Pad Down",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/Core/Tactical/",
        filenameConvention: "LOWBLOCK_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 13, mode: 'LIVE' }]
    },
    {
        id: 1014,
        category: "Core",
        eventName: "switch_of_play",
        label: "Switch / D-Left",
        defaultDuration: [5, 12],
        trigger: "D-Pad Left",
        isRealTime: true,
        isPostMatch: true,
        gamepadMappings: [{ buttonIndex: 14, mode: 'LIVE' }]
    },
    {
        id: 1015,
        category: "Core",
        eventName: "final_third_entry",
        label: "Final Third / RB+A",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D-Pad Right / RB+A",
        isRealTime: true,
        isPostMatch: true,
        gamepadMappings: [
            { buttonIndex: 15, mode: 'LIVE' },
            { buttonIndex: 0, modifier: 'RB', mode: 'LIVE' }
        ]
    },
    {
        id: 1016,
        category: "Core",
        eventName: "cross_start",
        label: "Cross / RT+B",
        defaultDuration: [5, 12],
        trigger: "RT+B",
        isRealTime: true,
        isPostMatch: true,
        gamepadMappings: [{ buttonIndex: 1, modifier: 'RT', mode: 'LIVE' }]
    },
    {
        id: 1017,
        category: "Core",
        eventName: "duel_ground",
        label: "Duel Ground / RT+X",
        defaultDuration: [5, 12],
        trigger: "RT+X",
        isRealTime: true,
        isPostMatch: true,
        gamepadMappings: [{ buttonIndex: 2, modifier: 'RT', mode: 'LIVE' }]
    },
    {
        id: 1018,
        category: "Core",
        eventName: "big_chance",
        label: "Big Chance / RT+R3",
        defaultDuration: [5, 12],
        trigger: "RT+R3",
        isRealTime: true,
        isPostMatch: true,
        gamepadMappings: [{ buttonIndex: 11, modifier: 'RT', mode: 'LIVE' }]
    },
    {
        id: 1019,
        category: "Core",
        eventName: "obs_toggle_record",
        label: "OBS Record / RT+Menu",
        defaultDuration: [0, 0],
        trigger: "RT+Menu",
        isRealTime: true,
        gamepadMappings: [{ buttonIndex: 9, modifier: 'RT', mode: 'LIVE' }]
    },
    {
        id: 1020,
        category: "Core",
        eventName: "ball_out_of_play",
        label: "Ball Out / LT+Menu",
        defaultDuration: [0, 0],
        trigger: "LT+Menu",
        isRealTime: true,
        gamepadMappings: [{ buttonIndex: 9, modifier: 'LT', mode: 'LIVE' }]
    },
    {
        id: 1021,
        category: "Core",
        eventName: "analyst_note",
        label: "Note / View+LB",
        defaultDuration: [0, 0],
        trigger: "View+LB",
        isRealTime: true,
        gamepadMappings: [{ buttonIndex: 4, modifier: 'View', mode: 'LIVE' }]
    },
    {
        id: 1022,
        category: "Core",
        eventName: "phase_highpress",
        label: "High Press / Hold D-Up",
        defaultDuration: [5, 12],
        trigger: "Hold D-Pad Up",
        isRealTime: true,
        gamepadMappings: [{ buttonIndex: 12, isHold: true, mode: 'LIVE' }]
    },
    {
        id: 1023,
        category: "Core",
        eventName: "free_kick",
        label: "Free Kick / RT+View",
        defaultDuration: [5, 12],
        trigger: "RT+View",
        isRealTime: true,
        gamepadMappings: [{ buttonIndex: 8, modifier: 'RT', mode: 'LIVE' }]
    },
    {
        id: 1024,
        category: "Core",
        eventName: "offside",
        label: "Offside / View+A",
        defaultDuration: [5, 12],
        trigger: "View+A",
        isRealTime: true,
        gamepadMappings: [{ buttonIndex: 0, modifier: 'View', mode: 'LIVE' }]
    },
    {
        id: 1025,
        category: "Core",
        eventName: "throw_in_tactical",
        label: "Throw-In / Menu+LB",
        defaultDuration: [5, 12],
        trigger: "Menu+LB",
        isRealTime: true,
        gamepadMappings: [
            { buttonIndex: 5, modifier: 'View', mode: 'LIVE' },
            { buttonIndex: 4, modifier: 'Menu', mode: 'LIVE' }
        ]
    },

    // 1. Build-Up
    {
        id: 1,
        category: "Build-Up",
        eventName: "sortie_de_balle_courte",
        label: "Sortie de balle courte",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Sortie_de_balle_courte/",
        filenameConvention: "SORTIE_DE_BALLE_COURTE_MIN_SEC.mp4"
    },
    {
        id: 2,
        category: "Build-Up",
        eventName: "sortie_de_balle_longue",
        label: "Sortie de balle longue",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Sortie_de_balle_longue/",
        filenameConvention: "SORTIE_DE_BALLE_LONGUE_MIN_SEC.mp4"
    },
    {
        id: 3,
        category: "Build-Up",
        eventName: "progression_axe",
        label: "Progression axe",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Progression_axe/",
        filenameConvention: "PROGRESSION_AXE_MIN_SEC.mp4"
    },
    {
        id: 4,
        category: "Build-Up",
        eventName: "progression_cote",
        label: "Progression c√¥t√©",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Progression_c√¥t√©/",
        filenameConvention: "PROGRESSION_C√îT√â_MIN_SEC.mp4"
    },
    {
        id: 5,
        category: "Build-Up",
        eventName: "circulation_lente",
        label: "Circulation lente",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Circulation_lente/",
        filenameConvention: "CIRCULATION_LENTE_MIN_SEC.mp4"
    },
    {
        id: 6,
        category: "Build-Up",
        eventName: "circulation_rapide",
        label: "Circulation rapide",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Circulation_rapide/",
        filenameConvention: "CIRCULATION_RAPIDE_MIN_SEC.mp4"
    },
    {
        id: 7,
        category: "Build-Up",
        eventName: "fixation_bloc",
        label: "Fixation bloc",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Fixation_bloc/",
        filenameConvention: "FIXATION_BLOC_MIN_SEC.mp4"
    },
    {
        id: 8,
        category: "Build-Up",
        eventName: "renversement",
        label: "Renversement / D-Left",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Renversement/",
        filenameConvention: "RENVERSEMENT_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 14, mode: 'BOTH' }]
    },
    {
        id: 9,
        category: "Build-Up",
        eventName: "troisieme_homme",
        label: "Troisi√®me homme",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Troisi√®me_homme/",
        filenameConvention: "TROISI√àME_HOMME_MIN_SEC.mp4"
    },
    {
        id: 10,
        category: "Build-Up",
        eventName: "break_line_pass",
        label: "Break line pass",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Break_line_pass/",
        filenameConvention: "BREAK_LINE_PASS_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 15, mode: 'LIVE' }]
    },
    {
        id: 11,
        category: "Build-Up",
        eventName: "appel_decroche",
        label: "Appel d√©croch√©",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Appel_d√©croch√©/",
        filenameConvention: "APPEL_D√âCROCH√â_MIN_SEC.mp4"
    },
    {
        id: 12,
        category: "Build-Up",
        eventName: "appel_profondeur",
        label: "Appel profondeur",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/01_BuildUp/Appel_profondeur/",
        filenameConvention: "APPEL_PROFONDEUR_MIN_SEC.mp4"
    },

    // 2. Offensive
    {
        id: 13,
        category: "Offensive",
        eventName: "tir_cadre",
        label: "Tir cadr√©",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Tir_cadr√©/",
        filenameConvention: "TIR_CADR√â_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 1, modifier: 'RB', mode: 'LIVE' }]
    },
    {
        id: 14,
        category: "Offensive",
        eventName: "tir_non_cadre",
        label: "Tir non cadr√©",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Tir_non_cadr√©/",
        filenameConvention: "TIR_NON_CADR√â_MIN_SEC.mp4"
    },
    {
        id: 15,
        category: "Offensive",
        eventName: "occasion_creee",
        label: "Occasion cr√©√©e",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Occasion_cr√©√©e/",
        filenameConvention: "OCCASION_CR√â√âE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 3, modifier: 'RB', mode: 'LIVE' }]
    },
    {
        id: 16,
        category: "Offensive",
        eventName: "xg_eleve",
        label: "xG √©lev√©",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/xG_√©lev√©/",
        filenameConvention: "XG_√âLEV√â_MIN_SEC.mp4"
    },
    {
        id: 17,
        category: "Offensive",
        eventName: "centre_dangereux",
        label: "Centre dangereux",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Centre_dangereux/",
        filenameConvention: "CENTRE_DANGEREUX_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 2, modifier: 'RB', mode: 'LIVE' }]
    },
    {
        id: 18,
        category: "Offensive",
        eventName: "centre_rate",
        label: "Centre rat√©",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Centre_rat√©/",
        filenameConvention: "CENTRE_RAT√â_MIN_SEC.mp4"
    },
    {
        id: 19,
        category: "Offensive",
        eventName: "dribble_reussi",
        label: "Dribble r√©ussi",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Dribble_r√©ussi/",
        filenameConvention: "DRIBBLE_R√âUSSI_MIN_SEC.mp4"
    },
    {
        id: 20,
        category: "Offensive",
        eventName: "dribble_rate",
        label: "Dribble rat√©",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Dribble_rat√©/",
        filenameConvention: "DRIBBLE_RAT√â_MIN_SEC.mp4"
    },
    {
        id: 21,
        category: "Offensive",
        eventName: "une_deux",
        label: "Une-deux",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Une-deux/",
        filenameConvention: "UNE-DEUX_MIN_SEC.mp4"
    },
    {
        id: 22,
        category: "Offensive",
        eventName: "passe_cle",
        label: "Passe cl√©",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Passe_cl√©/",
        filenameConvention: "PASSE_CL√â_MIN_SEC.mp4"
    },
    {
        id: 23,
        category: "Offensive",
        eventName: "counter_attack",
        label: "Contre-attaque",
        requiresZone: true,
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Contre-attaque/",
        filenameConvention: "CONTRE-ATTAQUE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 3, modifier: 'RB', mode: 'LIVE' }]
    },
    {
        id: 24,
        category: "Offensive",
        eventName: "projection_milieu",
        label: "Projection milieu",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/02_Offensive/Projection_milieu/",
        filenameConvention: "PROJECTION_MILIEU_MIN_SEC.mp4"
    },

    // 3. Defensive
    {
        id: 25,
        category: "D√©fensive",
        eventName: "duel_gagne",
        label: "Duel gagn√© / LB+B",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Duel_gagn√©/",
        filenameConvention: "DUEL_GAGN√â_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 1, modifier: 'LB', mode: 'LIVE' }]
    },
    {
        id: 26,
        category: "D√©fensive",
        eventName: "duel_perdu",
        label: "Duel perdu",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Duel_perdu/",
        filenameConvention: "DUEL_PERDU_MIN_SEC.mp4"
    },
    {
        id: 27,
        category: "D√©fensive",
        eventName: "interception",
        label: "Interception / LB+X",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Interception/",
        filenameConvention: "INTERCEPTION_MIN_SEC.mp4",
        gamepadMappings: [
            { buttonIndex: 5, mode: 'BOTH' },
            { buttonIndex: 2, modifier: 'LB', mode: 'LIVE' }
        ]
    },
    {
        id: 28,
        category: "D√©fensive",
        eventName: "tacle_reussi",
        label: "Tacle r√©ussi / LB+A",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Tacle_r√©ussi/",
        filenameConvention: "TACLE_R√âUSSI_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 0, modifier: 'LB', mode: 'LIVE' }]
    },
    {
        id: 29,
        category: "D√©fensive",
        eventName: "tacle_rate",
        label: "Tacle rat√©",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Tacle_rat√©/",
        filenameConvention: "TACLE_RAT√â_MIN_SEC.mp4"
    },
    {
        id: 30,
        category: "D√©fensive",
        eventName: "bloc_bas",
        label: "Bloc bas / D-Down",
        requiresZone: true,
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Bloc_bas/",
        filenameConvention: "BLOC_BAS_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 13, mode: 'BOTH' }]
    },
    {
        id: 31,
        category: "D√©fensive",
        eventName: "bloc_median",
        label: "Bloc m√©dian",
        requiresZone: true,
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Bloc_m√©dian/",
        filenameConvention: "BLOC_M√âDIAN_MIN_SEC.mp4"
    },
    {
        id: 32,
        category: "D√©fensive",
        eventName: "pressing_haut",
        label: "Pressing haut / D-Up",
        requiresZone: true,
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Pressing_haut/",
        filenameConvention: "PRESSING_HAUT_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 12, mode: 'BOTH' }]
    },
    {
        id: 33,
        category: "D√©fensive",
        eventName: "pressing_coordonne",
        label: "Pressing coordonn√©",
        requiresZone: true,
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Pressing_coordonn√©/",
        filenameConvention: "PRESSING_COORDONN√â_MIN_SEC.mp4"
    },
    {
        id: 34,
        category: "D√©fensive",
        eventName: "sortie_defenseur",
        label: "Sortie d√©fenseur",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Sortie_d√©fenseur/",
        filenameConvention: "SORTIE_D√âFENSEUR_MIN_SEC.mp4"
    },
    {
        id: 35,
        category: "D√©fensive",
        eventName: "couverture",
        label: "Couverture",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Couverture/",
        filenameConvention: "COUVERTURE_MIN_SEC.mp4"
    },
    {
        id: 36,
        category: "D√©fensive",
        eventName: "faute_tactique",
        label: "Faute tactique / Menu+RB",
        defaultDuration: [5, 12],
        trigger: "Menu+RB",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/03_Defensive/Faute_tactique/",
        filenameConvention: "FAUTE_TACTIQUE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 5, modifier: 'Menu', mode: 'BOTH' }]
    },

    // 4. Transition
    {
        id: 37,
        category: "Transition",
        eventName: "recuperation_haute",
        label: "R√©cup√©ration haute",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/04_Transition/R√©cup√©ration_haute/",
        filenameConvention: "R√âCUP√âRATION_HAUTE_MIN_SEC.mp4"
    },
    {
        id: 38,
        category: "Transition",
        eventName: "recuperation_mediane",
        label: "R√©cup√©ration m√©diane",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/04_Transition/R√©cup√©ration_m√©diane/",
        filenameConvention: "R√âCUP√âRATION_M√âDIANE_MIN_SEC.mp4"
    },
    {
        id: 39,
        category: "Transition",
        eventName: "recuperation_basse",
        label: "R√©cup√©ration basse",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/04_Transition/R√©cup√©ration_basse/",
        filenameConvention: "R√âCUP√âRATION_BASSE_MIN_SEC.mp4"
    },
    {
        id: 40,
        category: "Transition",
        eventName: "transition_off_start",
        label: "Transition offensive",
        requiresZone: true,
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/04_Transition/Transition_offensive/",
        filenameConvention: "TRANSITION_OFFENSIVE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 7, mode: 'LIVE' }]
    },
    {
        id: 41,
        category: "Transition",
        eventName: "transition_def_start",
        label: "Transition d√©fensive",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/04_Transition/Transition_d√©fensive/",
        filenameConvention: "TRANSITION_D√âFENSIVE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 6, mode: 'LIVE' }]
    },
    {
        id: 42,
        category: "Transition",
        eventName: "projection_rapide",
        label: "Projection rapide",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/04_Transition/Projection_rapide/",
        filenameConvention: "PROJECTION_RAPIDE_MIN_SEC.mp4"
    },
    {
        id: 43,
        category: "Transition",
        eventName: "retard_defensif",
        label: "Retard d√©fensif",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/04_Transition/Retard_d√©fensif/",
        filenameConvention: "RETARD_D√âFENSIF_MIN_SEC.mp4"
    },
    {
        id: 44,
        category: "Transition",
        eventName: "contre_pressing",
        label: "Contre pressing",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/04_Transition/Contre_pressing/",
        filenameConvention: "CONTRE_PRESSING_MIN_SEC.mp4"
    },
    {
        id: 45,
        category: "Transition",
        eventName: "perte_dangereuse",
        label: "Perte dangereuse",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/04_Transition/Perte_dangereuse/",
        filenameConvention: "PERTE_DANGEREUSE_MIN_SEC.mp4"
    },
    {
        id: 46,
        category: "Transition",
        eventName: "perte_anodine",
        label: "Perte anodine",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/04_Transition/Perte_anodine/",
        filenameConvention: "PERTE_ANODINE_MIN_SEC.mp4"
    },

    // 5. Moments Cl√©s
    {
        id: 47,
        category: "Moments Cl√©s",
        eventName: "goal",
        label: "But / Menu+Y",
        defaultDuration: [5, 12],
        trigger: "Menu+Y",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/05_MomentsCles/But/",
        filenameConvention: "BUT_MIN_SEC.mp4",
        gamepadMappings: [
            { buttonIndex: 3, modifier: 'Menu', mode: 'BOTH' },
            { buttonIndex: 5, mode: 'POST' }
        ]
    },
    {
        id: 48,
        category: "Moments Cl√©s",
        eventName: "but_refuse",
        label: "But refus√©",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/05_MomentsCles/But_refus√©/",
        filenameConvention: "BUT_REFUS√â_MIN_SEC.mp4"
    },
    {
        id: 49,
        category: "Moments Cl√©s",
        eventName: "passe_decisive",
        label: "Passe d√©cisive / Menu+X",
        defaultDuration: [5, 12],
        trigger: "Menu+X",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/05_MomentsCles/Passe_d√©cisive/",
        filenameConvention: "PASSE_D√âCISIVE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 2, modifier: 'Menu', mode: 'BOTH' }]
    },
    {
        id: 50,
        category: "Moments Cl√©s",
        eventName: "penalty",
        label: "Penalty obtenu",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/05_MomentsCles/Penalty_obtenu/",
        filenameConvention: "PENALTY_OBTENU_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 8, modifier: 'LT', mode: 'LIVE' }]
    },
    {
        id: 51,
        category: "Moments Cl√©s",
        eventName: "penalty_concede",
        label: "Penalty conc√©d√©",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/05_MomentsCles/Penalty_conc√©d√©/",
        filenameConvention: "PENALTY_CONC√âD√â_MIN_SEC.mp4"
    },
    {
        id: 52,
        category: "Moments Cl√©s",
        eventName: "occasion_ratee",
        label: "Occasion rat√©e",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/05_MomentsCles/Occasion_rat√©e/",
        filenameConvention: "OCCASION_RAT√âE_MIN_SEC.mp4"
    },
    {
        id: 53,
        category: "Moments Cl√©s",
        eventName: "sauvetage_ligne",
        label: "Sauvetage ligne",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/05_MomentsCles/Sauvetage_ligne/",
        filenameConvention: "SAUVETAGE_LIGNE_MIN_SEC.mp4"
    },
    {
        id: 54,
        category: "Moments Cl√©s",
        eventName: "erreur_menant_au_tir",
        label: "Erreur menant au tir",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/05_MomentsCles/Erreur_menant_au_tir/",
        filenameConvention: "ERREUR_MENANT_AU_TIR_MIN_SEC.mp4"
    },
    {
        id: 55,
        category: "Moments Cl√©s",
        eventName: "erreur_menant_au_but",
        label: "Erreur menant au but",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/05_MomentsCles/Erreur_menant_au_but/",
        filenameConvention: "ERREUR_MENANT_AU_BUT_MIN_SEC.mp4"
    },
    {
        id: 56,
        category: "Moments Cl√©s",
        eventName: "action_decisive",
        label: "Action d√©cisive",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/05_MomentsCles/Action_d√©cisive/",
        filenameConvention: "ACTION_D√âCISIVE_MIN_SEC.mp4"
    },

    // 6. Phases Arr√™t√©es
    {
        id: 57,
        category: "Phases Arr√™t√©es",
        eventName: "corner_offensif",
        label: "Corner offensif",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/06_SetPieces/Corner_offensif/",
        filenameConvention: "CORNER_OFFENSIF_MIN_SEC.mp4"
    },
    {
        id: 58,
        category: "Phases Arr√™t√©es",
        eventName: "corner_defensif",
        label: "Corner d√©fensif",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/06_SetPieces/Corner_d√©fensif/",
        filenameConvention: "CORNER_D√âFENSIF_MIN_SEC.mp4"
    },
    {
        id: 59,
        category: "Phases Arr√™t√©es",
        eventName: "coup_franc_direct",
        label: "Coup franc direct",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/06_SetPieces/Coup_franc_direct/",
        filenameConvention: "COUP_FRANC_DIRECT_MIN_SEC.mp4"
    },
    {
        id: 60,
        category: "Phases Arr√™t√©es",
        eventName: "coup_franc_indirect",
        label: "Coup franc indirect",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/06_SetPieces/Coup_franc_indirect/",
        filenameConvention: "COUP_FRANC_INDIRECT_MIN_SEC.mp4"
    },
    {
        id: 61,
        category: "Phases Arr√™t√©es",
        eventName: "penalty_tire",
        label: "Penalty tir√©",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/06_SetPieces/Penalty_tir√©/",
        filenameConvention: "PENALTY_TIR√â_MIN_SEC.mp4"
    },
    {
        id: 62,
        category: "Phases Arr√™t√©es",
        eventName: "penalty_arrete",
        label: "Penalty arr√™t√©",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/06_SetPieces/Penalty_arr√™t√©/",
        filenameConvention: "PENALTY_ARR√äT√â_MIN_SEC.mp4"
    },
    {
        id: 63,
        category: "Phases Arr√™t√©es",
        eventName: "second_ballon_cpa",
        label: "Second ballon CPA",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/06_SetPieces/Second_ballon_CPA/",
        filenameConvention: "SECOND_BALLON_CPA_MIN_SEC.mp4"
    },
    {
        id: 64,
        category: "Phases Arr√™t√©es",
        eventName: "organisation_cpa",
        label: "Organisation CPA",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/06_SetPieces/Organisation_CPA/",
        filenameConvention: "ORGANISATION_CPA_MIN_SEC.mp4"
    },

    // 7. Gardien
    {
        id: 65,
        category: "Gardien",
        eventName: "arret_simple",
        label: "Arr√™t simple",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/07_Gardien/Arr√™t_simple/",
        filenameConvention: "ARR√äT_SIMPLE_MIN_SEC.mp4"
    },
    {
        id: 66,
        category: "Gardien",
        eventName: "arret_reflexe",
        label: "Arr√™t r√©flexe",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/07_Gardien/Arr√™t_r√©flexe/",
        filenameConvention: "ARR√äT_R√âFLEXE_MIN_SEC.mp4"
    },
    {
        id: 67,
        category: "Gardien",
        eventName: "sortie_aerienne",
        label: "Sortie a√©rienne",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/07_Gardien/Sortie_a√©rienne/",
        filenameConvention: "SORTIE_A√âRIENNE_MIN_SEC.mp4"
    },
    {
        id: 68,
        category: "Gardien",
        eventName: "sortie_au_sol",
        label: "Sortie au sol",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/07_Gardien/Sortie_au_sol/",
        filenameConvention: "SORTIE_AU_SOL_MIN_SEC.mp4"
    },
    {
        id: 69,
        category: "Gardien",
        eventName: "relance_courte",
        label: "Relance courte",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/07_Gardien/Relance_courte/",
        filenameConvention: "RELANCE_COURTE_MIN_SEC.mp4"
    },
    {
        id: 70,
        category: "Gardien",
        eventName: "relance_longue",
        label: "Relance longue",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/07_Gardien/Relance_longue/",
        filenameConvention: "RELANCE_LONGUE_MIN_SEC.mp4"
    },
    {
        id: 71,
        category: "Gardien",
        eventName: "erreur_relance",
        label: "Erreur relance",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/07_Gardien/Erreur_relance/",
        filenameConvention: "ERREUR_RELANCE_MIN_SEC.mp4"
    },
    {
        id: 72,
        category: "Gardien",
        eventName: "1v1_gagne",
        label: "1v1 gagn√©",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/07_Gardien/1v1_gagn√©/",
        filenameConvention: "1V1_GAGN√â_MIN_SEC.mp4"
    },
    {
        id: 73,
        category: "Gardien",
        eventName: "1v1_perdu",
        label: "1v1 perdu",
        requiresZone: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/07_Gardien/1v1_perdu/",
        filenameConvention: "1V1_PERDU_MIN_SEC.mp4"
    },

    // 8. Discipline
    {
        id: 74,
        category: "Discipline",
        eventName: "foul",
        label: "Faute simple",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/08_Discipline/Faute_simple/",
        filenameConvention: "FAUTE_SIMPLE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 8, mode: 'LIVE' }]
    },
    {
        id: 75,
        category: "Discipline",
        eventName: "faute_dangereuse",
        label: "Faute dangereuse",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/08_Discipline/Faute_dangereuse/",
        filenameConvention: "FAUTE_DANGEREUSE_MIN_SEC.mp4"
    },
    {
        id: 76,
        category: "Discipline",
        eventName: "card_yellow",
        label: "Carton jaune",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/08_Discipline/Carton_jaune/",
        filenameConvention: "CARTON_JAUNE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 3, modifier: 'View', mode: 'LIVE' }]
    },
    {
        id: 77,
        category: "Discipline",
        eventName: "card_red",
        label: "Carton rouge",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/08_Discipline/Carton_rouge/",
        filenameConvention: "CARTON_ROUGE_MIN_SEC.mp4",
        gamepadMappings: [{ buttonIndex: 1, modifier: 'View', mode: 'LIVE' }]
    },
    {
        id: 78,
        category: "Discipline",
        eventName: "avertissement_verbal",
        label: "Avertissement verbal",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/08_Discipline/Avertissement_verbal/",
        filenameConvention: "AVERTISSEMENT_VERBAL_MIN_SEC.mp4"
    },

    // 9. Physique
    {
        id: 79,
        category: "Physique",
        eventName: "sprint",
        label: "Sprint",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/09_Physique/Sprint/",
        filenameConvention: "SPRINT_MIN_SEC.mp4"
    },
    {
        id: 80,
        category: "Physique",
        eventName: "haute_intensite",
        label: "Haute intensit√©",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/09_Physique/Haute_intensit√©/",
        filenameConvention: "HAUTE_INTENSIT√â_MIN_SEC.mp4"
    },
    {
        id: 81,
        category: "Physique",
        eventName: "baisse_de_rythme",
        label: "Baisse de rythme",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/09_Physique/Baisse_de_rythme/",
        filenameConvention: "BAISSE_DE_RYTHME_MIN_SEC.mp4"
    },
    {
        id: 82,
        category: "Physique",
        eventName: "retour_defensif_long",
        label: "Retour d√©fensif long",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/09_Physique/Retour_d√©fensif_long/",
        filenameConvention: "RETOUR_D√âFENSIF_LONG_MIN_SEC.mp4"
    },
    {
        id: 83,
        category: "Physique",
        eventName: "fatigue_visible",
        label: "Fatigue visible",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/09_Physique/Fatigue_visible/",
        filenameConvention: "FATIGUE_VISIBLE_MIN_SEC.mp4"
    },

    // 10. Tactique
    {
        id: 84,
        category: "Tactique",
        eventName: "changement_systeme",
        label: "Changement syst√®me",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/10_Tactique/Changement_syst√®me/",
        filenameConvention: "CHANGEMENT_SYST√àME_MIN_SEC.mp4"
    },
    {
        id: 85,
        category: "Tactique",
        eventName: "ajustement_pressing",
        label: "Ajustement pressing",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/10_Tactique/Ajustement_pressing/",
        filenameConvention: "AJUSTEMENT_PRESSING_MIN_SEC.mp4"
    },
    {
        id: 86,
        category: "Tactique",
        eventName: "bloc_plus_haut",
        label: "Bloc plus haut",
        requiresZone: true,
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/10_Tactique/Bloc_plus_haut/",
        filenameConvention: "BLOC_PLUS_HAUT_MIN_SEC.mp4"
    },
    {
        id: 87,
        category: "Tactique",
        eventName: "bloc_plus_bas",
        label: "Bloc plus bas",
        requiresZone: true,
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/10_Tactique/Bloc_plus_bas/",
        filenameConvention: "BLOC_PLUS_BAS_MIN_SEC.mp4"
    },
    {
        id: 88,
        category: "Tactique",
        eventName: "desequilibre_cote",
        label: "D√©s√©quilibre c√¥t√©",
        requiresZone: true,
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/10_Tactique/D√©s√©quilibre_c√¥t√©/",
        filenameConvention: "D√âS√âQUILIBRE_C√îT√â_MIN_SEC.mp4"
    },
    {
        id: 89,
        category: "Tactique",
        eventName: "surnombre_cree",
        label: "Surnombre cr√©√©",
        requiresZone: true,
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/10_Tactique/Surnombre_cr√©√©/",
        filenameConvention: "SURNOMBRE_CR√â√â_MIN_SEC.mp4"
    },

    // 11. Psychologique
    {
        id: 90,
        category: "Psychologique",
        eventName: "leadership",
        label: "Leadership",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/11_Psychologique/Leadership/",
        filenameConvention: "LEADERSHIP_MIN_SEC.mp4"
    },
    {
        id: 91,
        category: "Psychologique",
        eventName: "reaction_apres_but",
        label: "R√©action apr√®s but",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/11_Psychologique/R√©action_apr√®s_but/",
        filenameConvention: "R√âACTION_APR√àS_BUT_MIN_SEC.mp4"
    },
    {
        id: 92,
        category: "Psychologique",
        eventName: "perte_de_concentration",
        label: "Perte de concentration",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/11_Psychologique/Perte_de_concentration/",
        filenameConvention: "PERTE_DE_CONCENTRATION_MIN_SEC.mp4"
    },
    {
        id: 93,
        category: "Psychologique",
        eventName: "motivation_collective",
        label: "Motivation collective",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/11_Psychologique/Motivation_collective/",
        filenameConvention: "MOTIVATION_COLLECTIVE_MIN_SEC.mp4"
    },

    // 12. Match
    {
        id: 94,
        category: "Match",
        eventName: "coup_denvoi",
        label: "Coup d‚Äôenvoi",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/12_Match/Coup_d‚Äôenvoi/",
        filenameConvention: "COUP_D‚ÄôENVOI_MIN_SEC.mp4"
    },
    {
        id: 95,
        category: "Match",
        eventName: "mi_temps",
        label: "Mi-temps",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/12_Match/Mi-temps/",
        filenameConvention: "MI-TEMPS_MIN_SEC.mp4"
    },
    {
        id: 96,
        category: "Match",
        eventName: "fin_de_match",
        label: "Fin de match",
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: false,
        isPostMatch: true,
        folderPath: "/Match_DATE/12_Match/Fin_de_match/",
        filenameConvention: "FIN_DE_MATCH_MIN_SEC.mp4"
    },
    {
        id: 97,
        category: "Match",
        eventName: "temps_fort",
        label: "Temps fort",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/12_Match/Temps_fort/",
        filenameConvention: "TEMPS_FORT_MIN_SEC.mp4"
    },
    {
        id: 98,
        category: "Match",
        eventName: "temps_faible",
        label: "Temps faible",
        requiresDuration: true,
        defaultDuration: [5, 12],
        trigger: "D√©clencheur terrain",
        endCondition: "Action termin√©e",
        isRealTime: true,
        isPostMatch: true,
        folderPath: "/Match_DATE/12_Match/Temps_faible/",
        filenameConvention: "TEMPS_FAIBLE_MIN_SEC.mp4"
    }
];

export const getEventsByCategory = (category: string) => EVENT_REGISTRY.filter(e => e.category === category);
export const getAllCategories = () => Array.from(new Set(EVENT_REGISTRY.map(e => e.category)));
</file>

<file path="src/config/multer.js">
// src/config/multer.js - File upload configuration
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '../..');

const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        const uploadDir = path.join(rootDir, 'public', 'uploads');
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
    },
    filename: function (req, file, cb) {
        // Use 'file-' prefix by default, or 'video-' if it's a video, or 'image-' if it's an image
        let prefix = 'file-';
        if (file.mimetype.startsWith('video/')) prefix = 'video-';
        if (file.mimetype.startsWith('image/')) prefix = 'image-';

        cb(null, prefix + Date.now() + path.extname(file.originalname));
    }
});

export const upload = multer({ storage });
</file>

<file path="src/config/state.js">
// src/config/state.js - Application state management
export const state = {
    events: [],
    matchTime: 0,
    isMatchActive: false,
    selectedTeam: "",
    teams: [],
    videoState: {
        currentTime: 0,
        isPlaying: false,
        playbackRate: 1.0,
        videoUrl: ""
    },
    isSessionStarted: false,
    videoMode: 'live',
    useVideoMode: true,
    streamUrl: ""
};

export let broadcasterId = null;

export function setBroadcasterId(id) {
    broadcasterId = id;
}

export function resetBroadcaster() {
    broadcasterId = null;
}
</file>

<file path="src/contexts/AuthContext.tsx">
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { API_BASE_URL, API_HEADERS } from '@/utils/apiConfig';

export type UserRole = 'operational_analyst' | 'tactical_analyst' | 'quality_controller' | 'early_tester' | 'admin' | 'lead_analyst' | 'live_tagger' | 'eye_spotter' | 'logger';

export interface User {
    id: number;
    username: string;
    role: UserRole;
    name: string;
    permissions: string[];
}

interface AuthContextType {
    user: User | null;
    token: string | null;
    login: (username: string, password: string) => Promise<void>;
    logout: () => void;
    isAuthenticated: boolean;
    hasPermission: (permission: string) => boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(() => {
        const stored = localStorage.getItem('tacta_user');
        try {
            return stored ? JSON.parse(stored) : null;
        } catch (e) {
            console.error("Failed to parse initial user", e);
            return null;
        }
    });
    const [token, setToken] = useState<string | null>(localStorage.getItem('tacta_token'));
    const [isAuthenticated, setIsAuthenticated] = useState<boolean>(!!localStorage.getItem('tacta_token'));

    useEffect(() => {
        const storedUser = localStorage.getItem('tacta_user');
        const storedToken = localStorage.getItem('tacta_token');

        if (storedToken && storedUser) {
            try {
                const parsedUser = JSON.parse(storedUser);
                setUser(parsedUser);
            } catch (e) {
                console.error("Failed to parse user data", e);
                logout();
            }
        } else if (storedToken && !storedUser) {
            console.warn("Found token but no user data, logging out to ensure consistency");
            logout();
        }
    }, []);

    const hasPermission = (permission: string): boolean => {
        if (!user || !user.permissions) return false;

        // Admin wildcard
        if (user.permissions.includes('*')) return true;

        // Exact match
        if (user.permissions.includes(permission)) return true;

        // Check for category wildcards (e.g. 'dashboard.*' matches 'dashboard.view')
        const wildcardPermissions = user.permissions.filter(p => p.endsWith('.*'));
        for (const wp of wildcardPermissions) {
            const prefix = wp.slice(0, -2);
            if (permission.startsWith(prefix)) return true;
        }

        return false;
    };

    const login = async (username: string, password: string) => {
        try {
            const response = await fetch(`${API_BASE_URL}/api/auth/login`, {
                method: 'POST',
                headers: API_HEADERS,
                body: JSON.stringify({ username, password }),
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Login failed');
            }

            const data = await response.json();
            setToken(data.token);
            setUser(data.user);
            setIsAuthenticated(true);
            localStorage.setItem('tacta_token', data.token);
            localStorage.setItem('tacta_user', JSON.stringify(data.user));
        } catch (error) {
            console.error('Login error:', error);
            throw error;
        }
    };

    const logout = () => {
        setToken(null);
        setUser(null);
        setIsAuthenticated(false);
        localStorage.removeItem('tacta_token');
        localStorage.removeItem('tacta_user');
        window.location.href = '/login';
    };

    return (
        <AuthContext.Provider value={{ user, token, login, logout, isAuthenticated, hasPermission }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
</file>

<file path="src/contexts/EventConfigContext.tsx">
import React, { createContext, useContext, useEffect, useState } from 'react';
import { EVENT_REGISTRY, EventDefinition } from '../config/eventRegistry';
import { toast } from 'sonner';
import { API_BASE_URL } from '@/utils/apiConfig';

interface EventConfigContextType {
    events: EventDefinition[];
    isLoading: boolean;
    updateEvent: (updatedEvent: EventDefinition) => Promise<void>;
    resetToDefaults: () => Promise<void>;
    saveConfig: () => Promise<void>;
}

const EventConfigContext = createContext<EventConfigContextType | undefined>(undefined);

export const EventConfigProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [events, setEvents] = useState<EventDefinition[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    const fetchConfig = async () => {
        try {
            setIsLoading(true);
            const res = await fetch(`${API_BASE_URL}/api/events-config`);
            if (!res.ok) throw new Error('Failed to fetch config');
            const data = await res.json();

            if (Array.isArray(data) && data.length > 0) {
                setEvents(data);
            } else {
                // Determine if we should auto-init with defaults locally if server is empty
                console.log('No remote config found, using defaults.');
                setEvents(EVENT_REGISTRY);
            }
        } catch (err) {
            console.error('Failed to load event config:', err);
            // Fallback to static registry on error
            setEvents(EVENT_REGISTRY);
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        fetchConfig();
    }, []);

    const saveConfig = async (newEvents = events) => {
        try {
            const res = await fetch(`${API_BASE_URL}/api/events-config`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newEvents)
            });
            if (!res.ok) throw new Error('Failed to save config');
            toast.success('Event configuration saved successfully');
        } catch (err) {
            console.error('Error saving config:', err);
            toast.error('Failed to save configuration');
        }
    };

    const updateEvent = async (updatedEvent: EventDefinition) => {
        const newEvents = events.map(e => e.id === updatedEvent.id ? updatedEvent : e);
        setEvents(newEvents);
        await saveConfig(newEvents);
    };

    const resetToDefaults = async () => {
        if (!confirm('Are you sure you want to reset all events to default settings?')) return;
        setEvents(EVENT_REGISTRY);
        await saveConfig(EVENT_REGISTRY);
        toast.info('Reset to default configuration');
    };

    return (
        <EventConfigContext.Provider value={{ events, isLoading, updateEvent, resetToDefaults, saveConfig: () => saveConfig() }}>
            {children}
        </EventConfigContext.Provider>
    );
};

export const useEventConfig = () => {
    const context = useContext(EventConfigContext);
    if (!context) throw new Error('useEventConfig must be used within EventConfigProvider');
    return context;
};
</file>

<file path="src/contexts/IPTVAuthContext.tsx">
import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import type { IPTVCredentials } from "@/types/xtream";

interface IPTVAuthContextType {
    isConfigured: boolean;
    credentials: IPTVCredentials | null;
    configureIPTV: (credentials: IPTVCredentials) => void;
    clearConfiguration: () => void;
    isLoading: boolean;
}

const IPTVAuthContext = createContext<IPTVAuthContextType | undefined>(undefined);
const IPTV_STORAGE_KEY = "react-iptv-credentials";

export function IPTVAuthProvider({ children }: { children: ReactNode }) {
    const [isConfigured, setIsConfigured] = useState(false);
    const [credentials, setCredentials] = useState<IPTVCredentials | null>(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        try {
            const storedCredentials = localStorage.getItem(IPTV_STORAGE_KEY);
            if (storedCredentials) {
                const parsedCredentials = JSON.parse(storedCredentials);
                setCredentials(parsedCredentials);
                setIsConfigured(true);
            } else {
                // Auto-configure from .env if available
                const defaultStreamUrl = import.meta.env.VITE_DEFAULT_STREAM_URL;
                if (defaultStreamUrl) {
                    try {
                        const url = new URL(defaultStreamUrl);
                        const username = url.searchParams.get("username");
                        const password = url.searchParams.get("password");

                        if (username && password) {
                            // Force output=m3u8 for compatibility with Hls.js
                            url.searchParams.set("output", "m3u8");

                            const apiBase = `${url.protocol}//${url.host}/player_api.php`;
                            const autoCredentials = {
                                apiBase,
                                username,
                                password
                            };
                            setCredentials(autoCredentials);
                            setIsConfigured(true);
                            console.log("üì∫ IPTV Auto-configured from .env (Forced output=m3u8)");
                        }
                    } catch (e) {
                        console.error("‚ùå Failed to parse VITE_DEFAULT_STREAM_URL:", e);
                    }
                }
            }
        } catch {
            // Ignore parse errors
        } finally {
            setIsLoading(false);
        }
    }, []);

    const configureIPTV = (newCredentials: IPTVCredentials) => {
        setCredentials(newCredentials);
        setIsConfigured(true);
        try {
            localStorage.setItem(IPTV_STORAGE_KEY, JSON.stringify(newCredentials));
        } catch {
            // Ignore storage errors
        }
    };

    const clearConfiguration = () => {
        setCredentials(null);
        setIsConfigured(false);
        try {
            localStorage.removeItem(IPTV_STORAGE_KEY);
            localStorage.removeItem("react-iptv-categories-cache");
        } catch {
            // Ignore storage errors
        }
    };

    return (
        <IPTVAuthContext.Provider
            value={{
                isConfigured,
                credentials,
                configureIPTV,
                clearConfiguration,
                isLoading,
            }}
        >
            {children}
        </IPTVAuthContext.Provider>
    );
}

export function useIPTVAuth() {
    const context = useContext(IPTVAuthContext);
    if (context === undefined) {
        throw new Error("useIPTVAuth must be used within an IPTVAuthProvider");
    }
    return context;
}
</file>

<file path="src/contexts/KPIContext.tsx">
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { initialKPI, KPIModel, calculateKPIs, EngineResult } from '../utils/kpiEngine';

interface KPIContextType {
    kpi: KPIModel;
    metrics: EngineResult;
    updateKPI: (key: keyof KPIModel, value: any) => void;
    resetDefaults: () => void;
    exportData: () => void;
}

const KPIContext = createContext<KPIContextType | undefined>(undefined);

export function KPIProvider({ children }: { children: ReactNode }) {
    const [kpi, setKpi] = useState<KPIModel>(initialKPI);
    const [metrics, setMetrics] = useState<EngineResult>(calculateKPIs(initialKPI));

    useEffect(() => {
        setMetrics(calculateKPIs(kpi));
    }, [kpi]);

    const updateKPI = (key: keyof KPIModel, value: any) => {
        setKpi(prev => {
            const newVal = typeof prev[key] === 'number' ? Number(value) : value;
            return { ...prev, [key]: newVal };
        });
    };

    const resetDefaults = () => {
        setKpi(initialKPI);
    };

    const exportData = () => {
        const data = { timestamp: new Date().toISOString(), inputs: kpi, results: metrics };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `sportdata_kpis_${Date.now()}.json`;
        a.click();
    };

    return (
        <KPIContext.Provider value={{ kpi, metrics, updateKPI, resetDefaults, exportData }}>
            {children}
        </KPIContext.Provider>
    );
}

export function useKPI() {
    const context = useContext(KPIContext);
    if (!context) {
        throw new Error('useKPI must be used within KPIProvider');
    }
    return context;
}
</file>

<file path="src/contexts/MatchContext.tsx">
// src/contexts/MatchContext.tsx - Match state management with State Machine
import { createContext, useContext, useState, useRef, useCallback, ReactNode, Dispatch, SetStateAction, useEffect } from 'react';
import { LoggedEvent } from '@/hooks/useGamepad';
import { TeamRoster } from '@/types/player';
import { useSocket as useSocketContext } from '@/contexts/SocketContext';
import { toast } from 'sonner';

// State Machine imports
import {
    MatchState,
    createInitialState,
    processEvent as processStateEvent,
    isInTransitionWindow,
    getTransitionTimeRemaining,
    getStateLabel,
    TeamId
} from '@/utils/MatchStateMachine';

import {
    PossessionChain,
    PossessionManager,
    createPossessionManager,
    startNewPossession,
    addEventToChain,
    endPossession,
    calculateChainStats,
    ChainStats
} from '@/utils/PossessionChain';

import {
    SequencePredictorState,
    Prediction,
    createSequencePredictor,
    recordEvent as recordPredictorEvent,
    getPredictions,
    savePatternsToStorage,
    getLearningStats,
    LearningStats
} from '@/utils/SequencePredictor';

interface VideoState {
    currentTime: number;
    isPlaying: boolean;
    playbackRate: number;
    videoUrl: string;
}

interface MatchContextType {
    // Events
    events: LoggedEvent[];
    setEvents: Dispatch<SetStateAction<LoggedEvent[]>>;

    // Teams
    teams: Map<string, TeamRoster>;
    setTeams: Dispatch<SetStateAction<Map<string, TeamRoster>>>;
    selectedTeam: string;
    setSelectedTeam: Dispatch<SetStateAction<string>>;

    // Match Time
    matchTime: number;
    setMatchTime: Dispatch<SetStateAction<number>>;
    isMatchActive: boolean;
    setIsMatchActive: Dispatch<SetStateAction<boolean>>;

    // Video
    videoFile: File | null;
    setVideoFile: Dispatch<SetStateAction<File | null>>;
    remoteVideoUrl: string | null;
    setRemoteVideoUrl: Dispatch<SetStateAction<string | null>>;
    videoTime: number;
    setVideoTime: Dispatch<SetStateAction<number>>;
    useVideoMode: boolean;
    setUseVideoMode: Dispatch<SetStateAction<boolean>>;
    seekTime: number | null;
    setSeekTime: Dispatch<SetStateAction<number | null>>;
    isVideoPlaying: boolean;
    setIsVideoPlaying: Dispatch<SetStateAction<boolean>>;
    videoMode: 'upload' | 'live' | 'fifaplus';
    setVideoMode: Dispatch<SetStateAction<'upload' | 'live' | 'fifaplus'>>;
    showAnalysisView: boolean;
    setShowAnalysisView: Dispatch<SetStateAction<boolean>>;
    isSessionStarted: boolean;
    setIsSessionStarted: Dispatch<SetStateAction<boolean>>;

    // Analysis
    analysisResults: any;
    setAnalysisResults: Dispatch<SetStateAction<any>>;
    calibrationMatrix: number[][] | null;
    setCalibrationMatrix: Dispatch<SetStateAction<number[][] | null>>;
    realtimeDetections: any[];
    setRealtimeDetections: Dispatch<SetStateAction<any[]>>;

    // UI State
    editingEventId: number | null;
    setEditingEventId: Dispatch<SetStateAction<number | null>>;
    lastEventButtonLabel: string | undefined;
    setLastEventButtonLabel: Dispatch<SetStateAction<string | undefined>>;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // STATE MACHINE
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    matchState: MatchState;
    processEvent: (event: LoggedEvent) => {
        newState: MatchState;
        possessionId?: number;
        predictions: Prediction[];
        isInTransition: boolean;
    };
    isInTransition: boolean;
    transitionTimeRemaining: number;
    stateLabel: string;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // POSSESSION CHAINS
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    currentPossession: PossessionChain | null;
    possessionHistory: PossessionChain[];
    chainStats: ChainStats | null;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // SEQUENCE PREDICTIONS
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    predictions: Prediction[];
    learningStats: LearningStats | null;
    resetPredictions: () => void;

    possessionId?: number;
    // Stream
    streamUrl: string;
    setStreamUrl: (url: string) => void;
    useStreamProxy: boolean;
    setUseStreamProxy: (use: boolean) => void;
}

const MatchContext = createContext<MatchContextType | undefined>(undefined);

export function MatchProvider({ children }: { children: ReactNode }) {
    // -------------------------------------------------------------------------
    // EXISTING STATE
    // -------------------------------------------------------------------------
    const [events, setEvents] = useState<LoggedEvent[]>([]);
    const [teams, setTeams] = useState<Map<string, TeamRoster>>(new Map());
    const [selectedTeam, setSelectedTeam] = useState<string>('');
    const [lastEventButtonLabel, setLastEventButtonLabel] = useState<string>();

    const [matchTime, setMatchTime] = useState(0);
    const [isMatchActive, setIsMatchActive] = useState(false);

    const [videoFile, setVideoFile] = useState<File | null>(null);
    const [remoteVideoUrl, setRemoteVideoUrl] = useState<string | null>(null);
    const [videoTime, setVideoTime] = useState(0);
    const [useVideoMode, setUseVideoMode] = useState(false);
    const [seekTime, setSeekTime] = useState<number | null>(null);
    const [analysisResults, setAnalysisResults] = useState<any>(null);
    const [isVideoPlaying, setIsVideoPlaying] = useState(false);
    const [videoMode, setVideoMode] = useState<'upload' | 'live' | 'fifaplus'>('upload');
    const [showAnalysisView, setShowAnalysisView] = useState(false);
    const [isSessionStarted, setIsSessionStarted] = useState(false);
    const [calibrationMatrix, setCalibrationMatrix] = useState<number[][] | null>(null);
    const [realtimeDetections, setRealtimeDetections] = useState<any[]>([]);

    const [editingEventId, setEditingEventId] = useState<number | null>(null);
    const [streamUrl, setStreamUrl] = useState<string>(() => {
        try {
            return localStorage.getItem('matchStreamUrl') || (import.meta as any).env.VITE_DEFAULT_STREAM_URL || "";
        } catch (e) {
            return (import.meta as any).env.VITE_DEFAULT_STREAM_URL || "";
        }
    });
    const [useStreamProxy, setUseStreamProxy] = useState<boolean>(() => {
        try {
            return localStorage.getItem('matchUseStreamProxy') === 'true';
        } catch (e) {
            return false;
        }
    });

    // -------------------------------------------------------------------------
    // STATE MACHINE STATE
    // -------------------------------------------------------------------------
    const [matchState, setMatchState] = useState<MatchState>(createInitialState);
    const matchStateRef = useRef<MatchState>(matchState);

    // -------------------------------------------------------------------------
    // POSSESSION CHAIN STATE
    // -------------------------------------------------------------------------
    const [possessionManager, setPossessionManager] = useState<PossessionManager>(createPossessionManager);
    const possessionManagerRef = useRef<PossessionManager>(possessionManager);

    // -------------------------------------------------------------------------
    // SEQUENCE PREDICTOR STATE
    // -------------------------------------------------------------------------
    const [predictorState, setPredictorState] = useState<SequencePredictorState>(createSequencePredictor);
    const predictorRef = useRef<SequencePredictorState>(predictorState);
    const [predictions, setPredictions] = useState<Prediction[]>([]);

    // Socket for synchronization
    const { socket, role, connected } = useSocketContext();

    // Keep refs in sync
    matchStateRef.current = matchState;
    possessionManagerRef.current = possessionManager;
    predictorRef.current = predictorState;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // SOCKET SYNCHRONIZATION
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    // Broadcast state updates (Broadcaster only)
    useEffect(() => {
        if (socket && connected && role === 'broadcaster') {
            socket.emit('match-state-sync', {
                matchState,
                possessionManager,
                predictions,
                streamUrl,
                useStreamProxy,
                videoMode,
                useVideoMode,
                isSessionStarted
            });
        }
    }, [matchState, possessionManager, predictions, streamUrl, useStreamProxy, socket, connected, role]);

    // Receive state updates (Viewer/Monitoring only)
    useEffect(() => {
        if (!socket) return;

        const handleRemoteSync = (data: any) => {
            if (role === 'viewer') {
                if (data.matchState) {
                    setMatchState(data.matchState);
                    matchStateRef.current = data.matchState;
                }
                if (data.possessionManager) {
                    setPossessionManager(data.possessionManager);
                    possessionManagerRef.current = data.possessionManager;
                }
                if (data.predictions) {
                    setPredictions(data.predictions);
                }
                if (data.streamUrl !== undefined) {
                    setStreamUrl(data.streamUrl);
                }
                if (data.useStreamProxy !== undefined) {
                    setUseStreamProxy(data.useStreamProxy);
                }
                if (data.videoMode !== undefined) {
                    setVideoMode(data.videoMode);
                }
                if (data.useVideoMode !== undefined) {
                    setUseVideoMode(data.useVideoMode);
                }
                if (data.isSessionStarted !== undefined) {
                    setIsSessionStarted(data.isSessionStarted);
                }
            }
        };

        socket.on('match-state-remote-sync', handleRemoteSync);
        return () => {
            socket.off('match-state-remote-sync', handleRemoteSync);
        };
    }, [socket, role]);

    // -------------------------------------------------------------------------
    // CORE PROCESS EVENT FUNCTION
    // -------------------------------------------------------------------------
    const processEvent = useCallback((event: LoggedEvent) => {
        // 1. Process through state machine
        const { newState, transition } = processStateEvent(matchStateRef.current, event);
        setMatchState(newState);
        matchStateRef.current = newState;

        // 2. Update possession chains
        let newPossessionManager = possessionManagerRef.current;

        // Check for possession-changing events
        if (event.eventName === 'interception') {
            // RB - Start new possession
            newPossessionManager = startNewPossession(
                newPossessionManager,
                event.team as TeamId,
                event,
                newState
            );
        } else if (event.eventName === 'turnover') {
            // LB - End current possession (lost)
            newPossessionManager = endPossession(newPossessionManager, 'LOSS');
        } else if (event.eventName === 'shot_start') {
            // Shot taken - mark in chain
            newPossessionManager = addEventToChain(newPossessionManager, event, newState);
        } else if (event.eventName === 'goal') {
            // Goal - end possession with goal outcome
            newPossessionManager = endPossession(newPossessionManager, 'GOAL');
        } else if (event.eventName === 'foul' || event.eventName === 'offside') {
            // Set piece - end current possession
            newPossessionManager = endPossession(newPossessionManager, 'SET_PIECE');
        } else {
            // Regular event - add to current chain
            newPossessionManager = addEventToChain(newPossessionManager, event, newState);
        }

        setPossessionManager(newPossessionManager);
        possessionManagerRef.current = newPossessionManager;

        // Alert for consecutive passes (>= 5)
        if (newPossessionManager.currentChain && newPossessionManager.currentChain.passCount >= 5 && event.eventName.includes('pass')) {
            toast.success(`${newPossessionManager.currentChain.team === 'TEAM_A' ? 'Algeria' : 'Nigeria'} - Sequence Alert: ${newPossessionManager.currentChain.passCount} Consecutive Passes!`, {
                icon: '‚öΩ',
                duration: 3000,
                position: 'top-center'
            });
        }

        // 3. Update sequence predictor
        const newPredictorState = recordPredictorEvent(predictorRef.current, event.eventName);
        setPredictorState(newPredictorState);
        predictorRef.current = newPredictorState;

        // 4. Get new predictions
        const newPredictions = getPredictions(newPredictorState);
        setPredictions(newPredictions);

        const inTransition = isInTransitionWindow(newState);

        // Log state change for debugging
        console.log(`üéØ State: ${getStateLabel(newState)} | Chain: ${newPossessionManager.currentChain?.id || 'none'}`);

        return {
            newState,
            possessionId: newPossessionManager.currentChain?.id,
            predictions: newPredictions,
            isInTransition: inTransition
        };
    }, []);

    // -------------------------------------------------------------------------
    // COMPUTED VALUES
    // -------------------------------------------------------------------------
    const isInTransition = isInTransitionWindow(matchState);
    const transitionTimeRemaining = getTransitionTimeRemaining(matchState);
    const stateLabel = getStateLabel(matchState);

    const currentPossession = possessionManager.currentChain;
    const possessionHistory = possessionManager.completedChains;

    const chainStats = possessionHistory.length > 0
        ? calculateChainStats(possessionHistory)
        : null;

    const learningStats = predictorState.totalEventsProcessed > 0
        ? getLearningStats(predictorState)
        : null;

    useEffect(() => {
        if (streamUrl) {
            try {
                localStorage.setItem('matchStreamUrl', streamUrl);
            } catch (e) { /* ignore */ }
        }
    }, [streamUrl]);

    useEffect(() => {
        try {
            localStorage.setItem('matchUseStreamProxy', useStreamProxy.toString());
        } catch (e) { /* ignore */ }
    }, [useStreamProxy]);

    // -------------------------------------------------------------------------
    // RESET PREDICTIONS
    // -------------------------------------------------------------------------
    const resetPredictions = useCallback(() => {
        const freshPredictor = createSequencePredictor();
        setPredictorState(freshPredictor);
        predictorRef.current = freshPredictor;
        setPredictions([]);
        savePatternsToStorage(freshPredictor);
    }, []);

    return (
        <MatchContext.Provider
            value={{
                // Existing
                events,
                setEvents,
                teams,
                setTeams,
                selectedTeam,
                setSelectedTeam,
                matchTime,
                setMatchTime,
                isMatchActive,
                setIsMatchActive,
                videoFile,
                setVideoFile,
                remoteVideoUrl,
                setRemoteVideoUrl,
                videoTime,
                setVideoTime,
                useVideoMode,
                setUseVideoMode,
                seekTime,
                setSeekTime,
                isVideoPlaying,
                setIsVideoPlaying,
                videoMode,
                setVideoMode,
                showAnalysisView,
                setShowAnalysisView,
                isSessionStarted,
                setIsSessionStarted,
                analysisResults,
                setAnalysisResults,
                calibrationMatrix,
                setCalibrationMatrix,
                realtimeDetections,
                setRealtimeDetections,
                editingEventId,
                setEditingEventId,
                lastEventButtonLabel,
                setLastEventButtonLabel,

                // State Machine
                matchState,
                processEvent,
                isInTransition,
                transitionTimeRemaining,
                stateLabel,

                // Possession Chains
                currentPossession,
                possessionHistory,
                chainStats,

                // Predictions
                predictions,
                learningStats,
                resetPredictions,

                // Stream
                streamUrl,
                setStreamUrl,
                useStreamProxy,
                setUseStreamProxy,
            }}
        >
            {children}
        </MatchContext.Provider>
    );
}

export function useMatchContext() {
    const context = useContext(MatchContext);
    if (!context) {
        throw new Error('useMatchContext must be used within MatchProvider');
    }
    return context;
}
</file>

<file path="src/contexts/SocketContext.tsx">
import { createContext, useContext, useEffect, useRef, useState } from 'react';
import { io, Socket } from 'socket.io-client';
import { API_SOCKET_URL } from '@/utils/apiConfig';
import { useAuth } from './AuthContext';

interface SocketContextValue {
    socket: Socket | null;
    connected: boolean;
    role: string | null;
}

const SocketContext = createContext<SocketContextValue>({
    socket: null,
    connected: false,
    role: null,
});

export const SocketProvider = ({ children }: { children: React.ReactNode }) => {
    const { token } = useAuth();
    const socketRef = useRef<Socket | null>(null);
    const [connected, setConnected] = useState(false);
    const [role, setRole] = useState<string | null>(null);

    useEffect(() => {
        // Don't attempt to connect if there's no token
        if (!token) {
            if (socketRef.current) {
                console.info('[socket] User logged out, disconnecting socket.');
                socketRef.current.disconnect();
                socketRef.current = null;
                setConnected(false);
                setRole(null);
            }
            return;
        }

        console.info('[socket] Token available, connecting...');

        const socket = io(API_SOCKET_URL, {
            path: '/socket.io',
            transports: ['websocket'],
            timeout: 5000,
            reconnectionAttempts: 5,
            auth: {
                token,
            },
        });

        socketRef.current = socket;

        socket.on('connect', () => {
            console.log('[socket] connected:', socket.id);
            setConnected(true);
        });

        socket.on('role-assignment', (newRole: string) => {
            console.log('[socket] role-assigned:', newRole);
            setRole(newRole);
        });

        socket.on('disconnect', (reason) => {
            console.warn('[socket] disconnected:', reason);
            setConnected(false);
        });

        socket.on('connect_error', (err) => {
            console.error('[socket] connect error:', err.message);
        });

        return () => {
            console.info('[socket] Cleaning up connection...');
            socket.disconnect();
            socketRef.current = null;
            setConnected(false);
        };
    }, [token]);

    return (
        <SocketContext.Provider
            value={{
                socket: socketRef.current,
                connected,
                role,
            }}
        >
            {children}
        </SocketContext.Provider>
    );
};

export const useSocket = () => useContext(SocketContext);
</file>

<file path="src/data/algerian_teams.json">
{
    "MC Alger": {
        "teamName": "MC Alger",
        "PlayerData": [
            {
                "ID": 1001,
                "Forename": "Oussama",
                "Surname": "Litim",
                "Number": 1
            },
            {
                "ID": 1002,
                "Forename": "Ayoub",
                "Surname": "Abdellaoui",
                "Number": 5
            },
            {
                "ID": 1003,
                "Forename": "Mohamed",
                "Surname": "Benkhemassa",
                "Number": 8
            },
            {
                "ID": 1004,
                "Forename": "Youcof",
                "Surname": "Bela√Øli",
                "Number": 10
            },
            {
                "ID": 1005,
                "Forename": "Zakaria",
                "Surname": "Naidji",
                "Number": 7
            },
            {
                "ID": 1006,
                "Forename": "Sofiane",
                "Surname": "Bayazid",
                "Number": 9
            },
            {
                "ID": 1007,
                "Forename": "Hamza",
                "Surname": "Mouali",
                "Number": 15
            },
            {
                "ID": 1008,
                "Forename": "Reda",
                "Surname": "Halaipmia",
                "Number": 27
            }
        ]
    },
    "CR Belouizdad": {
        "teamName": "CR Belouizdad",
        "PlayerData": [
            {
                "ID": 2001,
                "Forename": "Alexis",
                "Surname": "Guendouz",
                "Number": 26
            },
            {
                "ID": 2002,
                "Forename": "Chouaib",
                "Surname": "Keddad",
                "Number": 2
            },
            {
                "ID": 2003,
                "Forename": "Houcine",
                "Surname": "Benayada",
                "Number": 13
            },
            {
                "ID": 2004,
                "Forename": "Abderrahmane",
                "Surname": "Meziane",
                "Number": 11
            },
            {
                "ID": 2005,
                "Forename": "Mohamed",
                "Surname": "Islam Belkhir",
                "Number": 7
            },
            {
                "ID": 2006,
                "Forename": "Leonel",
                "Surname": "Wamba",
                "Number": 42
            }
        ]
    },
    "USM Alger": {
        "teamName": "USM Alger",
        "PlayerData": [
            {
                "ID": 3001,
                "Forename": "Oussama",
                "Surname": "Benbot",
                "Number": 25
            },
            {
                "ID": 3002,
                "Forename": "Sa√¢di",
                "Surname": "Radouani",
                "Number": 19
            },
            {
                "ID": 3003,
                "Forename": "Zinedine",
                "Surname": "Bela√Ød",
                "Number": 4
            },
            {
                "ID": 3004,
                "Forename": "Brahim",
                "Surname": "Benzaza",
                "Number": 6
            },
            {
                "ID": 3005,
                "Forename": "Ismail",
                "Surname": "Belkacemi",
                "Number": 10
            }
        ]
    },
    "JS Kabylie": {
        "teamName": "JS Kabylie",
        "PlayerData": [
            {
                "ID": 4001,
                "Forename": "Chamseddine",
                "Surname": "Rahmani",
                "Number": 16
            },
            {
                "ID": 4002,
                "Forename": "Badreddine",
                "Surname": "Souyad",
                "Number": 4
            },
            {
                "ID": 4003,
                "Forename": "Salim",
                "Surname": "Boukhenchouche",
                "Number": 6
            },
            {
                "ID": 4004,
                "Forename": "Kouceila",
                "Surname": "Boualia",
                "Number": 7
            },
            {
                "ID": 4005,
                "Forename": "Dadi",
                "Surname": "El Hocine",
                "Number": 11
            }
        ]
    },
    "ES S√©tif": {
        "teamName": "ES S√©tif",
        "PlayerData": [
            {
                "ID": 5001,
                "Forename": "Zakaria",
                "Surname": "Saidi",
                "Number": 1
            },
            {
                "ID": 5002,
                "Forename": "Tarek",
                "Surname": "Aggoun",
                "Number": 5
            },
            {
                "ID": 5003,
                "Forename": "Amir",
                "Surname": "Karaoui",
                "Number": 14
            },
            {
                "ID": 5004,
                "Forename": "Walid",
                "Surname": "Zamoum",
                "Number": 10
            }
        ]
    }
}
</file>

<file path="src/data/eventDefinitions.ts">
export interface EventDefinition {
    id: number;
    category: string;
    eventName: string;
    isRealTime: boolean;
    isPostMatch: boolean;
    clipDuration: number; // in seconds
    preRoll: number; // seconds before the event timestamp to start the clip
    description?: string;
}

export const EVENT_DEFINITIONS: EventDefinition[] = [
    // PHASES DE JEU GLOBALES
    { id: 1, category: "Phase de jeu", eventName: "Possession offensive", isRealTime: true, isPostMatch: true, clipDuration: 45, preRoll: 5 },
    { id: 2, category: "Phase de jeu", eventName: "Possession d√©fensive", isRealTime: true, isPostMatch: true, clipDuration: 40, preRoll: 5 },
    { id: 3, category: "Phase de jeu", eventName: "Transition OFF-DEF", isRealTime: true, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 4, category: "Phase de jeu", eventName: "Transition DEF-OFF", isRealTime: true, isPostMatch: true, clipDuration: 15, preRoll: 5 },
    { id: 5, category: "Phase de jeu", eventName: "Phase arr√™t√©e offensive", isRealTime: true, isPostMatch: true, clipDuration: 30, preRoll: 5 },
    { id: 6, category: "Phase de jeu", eventName: "Phase arr√™t√©e d√©fensive", isRealTime: true, isPostMatch: true, clipDuration: 30, preRoll: 5 },

    // TYPES D'ATTAQUES
    { id: 7, category: "Offensive", eventName: "Attaque plac√©e", isRealTime: false, isPostMatch: true, clipDuration: 45, preRoll: 10 },
    { id: 8, category: "Offensive", eventName: "Contre-attaque", isRealTime: true, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 9, category: "Offensive", eventName: "Attaque rapide", isRealTime: false, isPostMatch: true, clipDuration: 20, preRoll: 5 },
    { id: 10, category: "Offensive", eventName: "Jeu direct", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 3 },
    { id: 11, category: "Offensive", eventName: "Pressing haut-R√©cup-Attaque", isRealTime: true, isPostMatch: true, clipDuration: 15, preRoll: 5 },

    // FINALISATION OFFENSIVE
    { id: 12, category: "Finalisation", eventName: "But marqu√©", isRealTime: true, isPostMatch: true, clipDuration: 35, preRoll: 15 },
    { id: 13, category: "Finalisation", eventName: "Tir cadr√© sauv√©", isRealTime: true, isPostMatch: true, clipDuration: 15, preRoll: 5 },
    { id: 14, category: "Finalisation", eventName: "Tir non cadr√©", isRealTime: true, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 15, category: "Finalisation", eventName: "Tir contr√©", isRealTime: true, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 16, category: "Finalisation", eventName: "Occasion franche", isRealTime: true, isPostMatch: true, clipDuration: 18, preRoll: 8 },
    { id: 17, category: "Finalisation", eventName: "Occasion moyenne", isRealTime: false, isPostMatch: true, clipDuration: 15, preRoll: 5 },
    { id: 18, category: "Finalisation", eventName: "Passe d√©cisive", isRealTime: false, isPostMatch: true, clipDuration: 18, preRoll: 8 },
    { id: 19, category: "Finalisation", eventName: "Passe cl√©", isRealTime: false, isPostMatch: true, clipDuration: 15, preRoll: 5 },
    { id: 20, category: "Finalisation", eventName: "Centre", isRealTime: true, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 21, category: "Finalisation", eventName: "Centre rentrant", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 22, category: "Finalisation", eventName: "Centre sortant", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 5 },

    // CONSTRUCTION OFFENSIVE
    { id: 23, category: "Construction", eventName: "Relance gardien courte", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },
    { id: 24, category: "Construction", eventName: "Relance gardien longue", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 2 },
    { id: 25, category: "Construction", eventName: "Construction 3 d√©fenseurs", isRealTime: false, isPostMatch: true, clipDuration: 25, preRoll: 5 },
    { id: 26, category: "Construction", eventName: "Construction 2 d√©fenseurs", isRealTime: false, isPostMatch: true, clipDuration: 25, preRoll: 5 },
    { id: 27, category: "Construction", eventName: "Passe progressive", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 2 },
    { id: 28, category: "Construction", eventName: "Circulation lat√©rale", isRealTime: false, isPostMatch: true, clipDuration: 20, preRoll: 5 },
    { id: 29, category: "Construction", eventName: "Combinaison courte (une-deux)", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 2 },
    { id: 30, category: "Construction", eventName: "Combinaison √† 3+ joueurs", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 3 },

    // ACTIONS TECHNIQUES INDIVIDUELLES
    { id: 31, category: "Technique", eventName: "Dribble r√©ussi", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 2 },
    { id: 32, category: "Technique", eventName: "Dribble rat√©", isRealTime: false, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 33, category: "Technique", eventName: "Passe courte r√©ussie", isRealTime: false, isPostMatch: true, clipDuration: 4, preRoll: 2 },
    { id: 34, category: "Technique", eventName: "Passe moyenne r√©ussie", isRealTime: false, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 35, category: "Technique", eventName: "Passe longue r√©ussie", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 2 },
    { id: 36, category: "Technique", eventName: "Passe en profondeur", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 2 },
    { id: 37, category: "Technique", eventName: "Contr√¥le orient√©", isRealTime: false, isPostMatch: true, clipDuration: 4, preRoll: 2 },
    { id: 38, category: "Technique", eventName: "Mauvais contr√¥le", isRealTime: false, isPostMatch: true, clipDuration: 4, preRoll: 2 },
    { id: 39, category: "Technique", eventName: "Passe rat√©e/intercept√©e", isRealTime: false, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 40, category: "Technique", eventName: "Geste technique spectaculaire", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 2 },

    // PERTES DE BALLE
    { id: 41, category: "Perte", eventName: "Interception adverse", isRealTime: true, isPostMatch: true, clipDuration: 6, preRoll: 2 },
    { id: 42, category: "Perte", eventName: "Mauvaise passe", isRealTime: true, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 43, category: "Perte", eventName: "Mauvais contr√¥le-Perte", isRealTime: false, isPostMatch: true, clipDuration: 4, preRoll: 2 },
    { id: 44, category: "Perte", eventName: "Duel perdu", isRealTime: false, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 45, category: "Perte", eventName: "Perte sous pression", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 3 },
    { id: 46, category: "Perte", eventName: "Faute commise", isRealTime: true, isPostMatch: true, clipDuration: 8, preRoll: 3 },
    { id: 47, category: "Perte", eventName: "Hors-jeu signal√©", isRealTime: true, isPostMatch: true, clipDuration: 10, preRoll: 5 },

    // ACTIONS D√âFENSIVES
    { id: 48, category: "D√©fense", eventName: "Bloc bas organis√©", isRealTime: false, isPostMatch: true, clipDuration: 30, preRoll: 5 },
    { id: 49, category: "D√©fense", eventName: "Bloc m√©dian", isRealTime: false, isPostMatch: true, clipDuration: 25, preRoll: 5 },
    { id: 50, category: "D√©fense", eventName: "Pressing haut collectif", isRealTime: true, isPostMatch: true, clipDuration: 15, preRoll: 5 },
    { id: 51, category: "D√©fense", eventName: "Pressing m√©dian", isRealTime: false, isPostMatch: true, clipDuration: 15, preRoll: 5 },
    { id: 52, category: "D√©fense", eventName: "Repli d√©fensif organis√©", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 53, category: "D√©fense", eventName: "Repli d√©fensif d√©sorganis√©", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 54, category: "D√©fense", eventName: "Interception propre", isRealTime: false, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 55, category: "D√©fense", eventName: "Tacle r√©ussi", isRealTime: false, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 56, category: "D√©fense", eventName: "Tacle rat√©/Faute", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 3 },
    { id: 57, category: "D√©fense", eventName: "Duel a√©rien gagn√©", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 2 },
    { id: 58, category: "D√©fense", eventName: "Duel a√©rien perdu", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 2 },
    { id: 59, category: "D√©fense", eventName: "Duel au sol gagn√©", isRealTime: false, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 60, category: "D√©fense", eventName: "Duel au sol perdu", isRealTime: false, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 61, category: "D√©fense", eventName: "Hors-jeu provoqu√©", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 5 },
    { id: 62, category: "D√©fense", eventName: "Couverture d√©fensive", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 3 },
    { id: 63, category: "D√©fense", eventName: "R√©cup√©ration haute", isRealTime: true, isPostMatch: true, clipDuration: 8, preRoll: 3 },
    { id: 64, category: "D√©fense", eventName: "R√©cup√©ration m√©diane", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 3 },
    { id: 65, category: "D√©fense", eventName: "R√©cup√©ration basse", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 3 },

    // R√âSULTATS D√âFENSIFS
    { id: 66, category: "D√©fense", eventName: "But encaiss√©", isRealTime: true, isPostMatch: true, clipDuration: 40, preRoll: 20 },
    { id: 67, category: "D√©fense", eventName: "Tir adverse cadr√©", isRealTime: true, isPostMatch: true, clipDuration: 15, preRoll: 5 },
    { id: 68, category: "D√©fense", eventName: "Tir adverse non cadr√©", isRealTime: true, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 69, category: "D√©fense", eventName: "Occasion adverse", isRealTime: true, isPostMatch: true, clipDuration: 18, preRoll: 8 },
    { id: 70, category: "D√©fense", eventName: "Corner conc√©d√©", isRealTime: true, isPostMatch: true, clipDuration: 10, preRoll: 5 },
    { id: 71, category: "D√©fense", eventName: "Coup franc conc√©d√© dangereux", isRealTime: true, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 72, category: "D√©fense", eventName: "Coup franc conc√©d√© non dangereux", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 3 },
    { id: 73, category: "D√©fense", eventName: "P√©nalty conc√©d√©", isRealTime: true, isPostMatch: true, clipDuration: 25, preRoll: 5 },

    // PHASES ARR√äT√âES OFFENSIVES
    { id: 74, category: "PA Offensive", eventName: "Corner pour - Rentrant", isRealTime: true, isPostMatch: true, clipDuration: 20, preRoll: 2 },
    { id: 75, category: "PA Offensive", eventName: "Corner pour - Sortant", isRealTime: true, isPostMatch: true, clipDuration: 20, preRoll: 2 },
    { id: 76, category: "PA Offensive", eventName: "Corner pour - Court", isRealTime: false, isPostMatch: true, clipDuration: 18, preRoll: 2 },
    { id: 77, category: "PA Offensive", eventName: "Corner pour - Variante", isRealTime: false, isPostMatch: true, clipDuration: 20, preRoll: 2 },
    { id: 78, category: "PA Offensive", eventName: "Coup franc direct cadr√©", isRealTime: true, isPostMatch: true, clipDuration: 18, preRoll: 5 },
    { id: 79, category: "PA Offensive", eventName: "Coup franc direct non cadr√©", isRealTime: true, isPostMatch: true, clipDuration: 12, preRoll: 5 },
    { id: 80, category: "PA Offensive", eventName: "Coup franc indirect (centre)", isRealTime: false, isPostMatch: true, clipDuration: 20, preRoll: 5 },
    { id: 81, category: "PA Offensive", eventName: "Coup franc indirect (combinaison)", isRealTime: false, isPostMatch: true, clipDuration: 18, preRoll: 5 },
    { id: 82, category: "PA Offensive", eventName: "P√©nalty pour", isRealTime: true, isPostMatch: true, clipDuration: 35, preRoll: 5 },
    { id: 83, category: "PA Offensive", eventName: "Touche offensive longue", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },
    { id: 84, category: "PA Offensive", eventName: "Touche offensive courte", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 2 },
    { id: 85, category: "PA Offensive", eventName: "Remise 6 m√®tres adverse", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },

    // PHASES ARR√äT√âES D√âFENSIVES
    { id: 86, category: "PA D√©fensive", eventName: "Corner contre - D√©fense zonale", isRealTime: false, isPostMatch: true, clipDuration: 25, preRoll: 5 },
    { id: 87, category: "PA D√©fensive", eventName: "Corner contre - D√©fense individuelle", isRealTime: false, isPostMatch: true, clipDuration: 25, preRoll: 5 },
    { id: 88, category: "PA D√©fensive", eventName: "Corner contre - D√©fense mixte", isRealTime: false, isPostMatch: true, clipDuration: 25, preRoll: 5 },
    { id: 89, category: "PA D√©fensive", eventName: "Coup franc contre - Mur", isRealTime: false, isPostMatch: true, clipDuration: 25, preRoll: 5 },
    { id: 90, category: "PA D√©fensive", eventName: "Coup franc contre - Sans mur", isRealTime: false, isPostMatch: true, clipDuration: 15, preRoll: 2 },
    { id: 91, category: "PA D√©fensive", eventName: "P√©nalty contre", isRealTime: true, isPostMatch: true, clipDuration: 30, preRoll: 5 },
    { id: 92, category: "PA D√©fensive", eventName: "Touche d√©fensive - Marquage serr√©", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },
    { id: 93, category: "PA D√©fensive", eventName: "Touche d√©fensive - Laisser jouer", isRealTime: false, isPostMatch: true, clipDuration: 30, preRoll: 2 },

    // GARDIEN DE BUT
    { id: 94, category: "Gardien", eventName: "Arr√™t r√©flexe", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },
    { id: 95, category: "Gardien", eventName: "Arr√™t classique", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 2 },
    { id: 96, category: "Gardien", eventName: "Sortie a√©rienne r√©ussie", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },
    { id: 97, category: "Gardien", eventName: "Sortie a√©rienne rat√©e", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 2 },
    { id: 98, category: "Gardien", eventName: "Sortie aux pieds r√©ussie", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },
    { id: 99, category: "Gardien", eventName: "Sortie aux pieds rat√©e", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 2 },
    { id: 100, category: "Gardien", eventName: "Un contre un gagn√©", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 2 },
    { id: 101, category: "Gardien", eventName: "Un contre un perdu", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 2 },
    { id: 102, category: "Gardien", eventName: "Relance courte au pied", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 2 },
    { id: 103, category: "Gardien", eventName: "Relance longue au pied", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 2 },
    { id: 104, category: "Gardien", eventName: "Relance main pr√©cise", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 2 },
    { id: 105, category: "Gardien", eventName: "Relance main impr√©cise", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 2 },
    { id: 106, category: "Gardien", eventName: "Communication d√©fensive", isRealTime: false, isPostMatch: true, clipDuration: 15, preRoll: 2 },

    // MOUVEMENTS SANS BALLON
    { id: 107, category: "Mouvement", eventName: "Appel de balle intelligent", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 2 },
    { id: 108, category: "Mouvement", eventName: "Appel de balle ignor√©", isRealTime: false, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 109, category: "Mouvement", eventName: "Course en profondeur", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 2 },
    { id: 110, category: "Mouvement", eventName: "D√©crochage", isRealTime: false, isPostMatch: true, clipDuration: 6, preRoll: 2 },
    { id: 111, category: "Mouvement", eventName: "Appel-contre-appel", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 2 },
    { id: 112, category: "Mouvement", eventName: "Soutien offensif", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 2 },
    { id: 113, category: "Mouvement", eventName: "Replacement d√©fensif rapide", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },
    { id: 114, category: "Mouvement", eventName: "Replacement d√©fensif lent", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 2 },

    // DISCIPLINE
    { id: 115, category: "Discipline", eventName: "Carton jaune", isRealTime: true, isPostMatch: true, clipDuration: 15, preRoll: 2 },
    { id: 116, category: "Discipline", eventName: "Carton rouge direct", isRealTime: true, isPostMatch: true, clipDuration: 20, preRoll: 3 },
    { id: 117, category: "Discipline", eventName: "Second carton jaune-Rouge", isRealTime: true, isPostMatch: true, clipDuration: 20, preRoll: 3 },
    { id: 118, category: "Discipline", eventName: "Faute tactique", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 3 },
    { id: 119, category: "Discipline", eventName: "Simulation/Plongeon", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 3 },
    { id: 120, category: "Discipline", eventName: "Protestation", isRealTime: false, isPostMatch: true, clipDuration: 12, preRoll: 3 },

    // √âV√âNEMENTS DE MATCH
    { id: 121, category: "Match", eventName: "D√©but 1√®re mi-temps", isRealTime: true, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 122, category: "Match", eventName: "Fin 1√®re mi-temps", isRealTime: true, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 123, category: "Match", eventName: "D√©but 2√®me mi-temps", isRealTime: true, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 124, category: "Match", eventName: "Fin 2√®me mi-temps", isRealTime: true, isPostMatch: true, clipDuration: 5, preRoll: 2 },
    { id: 125, category: "Match", eventName: "Temps additionnel", isRealTime: true, isPostMatch: true, clipDuration: 60, preRoll: 5 },
    { id: 126, category: "Match", eventName: "Blessure joueur", isRealTime: true, isPostMatch: true, clipDuration: 120, preRoll: 10 },
    { id: 127, category: "Match", eventName: "Remplacement", isRealTime: true, isPostMatch: true, clipDuration: 30, preRoll: 5 },
    { id: 128, category: "Match", eventName: "Changement tactique", isRealTime: true, isPostMatch: true, clipDuration: 180, preRoll: 10 },
    { id: 129, category: "Match", eventName: "Boisson technique", isRealTime: true, isPostMatch: true, clipDuration: 90, preRoll: 5 },
    { id: 130, category: "Match", eventName: "Incident arbitrage", isRealTime: true, isPostMatch: true, clipDuration: 30, preRoll: 5 },

    // MOMENTS PSYCHOLOGIQUES
    { id: 131, category: "Psycho", eventName: "C√©l√©bration but", isRealTime: false, isPostMatch: true, clipDuration: 15, preRoll: 2 },
    { id: 132, category: "Psycho", eventName: "Frustration visible", isRealTime: false, isPostMatch: true, clipDuration: 8, preRoll: 2 },
    { id: 133, category: "Psycho", eventName: "Encouragement collectif", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },
    { id: 134, category: "Psycho", eventName: "Conflit interne √©quipe", isRealTime: false, isPostMatch: true, clipDuration: 20, preRoll: 5 },
    { id: 135, category: "Psycho", eventName: "Altercation adverse", isRealTime: false, isPostMatch: true, clipDuration: 25, preRoll: 5 },

    // STATISTIQUES PHYSIQUES
    { id: 136, category: "Physique", eventName: "Sprint longue distance (>30m)", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },
    { id: 137, category: "Physique", eventName: "Effort d√©fensif intense", isRealTime: false, isPostMatch: true, clipDuration: 15, preRoll: 3 },
    { id: 138, category: "Physique", eventName: "Signe de fatigue", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 2 },
    { id: 139, category: "Physique", eventName: "R√©cup√©ration lente apr√®s effort", isRealTime: false, isPostMatch: true, clipDuration: 20, preRoll: 5 },

    // ANALYSE TACTIQUE AVANC√âE
    { id: 140, category: "Tactique", eventName: "Sup√©riorit√© num√©rique cr√©√©e", isRealTime: false, isPostMatch: true, clipDuration: 20, preRoll: 5 },
    { id: 141, category: "Tactique", eventName: "Inf√©riorit√© num√©rique subie", isRealTime: false, isPostMatch: true, clipDuration: 20, preRoll: 5 },
    { id: 142, category: "Tactique", eventName: "Changement syst√®me en jeu", isRealTime: false, isPostMatch: true, clipDuration: 300, preRoll: 15 },
    { id: 143, category: "Tactique", eventName: "Automatisme travaill√© r√©ussi", isRealTime: false, isPostMatch: true, clipDuration: 15, preRoll: 5 },
    { id: 144, category: "Tactique", eventName: "Automatisme travaill√© rat√©", isRealTime: false, isPostMatch: true, clipDuration: 15, preRoll: 5 },
    { id: 145, category: "Tactique", eventName: "Exploitation faiblesse adverse", isRealTime: false, isPostMatch: true, clipDuration: 25, preRoll: 5 },
    { id: 146, category: "Tactique", eventName: "Adaptation tactique r√©ussie", isRealTime: false, isPostMatch: true, clipDuration: 180, preRoll: 10 },
    { id: 147, category: "Tactique", eventName: "Non-adaptation probl√©matique", isRealTime: false, isPostMatch: true, clipDuration: 180, preRoll: 10 },

    // ZONES DU TERRAIN (Overlay)
    { id: 148, category: "Zone", eventName: "Zone d√©fensive gauche", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 149, category: "Zone", eventName: "Zone d√©fensive centre", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 150, category: "Zone", eventName: "Zone d√©fensive droite", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 151, category: "Zone", eventName: "Zone m√©diane gauche", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 152, category: "Zone", eventName: "Zone m√©diane centre", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 153, category: "Zone", eventName: "Zone m√©diane droite", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 154, category: "Zone", eventName: "Zone offensive gauche", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 155, category: "Zone", eventName: "Zone offensive centre", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 156, category: "Zone", eventName: "Zone offensive droite", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 157, category: "Zone", eventName: "Grande surface adverse", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 158, category: "Zone", eventName: "Petite surface adverse", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 159, category: "Zone", eventName: "Couloir lat√©ral gauche complet", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
    { id: 160, category: "Zone", eventName: "Couloir lat√©ral droit complet", isRealTime: false, isPostMatch: true, clipDuration: 10, preRoll: 0 },
];
</file>

<file path="src/hooks/index/useIndexEffects.ts">
import { useEffect, useRef } from 'react';
import { toast } from 'sonner';

export function useIndexEffects(state: any) {
    const {
        socket,
        matchTime,
        isMatchActive,
        audioRef,
        remoteAudioStream,
        videoRef,
        videoStream,
        isSessionStarted,
        sessionMode,
        setSessionMode,
        user,
        joinVoiceRoom
    } = state;

    // Sync Timer with Socket
    useEffect(() => {
        socket?.emit('sync-timer', { matchTime, isMatchActive });
    }, [isMatchActive, matchTime, socket]);

    // Handle Remote Audio
    useEffect(() => {
        if (audioRef.current && remoteAudioStream) {
            if (audioRef.current.srcObject !== remoteAudioStream) {
                audioRef.current.srcObject = remoteAudioStream;
                audioRef.current.play().catch((err: any) => console.error('Error playing audio:', err));
            }
        }
    }, [remoteAudioStream, audioRef]);

    // Handle Local Video Stream
    useEffect(() => {
        if (videoRef.current && videoStream) {
            if (videoRef.current.srcObject !== videoStream) {
                videoRef.current.srcObject = videoStream;
            }
        }
    }, [videoStream, videoRef]);

    // Auto-join collaboration mode
    useEffect(() => {
        if (isSessionStarted && sessionMode === null && user?.role !== 'admin') {
            setSessionMode('collab');
            joinVoiceRoom();
            toast.info('Joining live collaboration session...');
        }
    }, [isSessionStarted, sessionMode, user, joinVoiceRoom, setSessionMode]);
}
</file>

<file path="src/hooks/index/useIndexHandlers.ts">
import { useCallback } from 'react';
import { toast } from 'sonner';
import { LoggedEvent } from '@/hooks/useGamepad';
import { TeamRoster } from '@/types/player';
import { EVENT_REGISTRY } from '@/config/eventRegistry';
import { API_BASE_URL } from '@/utils/apiConfig';
import { exportToCSV } from '@/utils/csvExport';
import { COMMANDS, matchCommand, parseNumber } from '@/utils/voiceUtils';

export function useIndexHandlers(state: any) {
    const {
        // From match context/state
        events, setEvents,
        teams, setTeams,
        selectedTeam, setSelectedTeam,
        videoTime,
        useVideoMode, setUseVideoMode,
        setVideoMode,
        setIsVideoPlaying,
        editingEventId, setEditingEventId,
        setLastEventButtonLabel,
        processEvent,
        setIsMatchActive,
        isMatchActive,
        // From state hook
        matchTimeRef, formatTime,
        socket,
        hasPermission, user,
        autoExtract,
        serverVideoPath,
        setActiveDurations,
        setSelectedPendingEvent,
        voiceLanguage,
        startListening, isListening
    } = state;

    const extractClip = async (event: LoggedEvent) => {
        if (!serverVideoPath) return;

        const userBuffer = 5;
        const clipDuration = 10;
        const captureTime = Math.max(0, (event.videoTime || videoTime) - 0.6 - userBuffer);

        try {
            await fetch(`${API_BASE_URL}/api/extract-clip`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    videoPath: serverVideoPath,
                    startTime: captureTime,
                    duration: clipDuration,
                    eventType: event.eventName,
                    eventName: `${event.eventName}_Z${event.zone || 0}_${event.matchTime.replace(/:/g, '-')}`,
                    outputRelativePath: null
                })
            });
            toast.info(`Auto-Clipping: ${event.eventName}`);
        } catch (e) {
            console.error("Auto-extract failed", e);
            toast.error("Auto-clip failed");
        }
    };

    const handleEventLogged = useCallback((event: LoggedEvent) => {
        if (event.eventName === 'ui_confirm' || event.eventName === 'ui_cancel') {
            return;
        }

        const currentTime = matchTimeRef.current;
        const currentVideoTime = videoTime;
        const eventWithTime = {
            ...event,
            matchTime: formatTime(currentTime),
            ...(useVideoMode ? { videoTime: currentVideoTime } : {}),
        };

        const { newState, possessionId, predictions: newPredictions, isInTransition: inTrans } = processEvent(eventWithTime);

        const enrichedEvent = {
            ...eventWithTime,
            matchState: newState,
            possessionId,
            predictions: newPredictions.slice(0, 3),
            inTransitionWindow: inTrans
        };

        if (!hasPermission('dashboard.live.tagging') && user?.role !== 'admin') {
            toast.error('Only the Live Tagger can record events.');
            return;
        }

        setEvents((prev: LoggedEvent[]) => [enrichedEvent, ...prev]);
        setLastEventButtonLabel(event.buttonLabel);
        socket?.emit('new-event', enrichedEvent);

        const eventDef = EVENT_REGISTRY.find(e => e.eventName === event.eventName);
        if (autoExtract && useVideoMode && eventDef?.clippingEnabled !== false) {
            extractClip(enrichedEvent);
        }

        if (eventDef?.requiresDuration) {
            let isStarting = false;
            setActiveDurations((prev: Map<string, any>) => {
                const next = new Map(prev);
                if (next.has(event.eventName)) {
                    const startData = next.get(event.eventName)!;
                    const duration = (useVideoMode ? (videoTime - startData.startTime) : (matchTimeRef.current - startData.matchTime));
                    console.log(`‚è±Ô∏è Duration for ${event.eventName}: ${duration.toFixed(2)}s`);
                    next.delete(event.eventName);
                } else {
                    next.set(event.eventName, {
                        startTime: useVideoMode ? videoTime : 0,
                        matchTime: matchTimeRef.current
                    });
                    isStarting = true;
                }
                return next;
            });

            if (isStarting) {
                toast.info(`‚è∫Ô∏è Started: ${event.buttonLabel || event.eventName}`);
            }
        }
    }, [useVideoMode, videoTime, formatTime, matchTimeRef, setEvents, setLastEventButtonLabel, socket, processEvent, autoExtract, hasPermission, user, setActiveDurations, serverVideoPath]);

    const handleAssignZone = useCallback((eventId: number, zone: number) => {
        setEvents((prev: LoggedEvent[]) => prev.map(evt =>
            evt.id === eventId ? { ...evt, zone, isPendingZone: false } : evt
        ));

        const eventToUpdate = events.find((e: LoggedEvent) => e.id === eventId);
        if (eventToUpdate) {
            socket?.emit('update-event', { id: eventId, zone, isPendingZone: false });
        }

        setSelectedPendingEvent(null);
        toast.success('Zone assigned successfully');
    }, [events, setEvents, socket, setSelectedPendingEvent]);

    const handleDismissPending = useCallback((eventId: number) => {
        setEvents((prev: LoggedEvent[]) => prev.map(evt =>
            evt.id === eventId ? { ...evt, isPendingZone: false } : evt
        ));
        toast.info('Zone assignment skipped');
    }, [setEvents]);

    const handleTeamUpload = (newTeams: Map<string, TeamRoster>) => {
        const updatedTeams = new Map(teams);
        newTeams.forEach((roster, teamName) => {
            updatedTeams.set(teamName, roster);
        });
        setTeams(updatedTeams);
        socket?.emit('sync-teams', Array.from(updatedTeams.entries()));
        if (newTeams.size > 0) setSelectedTeam('');
    };

    const handleTeamSelect = (teamId: string) => {
        setSelectedTeam(teamId);
        socket?.emit('select-team', teamId);
    };

    const handlePlayerSelect = (playerId: number) => {
        setEvents((prevEvents: LoggedEvent[]) => {
            const newEvents = [...prevEvents];
            let targetIndex = -1;
            if (editingEventId !== null) {
                targetIndex = newEvents.findIndex(e => e.id === editingEventId);
            } else {
                const searchLimit = Math.min(newEvents.length, 10);
                for (let i = searchLimit - 1; i >= 0; i--) {
                    if (!newEvents[i].player && !newEvents[i].isCalculated) {
                        targetIndex = i;
                        break;
                    }
                }
            }
            if (targetIndex !== -1) {
                const targetEvent = newEvents[targetIndex];
                const roster = teams.get(selectedTeam);
                const player = roster?.PlayerData.find(p => p.ID === playerId);
                if (player) {
                    const updatedEvent = {
                        ...targetEvent,
                        player: { id: player.ID, name: `${player.Forename} ${player.Surname}` },
                    };
                    newEvents[targetIndex] = updatedEvent;
                    socket?.emit('update-event', updatedEvent);
                    toast.success('Player Assigned', { description: `Assigned ${player.Surname} to ${targetEvent.eventName}` });
                    if (editingEventId !== null) setEditingEventId(null);
                }
            }
            return newEvents;
        });
    };

    const handleGameEvent = (eventName: string, source: string = 'Manual') => {
        const teamKeys = Array.from(teams.keys());
        const teamSide = (selectedTeam === (teamKeys[1]) ? "TEAM_B" : "TEAM_A") as "TEAM_A" | "TEAM_B";
        const newEvent: LoggedEvent = {
            id: Number(`${Date.now()}${Math.floor(Math.random() * 1000)}`),
            timestamp: new Date().toISOString(),
            eventName,
            team: teamSide,
            buttonLabel: source,
            matchTime: formatTime(matchTimeRef.current),
        };
        handleEventLogged(newEvent);
    };

    const handleVoiceResult = (transcript: string) => {
        const lowerTranscript = transcript.toLowerCase();
        const number = parseNumber(lowerTranscript);
        if (number !== null) {
            const currentTeamRoster = teams.get(selectedTeam)?.PlayerData;
            if (currentTeamRoster) {
                const player = currentTeamRoster.find(p => p.Number === number);
                if (player) handlePlayerSelect(player.ID);
            }
        }
        let matchedCommand = null;
        if (matchCommand(lowerTranscript, COMMANDS.PASS)) matchedCommand = 'PASS';
        else if (matchCommand(lowerTranscript, COMMANDS.SHOOT)) matchedCommand = 'SHOT';
        else if (matchCommand(lowerTranscript, COMMANDS.GOAL)) matchedCommand = 'GOAL';
        else if (matchCommand(lowerTranscript, COMMANDS.FOUL)) matchedCommand = 'FOUL';
        else if (matchCommand(lowerTranscript, COMMANDS.OFFSIDE)) matchedCommand = 'OFFSIDE';
        else if (matchCommand(lowerTranscript, COMMANDS.PENALTY)) matchedCommand = 'PENALTY';
        else if (matchCommand(lowerTranscript, COMMANDS.CORNER)) matchedCommand = 'CORNER';
        else if (matchCommand(lowerTranscript, COMMANDS.SUBSTITUTION)) matchedCommand = 'SUBSTITUTION';

        if (matchedCommand) {
            handleGameEvent(matchedCommand, 'Voice');
            toast.success('Voice Command', { description: `Executed: ${matchedCommand}` });
        }
    };

    const toggleMatch = () => {
        if (!isMatchActive) {
            setIsMatchActive(true);
            if (useVideoMode) setIsVideoPlaying(true);
            if (!isListening) try { startListening(); } catch (e) { console.error(e); }
        } else {
            setIsMatchActive(false);
            if (useVideoMode) setIsVideoPlaying(false);
        }
    };

    const toggleWatchMatch = async () => {
        // This probably needs to access videoStream and setVideoStream from state
        const { videoStream, setVideoStream } = state;
        if (videoStream) {
            videoStream.getTracks().forEach((track: any) => track.stop());
            setVideoStream(null);
        } else {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: { displaySurface: 'window' } as any, audio: false });
                setVideoStream(stream);
                stream.getVideoTracks()[0].onended = () => setVideoStream(null);
            } catch (err) { console.error('Error sharing screen:', err); }
        }
    };

    const handleExport = () => {
        if (events.length === 0) {
            toast.error('No events');
            return;
        }
        exportToCSV(events);
        toast.success('Exported to CSV');
    };

    return {
        handleEventLogged,
        handleAssignZone,
        handleDismissPending,
        handleTeamUpload,
        handleTeamSelect,
        handlePlayerSelect,
        handleGameEvent,
        handleVoiceResult,
        toggleMatch,
        toggleWatchMatch,
        handleExport,
        extractClip
    };
}
</file>

<file path="src/hooks/index/useIndexState.ts">
import { useState, useRef, useMemo } from 'react';
import { ViewType } from '@/components/AppSidebar';
import { LoggedEvent } from '@/hooks/useGamepad';
import type { AnalysisMode } from '@/components/AnalysisModeSelector';
import { LiveStreamPlayerRef } from '@/components/LiveStreamPlayer';
import { TeamRoster } from '@/types/player';
import { useMatchTimer } from '@/hooks/useMatchTimer';
import { usePictureInPicture } from '@/hooks/usePictureInPicture';
import { useAudioBroadcast } from '@/hooks/useAudioBroadcast';
import { useVoiceRoom } from '@/hooks/useVoiceRoom';
import { useSocketEvents } from '@/hooks/useSocketEvents';
import { useIPTVAuth } from '@/contexts/IPTVAuthContext';

export function useIndexState(auth: any, match: any, socketContext: any) {
    const { user, hasPermission } = auth;
    const { teams, selectedTeam, matchTime, isMatchActive, setIsMatchActive, useVideoMode, setIsVideoPlaying } = match;
    const { socket, role: socketRole } = socketContext;

    const { isConfigured: isIPTVConfigured } = useIPTVAuth();
    const { matchTimeRef, formatTime } = useMatchTimer();
    const { pipWindow, togglePiP } = usePictureInPicture();
    const { remoteAudioStream } = useAudioBroadcast(socket, socketRole);
    const { isInRoom, joinVoiceRoom, leaveVoiceRoom, toggleMute, isMuted, peers } = useVoiceRoom(socket, user?.role);

    useSocketEvents(socket);

    // --- Local UI State ---
    const [voiceLanguage, setVoiceLanguage] = useState<'en' | 'fr' | 'ar'>('en');
    const [videoStream, setVideoStream] = useState<MediaStream | null>(null);

    // Initialize Mode based on Permissions
    const [trackingMode, setTrackingMode] = useState<AnalysisMode>(() => {
        if (hasPermission('dashboard.post.view') && !hasPermission('dashboard.live.view')) return 'POST_MATCH';
        return 'LIVE';
    });
    const [isEditingMode, setIsEditingMode] = useState(false);

    // Initialize View based on Permissions
    const [activeView, setActiveView] = useState<ViewType>(() => {
        if (hasPermission('dashboard.view')) return 'dashboard';
        if (hasPermission('analytics.view')) return 'analytics';
        if (hasPermission('qa.view')) return 'qa';
        return 'dashboard'; // Fallback
    });

    const [sessionMode, setSessionMode] = useState<'collab' | 'individual' | null>(null);
    const [showAdminWaitingRoom, setShowAdminWaitingRoom] = useState(false);

    // Menu Toggles
    const [showFeed, setShowFeed] = useState(true);
    const [showAnalytics, setShowAnalytics] = useState(true);
    const [showMappings, setShowMappings] = useState(true);
    const [showIPTVBrowser, setShowIPTVBrowser] = useState(false);
    const [showFIFAPlusBrowser, setShowFIFAPlusBrowser] = useState(false);

    // Refs
    const videoRef = useRef<HTMLVideoElement>(null);
    const audioRef = useRef<HTMLAudioElement>(null);
    const livePlayerRef = useRef<LiveStreamPlayerRef>(null);

    // Auto-Validation State
    const [autoExtract] = useState(() => localStorage.getItem('tacta_auto_extract') === 'true');
    const [serverVideoPath, setServerVideoPath] = useState<string | null>(null);

    // Advanced Event Interaction State
    const [activeDurations, setActiveDurations] = useState<Map<string, { startTime: number, matchTime: number }>>(new Map());
    const [selectedPendingEvent, setSelectedPendingEvent] = useState<LoggedEvent | null>(null);

    // Derived State
    const teamNames = useMemo(() => ({
        teamA: Array.from(teams.keys())[0] || 'Algeria',
        teamB: Array.from(teams.keys())[1] || 'Nigeria'
    }), [teams]);

    const gamepadConfig = useMemo(() => ({
        teamARoster: (teams.get(selectedTeam) as TeamRoster)?.PlayerData?.map(p => ({
            id: p.ID,
            name: `${p.Forename} ${p.Surname}`,
            number: p.Number,
        })) || [],
        teamBRoster: Array.from(teams.entries())
            .find(([id]) => id !== selectedTeam)?.[1]?.PlayerData?.map((p: any) => ({
                id: p.ID,
                name: `${p.Forename} ${p.Surname}`,
                number: p.Number,
            })) || [],
        teamAStartingNumbers: selectedTeam === 'Algeria' ? [1, 2, 5, 6, 7, 8, 9, 10, 11, 15, 22] : undefined,
        analysisMode: trackingMode,
        useKeyboardAsController: user?.role === 'early_tester',
    }), [teams, selectedTeam, trackingMode, user]);

    return {
        voiceLanguage, setVoiceLanguage,
        videoStream, setVideoStream,
        trackingMode, setTrackingMode,
        isEditingMode, setIsEditingMode,
        activeView, setActiveView,
        sessionMode, setSessionMode,
        showAdminWaitingRoom, setShowAdminWaitingRoom,
        showFeed, setShowFeed,
        showAnalytics, setShowAnalytics,
        showMappings, setShowMappings,
        showIPTVBrowser, setShowIPTVBrowser,
        showFIFAPlusBrowser, setShowFIFAPlusBrowser,
        videoRef,
        audioRef,
        livePlayerRef,
        autoExtract,
        serverVideoPath, setServerVideoPath,
        activeDurations, setActiveDurations,
        selectedPendingEvent, setSelectedPendingEvent,
        teamNames,
        gamepadConfig,
        isIPTVConfigured,
        matchTimeRef, formatTime,
        pipWindow, togglePiP,
        remoteAudioStream,
        isInRoom, joinVoiceRoom, leaveVoiceRoom, toggleMute, isMuted, peers,
        socket, socketRole,
        ...auth,
        ...match
    };
}
</file>

<file path="src/hooks/use-mobile.tsx">
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined);

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}
</file>

<file path="src/hooks/use-toast.ts">
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };
</file>

<file path="src/hooks/useAnnotations.ts">
import { useState, useCallback, useMemo } from 'react';
import { solveHomography, HomographyMatrix } from '../utils/homography';
import { useMatchContext } from '@/contexts/MatchContext';

// Point type
export interface Point {
    x: number;
    y: number;
}

// Annotation types
export type AnnotationType =
    | 'arrow'
    | 'circle'
    | 'rectangle'
    | 'text'
    | 'player-track'
    | 'ruler'
    | 'spotlight'
    | 'zone'
    | 'marker';

export interface AnnotationStyle {
    color: string;
    strokeWidth: number;
    opacity: number;
    fillOpacity?: number;
    dashed?: boolean;
    glow?: boolean;
}

export interface BaseAnnotation {
    id: string;
    type: AnnotationType;
    startTime: number;
    endTime: number;
    style: AnnotationStyle;
    pitchCoords?: { x: number; y: number; endX?: number; endY?: number; points?: Point[] };
}

export interface ArrowAnnotation extends BaseAnnotation {
    type: 'arrow';
    data: {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
    };
}

export interface CircleAnnotation extends BaseAnnotation {
    type: 'circle';
    data: {
        cx: number;
        cy: number;
        radius: number;
    };
}

export interface RectangleAnnotation extends BaseAnnotation {
    type: 'rectangle';
    data: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
}

export interface TextAnnotation extends BaseAnnotation {
    type: 'text';
    data: {
        x: number;
        y: number;
        text: string;
        fontSize: number;
    };
}

export interface PlayerTrackAnnotation extends BaseAnnotation {
    type: 'player-track';
    data: {
        playerId: number;
        points: Array<{ time: number; x: number; y: number }>;
        manual: boolean;
    };
}

export interface RulerAnnotation extends BaseAnnotation {
    type: 'ruler';
    data: {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        distanceMeters?: number;
    };
}

export interface SpotlightAnnotation extends BaseAnnotation {
    type: 'spotlight';
    data: {
        cx: number;
        cy: number;
        radius: number;
        height?: number;
    };
}

export interface ZoneAnnotation extends BaseAnnotation {
    type: 'zone';
    data: {
        points: Point[];
    };
}

export interface MarkerAnnotation extends BaseAnnotation {
    type: 'marker';
    data: {
        x: number;
        y: number;
        label?: string;
    };
}

export type Annotation =
    | ArrowAnnotation
    | CircleAnnotation
    | RectangleAnnotation
    | TextAnnotation
    | PlayerTrackAnnotation
    | RulerAnnotation
    | SpotlightAnnotation
    | ZoneAnnotation
    | MarkerAnnotation;

export interface UseAnnotationsReturn {
    annotations: Annotation[];
    activeAnnotations: Annotation[];
    calibration: {
        pairs: Array<{ src: Point; dst: Point }>;
        matrix: HomographyMatrix | null;
    };
    addAnnotation: (annotation: Omit<Annotation, 'id'>) => void;
    updateAnnotation: (id: string, updates: Partial<Annotation>) => void;
    deleteAnnotation: (id: string) => void;
    clearAnnotations: () => void;
    addCalibrationPair: (src: Point, dst: Point) => void;
    removeLastCalibrationPair: () => void;
    setCalibrationPairs: (pairs: Array<{ src: Point; dst: Point }>) => void;
    clearCalibration: () => void;
    exportAnnotations: () => string;
    importAnnotations: (json: string) => void;
}

export const useAnnotations = (currentTime: number): UseAnnotationsReturn => {
    const [annotations, setAnnotations] = useState<Annotation[]>([]);
    const { setCalibrationMatrix } = useMatchContext();
    const [calibrationPairs, setCalibrationPairsState] = useState<Array<{ src: Point; dst: Point }>>([]);
    const [homographyMatrix, setHomographyMatrix] = useState<HomographyMatrix | null>(null);

    // Get annotations visible at current time
    const activeAnnotations = useMemo(() => {
        return annotations.filter(
            (ann) => currentTime >= ann.startTime && currentTime <= ann.endTime
        );
    }, [annotations, currentTime]);

    const addAnnotation = useCallback((annotation: Omit<Annotation, 'id'>) => {
        const id = `ann-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newAnnotation = { ...annotation, id } as Annotation;
        setAnnotations((prev) => [...prev, newAnnotation]);
    }, []);

    const updateAnnotation = useCallback((id: string, updates: Partial<Annotation>) => {
        setAnnotations((prev) =>
            prev.map((ann) => {
                if (ann.id !== id) return ann;

                // Type-safe update: ensure the update is compatible with the annotation type
                const updated = { ...ann, ...updates };

                // Validate that critical type-specific fields aren't corrupted
                if (updated.type !== ann.type) {
                    console.error('Cannot change annotation type');
                    return ann;
                }

                return updated as Annotation;
            })
        );
    }, []);

    const deleteAnnotation = useCallback((id: string) => {
        setAnnotations((prev) => prev.filter((ann) => ann.id !== id));
    }, []);

    const clearAnnotations = useCallback(() => {
        setAnnotations([]);
    }, []);

    const exportAnnotations = useCallback(() => {
        return JSON.stringify(annotations, null, 2);
    }, [annotations]);

    const importAnnotations = useCallback((json: string) => {
        try {
            const imported = JSON.parse(json) as Annotation[];
            setAnnotations(imported);
        } catch (error) {
            console.error('Failed to import annotations:', error);
        }
    }, []);

    const updateHomography = useCallback((pairs: Array<{ src: Point; dst: Point }>) => {
        if (pairs.length >= 4) {
            const src = pairs.map(p => p.src);
            const dst = pairs.map(p => p.dst);
            const matrix = solveHomography(src, dst);
            setHomographyMatrix(matrix);
            setCalibrationMatrix(matrix);
        } else {
            setHomographyMatrix(null);
            setCalibrationMatrix(null);
        }
    }, [setCalibrationMatrix]);

    const addCalibrationPair = useCallback((src: Point, dst: Point) => {
        setCalibrationPairsState((prev) => {
            const next = [...prev, { src, dst }];
            updateHomography(next);
            return next;
        });
    }, [updateHomography]);

    const setCalibrationPairs = useCallback((pairs: Array<{ src: Point; dst: Point }>) => {
        setCalibrationPairsState(pairs);
        updateHomography(pairs);
    }, [updateHomography]);

    const clearCalibration = useCallback(() => {
        setCalibrationPairsState([]);
        setHomographyMatrix(null);
        setCalibrationMatrix(null);
    }, [setCalibrationMatrix]);

    const removeLastCalibrationPair = useCallback(() => {
        setCalibrationPairsState((prev) => {
            const next = prev.slice(0, -1);
            updateHomography(next);
            return next;
        });
    }, [updateHomography]);

    return {
        annotations,
        activeAnnotations,
        calibration: {
            pairs: calibrationPairs,
            matrix: homographyMatrix
        },
        addAnnotation,
        updateAnnotation,
        deleteAnnotation,
        clearAnnotations,
        addCalibrationPair,
        removeLastCalibrationPair,
        setCalibrationPairs,
        clearCalibration,
        exportAnnotations,
        importAnnotations,
    };
};
</file>

<file path="src/hooks/useAudioBroadcast.ts">
import { useState, useEffect, useRef } from 'react';
import { Socket } from 'socket.io-client';

export const useAudioBroadcast = (socket: Socket | null, role: 'broadcaster' | 'viewer' | null) => {
    const [localAudioStream, setLocalAudioStream] = useState<MediaStream | null>(null);
    const [remoteAudioStream, setRemoteAudioStream] = useState<MediaStream | null>(null);
    const [isBroadcasting, setIsBroadcasting] = useState(false);

    const peerConnections = useRef<Map<string, RTCPeerConnection>>(new Map());

    const startAudioBroadcast = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });

            setLocalAudioStream(stream);
            setIsBroadcasting(true);

            // Notify server that broadcaster is ready
            socket?.emit('audio-broadcaster-ready');
        } catch (err) {
            console.error('Error accessing microphone:', err);
            throw err;
        }
    };

    const stopAudioBroadcast = () => {
        if (localAudioStream) {
            localAudioStream.getTracks().forEach(track => track.stop());
            setLocalAudioStream(null);
        }

        // Close all peer connections
        peerConnections.current.forEach(pc => pc.close());
        peerConnections.current.clear();

        setIsBroadcasting(false);
        socket?.emit('audio-broadcast-stopped');
    };

    // Broadcaster: Handle new watchers
    useEffect(() => {
        if (role !== 'broadcaster' || !localAudioStream) return;

        const handleAudioWatcher = async (watcherId: string) => {
            console.log('Audio watcher connected:', watcherId);

            const peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            // Add audio track to peer connection
            localAudioStream.getAudioTracks().forEach(track => {
                peerConnection.addTrack(track, localAudioStream);
            });

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket?.emit('audio-candidate', {
                        candidate: event.candidate,
                        to: watcherId
                    });
                }
            };

            // Create and send offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            socket?.emit('audio-offer', {
                offer: peerConnection.localDescription,
                to: watcherId
            });

            peerConnections.current.set(watcherId, peerConnection);
        };

        if (!socket) return;
        socket.on('audio-watcher', handleAudioWatcher);

        return () => {
            socket.off('audio-watcher', handleAudioWatcher);
        };
    }, [role, localAudioStream, socket]);

    // Viewer: Request to watch and handle offer
    useEffect(() => {
        if (role !== 'viewer') return;

        // Notify broadcaster that we want to watch
        socket?.emit('audio-watcher');

        const handleAudioOffer = async (data: { offer: RTCSessionDescriptionInit, from: string }) => {
            console.log('Received audio offer from:', data.from);

            const peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            // Handle incoming audio stream
            peerConnection.ontrack = (event) => {
                console.log('Received remote audio track');
                setRemoteAudioStream(event.streams[0]);
            };

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket?.emit('audio-candidate', {
                        candidate: event.candidate,
                        to: data.from
                    });
                }
            };

            // Set remote description and create answer
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            socket?.emit('audio-answer', {
                answer: peerConnection.localDescription,
                to: data.from
            });

            peerConnections.current.set(data.from, peerConnection);
        };

        if (!socket) return;
        socket.on('audio-offer', handleAudioOffer);

        return () => {
            socket.off('audio-offer', handleAudioOffer);
        };
    }, [role, socket]);

    // Handle ICE candidates (both broadcaster and viewer)
    useEffect(() => {
        const handleAudioCandidate = async (data: { candidate: RTCIceCandidateInit, from: string }) => {
            const peerConnection = peerConnections.current.get(data.from);
            if (peerConnection) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        };

        if (!socket) return;
        socket.on('audio-candidate', handleAudioCandidate);

        return () => {
            socket.off('audio-candidate', handleAudioCandidate);
        };
    }, [socket]);

    // Handle answer (broadcaster only)
    useEffect(() => {
        if (role !== 'broadcaster') return;

        const handleAudioAnswer = async (data: { answer: RTCSessionDescriptionInit, from: string }) => {
            const peerConnection = peerConnections.current.get(data.from);
            if (peerConnection) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
            }
        };

        if (!socket) return;
        socket.on('audio-answer', handleAudioAnswer);

        return () => {
            socket.off('audio-answer', handleAudioAnswer);
        };
    }, [role, socket]);

    // Handle broadcast stopped (viewer only)
    useEffect(() => {
        if (role !== 'viewer') return;

        const handleAudioBroadcastStopped = () => {
            setRemoteAudioStream(null);
            peerConnections.current.forEach(pc => pc.close());
            peerConnections.current.clear();
        };

        if (!socket) return;
        socket.on('audio-broadcast-stopped', handleAudioBroadcastStopped);

        return () => {
            socket.off('audio-broadcast-stopped', handleAudioBroadcastStopped);
        };
    }, [role, socket]);

    return {
        localAudioStream,
        remoteAudioStream,
        isBroadcasting,
        startAudioBroadcast,
        stopAudioBroadcast
    };
};
</file>

<file path="src/hooks/useAutoZoom.ts">
import { useEffect, useRef, useState } from 'react';

interface UseAutoZoomProps {
    videoRef: React.RefObject<HTMLVideoElement>;
    isPlaying: boolean;
}

interface UseAutoZoomReturn {
    autoZoomEnabled: boolean;
    setAutoZoomEnabled: (enabled: boolean) => void;
    zoomLevel: number;
    panPosition: { x: number; y: number };
    canvasRef: React.RefObject<HTMLCanvasElement>;
}

export const useAutoZoom = ({ videoRef, isPlaying }: UseAutoZoomProps): UseAutoZoomReturn => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const [autoZoomEnabled, setAutoZoomEnabled] = useState(false);
    const [zoomLevel, setZoomLevel] = useState(1);
    const [panPosition, setPanPosition] = useState({ x: 0, y: 0 });

    // Video-Based Auto-Zoom (analyzes video frames - no calibration needed)
    useEffect(() => {
        if (!autoZoomEnabled || !videoRef.current || !canvasRef.current) {
            // Reset zoom if auto-zoom is disabled
            if (!autoZoomEnabled && zoomLevel !== 1) {
                setZoomLevel(1);
                setPanPosition({ x: 0, y: 0 });
            }
            return;
        }

        const analyzeFrame = () => {
            const canvas = canvasRef.current;
            const video = videoRef.current;
            if (!canvas || !video || video.paused || video.ended) return;

            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            // Sample at low resolution for performance
            canvas.width = 320;
            canvas.height = 180;

            try {
                ctx.drawImage(video, 0, 0, 320, 180);
                const imageData = ctx.getImageData(0, 0, 320, 180);
                const pixels = imageData.data;

                let greenPixels = 0;
                const totalPixels = pixels.length / 4;

                // Track non-green pixels (players, ball, etc.) for focus detection
                let focusX = 0;
                let focusY = 0;
                let focusCount = 0;

                // Detect green field pixels and non-green focus points
                for (let i = 0; i < pixels.length; i += 4) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];

                    // Calculate position in frame
                    const pixelIndex = i / 4;
                    const x = (pixelIndex % 320) / 320; // 0-1
                    const y = Math.floor(pixelIndex / 320) / 180; // 0-1

                    // IGNORE TOP 30% of frame (crowd/stands area)
                    if (y < 0.3) continue;

                    // Green detection: g > r && g > b && g > threshold
                    if (g > r && g > b && g > 60) {
                        greenPixels++;
                    } else {
                        // Non-green pixel (potential player/ball)
                        // Only consider pixels in the field area (lower 70% of frame)

                        // Weight brighter pixels more (likely to be players/ball)
                        const brightness = (r + g + b) / 3;

                        // Filter: bright enough but not too bright (avoid ads/graphics)
                        if (brightness > 80 && brightness < 240) {
                            focusX += x * brightness;
                            focusY += y * brightness;
                            focusCount += brightness;
                        }
                    }
                }

                const fieldRatio = greenPixels / totalPixels;

                // Calculate focus point (center of action)
                let targetX = 50; // Default center
                let targetY = 50;

                if (focusCount > 0) {
                    targetX = (focusX / focusCount) * 100; // Convert to 0-100
                    targetY = (focusY / focusCount) * 100;
                }

                // High field ratio = wide shot = zoom in
                if (fieldRatio > 0.4) {
                    setZoomLevel(2.5);
                    // Pan to focus point
                    setPanPosition({
                        x: (50 - targetX) * 1.5,
                        y: (50 - targetY) * 1.5
                    });
                } else if (fieldRatio > 0.25) {
                    setZoomLevel(1.8);
                    setPanPosition({
                        x: (50 - targetX) * 0.8,
                        y: (50 - targetY) * 0.8
                    });
                } else {
                    setZoomLevel(1);
                    setPanPosition({ x: 0, y: 0 });
                }
            } catch (err) {
                console.error('Frame analysis error:', err);
            }
        };

        // Analyze frames every 500ms
        const interval = setInterval(analyzeFrame, 500);

        // Initial analysis
        analyzeFrame();

        return () => clearInterval(interval);
    }, [autoZoomEnabled, isPlaying, videoRef]);

    return {
        autoZoomEnabled,
        setAutoZoomEnabled,
        zoomLevel,
        panPosition,
        canvasRef
    };
};
</file>

<file path="src/hooks/useDashboardLayout.ts">
import { useState, useEffect, useCallback } from 'react';
import { toast } from 'sonner';

export interface LayoutConfig {
    [key: string]: {
        hidden: boolean;
        order?: number; // Future proofing for reordering
    };
}

const STORAGE_KEY = 'tacta_dashboard_layout_v1';

export const useDashboardLayout = () => {
    const [isEditMode, setIsEditMode] = useState(false);
    const [layoutConfig, setLayoutConfig] = useState<LayoutConfig>({});

    // Load config on mount
    useEffect(() => {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                setLayoutConfig(JSON.parse(saved));
            }
        } catch (e) {
            console.error('Failed to load dashboard layout', e);
        }
    }, []);

    const toggleComponentVisibility = useCallback((id: string) => {
        setLayoutConfig(prev => {
            const current = prev[id] || { hidden: false };
            return {
                ...prev,
                [id]: { ...current, hidden: !current.hidden }
            };
        });
    }, []);

    const saveLayout = useCallback(() => {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(layoutConfig));
            toast.success('Dashboard layout saved');
            setIsEditMode(false);
        } catch (e) {
            toast.error('Failed to save layout');
        }
    }, [layoutConfig]);

    const resetLayout = useCallback(() => {
        setLayoutConfig({});
        localStorage.removeItem(STORAGE_KEY);
        toast.info('Layout reset to default');
    }, []);

    return {
        isEditMode,
        setIsEditMode,
        layoutConfig,
        toggleComponentVisibility,
        saveLayout,
        resetLayout
    };
};
</file>

<file path="src/hooks/useGamepad.ts">
import { useState, useEffect, useRef, useCallback, useMemo } from "react";
import { useEventConfig } from '@/contexts/EventConfigContext';
import { PlayerPosition, predictPassTargets, createDefaultRoster, convertToPlayerPosition } from "@/utils/passPredictor";

// Mappings are now derived dynamically from EventConfigContext
export type GamepadButtonMapping = {
  index: number;
  eventName: string;
  eventDescription: string;
  buttonLabel: string;
};

export const BUTTON_LABELS: { [key: number]: string } = {
  0: "A", 1: "B", 2: "X", 3: "Y",
  4: "LB", 5: "RB", 6: "LT", 7: "RT",
  8: "View", 9: "Menu", 10: "L3", 11: "R3",
  12: "D-Up", 13: "D-Down", 14: "D-Left", 15: "D-Right",
};

export type ModifierCombo = {
  modifier: 'RT' | 'LT' | 'RB' | 'LB' | 'View' | 'Menu' | 'D-Up' | 'D-Down' | 'D-Left' | 'D-Right';
  button: number;
  eventName: string;
  eventDescription: string;
  buttonLabel: string;
};

// Events that trigger Immediate Player Selection (One-Step)
const IMMEDIATE_PLAYER_EVENTS = [
  "pass_start",
  "shot_start",
  "dribble_attempt",
  "foul",
  "interception",
  "turnover",
  "save",
  "card_yellow",
  "card_red",
  "goal",
  "key_pass",
  "assist"
];

export type LoggedEvent = {
  id: number;
  timestamp: string;
  eventName: string;
  team: "TEAM_A" | "TEAM_B";
  buttonLabel: string;
  player?: {
    id: number;
    name: string;
  };
  matchTime?: string;
  videoTime?: number;
  isCalculated?: boolean;
  mode?: 'LIVE' | 'POST_MATCH';
  zone?: number;
  subType?: "SHORT" | "LONG";
  x?: number; // 0-105m
  y?: number; // 0-68m
  endX?: number;
  endY?: number;
  endZone?: number;
  qualityRating?: 1 | 2 | 3 | 4 | 5;
  category?: string;
  folder?: string;
  filenameConvention?: string;
  tempo?: 'HIGH' | 'MEDIUM' | 'LOW';
  underPressure?: boolean;
  isProgressive?: boolean;
  xgValue?: number;
  corridor?: 'LW' | 'LHS' | 'C' | 'RHS' | 'RW';
  durationMs?: number;
  isValidated?: boolean;
  reviewedBy?: string;
  validationNotes?: string;

  // --- Semantic Intelligence Layer ---
  semanticIndicator?: string;      // e.g., "Defensive Block Height", "Momentum Shift"
  intensity?: 'LOW' | 'MEDIUM' | 'HIGH';
  psychology?: 'SPIRIT' | 'EGO' | 'FEAR' | 'COMA';
  contextualFactor?: string;       // e.g., "Post-Goal", "Ref Decision"

  // --- Match State Machine & Prediction ---
  matchState?: any;                // MatchState snapshot
  possessionId?: number;
  inTransitionWindow?: boolean;
  predictions?: any[];             // Prediction[]
  isDelayed?: boolean;             // Logger: Marked as captured with delay
  isMissed?: boolean;              // Logger: Marked as a missed event
  isPendingZone?: boolean;          // NEW: Awaiting asynchronous zone assignment
};

export interface GameState {
  currentTeam: "TEAM_A" | "TEAM_B";
  lastAction: { type: string, timestamp: number, team: "TEAM_A" | "TEAM_B" } | null;
  passSequenceCount: number;
  lastStickMove?: number;
}

export interface PlayerSelectionState {
  currentBallHolder: PlayerPosition | null;
  predictedTargets: PlayerPosition[];
  selectedTargetIndex: number;
  isSelecting: boolean;
}

export interface QuickSelectorState {
  isOpen: boolean;
  roster: PlayerPosition[];
  selectedIndex: number;
  team: "TEAM_A" | "TEAM_B";
}

export interface ZoneSelectorState {
  isOpen: boolean;
  selectedZone: number;
}

// NEW: Thirds-based zone selection state
export type PitchThird = 'DEFENSE' | 'MIDFIELD' | 'ATTACK';
export interface ThirdsZoneState {
  activeThird: PitchThird;
  previewZone: number | null; // 1-18, null if stick is neutral
  confirmedZone: number; // Last confirmed zone (for display)
}

interface UseGamepadOptions {
  teamARoster?: any[];
  teamBRoster?: any[];
  teamAStartingNumbers?: number[];
  teamBStartingNumbers?: number[];
  analysisMode?: 'LIVE' | 'POST_MATCH';
  useKeyboardAsController?: boolean; // NEW: Enable Virtual Controller
}

// Virtual Controller Mapping (Keyboard -> Gamepad Button Index)
const KEYBOARD_CONTROLLER_MAP: { [key: string]: number } = {
  // Face Buttons
  "Space": 0,       // A (Confirm)
  "ShiftLeft": 1,   // B (Cancel)
  "KeyK": 2,        // X
  "KeyL": 3,        // Y

  // Bumpers
  "KeyQ": 4,        // LB
  "KeyE": 5,        // RB

  // Triggers
  "KeyU": 6,        // LT
  "KeyO": 7,        // RT

  // Special
  "KeyV": 8,        // View
  "KeyM": 9,        // Menu
  "KeyZ": 10,       // L3
  "KeyX": 11,       // R3

  // D-Pad
  "ArrowUp": 12,    // D-Up
  "ArrowDown": 13,  // D-Down
  "ArrowLeft": 14,  // D-Left
  "ArrowRight": 15, // D-Right
};

const HOLD_THRESHOLD = 500; // 500ms for hold events

export const useGamepad = (
  onEventLogged: (event: LoggedEvent) => void,
  options: UseGamepadOptions = {},
  onPlayPause?: (isPlaying: boolean) => void
) => {
  const { events: registryEvents } = useEventConfig();
  const [isConnected, setIsConnected] = useState(false);
  const [pressedButtons, setPressedButtons] = useState<number[]>([]);
  const [axes, setAxes] = useState<number[]>([]);
  const [buttons, setButtons] = useState<GamepadButton[]>([]);

  // --- 1. Dynamic Mapping Logic (SSOT) ---
  const { mappings, combos, buttonHolds, dpadHolds } = useMemo(() => {
    const mappings: GamepadButtonMapping[] = [];
    const combos: ModifierCombo[] = [];
    const buttonHolds: { [key: number]: string } = {};
    const dpadHolds: { [key: number]: string } = {};

    registryEvents.forEach(event => {
      if (!event.gamepadMappings) return;

      event.gamepadMappings.forEach(m => {
        // Filter by mode (LIVE vs POST)
        const isPostMatch = options.analysisMode === 'POST_MATCH';
        const matchMode = m.mode === 'BOTH' || (isPostMatch ? m.mode === 'POST' : m.mode === 'LIVE');
        if (!matchMode) return;

        const buttonLabel = m.modifier ? `${m.modifier}+${BUTTON_LABELS[m.buttonIndex]}` : BUTTON_LABELS[m.buttonIndex];

        if (m.modifier) {
          combos.push({
            modifier: m.modifier,
            button: m.buttonIndex,
            eventName: event.eventName,
            eventDescription: event.label,
            buttonLabel: buttonLabel
          });
        } else if (m.isHold) {
          if (m.buttonIndex >= 12 && m.buttonIndex <= 15) {
            dpadHolds[m.buttonIndex] = event.eventName;
          } else {
            buttonHolds[m.buttonIndex] = event.eventName;
          }
        } else {
          mappings.push({
            index: m.buttonIndex,
            eventName: event.eventName,
            eventDescription: event.label,
            buttonLabel: buttonLabel
          });
        }
      });
    });

    return { mappings, combos, buttonHolds, dpadHolds };
  }, [registryEvents, options.analysisMode]);

  // Player Selection State (Legacy / Semantic)
  const [playerSelection, setPlayerSelection] = useState<PlayerSelectionState>({
    currentBallHolder: null,
    predictedTargets: [],
    selectedTargetIndex: 0,
    isSelecting: false
  });

  // Quick Player Selector State (New Popup)
  const [quickSelectorState, setQuickSelectorState] = useState<QuickSelectorState>({
    isOpen: false,
    roster: [],
    selectedIndex: 0,
    team: "TEAM_A"
  });

  const [zoneSelector, setZoneSelector] = useState<ZoneSelectorState>({
    isOpen: false,
    selectedZone: 1
  });

  // NEW: Thirds-based Zone Selection State
  const [thirdsZone, setThirdsZone] = useState<ThirdsZoneState>({
    activeThird: 'MIDFIELD',
    previewZone: null,
    confirmedZone: 0
  });
  const thirdsZoneRef = useRef<ThirdsZoneState>({
    activeThird: 'MIDFIELD',
    previewZone: null,
    confirmedZone: 0
  });

  // Sync thirdsZone to ref
  useEffect(() => {
    thirdsZoneRef.current = thirdsZone;
  }, [thirdsZone]);

  const [pendingEvent, setPendingEvent] = useState<Partial<LoggedEvent> | null>(null);
  const pendingEventRef = useRef<Partial<LoggedEvent> | null>(null);
  const quickSelectorRef = useRef<QuickSelectorState>({
    isOpen: false,
    roster: [],
    selectedIndex: 0,
    team: "TEAM_A"
  });
  const zoneSelectorRef = useRef<ZoneSelectorState>({
    isOpen: false,
    selectedZone: 1
  });

  // Workflow State
  const [isPassing, setIsPassing] = useState(false);
  const isPassingRef = useRef(false);

  useEffect(() => {
    isPassingRef.current = isPassing;
  }, [isPassing]);

  // Sync refs
  useEffect(() => {
    quickSelectorRef.current = quickSelectorState;
  }, [quickSelectorState]);

  useEffect(() => {
    pendingEventRef.current = pendingEvent;
  }, [pendingEvent]);

  useEffect(() => {
    zoneSelectorRef.current = zoneSelector;
  }, [zoneSelector]);

  const resetMappings = useCallback(() => {
    // Legacy: Reset no longer needed as state comes from SSOT
    console.warn("resetMappings called: This is now handled by the Event Registry SSOT.");
  }, []);

  const updateMapping = useCallback((index: number, eventName: string) => {
    // Legacy: Mappings are now read-only derived from registry
    console.warn("updateMapping called locally: Please update the Event Registry via Admin UI instead.");
  }, []);


  // Grid System State
  const [currentZone, setCurrentZone] = useState<number>(0);
  const zoneRef = useRef(0);
  const [keyboardBuffer, setKeyboardBuffer] = useState<string>("");
  const keyboardBufferRef = useRef("");
  const playerSelectionRef = useRef(playerSelection);

  useEffect(() => {
    playerSelectionRef.current = playerSelection;
  }, [playerSelection]);

  useEffect(() => {
    zoneRef.current = currentZone;
  }, [currentZone]);

  const buttonStatesRef = useRef<boolean[]>(new Array(32).fill(false));
  const buttonPressTimestamps = useRef<{ [key: number]: number }>({});

  // TACTA Standard Hold Event Tracking
  const holdEventRef = useRef<{
    startTime: number;
    eventName: string;
    team: "TEAM_A" | "TEAM_B";
    x: number;
    y: number;
    outcomes: Set<string>;
    tempo?: 'HIGH' | 'LOW';
    buttonIndex: number;
  } | null>(null);

  // New: Track if a combo was triggered during a button press sequence
  const comboTriggeredRef = useRef<boolean>(false);
  const modifierSourceRef = useRef<number | null>(null); // Track which modifier button is being held

  // Quality Tap Tracking
  const qualityTapRef = useRef<{
    startTime: number;
    count: number;
    eventId: number | null;
  } | null>(null);

  const rosterARef = useRef<PlayerPosition[]>([]);
  const rosterBRef = useRef<PlayerPosition[]>([]);
  const startingNumbersARef = useRef<number[] | undefined>(undefined);
  const startingNumbersBRef = useRef<number[] | undefined>(undefined);

  // Buffer System for Cancellation (600ms)
  const pendingLogTimeouts = useRef<Map<number, NodeJS.Timeout>>(new Map());
  const lastPendingEventId = useRef<number | null>(null);
  const CANCELLATION_WINDOW_MS = 600;

  const gameStateRef = useRef<GameState>({
    currentTeam: "TEAM_A",
    lastAction: null,
    passSequenceCount: 0,
  });

  // Virtual Controller State (Keyboard emulation)
  const virtualControllerState = useRef<{ [key: number]: boolean }>({});

  // Initialize rosters
  useEffect(() => {
    if (options.teamARoster) rosterARef.current = convertToPlayerPosition(options.teamARoster, "TEAM_A");
    else rosterARef.current = createDefaultRoster("TEAM_A");

    if (options.teamBRoster) rosterBRef.current = convertToPlayerPosition(options.teamBRoster, "TEAM_B");
    else rosterBRef.current = createDefaultRoster("TEAM_B");

    startingNumbersARef.current = options.teamAStartingNumbers;
    startingNumbersBRef.current = options.teamBStartingNumbers;

    if (rosterARef.current.length > 0) {
      let initialPlayer = rosterARef.current[0];
      if (options.teamAStartingNumbers && options.teamAStartingNumbers.length > 0) {
        const starter = rosterARef.current.find(p => options.teamAStartingNumbers?.includes(p.number));
        if (starter) initialPlayer = starter;
      }
      setPlayerSelection(prev => !prev.currentBallHolder ? { ...prev, currentBallHolder: initialPlayer } : prev);
    }
  }, [options.teamARoster, options.teamBRoster, options.teamAStartingNumbers, options.teamBStartingNumbers]);

  const logEvent = useCallback((
    eventName: string,
    team: "TEAM_A" | "TEAM_B",
    buttonLabel: string = "System",
    isCalculated: boolean = false,
    player?: PlayerPosition | null,
    subType?: "SHORT" | "LONG",
    metadata: Partial<LoggedEvent> = {}
  ) => {
    // 0. PREVENT LOGGING UI EVENTS (A/B buttons in LIVE mode)
    // AND HANDLE CANCELLATION
    if (eventName === 'ui_confirm') {
      console.log(`üéÆ UI Action: ${eventName}`);
      return;
    }

    if (eventName === 'ui_cancel') {
      // CANCELLATION LOGIC
      if (lastPendingEventId.current && pendingLogTimeouts.current.has(lastPendingEventId.current)) {
        const idToCancel = lastPendingEventId.current;
        clearTimeout(pendingLogTimeouts.current.get(idToCancel));
        pendingLogTimeouts.current.delete(idToCancel);
        lastPendingEventId.current = null;

        console.log("‚ùå EVENT CANCELLED BY USER");
        return;
      }

      console.log(`üéÆ UI Action: ${eventName}`);
      return;
    }

    // 1. POST-MATCH SPECIAL WORKFLOWS
    if (options.analysisMode === 'POST_MATCH') {
      // A) PASSING WORKFLOW (2-Step)
      if (eventName === 'pass_start') {
        if (!isPassingRef.current) {
          // Step 1: Start Pass (Log Start, Enter State)
          const event: LoggedEvent = {
            id: Number(`${Date.now()}${Math.floor(Math.random() * 1000)}`),
            timestamp: new Date().toISOString(),
            eventName: "pass_start",
            team,
            buttonLabel,
            isCalculated,
            zone: zoneRef.current,
            subType,
            mode: 'POST_MATCH'
          };
          onEventLogged(event);
          setIsPassing(true);
          isPassingRef.current = true; // Sync ref immediately for consistent checks
          console.log("‚öΩ Pass Started... Waiting for Receiver");
          return;
        } else {
          // Step 2: End Pass (Trigger Selector for 'pass_end')
          eventName = "pass_end";
          // Fall through to Selector Logic...
        }
      }

      // B) IMMEDIATE EVENTS (or Step 2 of Pass)
      if (IMMEDIATE_PLAYER_EVENTS.includes(eventName) || eventName === 'pass_end') {
        const partialEvent: Partial<LoggedEvent> = {
          id: Number(`${Date.now()}${Math.floor(Math.random() * 1000)}`),
          timestamp: new Date().toISOString(),
          eventName,
          team,
          buttonLabel,
          isCalculated,
          zone: zoneRef.current,
          subType,
          mode: 'POST_MATCH'
        };

        setPendingEvent(partialEvent);
        pendingEventRef.current = partialEvent;

        const fullRoster = team === "TEAM_A" ? rosterARef.current : rosterBRef.current;
        const startingNumbers = team === "TEAM_A" ? startingNumbersARef.current : startingNumbersBRef.current;

        let filteredRoster = fullRoster;
        if (startingNumbers && startingNumbers.length > 0) {
          filteredRoster = fullRoster.filter(p => startingNumbers.includes(p.number));
        }

        // Fallback if filter results in empty list (e.g. bad config), show full
        if (filteredRoster.length === 0) filteredRoster = fullRoster;

        const selectorData = {
          isOpen: true,
          roster: filteredRoster,
          selectedIndex: 0,
          team
        };
        setQuickSelectorState(selectorData);
        quickSelectorRef.current = selectorData;

        // Pause Video Immediately
        if (onPlayPause) {
          onPlayPause(false);
        }

        return; // STOP here
      }
    }

    // Find dynamic definition
    const eventDef = registryEvents.find(e => e.eventName === eventName);

    // --- NEW: INTERACTION CHECKS (Async Flow) ---
    const needsZone = eventDef?.requiresZone && !metadata.zone;

    // If it needs a zone, we log it immediately but mark it as pending
    // This prevents the "Live Dialog" interruption requested by the user.
    if (needsZone) {
      console.log(`üìç Event [${eventName}] queued for Asynchronous Zone Selection...`);
      metadata = { ...metadata, isPendingZone: true };
    }

    const event: LoggedEvent = {
      id: Number(`${Date.now()}${Math.floor(Math.random() * 1000)}`),
      timestamp: new Date().toISOString(),
      eventName,
      team,
      buttonLabel,
      isCalculated,
      zone: zoneRef.current,
      subType,
      mode: options.analysisMode || 'POST_MATCH',
      // Dynamic Metadata from Registry
      category: eventDef?.category,
      folder: eventDef?.folderPath,
      filenameConvention: eventDef?.filenameConvention,
      durationMs: (eventDef?.defaultDuration ? eventDef.defaultDuration[0] * 1000 : 0), // Default to min duration
      ...(player ? {
        player: {
          id: player.id,
          name: player.name
        }
      } : {}),
      ...metadata
    };

    // NEW BUFFERED LOGGING (0.6s Grace Period)
    const timeoutId = setTimeout(() => {
      onEventLogged(event);
      pendingLogTimeouts.current.delete(event.id);
      if (lastPendingEventId.current === event.id) {
        lastPendingEventId.current = null;
      }
    }, CANCELLATION_WINDOW_MS);

    pendingLogTimeouts.current.set(event.id, timeoutId);
    lastPendingEventId.current = event.id;

    // Switch possession on turnover
    if (eventName === 'turnover') {
      gameStateRef.current.currentTeam = gameStateRef.current.currentTeam === 'TEAM_A' ? 'TEAM_B' : 'TEAM_A';
      console.log(`‚öΩ Possession changed to ${gameStateRef.current.currentTeam}`);
    }
    return event;
  }, [onEventLogged, options.analysisMode, onPlayPause, registryEvents]);

  // Keyboard Listener (TACTA Standard + Virtual Controller)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // 0. IGNORE if typing in an input field
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }

      // --- VIRTUAL CONTROLLER LOGIC ---
      if (options.useKeyboardAsController) {
        const buttonIndex = KEYBOARD_CONTROLLER_MAP[e.code];
        if (buttonIndex !== undefined) {
          e.preventDefault();
          virtualControllerState.current[buttonIndex] = true;
          // Don't return, as we still might want native shortcuts if not mapped to a button?
          // Actually, if it's acting as a controller, we should let the pollGamepad loop handle it
          // OR we can allow hybrid.
          // For now, if it's a controller key, we update state and return to prevent double firing native shortcuts if they overlap
          // If it's a controller key, we update state and return to prevent double firing native shortcuts if they overlap
          // unless it's a key that shouldn't conflict or we want both.
          // For safety, if mapped to controller, we consume it.
          return;
        }
      }

      // 1. GLOBAL: Player ID Input (Numpad)
      if (e.code.startsWith("Numpad") && e.code.length === 7) {
        const num = e.code.slice(6);
        setKeyboardBuffer(prev => prev + num);
        keyboardBufferRef.current += num;
        return;
      }
      if (e.code === "Enter" || e.code === "NumpadEnter") {
        const playerId = parseInt(keyboardBufferRef.current);
        if (!isNaN(playerId)) {
          const currentTeam = gameStateRef.current.currentTeam;
          const roster = currentTeam === "TEAM_A" ? rosterARef.current : rosterBRef.current;
          const player = roster.find(p => p.number === playerId);
          if (player) {
            setPlayerSelection(prev => ({ ...prev, currentBallHolder: player }));
            console.log(`Identified Player: #${playerId} (${player.name})`);
          } else {
            console.warn(`Player #${playerId} not found in ${currentTeam}`);
          }
        }
        setKeyboardBuffer("");
        keyboardBufferRef.current = "";
        return;
      }

      // 2. KEYBOARD SHORTCUTS (Available in both LIVE and POST-MATCH)
      // Only process these if NOT in Virtual Controller mode OR if keys don't conflict
      const team = gameStateRef.current.currentTeam;
      const source = "Keyboard";

      // NUMBER KEYS (1-4) - Core Events
      if (e.key === "1") {
        if (e.altKey) logEvent("pre_assist", team, source);
        else if (e.ctrlKey) logEvent("assist", team, source);
        else if (e.shiftKey) logEvent("key_pass", team, source);
        else logEvent("pass_end", team, source);
        return;
      } else if (e.key === "2") {
        if (e.shiftKey) logEvent("goal", team, source);
        else logEvent("shot_outcome", team, source);
        return;
      } else if (e.key === "3") {
        if (e.shiftKey) logEvent("dribble_fail", team, source);
        else logEvent("dribble_success", team, source);
        return;
      } else if (e.key === "4") {
        logEvent("duel_ground", team, source);
        return;
      } else if (e.key === "5") {
        logEvent("duel_aerial", team, source);
        return;
      }

      // TACTICAL PHASES (Q, W, E, M, L)
      else if (e.key.toLowerCase() === "q") {
        if (!options.useKeyboardAsController) { logEvent("phase_buildup_end", team, source); return; }
      }
      else if (e.key.toLowerCase() === "w") { logEvent("phase_consolidation", team, source); return; }
      else if (e.key.toLowerCase() === "e") {
        if (!options.useKeyboardAsController) { logEvent("phase_final_third", team, source); return; }
      }
      else if (e.key.toLowerCase() === "m") { logEvent("phase_midblock", team, source); return; }
      else if (e.key.toLowerCase() === "l") { logEvent("phase_lowblock", team, source); return; }

      // TRANSITIONS (Z)
      else if (e.key.toLowerCase() === "z") { logEvent("transition_end", team, source); return; }

      // PRESSING (P, R)
      else if (e.key.toLowerCase() === "p") {
        if (e.shiftKey) logEvent("pressing_fail", team, source);
        else logEvent("pressing_success", team, source);
        return;
      }
      else if (e.key.toLowerCase() === "r") { logEvent("pressing_resistance", team, source); return; }

      // OFF-BALL MOVEMENT (O, T, D)
      else if (e.key.toLowerCase() === "o") {
        if (!options.useKeyboardAsController) {
          if (e.altKey) logEvent("underlap", team, source);
          else if (e.shiftKey) logEvent("overlap", team, source);
          else logEvent("off_ball_run", team, source);
          return;
        }
      }
      else if (e.key.toLowerCase() === "t") { logEvent("third_man_run", team, source); return; }
      else if (e.key.toLowerCase() === "d") { logEvent("dummy_run", team, source); return; }

      // PERFORMANCE (C)
      else if (e.key.toLowerCase() === "c") { logEvent("chance_created", team, source); return; }

      // WORKFLOW (F, Enter, Backspace)
      else if (e.key.toLowerCase() === "f") { logEvent("timestamp_fix", team, source); return; }
      else if (e.key === "Enter" && !e.code.startsWith("Numpad")) {
        // Avoid conflict with numpad Enter for player ID
        logEvent("ai_accept", team, source);
        return;
      }
      else if (e.key === "Backspace") { logEvent("ai_reject", team, source); return; }

      // LIVE MODE Legacy / Extras
      if (options.analysisMode === 'LIVE' && !options.useKeyboardAsController) {
        if (e.code === "Space") logEvent("corner_start", team, "Keyboard");
        else if (e.code === "ArrowUp") logEvent("foul_committed", team, "Keyboard");
        else if (e.code === "ArrowDown") logEvent("offside", team, "Keyboard");
      }
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      if (options.useKeyboardAsController) {
        const buttonIndex = KEYBOARD_CONTROLLER_MAP[e.code];
        if (buttonIndex !== undefined) {
          e.preventDefault();
          virtualControllerState.current[buttonIndex] = false;
        }
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [logEvent, options.analysisMode, options.useKeyboardAsController]);


  useEffect(() => {
    const handleBlur = () => {
      console.group('[useGamepad] Window Focus Lost');
      console.info('Resetting button states and modifier refs...');
      buttonStatesRef.current = new Array(16).fill(false);
      modifierSourceRef.current = null;
      comboTriggeredRef.current = false;
      buttonPressTimestamps.current = {};
      console.groupEnd();
    };

    window.addEventListener('blur', handleBlur);
    return () => window.removeEventListener('blur', handleBlur);
  }, []);

  useEffect(() => {
    const checkGamepadConnection = () => {
      const gamepads = navigator.getGamepads();
      const connected = gamepads.some(gp => gp !== null);
      // Virtual controller implies "connected"
      setIsConnected(connected || !!options.useKeyboardAsController);
    };

    // Initial check
    checkGamepadConnection();

    const processInput = (mapping: GamepadButtonMapping, modifiers: { lb: boolean, rb: boolean }, durationMs?: number) => {
      const { currentTeam } = gameStateRef.current;
      // In Live Mode or generic Post-Match input, simple logging:
      logEvent(mapping.eventName, currentTeam, mapping.buttonLabel, false, null, undefined, { durationMs });
    };

    let animationFrameId: number;

    const pollGamepad = () => {
      const gamepads = navigator.getGamepads();
      const gamepad = Array.from(gamepads).find(gp => gp !== null);

      let currentlyPressed: number[] = [];
      let buttonPressed = (idx: number) => false;
      let currentAxes = [0, 0, 0, 0]; // Default axes

      // Merge Physical & Virtual Inputs
      if (gamepad) {
        // Physical gamepad exists
        const physicalButtonPressed = (idx: number) => {
          const btn = gamepad.buttons[idx];
          if (!btn) return false;
          // For triggers (6, 7), use threshold; for others use native pressed flag
          if (idx === 6 || idx === 7) return btn.value > 0.2;
          return btn.pressed;
        };

        buttonPressed = (idx: number) => {
          const physical = physicalButtonPressed(idx);
          const virtual = options.useKeyboardAsController ? virtualControllerState.current[idx] : false;
          return physical || virtual;
        };
        currentAxes = [...gamepad.axes];
        setButtons([...gamepad.buttons]); // Still show physical buttons if available
      } else if (options.useKeyboardAsController) {
        // Virtual Controller Only
        buttonPressed = (idx: number) => !!virtualControllerState.current[idx];
        setButtons(new Array(16).fill(null).map((_, i) => ({
          pressed: virtualControllerState.current[i] || false,
          value: virtualControllerState.current[i] ? 1 : 0,
          touched: virtualControllerState.current[i] || false,
        } as GamepadButton)));
      } else {
        // No input source, skip loop
        animationFrameId = requestAnimationFrame(pollGamepad);
        return;
      }

      setAxes(currentAxes);

      // --- THIRDS-BASED ZONE SELECTION (LT/RT + Right Stick) ---
      // Calculates zone 1-18 based on trigger state and stick direction
      const ltPressed = buttonPressed(6); // LT = Defense (Zones 1-6)
      const rtPressed = buttonPressed(7); // RT = Attack (Zones 13-18)

      // Determine active third
      let activeThird: PitchThird = 'MIDFIELD';
      let thirdOffset = 6; // Midfield zones start at 7 (offset 6)
      if (ltPressed && !rtPressed) {
        activeThird = 'DEFENSE';
        thirdOffset = 0; // Defense zones start at 1 (offset 0)
      } else if (rtPressed && !ltPressed) {
        activeThird = 'ATTACK';
        thirdOffset = 12; // Attack zones start at 13 (offset 12)
      }

      // Calculate subzone from Right Stick (axes[2], axes[3])
      // Grid: 2 rows (top/bottom) x 3 cols (left/center/right)
      const rx = currentAxes[2] || 0;
      const ry = currentAxes[3] || 0;
      const ZONE_STICK_THRESHOLD = 0.4;

      let previewZone: number | null = null;
      if (Math.abs(rx) > ZONE_STICK_THRESHOLD || Math.abs(ry) > ZONE_STICK_THRESHOLD) {
        // Determine column (1-3): Left, Center, Right
        let col = 2; // Center
        if (rx < -ZONE_STICK_THRESHOLD) col = 1; // Left
        else if (rx > ZONE_STICK_THRESHOLD) col = 3; // Right

        // Determine row (1-2): Top (away from goal), Bottom (near goal)
        // Negative Y = Up/Away, Positive Y = Down/Near
        let row = ry < 0 ? 1 : 2; // Row 1 = Top, Row 2 = Bottom

        // Calculate subzone (1-6 within this third)
        // Layout: Row 1 = [1,2,3], Row 2 = [4,5,6]
        const subzone = (row - 1) * 3 + col;
        previewZone = thirdOffset + subzone;
      }

      // Update thirdsZone state if changed
      if (thirdsZoneRef.current.activeThird !== activeThird ||
        thirdsZoneRef.current.previewZone !== previewZone) {
        setThirdsZone(prev => ({
          ...prev,
          activeThird,
          previewZone
        }));
      }

      // Calculate Currently Pressed
      for (let i = 0; i < 16; i++) { // Check standard 16 buttons
        if (buttonPressed(i)) currentlyPressed.push(i);
      }
      setPressedButtons(currentlyPressed);

      // *** INTERCEPT: Quick Player Selection Mode ***
      if (quickSelectorRef.current.isOpen) {
        const { selectedIndex, roster } = quickSelectorRef.current;
        const cols = 5;

        if (buttonPressed(15) && !buttonStatesRef.current[15]) { // Right
          setQuickSelectorState(prev => ({ ...prev, selectedIndex: Math.min(prev.selectedIndex + 1, prev.roster.length - 1) }));
        }
        if (buttonPressed(14) && !buttonStatesRef.current[14]) { // Left
          setQuickSelectorState(prev => ({ ...prev, selectedIndex: Math.max(prev.selectedIndex - 1, 0) }));
        }
        if (buttonPressed(13) && !buttonStatesRef.current[13]) { // Down
          setQuickSelectorState(prev => ({ ...prev, selectedIndex: Math.min(prev.selectedIndex + cols, prev.roster.length - 1) }));
        }
        if (buttonPressed(12) && !buttonStatesRef.current[12]) { // Up
          setQuickSelectorState(prev => ({ ...prev, selectedIndex: Math.max(prev.selectedIndex - cols, 0) }));
        }

        if (buttonPressed(0) && !buttonStatesRef.current[0]) { // A
          const selectedPlayer = roster[selectedIndex];
          if (pendingEventRef.current && selectedPlayer) {
            const finalEvent: LoggedEvent = {
              ...pendingEventRef.current as LoggedEvent,
              player: { id: selectedPlayer.id, name: selectedPlayer.name }
            };
            onEventLogged(finalEvent);
            console.log(`‚úÖ Logged ${finalEvent.eventName} for ${selectedPlayer.name}`);
          }
          setQuickSelectorState(prev => ({ ...prev, isOpen: false }));
          setPendingEvent(null);
          setIsPassing(false);
          if (onPlayPause) onPlayPause(true);
        }

        if (buttonPressed(1) && !buttonStatesRef.current[1]) { // B
          if (pendingEventRef.current) {
            const finalEvent: LoggedEvent = { ...pendingEventRef.current as LoggedEvent };
            onEventLogged(finalEvent);
          }
          setQuickSelectorState(prev => ({ ...prev, isOpen: false }));
          setPendingEvent(null);
          setIsPassing(false);
          if (onPlayPause) onPlayPause(true);
        }

        // Always update states before early exit
        for (let i = 0; i < 16; i++) {
          buttonStatesRef.current[i] = buttonPressed(i);
        }
        animationFrameId = requestAnimationFrame(pollGamepad);
        return;
      }

      // --- THIRDS-BASED ZONE CONFIRMATION (A Button) ---
      if (buttonPressed(0) && !buttonStatesRef.current[0]) {
        const pZone = thirdsZoneRef.current.previewZone;
        if (pZone !== null) {
          // Confirm the previewed zone
          setCurrentZone(pZone);
          zoneRef.current = pZone;
          setThirdsZone(prev => ({ ...prev, confirmedZone: pZone }));
          console.log(`üìç Zone Confirmed: ${pZone}`);
        }
      }

      // *** INTERCEPT: Zone Selection Mode (POST_MATCH only usually, but safety check) ***
      // In LIVE mode, zones might be automatic or different workflow.
      // But if Zone Selector IS open, we should control it.
      // However, OP requested D-Pad logic check missing live check?
      // "Lines 550-558 handled zone selector D-pad... should only apply in POST_MATCH".
      if (zoneSelectorRef.current.isOpen && options.analysisMode === 'POST_MATCH') {
        const { selectedZone } = zoneSelectorRef.current;
        const cols = 3; // 3x6 Grid

        // D-Pad or Stick Navigation
        if ((buttonPressed(15) && !buttonStatesRef.current[15])) { // Right
          if (selectedZone % cols !== 0) setZoneSelector(prev => ({ ...prev, selectedZone: prev.selectedZone + 1 }));
        }
        if ((buttonPressed(14) && !buttonStatesRef.current[14])) { // Left
          if (selectedZone % cols !== 1) setZoneSelector(prev => ({ ...prev, selectedZone: prev.selectedZone - 1 }));
        }
        if ((buttonPressed(13) && !buttonStatesRef.current[13])) { // Down
          if (selectedZone <= 15) setZoneSelector(prev => ({ ...prev, selectedZone: prev.selectedZone + cols }));
        }
        if ((buttonPressed(12) && !buttonStatesRef.current[12])) { // Up
          if (selectedZone > cols) setZoneSelector(prev => ({ ...prev, selectedZone: prev.selectedZone - cols }));
        }

        if (buttonPressed(0) && !buttonStatesRef.current[0]) { // A (Confirm)
          if (pendingEventRef.current) {
            logEvent(pendingEventRef.current.eventName!, pendingEventRef.current.team!, pendingEventRef.current.buttonLabel, false, null, undefined, { zone: selectedZone });
          }
          setZoneSelector({ isOpen: false, selectedZone: 1 });
          setPendingEvent(null);
          if (onPlayPause) onPlayPause(true);
        }

        if (buttonPressed(1) && !buttonStatesRef.current[1]) { // B (Cancel)
          setZoneSelector({ isOpen: false, selectedZone: 1 });
          setPendingEvent(null);
          if (onPlayPause) onPlayPause(true);
        }

        for (let i = 0; i < 16; i++) {
          buttonStatesRef.current[i] = buttonPressed(i);
        }
        animationFrameId = requestAnimationFrame(pollGamepad);
        return;
      }

      const now = Date.now();

      // --- 1. Quality Rating Management ---
      if (qualityTapRef.current) {
        const { startTime, count, eventId } = qualityTapRef.current;
        if (now - startTime > 2000) {
          qualityTapRef.current = null;
        } else if (buttonPressed(0) && !buttonStatesRef.current[0]) {
          const newCount = Math.min(count + 1, 5);
          qualityTapRef.current.count = newCount;
          console.log(`‚≠ê Quality Rated: ${newCount}/5 for Event ${eventId}`);
        }
      }

      // --- 2. Button Hold & Release Logic (Improved) ---
      const activeModifiers = {
        RT: buttonPressed(7),
        LT: buttonPressed(6),
        RB: buttonPressed(5),
        LB: buttonPressed(4),
        View: buttonPressed(8),
        Menu: buttonPressed(9),
        "D-Up": buttonPressed(12),
        "D-Down": buttonPressed(13),
        "D-Left": buttonPressed(14),
        "D-Right": buttonPressed(15)
      };

      // TRACK PRESS START for all buttons to support Hold events
      for (let i = 0; i < 16; i++) {
        if (buttonPressed(i) && !buttonStatesRef.current[i]) {
          buttonPressTimestamps.current[i] = now;
          // If it's a modifier, track that we've started a potential combo/standalone sequence
          if ([4, 5, 6, 7, 8, 9, 12, 13, 14, 15].includes(i)) {
            comboTriggeredRef.current = false;
            modifierSourceRef.current = i;
          }
        }
      }

      // CHECK FOR HOLD EVENTS (X, D-Pad Up, etc.)
      Object.entries(buttonHolds).forEach(([idx, eventName]) => {
        const i = parseInt(idx);
        if (buttonPressed(i) && buttonPressTimestamps.current[i]) {
          const duration = now - buttonPressTimestamps.current[i];
          if (duration >= HOLD_THRESHOLD && !buttonStatesRef.current[i]) { // Trigger once at threshold
            logEvent(eventName, gameStateRef.current.currentTeam, BUTTON_LABELS[i] || `B${i}`);
            // Mark as triggered so we don't fire tap event on release
            comboTriggeredRef.current = true;
          }
        }
      });

      Object.entries(dpadHolds).forEach(([idx, eventName]) => {
        const i = parseInt(idx);
        if (buttonPressed(i) && buttonPressTimestamps.current[i]) {
          const duration = now - buttonPressTimestamps.current[i];
          if (duration >= HOLD_THRESHOLD && !buttonStatesRef.current[i]) {
            logEvent(eventName, gameStateRef.current.currentTeam, BUTTON_LABELS[i] || `B${i}`);
            comboTriggeredRef.current = true;
          }
        }
      });

      // --- 3. Combo Logic ---
      let comboTriggeredInFrame = false;

      combos.forEach(combo => {
        if (activeModifiers[combo.modifier]) {
          if (buttonPressed(combo.button) && !buttonStatesRef.current[combo.button]) {
            processInput({
              index: combo.button,
              eventName: combo.eventName,
              eventDescription: combo.eventDescription,
              buttonLabel: combo.buttonLabel
            }, { lb: activeModifiers.LB, rb: activeModifiers.RB }, 0); // Combos are instantaneous triggers usually
            comboTriggeredInFrame = true;
            comboTriggeredRef.current = true; // Mark that a combo happened during this modifier's hold
          }
        }
      });

      // --- 4. Standalone & Modifier Release Logic (The Fix) ---
      // We only log standalone actions when the button is RELEASED, 
      // and only if no combo or hold was triggered during the press.
      for (let i = 0; i < 16; i++) {
        const released = !buttonPressed(i) && buttonStatesRef.current[i];
        if (released) {
          const pressDuration = now - (buttonPressTimestamps.current[i] || 0);

          // If it's a modifier button (RT, LT, RB, LB, View, Menu, D-Pad)
          if ([4, 5, 6, 7, 8, 9, 12, 13, 14, 15].includes(i)) {
            // LT (6) and RT (7) are MODIFIER-ONLY in TACTA - do not fire standalone events ever
            if (i === 6 || i === 7) {
              modifierSourceRef.current = null;
              delete buttonPressTimestamps.current[i];
              continue;
            }

            // For other modifiers (LB, RB, View), only fire if NOT part of a combo
            if (!comboTriggeredRef.current) {
              const mapping = mappings.find(m => m.index === i);
              if (mapping) {
                processInput(mapping, { lb: activeModifiers.LB, rb: activeModifiers.RB }, pressDuration);
              }
            }
            modifierSourceRef.current = null;
          }
          // If it's a regular button (A, B, X, Y, etc.) and not a hold/combo
          else if (!comboTriggeredRef.current || pressDuration < HOLD_THRESHOLD) {
            const mapping = mappings.find(m => m.index === i);
            if (mapping && !comboTriggeredInFrame) {
              // Ensure we don't fire standalone mapping if it's LT/RT by any chance
              if (mapping.eventName !== 'transition_def_start' && mapping.eventName !== 'transition_off_start') {
                processInput(mapping, { lb: activeModifiers.LB, rb: activeModifiers.RB }, pressDuration);
              }
            }
          }
          delete buttonPressTimestamps.current[i];
        }
      }

      // --- 5. Stick Navigation ---
      // ... (rest of stick logic)
      // Basic Virtual D-Pad for zones if using keyboard
      if (!activeModifiers.RT && !activeModifiers.LT) {
        // If using keyboard, use arrow keys (12,13,14,15) as "stick" for zones if held?
        // Currently loop handles digital 0/1. Stick logic requires axis.
        // We can skip stick logic for keyboard/virtual controller for now as they use D-Pad for pressing
        const lx = currentAxes[0];
        const ly = currentAxes[1];
        const STICK_THRESHOLD = 0.5;

        if (!gameStateRef.current.lastStickMove || (now - gameStateRef.current.lastStickMove > 200)) {
          let newZone = zoneRef.current;
          let moved = false;

          // ROW-MAJOR Navigation Logic (To match ZoneGrid.tsx)
          // Grid is 3 Columns x 6 Rows
          // [1, 2, 3]
          // [4, 5, 6]
          // ...
          // [16,17,18]

          if (ly < -STICK_THRESHOLD) {
            // Down (Physically down on stick) -> Increase Row ID (+3)
            if (newZone <= 15) { newZone += 3; moved = true; }
          }
          else if (ly > STICK_THRESHOLD) {
            // Up (Physically up on stick) -> Decrease Row ID (-3)
            if (newZone > 3) { newZone -= 3; moved = true; }
          }
          else if (lx < -STICK_THRESHOLD) {
            // Left - don't move if at left edge (zone % 3 === 1)
            // 1, 4, 7... are left edge. 1%3==1, 4%3==1.
            if (newZone > 1 && newZone % 3 !== 1) {
              newZone -= 1;
              moved = true;
            }
          }
          else if (lx > STICK_THRESHOLD) {
            // Right - don't move if at right edge (zone % 3 === 0)
            if (newZone < 18 && newZone % 3 !== 0) {
              newZone += 1;
              moved = true;
            }
          }

          if (moved) {
            setCurrentZone(newZone);
            gameStateRef.current.lastStickMove = now;
          }
        }
      }

      // --- 6. Team Toggle (Fallback) ---
      if (!buttonPressed(5) && buttonStatesRef.current[5] && !comboTriggeredRef.current) {
        if (!mappings.find(m => m.index === 5)) {
          gameStateRef.current.currentTeam = gameStateRef.current.currentTeam === 'TEAM_A' ? 'TEAM_B' : 'TEAM_A';
          console.log(`‚öΩ Team Toggled: ${gameStateRef.current.currentTeam}`);
        }
      }

      // Update button states for next frame
      for (let i = 0; i < 16; i++) {
        buttonStatesRef.current[i] = buttonPressed(i);
      }
    };

    const workerCode = `let intervalId; self.onmessage = function(e) { if (e.data === 'start') { intervalId = setInterval(() => { self.postMessage('tick'); }, 16); } else if (e.data === 'stop') { clearInterval(intervalId); } };`;
    const blob = new Blob([workerCode], { type: "application/javascript" });
    const worker = new Worker(URL.createObjectURL(blob));
    worker.onmessage = (e) => { if (e.data === 'tick') pollGamepad(); };

    window.addEventListener("gamepadconnected", checkGamepadConnection);
    window.addEventListener("gamepaddisconnected", checkGamepadConnection);
    checkGamepadConnection();
    worker.postMessage('start');

    return () => {
      window.removeEventListener("gamepadconnected", checkGamepadConnection);
      window.removeEventListener("gamepaddisconnected", checkGamepadConnection);
      worker.postMessage('stop');
      worker.terminate();
    };
  }, [mappings, onEventLogged, options.useKeyboardAsController, onPlayPause]);

  const manualCheck = useCallback(() => {
    const gamepads = navigator.getGamepads();
    const connected = gamepads.some(gp => gp !== null);
    setIsConnected(connected);
    return connected;
  }, []);

  return {
    isConnected,
    manualCheck,
    pressedButtons,
    axes,
    buttons,
    mappings,
    updateMapping,
    resetMappings,
    playerSelection,
    currentZone,
    setCurrentZone,
    keyboardBuffer,
    quickSelectorState,
    zoneSelector,
    setZoneSelector,
    thirdsZone, // NEW: Thirds-based zone selection state
    setThirdsZone
  };
};
</file>

<file path="src/hooks/useIPTVFavorites.ts">
import { useState, useCallback, useEffect } from "react";
import type { ChannelStream } from "@/types/xtream";

const FAVORITES_KEY = "react-iptv-favorites";

export function useIPTVFavorites() {
    const [favorites, setFavorites] = useState<number[]>([]);

    useEffect(() => {
        try {
            const stored = localStorage.getItem(FAVORITES_KEY);
            if (stored) {
                setFavorites(JSON.parse(stored));
            }
        } catch {
            // Ignore parse errors
        }
    }, []);

    const saveFavorites = useCallback((newFavorites: number[]) => {
        setFavorites(newFavorites);
        try {
            localStorage.setItem(FAVORITES_KEY, JSON.stringify(newFavorites));
        } catch {
            // Ignore storage errors
        }
    }, []);

    const isChannelFavorite = useCallback(
        (channelId: number) => favorites.includes(channelId),
        [favorites]
    );

    const toggleChannelFavorite = useCallback(
        (channelId: number) => {
            const newFavorites = favorites.includes(channelId)
                ? favorites.filter((id) => id !== channelId)
                : [...favorites, channelId];
            saveFavorites(newFavorites);
        },
        [favorites, saveFavorites]
    );

    const getFavoriteChannels = useCallback(
        (streams: ChannelStream[]) =>
            streams.filter((stream) => favorites.includes(stream.id)),
        [favorites]
    );

    return {
        favorites,
        isChannelFavorite,
        toggleChannelFavorite,
        getFavoriteChannels,
    };
}
</file>

<file path="src/hooks/useMatchTimer.ts">
// src/hooks/useMatchTimer.ts - Match timer logic
import { useEffect, useRef } from 'react';
import { useMatchContext } from '@/contexts/MatchContext';

export function useMatchTimer() {
    const { matchTime, setMatchTime, isMatchActive, useVideoMode, videoTime } = useMatchContext();
    const matchTimeRef = useRef(0);
    const videoTimeRef = useRef(0);

    // Match timer interval
    useEffect(() => {
        let interval: NodeJS.Timeout;
        if (isMatchActive && !useVideoMode) {
            interval = setInterval(() => {
                setMatchTime(prev => {
                    const newTime = prev + 1;
                    matchTimeRef.current = newTime;
                    return newTime;
                });
            }, 1000);
        }
        return () => clearInterval(interval);
    }, [isMatchActive, useVideoMode, setMatchTime]);

    // Sync match time with video time
    useEffect(() => {
        if (useVideoMode) {
            videoTimeRef.current = videoTime;
            const timeInSeconds = Math.floor(videoTime);
            if (matchTimeRef.current !== timeInSeconds) {
                setMatchTime(timeInSeconds);
                matchTimeRef.current = timeInSeconds;
            }
        }
    }, [videoTime, useVideoMode, setMatchTime]);

    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };

    return { matchTimeRef, videoTimeRef, formatTime };
}
</file>

<file path="src/hooks/useMediaCoords.ts">
import { useCallback } from 'react';

export const useMediaCoords = (naturalWidth: number, naturalHeight: number) => {
    const getCoordinates = useCallback((e: React.MouseEvent, containerRef: React.RefObject<HTMLDivElement>) => {
        if (!containerRef.current || naturalWidth === 0) return { x: 0, y: 0 };

        const rect = containerRef.current.getBoundingClientRect();
        const containerAspect = rect.width / rect.height;
        const mediaAspect = naturalWidth / naturalHeight;

        let renderWidth: number, renderHeight: number, offsetX: number, offsetY: number;

        if (mediaAspect > containerAspect) {
            // Letterboxed (Bars top/bottom)
            renderWidth = rect.width;
            renderHeight = rect.width / mediaAspect;
            offsetX = 0;
            offsetY = (rect.height - renderHeight) / 2;
        } else {
            // Pillarboxed (Bars left/right)
            renderHeight = rect.height;
            renderWidth = rect.height * mediaAspect;
            offsetX = (rect.width - renderWidth) / 2;
            offsetY = 0;
        }

        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        // Convert click to 0-1 normalized range within the actual media area
        const normX = (clickX - offsetX) / renderWidth;
        const normY = (clickY - offsetY) / renderHeight;

        // Convert to natural video pixels
        return {
            x: normX * naturalWidth,
            y: normY * naturalHeight,
            isOutOfBounds: normX < 0 || normX > 1 || normY < 0 || normY > 1
        };
    }, [naturalWidth, naturalHeight]);

    return { getCoordinates };
};
</file>

<file path="src/hooks/usePictureInPicture.ts">
// src/hooks/usePictureInPicture.ts - Picture-in-Picture window management
import { useState } from 'react';
import { useToast } from '@/hooks/use-toast';

export function usePictureInPicture() {
    const [pipWindow, setPipWindow] = useState<Window | null>(null);
    const { toast } = useToast();

    const setupWindow = (win: Window) => {
        // Copy all stylesheets to PiP window
        [...document.styleSheets].forEach(styleSheet => {
            try {
                if (styleSheet.href) {
                    const link = win.document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = styleSheet.href;
                    win.document.head.appendChild(link);
                } else {
                    const style = win.document.createElement('style');
                    [...styleSheet.cssRules].forEach(rule => {
                        style.appendChild(win.document.createTextNode(rule.cssText));
                    });
                    win.document.head.appendChild(style);
                }
            } catch (e) {
                console.error('Error copying style:', e);
            }
        });

        // Handle window close
        win.addEventListener('pagehide', () => setPipWindow(null));
        win.addEventListener('unload', () => setPipWindow(null));

        setPipWindow(win);
    };

    const togglePiP = async () => {
        if (pipWindow) {
            pipWindow.close();
            setPipWindow(null);
            return;
        }

        // Try Document Picture-in-Picture API first
        if ('documentPictureInPicture' in window) {
            try {
                const pip = await (window as any).documentPictureInPicture.requestWindow({
                    width: 1000,
                    height: 800,
                });
                setupWindow(pip);
                return;
            } catch (err) {
                console.warn('Document PiP failed, falling back to popup:', err);
            }
        }

        // Fallback to popup window
        try {
            const popup = window.open('', 'SoccerLoggerPopup', 'width=1000,height=800,popup=yes');
            if (popup) {
                if (!popup.document.body) {
                    popup.document.write('<body></body>');
                }
                popup.document.title = 'Soccer Event Logger (Overlay)';
                setupWindow(popup);
            } else {
                toast({
                    title: 'Popup Blocked',
                    description: 'Please allow popups for this site to use the overlay.',
                    variant: 'destructive',
                });
            }
        } catch (err) {
            console.error('Failed to open popup:', err);
            toast({
                title: 'Error',
                description: 'Failed to open Pop-out window.',
                variant: 'destructive',
            });
        }
    };

    return { pipWindow, togglePiP };
}
</file>

<file path="src/hooks/useSocketEvents.ts">
// src/hooks/useSocketEvents.ts - Socket event listeners
import { useEffect, useRef } from 'react';
import { Socket } from 'socket.io-client';
import { useToast } from '@/hooks/use-toast';
import { useMatchContext } from '@/contexts/MatchContext';
import { LoggedEvent } from '@/hooks/useGamepad';
import { TeamRoster } from '@/types/player';

export function useSocketEvents(socket: Socket) {
    const { toast } = useToast();
    const {
        setEvents,
        setMatchTime,
        setIsMatchActive,
        setSelectedTeam,
        setTeams,
        setRemoteVideoUrl,
        setUseVideoMode,
        setVideoMode,
        setIsVideoPlaying,
        setVideoTime,
        setSeekTime,
        setIsSessionStarted,
        setStreamUrl,
    } = useMatchContext();

    const matchTimeRef = useRef(0);

    useEffect(() => {
        function onSyncState(state: any) {
            console.log('Syncing state:', state);

            if (state.events && state.events.length > 0) {
                setEvents(state.events);
            }

            if (state.matchTime > matchTimeRef.current) {
                setMatchTime(state.matchTime);
                matchTimeRef.current = state.matchTime;
            }

            if (state.isMatchActive !== undefined) {
                setIsMatchActive(state.isMatchActive);
            }

            if (state.selectedTeam) {
                setSelectedTeam(state.selectedTeam);
            }

            if (state.teams && state.teams.length > 0) {
                try {
                    const newTeams = new Map<string, TeamRoster>();
                    if (Array.isArray(state.teams)) {
                        state.teams.forEach((t: any) => {
                            if (Array.isArray(t) && t.length === 2) {
                                newTeams.set(t[0], t[1]);
                            }
                        });
                    }
                    if (newTeams.size > 0) setTeams(newTeams);
                } catch (e) {
                    console.error('Error syncing teams:', e);
                }
            }

            if (state.streamUrl) {
                setStreamUrl(state.streamUrl);
                setVideoMode('live');
                setUseVideoMode(true);
            }

            if (state.videoMode) {
                setVideoMode(state.videoMode);
            }

            if (state.useVideoMode !== undefined) {
                setUseVideoMode(state.useVideoMode);
            }

            if (state.isSessionStarted !== undefined) {
                setIsSessionStarted(state.isSessionStarted);
            }

            if (state.videoState) {
                if (state.videoState.videoUrl) {
                    setRemoteVideoUrl(state.videoState.videoUrl);
                    // If we have a video URL, ensure we are in the right mode
                    if (state.useVideoMode) {
                        setVideoMode('upload');
                        setUseVideoMode(true);
                    }
                }
                if (state.videoState.currentTime !== undefined) {
                    setVideoTime(state.videoState.currentTime);
                    setSeekTime(state.videoState.currentTime); // Force seek to sync
                }
                if (state.videoState.isPlaying !== undefined) {
                    setIsVideoPlaying(state.videoState.isPlaying);
                }
            }
        }

        function onSyncTeams(teamsData: any[]) {
            console.log('Received synced teams:', teamsData);
            try {
                const newTeams = new Map<string, TeamRoster>();
                if (Array.isArray(teamsData)) {
                    teamsData.forEach((t: any) => {
                        if (Array.isArray(t) && t.length === 2) {
                            newTeams.set(t[0], t[1]);
                        }
                    });
                }
                if (newTeams.size > 0) setTeams(newTeams);
                toast({
                    title: 'Teams Synced',
                    description: 'Received team data from broadcaster.'
                });
            } catch (e) {
                console.error('Error handling sync-teams:', e);
            }
        }

        function onNewEvent(event: LoggedEvent) {
            console.log('Received remote event:', event);
            setEvents(prev => [...prev, event]);
        }

        function onSyncTimer(data: { matchTime: number; isMatchActive: boolean }) {
            setMatchTime(data.matchTime);
            matchTimeRef.current = data.matchTime;
            setIsMatchActive(data.isMatchActive);
        }

        function onSelectTeam(teamId: string) {
            console.log('Broadcaster switched team to:', teamId);
            setSelectedTeam(teamId);
        }

        function onUndoEvent(eventId: number) {
            console.log('Received undo event:', eventId);
            setEvents(prev => prev.filter(e => e.id !== eventId));
            toast({
                title: 'Event Annulled',
                description: `Event #${eventId} was removed by broadcaster`,
            });
        }

        function onUpdateEvent(updatedEvent: LoggedEvent) {
            console.log('Received update event:', updatedEvent);
            setEvents(prev => prev.map(e => (e.id === updatedEvent.id ? updatedEvent : e)));
        }

        // Video sync handlers
        function onVideoLoaded(url: string) {
            console.log('Broadcaster loaded video:', url);
            setRemoteVideoUrl(url);
            setUseVideoMode(true);
            setVideoMode('upload');
        }

        function onVideoPlay(time: number) {
            console.log('Broadcaster played at:', time);
            setIsVideoPlaying(true);
            setVideoTime(time);
        }

        function onVideoPause(time: number) {
            console.log('Broadcaster paused at:', time);
            setIsVideoPlaying(false);
            setVideoTime(time);
        }

        function onVideoSeek(time: number) {
            console.log('Broadcaster seeked to:', time);
            setSeekTime(time);
        }

        function onSessionStarted() {
            console.log('üöÄ Session started by admin');
            setIsSessionStarted(true);
            toast({
                title: 'Session Started',
                description: 'The analyst has initialized the collaboration session.',
            });
        }

        function onVideoModeChange(data: { mode: 'upload' | 'live', useVideoMode: boolean }) {
            console.log('üìπ Broadcaster changed video mode:', data);
            setVideoMode(data.mode);
            setUseVideoMode(data.useVideoMode);
            toast({
                title: 'View Synchronized',
                description: `Switched to ${data.mode === 'live' ? 'Live/IPTV' : 'Video Upload'} view.`,
            });
        }

        if (!socket) return;

        // Register listeners
        socket.on('sync-state', onSyncState);
        socket.on('new-event', onNewEvent);
        socket.on('sync-timer', onSyncTimer);
        socket.on('select-team', onSelectTeam);
        socket.on('sync-teams', onSyncTeams);
        socket.on('undo-event', onUndoEvent);
        socket.on('update-event', onUpdateEvent);
        socket.on('video-loaded', onVideoLoaded);
        socket.on('video-play', onVideoPlay);
        socket.on('video-pause', onVideoPause);
        socket.on('video-seek', onVideoSeek);
        socket.on('session-started', onSessionStarted);
        socket.on('video-mode-change', onVideoModeChange);

        // Cleanup
        return () => {
            socket.off('sync-state', onSyncState);
            socket.off('new-event', onNewEvent);
            socket.off('sync-timer', onSyncTimer);
            socket.off('select-team', onSelectTeam);
            socket.off('sync-teams', onSyncTeams);
            socket.off('undo-event', onUndoEvent);
            socket.off('update-event', onUpdateEvent);
            socket.off('video-loaded', onVideoLoaded);
            socket.off('video-play', onVideoPlay);
            socket.off('video-pause', onVideoPause);
            socket.off('video-seek', onVideoSeek);
            socket.off('session-started', onSessionStarted);
            socket.off('video-mode-change', onVideoModeChange);
        };
    }, [socket, setEvents, setMatchTime, setIsMatchActive, setSelectedTeam, setTeams, toast, setRemoteVideoUrl, setUseVideoMode, setVideoMode, setIsVideoPlaying, setVideoTime, setSeekTime, setIsSessionStarted]);

    return matchTimeRef;
}
</file>

<file path="src/hooks/useVideoControls.ts">
import { useEffect, useState, useRef } from 'react';

interface UseVideoControlsProps {
    videoRef: React.RefObject<HTMLVideoElement>;
    externalIsPlaying?: boolean;
    onPlayPause?: (isPlaying: boolean) => void;
    onTimeUpdate: (currentTime: number) => void;
}

interface UseVideoControlsReturn {
    isPlaying: boolean;
    currentTime: number;
    duration: number;
    volume: number;
    isMuted: boolean;
    playbackRate: number;
    togglePlay: () => void;
    handleSeek: (e: React.ChangeEvent<HTMLInputElement>) => void;
    handleVolumeChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    toggleMute: () => void;
    changePlaybackRate: () => void;
    skipTime: (seconds: number) => void;
    formatTime: (seconds: number) => string;
}

export const useVideoControls = ({
    videoRef,
    externalIsPlaying,
    onPlayPause,
    onTimeUpdate
}: UseVideoControlsProps): UseVideoControlsReturn => {
    const [localIsPlaying, setLocalIsPlaying] = useState(false);
    const [currentTime, setCurrentTime] = useState(0);
    const [duration, setDuration] = useState(0);
    const [volume, setVolume] = useState(1);
    const [isMuted, setIsMuted] = useState(false);
    const [playbackRate, setPlaybackRate] = useState(1);

    const isPlaying = externalIsPlaying !== undefined ? externalIsPlaying : localIsPlaying;

    // Video event handlers
    useEffect(() => {
        const video = videoRef.current;
        if (!video) return;

        const handleTimeUpdate = () => {
            setCurrentTime(video.currentTime);
            onTimeUpdate(video.currentTime);
        };

        const handleLoadedMetadata = () => {
            setDuration(video.duration);
        };

        const handlePlay = () => {
            if (onPlayPause) onPlayPause(true);
            else setLocalIsPlaying(true);
        };

        const handlePause = () => {
            if (onPlayPause) onPlayPause(false);
            else setLocalIsPlaying(false);
        };

        const handleEnded = () => {
            if (onPlayPause) onPlayPause(false);
            else setLocalIsPlaying(false);
        };

        video.addEventListener('timeupdate', handleTimeUpdate);
        video.addEventListener('loadedmetadata', handleLoadedMetadata);
        video.addEventListener('ended', handleEnded);
        video.addEventListener('play', handlePlay);
        video.addEventListener('pause', handlePause);

        return () => {
            video.removeEventListener('timeupdate', handleTimeUpdate);
            video.removeEventListener('loadedmetadata', handleLoadedMetadata);
            video.removeEventListener('ended', handleEnded);
            video.removeEventListener('play', handlePlay);
            video.removeEventListener('pause', handlePause);
        };
    }, [onTimeUpdate, onPlayPause, videoRef]);

    // Sync external play state
    useEffect(() => {
        const video = videoRef.current;
        if (!video) return;

        if (isPlaying && video.paused) {
            video.play().catch(e => console.error("Play failed:", e));
        } else if (!isPlaying && !video.paused) {
            video.pause();
        }
    }, [isPlaying, videoRef]);

    const togglePlay = () => {
        const video = videoRef.current;
        if (!video) return;

        const newState = !isPlaying;
        if (onPlayPause) {
            onPlayPause(newState);
        } else {
            setLocalIsPlaying(newState);
        }

        if (newState) {
            video.play();
        } else {
            video.pause();
        }
    };

    const handleSeek = (e: React.ChangeEvent<HTMLInputElement>) => {
        const video = videoRef.current;
        if (!video) return;

        const time = parseFloat(e.target.value);
        video.currentTime = time;
        setCurrentTime(time);
    };

    const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const video = videoRef.current;
        if (!video) return;

        const vol = parseFloat(e.target.value);
        video.volume = vol;
        setVolume(vol);
        setIsMuted(vol === 0);
    };

    const toggleMute = () => {
        const video = videoRef.current;
        if (!video) return;

        video.muted = !isMuted;
        setIsMuted(!isMuted);
    };

    const changePlaybackRate = () => {
        const video = videoRef.current;
        if (!video) return;

        const rates = [0.5, 0.75, 1, 1.25, 1.5, 2];
        const currentIndex = rates.indexOf(playbackRate);
        const nextRate = rates[(currentIndex + 1) % rates.length];
        video.playbackRate = nextRate;
        setPlaybackRate(nextRate);
    };

    const skipTime = (seconds: number) => {
        const video = videoRef.current;
        if (!video) return;

        video.currentTime = Math.max(0, Math.min(duration, currentTime + seconds));
    };

    const formatTime = (seconds: number) => {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        if (hrs > 0) {
            return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    return {
        isPlaying,
        currentTime,
        duration,
        volume,
        isMuted,
        playbackRate,
        togglePlay,
        handleSeek,
        handleVolumeChange,
        toggleMute,
        changePlaybackRate,
        skipTime,
        formatTime
    };
};
</file>

<file path="src/hooks/useVoiceRecognition.ts">
import { useState, useEffect, useCallback, useRef } from 'react';

// Add type definitions for Web Speech API
interface IWindow extends Window {
    webkitSpeechRecognition: any;
    SpeechRecognition: any;
}

interface UseVoiceRecognitionProps {
    onResult: (transcript: string) => void;
    onError?: (error: string) => void;
    language?: 'en' | 'fr' | 'ar';
}

export const useVoiceRecognition = ({ onResult, onError, language = 'en' }: UseVoiceRecognitionProps) => {
    const [isListening, setIsListening] = useState(false);
    const [recognition, setRecognition] = useState<any>(null);
    const [availableDevices, setAvailableDevices] = useState<MediaDeviceInfo[]>([]);
    const isListeningRef = useRef(false);
    const onResultRef = useRef(onResult);
    const onErrorRef = useRef(onError);

    // Update refs
    useEffect(() => {
        onResultRef.current = onResult;
        onErrorRef.current = onError;
    }, [onResult, onError]);

    useEffect(() => {
        isListeningRef.current = isListening;
    }, [isListening]);

    // Get available audio input devices
    useEffect(() => {
        const getDevices = async () => {
            try {
                // Check if mediaDevices is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    console.warn("Media devices not supported (insecure context?)");
                    return;
                }

                // Request permission first to ensure we can list labels
                await navigator.mediaDevices.getUserMedia({ audio: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                setAvailableDevices(audioInputs);
            } catch (error) {
                console.error("Error getting audio devices:", error);
                if (onErrorRef.current) {
                    onErrorRef.current("Microphone permission denied or no device found.");
                }
            }
        };
        getDevices();
    }, []);

    useEffect(() => {
        const { webkitSpeechRecognition, SpeechRecognition } = window as unknown as IWindow;
        if (webkitSpeechRecognition || SpeechRecognition) {
            const SpeechRecognitionConstructor = SpeechRecognition || webkitSpeechRecognition;
            const recognitionInstance = new SpeechRecognitionConstructor();

            recognitionInstance.continuous = true;
            recognitionInstance.interimResults = false;

            // Set language based on parameter
            const langCode = language === 'fr' ? 'fr-FR' : language === 'ar' ? 'ar-SA' : 'en-US';
            recognitionInstance.lang = langCode;

            // Add Grammar List (if supported)
            const SpeechGrammarList = (window as any).SpeechGrammarList || (window as any).webkitSpeechGrammarList;
            if (SpeechGrammarList) {
                const speechRecognitionList = new SpeechGrammarList();

                let grammarString = '';
                if (language === 'fr') {
                    grammarString = '#JSGF V1.0; grammar commands; public <command> = passe | tir | but | faute | un | deux | trois | quatre | cinq | six | sept | huit | neuf | dix;';
                } else if (language === 'ar') {
                    // Arabic grammar might be tricky with encoding, but let's try standard transliteration or Arabic script if supported. 
                    // Browsers often handle UTF-8. Let's use both for safety.
                    grammarString = '#JSGF V1.0; grammar commands; public <command> = tamrir | tasdid | hadaf | khata | wahid | ithnan | thalatha | arbaa | khamsa | sitta | sabaa | thamaniya | tisaa | ashara;';
                } else {
                    grammarString = '#JSGF V1.0; grammar commands; public <command> = pass | shoot | goal | foul | one | two | three | four | five | six | seven | eight | nine | ten;';
                }

                speechRecognitionList.addFromString(grammarString, 1);
                recognitionInstance.grammars = speechRecognitionList;
            }

            recognitionInstance.onresult = (event: any) => {
                const lastResultIndex = event.results.length - 1;
                const transcript = event.results[lastResultIndex][0].transcript;
                // Use ref to call the latest callback
                if (onResultRef.current) {
                    onResultRef.current(transcript);
                }
            };

            recognitionInstance.onend = () => {
                // Only turn off listening if we aren't supposed to be listening anymore
                if (!isListeningRef.current) {
                    setIsListening(false);
                } else {
                    // Auto-restart if we were supposed to be listening
                    // Add a small delay to prevent rapid-fire restarts
                    setTimeout(() => {
                        if (isListeningRef.current) {
                            try {
                                recognitionInstance.start();
                                console.log("Voice recognition auto-restarted");
                            } catch (e) {
                                console.log("Voice recognition restart failed (already started?)", e);
                            }
                        }
                    }, 100);
                }
            };

            recognitionInstance.onerror = (event: any) => {
                // Ignore "no-speech" errors as they're expected when user isn't speaking
                if (event.error === 'no-speech') {
                    return;
                }

                // Suppress network errors and auto-retry (common with Web Speech API)
                if (event.error === 'network') {
                    if (onErrorRef.current) onErrorRef.current("Network error: Check connection.");
                    return;
                }

                // Suppress "aborted" errors (happens when user stops listening)
                if (event.error === 'aborted') {
                    return;
                }

                // For other errors, log and stop
                console.error('Speech recognition error:', event.error);
                if (onErrorRef.current) {
                    onErrorRef.current(`Speech Error: ${event.error}`);
                }
                setIsListening(false);
            };

            setRecognition(recognitionInstance);

            // If we were already listening, restart with new language
            if (isListeningRef.current) {
                recognitionInstance.start();
            }

            return () => {
                recognitionInstance.abort();
                setRecognition(null);
            };
        }
    }, [language]);

    const startListening = useCallback(() => {
        if (recognition && !isListening) {
            try {
                recognition.start();
                setIsListening(true);
            } catch (error) {
                console.error("Failed to start recognition:", error);
            }
        }
    }, [recognition, isListening]);

    const stopListening = useCallback(() => {
        if (recognition && isListening) {
            recognition.stop();
            setIsListening(false);
        }
    }, [recognition, isListening]);

    const toggleListening = useCallback(() => {
        if (isListening) {
            stopListening();
        } else {
            startListening();
        }
    }, [isListening, startListening, stopListening]);

    return {
        isListening,
        startListening,
        stopListening,
        toggleListening,
        isSupported: !!recognition,
        availableDevices
    };
};
</file>

<file path="src/hooks/useVoiceRoom.ts">
import { useState, useEffect, useRef, useCallback } from 'react';
import { Socket } from 'socket.io-client';

interface PeerConnection {
    id: string; // Socket ID of the peer
    pc: RTCPeerConnection;
}

interface VoicePeer {
    id: string;
    name: string;
    role: string;
}

export const useVoiceRoom = (socket: Socket | null, userRole: string | undefined) => {
    const [isInRoom, setIsInRoom] = useState(false);
    const [peers, setPeers] = useState<VoicePeer[]>([]); // List of connected peers
    const [localStream, setLocalStream] = useState<MediaStream | null>(null);
    const [isMuted, setIsMuted] = useState(false);

    const peerConnections = useRef<Map<string, RTCPeerConnection>>(new Map());
    const localStreamRef = useRef<MediaStream | null>(null);
    const audioElementsRef = useRef<Map<string, HTMLAudioElement>>(new Map());

    // Helper: Create a peer connection
    const createPeerConnection = (targetId: string, stream: MediaStream): RTCPeerConnection => {
        const pc = new RTCPeerConnection({
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });

        // Add local tracks
        stream.getTracks().forEach(track => {
            pc.addTrack(track, stream);
        });

        // Handle ICE candidates
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                socket?.emit('voice-signal', {
                    to: targetId,
                    signal: { type: 'candidate', candidate: event.candidate }
                });
            }
        };

        // Handle incoming stream (Remote Audio)
        pc.ontrack = (event) => {
            console.log(`üîä Received audio track from ${targetId}`);

            // Avoid creating duplicate audio elements for same peer
            if (audioElementsRef.current.has(targetId)) return;

            const audio = new Audio();
            audio.srcObject = event.streams[0];
            audio.autoplay = true;
            audio.volume = 1.0;
            // audio.muted = false; // By default false, but good to be explicit

            // Store ref for cleanup
            audioElementsRef.current.set(targetId, audio);
        };

        return pc;
    };

    const joinVoiceRoom = async () => {
        if (!socket) return;
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            console.error("Media Devices API not available (requires HTTPS or localhost)");
            alert("Microphone access is not supported in this environment (HTTPS required).");
            return;
        }

        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 48000,
                    channelCount: 1
                }
            });
            setLocalStream(stream);
            localStreamRef.current = stream;
            setIsInRoom(true);

            socket.emit('join-voice-room');
        } catch (err) {
            console.error("Failed to access microphone:", err);
            alert("Could not access microphone. Please allow permissions.");
        }
    };

    const leaveVoiceRoom = () => {
        if (!socket) return;

        // Stop local stream
        if (localStreamRef.current) {
            localStreamRef.current.getTracks().forEach(track => track.stop());
            localStreamRef.current = null;
            setLocalStream(null);
        }

        // Cleanup Audio Elements
        audioElementsRef.current.forEach(audio => {
            audio.pause();
            audio.srcObject = null;
        });
        audioElementsRef.current.clear();

        // Close all peer connections
        peerConnections.current.forEach(pc => pc.close());
        peerConnections.current.clear();
        setPeers([]);
        setIsInRoom(false);

        socket.emit('leave-voice-room');
    };

    const toggleMute = () => {
        if (localStreamRef.current) {
            const audioTrack = localStreamRef.current.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                setIsMuted(!audioTrack.enabled);
            }
        }
    };

    // Socket Event Handlers
    useEffect(() => {
        if (!socket) return;

        // 1. Existing Users List (When WE join)
        const handleExistingUsers = async (users: VoicePeer[]) => {
            console.log("üë• Existing users in voice room:", users);
            setPeers(users);

            // Initiate calls to all existing users
            for (const user of users) {
                if (!localStreamRef.current) break;

                const pc = createPeerConnection(user.id, localStreamRef.current);
                peerConnections.current.set(user.id, pc);

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                socket.emit('voice-signal', {
                    to: user.id,
                    signal: { type: 'offer', sdp: pc.localDescription } // socket.io might need JSON primitive, but usually works with objects
                });
            }
        };

        // 2. New User Joined (They will call US)
        const handleUserJoined = (user: VoicePeer) => {
            console.log(`üë§ User joined voice room: ${user.name} (${user.id})`);
            setPeers(prev => [...prev, user]);
        };

        // 3. User Left
        const handleUserLeft = (userId: string) => {
            console.log(`üëã User left voice room: ${userId}`);
            setPeers(prev => prev.filter(p => p.id !== userId));

            // Cleanup Audio
            if (audioElementsRef.current.has(userId)) {
                const audio = audioElementsRef.current.get(userId);
                audio?.pause();
                audioElementsRef.current.delete(userId);
            }

            const pc = peerConnections.current.get(userId);
            if (pc) {
                pc.close();
                peerConnections.current.delete(userId);
            }
        };

        // 4. Signaling (Offer/Answer/Candidate)
        const handleSignal = async (data: { from: string, signal: any }) => {
            const { from, signal } = data;

            // Allow receiving signals even if we haven't officially "joined" yet? 
            // In mesh, yes, we should be ready if we are in state to accept.
            // But realistically we only care if we are isInRoom. 
            // However, the 'join-voice-room' event triggers the flow, so we should be initialized.
            if (!localStreamRef.current) return;

            let pc = peerConnections.current.get(from);

            if (!pc) {
                // If we receive an offer from someone we don't know (e.g., they just joined and we are existing)
                if (signal.type === 'offer') {
                    pc = createPeerConnection(from, localStreamRef.current);
                    peerConnections.current.set(from, pc);
                } else {
                    console.warn("Received signal for unknown peer:", from);
                    return;
                }
            }

            try {
                if (signal.type === 'offer') {
                    await pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    socket.emit('voice-signal', {
                        to: from,
                        signal: { type: 'answer', sdp: pc.localDescription }
                    });
                } else if (signal.type === 'answer') {
                    await pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
                } else if (signal.type === 'candidate') {
                    await pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
                }
            } catch (err) {
                console.error("Signaling error:", err);
            }
        };

        socket.on('voice-existing-users', handleExistingUsers);
        socket.on('voice-user-joined', handleUserJoined);
        socket.on('voice-user-left', handleUserLeft);
        socket.on('voice-signal', handleSignal);

        return () => {
            socket.off('voice-existing-users', handleExistingUsers);
            socket.off('voice-user-joined', handleUserJoined);
            socket.off('voice-user-left', handleUserLeft);
            socket.off('voice-signal', handleSignal);
        };
    }, [socket, isInRoom]); // Depend on isInRoom? Or just socket? 
    // Ideally just socket, but we need localStreamRef which is stable.

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            leaveVoiceRoom(); // Ensure cleanup
        };
    }, []);

    return {
        isInRoom,
        peers,
        isMuted,
        joinVoiceRoom,
        leaveVoiceRoom,
        toggleMute
    };
};
</file>

<file path="src/hooks/useWebRTC.ts">
import { useEffect, useRef, useState, useCallback } from 'react';
import { Socket } from 'socket.io-client';

const CONFIG = {
    iceServers: [
        { urls: "stun:stun.l.google.com:19302" }
    ]
};

export const useWebRTC = (socket: Socket, role: 'broadcaster' | 'viewer' | null) => {
    const [localStream, setLocalStream] = useState<MediaStream | null>(null);
    const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
    const peerConnections = useRef<{ [key: string]: RTCPeerConnection }>({});
    const localStreamRef = useRef<MediaStream | null>(null); // Ref to access current stream in callbacks

    useEffect(() => {
        localStreamRef.current = localStream;
    }, [localStream]);

    const startStreaming = useCallback(async () => {
        try {
            const stream = await navigator.mediaDevices.getDisplayMedia({
                video: true,
                audio: false // Or true if we want audio
            });
            setLocalStream(stream);
            localStreamRef.current = stream;
            return stream;
        } catch (err) {
            console.error("Error accessing display media:", err);
            return null;
        }
    }, []);

    useEffect(() => {
        if (!socket || !role) return;

        const handleWatcher = async (id: string) => {
            console.log("New watcher:", id);
            const peerConnection = new RTCPeerConnection(CONFIG);
            peerConnections.current[id] = peerConnection;

            if (localStreamRef.current) {
                localStreamRef.current.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStreamRef.current!);
                });
            }

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit("candidate", id, event.candidate);
                }
            };

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            socket.emit("offer", id, peerConnection.localDescription);
        };

        const handleOffer = async (id: string, description: RTCSessionDescriptionInit) => {
            console.log("Received offer from:", id);
            const peerConnection = new RTCPeerConnection(CONFIG);
            peerConnections.current[id] = peerConnection;

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit("candidate", id, event.candidate);
                }
            };

            peerConnection.ontrack = (event) => {
                console.log("Received remote track");
                setRemoteStream(event.streams[0]);
            };

            await peerConnection.setRemoteDescription(description);
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit("answer", id, peerConnection.localDescription);
        };

        const handleAnswer = async (id: string, description: RTCSessionDescriptionInit) => {
            console.log("Received answer from:", id);
            const peerConnection = peerConnections.current[id];
            if (peerConnection) {
                await peerConnection.setRemoteDescription(description);
            }
        };

        const handleCandidate = async (id: string, candidate: RTCIceCandidateInit) => {
            const peerConnection = peerConnections.current[id];
            if (peerConnection) {
                try {
                    await peerConnection.addIceCandidate(candidate);
                } catch (e) {
                    console.error("Error adding candidate:", e);
                }
            }
        };

        const handleStreamEnded = () => {
            setRemoteStream(null);
            // Close all connections?
            Object.values(peerConnections.current).forEach(pc => pc.close());
            peerConnections.current = {};
        };

        socket.on("watcher", handleWatcher);
        socket.on("offer", handleOffer);
        socket.on("answer", handleAnswer);
        socket.on("candidate", handleCandidate);
        socket.on("stream-ended", handleStreamEnded);

        if (role === 'viewer') {
            socket.emit("watcher");
        }

        return () => {
            socket.off("watcher", handleWatcher);
            socket.off("offer", handleOffer);
            socket.off("answer", handleAnswer);
            socket.off("candidate", handleCandidate);
            socket.off("stream-ended", handleStreamEnded);

            // Cleanup connections on unmount
            Object.values(peerConnections.current).forEach(pc => pc.close());
            peerConnections.current = {};
        };
    }, [socket, role]);

    return { localStream, remoteStream, startStreaming };
};
</file>

<file path="src/index.css">
@import url('https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap');
@tailwind base;
@tailwind components;
@tailwind utilities;

/* 
  TACTA DESIGN SYSTEM
  Enhanced with proper spacing scale, typography system, and semantic colors
*/

@layer base {
  :root {
    /* ==================== TYPOGRAPHY ==================== */
    --font-sans: "Inter", system-ui, -apple-system, sans-serif;
    --font-mono: "JetBrains Mono", monospace;

    /* Typography Scale (14px base) */
    --text-xs: 0.6875rem;
    /* 11px - micro labels */
    --text-sm: 0.8125rem;
    /* 13px - secondary text */
    --text-base: 0.875rem;
    /* 14px - body text */
    --text-md: 1rem;
    /* 16px - emphasized text */
    --text-lg: 1.125rem;
    /* 18px - section headers */
    --text-xl: 1.25rem;
    /* 20px - card headers */
    --text-2xl: 1.5rem;
    /* 24px - main stats */
    --text-3xl: 2rem;
    /* 32px - hero numbers */

    /* Font Weights */
    --font-normal: 400;
    --font-medium: 500;
    --font-semibold: 600;
    --font-bold: 700;

    /* ==================== SPACING SCALE ==================== */
    /* 8px base unit system for consistent spacing */
    --space-0: 0;
    --space-1: 0.25rem;
    /* 4px */
    --space-2: 0.5rem;
    /* 8px - base unit */
    --space-3: 0.75rem;
    /* 12px */
    --space-4: 1rem;
    /* 16px */
    --space-5: 1.25rem;
    /* 20px */
    --space-6: 1.5rem;
    /* 24px */
    --space-8: 2rem;
    /* 32px */
    --space-10: 2.5rem;
    /* 40px */
    --space-12: 3rem;
    /* 48px */
    --space-16: 4rem;
    /* 64px */

    /* ==================== COLOR SYSTEM ==================== */
    /* Backgrounds */
    --background: 215 40% 10%;
    /* Deep Navy */
    --background-elevated: 215 35% 13%;
    /* Slightly lighter for cards */
    --foreground: 0 0% 100%;

    /* Cards & Surfaces */
    --card: 215 35% 15%;
    --card-hover: 215 35% 18%;
    --card-foreground: 0 0% 100%;

    /* Popovers & Modals */
    --popover: 215 35% 15%;
    --popover-foreground: 0 0% 100%;

    /* Primary (Tacta Blue) */
    --primary: 212 90% 52%;
    /* Slightly brighter for better contrast */
    --primary-hover: 212 90% 58%;
    --primary-foreground: 0 0% 100%;

    /* Secondary & Muted */
    --secondary: 215 25% 22%;
    /* More contrast */
    --secondary-hover: 215 25% 26%;
    --secondary-foreground: 0 0% 100%;
    --muted: 215 25% 20%;
    --muted-foreground: 215 15% 65%;
    /* Better readability */

    /* Accent (same as primary for consistency) */
    --accent: 212 90% 52%;
    --accent-foreground: 0 0% 100%;

    /* Semantic Colors */
    --success: 142 70% 45%;
    /* Green */
    --success-foreground: 0 0% 100%;
    --warning: 38 92% 50%;
    /* Orange */
    --warning-foreground: 0 0% 100%;
    --destructive: 0 84% 60%;
    /* Red */
    --destructive-foreground: 0 0% 100%;
    --info: 212 90% 52%;
    /* Blue (same as primary) */
    --info-foreground: 0 0% 100%;

    /* Borders & Inputs */
    --border: 215 30% 28%;
    /* More visible borders */
    --border-hover: 215 30% 35%;
    --input: 215 30% 25%;
    --input-focus: 215 30% 30%;
    --ring: 212 90% 52%;

    /* ==================== EFFECTS ==================== */
    --radius-sm: 0.375rem;
    /* 6px */
    --radius: 0.5rem;
    /* 8px */
    --radius-md: 0.75rem;
    /* 12px */
    --radius-lg: 1rem;
    /* 16px */

    /* Shadows */
    --shadow-sm: 0 1px 2px 0 hsl(215 40% 5% / 0.05);
    --shadow: 0 2px 8px 0 hsl(215 40% 5% / 0.1);
    --shadow-md: 0 4px 12px 0 hsl(215 40% 5% / 0.15);
    --shadow-lg: 0 8px 24px 0 hsl(215 40% 5% / 0.2);
    --shadow-glow: 0 0 30px hsl(212 90% 50% / 0.3);
    --shadow-glow-sm: 0 0 15px hsl(212 90% 50% / 0.2);
    --shadow-success: 0 0 20px hsl(142 70% 45% / 0.4);

    /* Gradients */
    --gradient-primary: linear-gradient(135deg, hsl(212 90% 45%), hsl(212 90% 60%));
    --gradient-success: linear-gradient(135deg, hsl(142 70% 40%), hsl(142 70% 50%));
    --gradient-overlay: linear-gradient(180deg, hsl(215 40% 10% / 0) 0%, hsl(215 40% 10% / 0.8) 100%);

    /* ==================== TRANSITIONS ==================== */
    --transition-fast: 150ms ease;
    --transition-base: 200ms ease;
    --transition-slow: 300ms ease;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
    font-family: var(--font-sans);
    font-size: var(--text-base);
    line-height: 1.5;
    font-weight: var(--font-normal);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    letter-spacing: -0.01em;
  }

  /* Typography Elements */
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-weight: var(--font-semibold);
    line-height: 1.2;
    letter-spacing: -0.02em;
  }

  h1 {
    font-size: var(--text-3xl);
  }

  h2 {
    font-size: var(--text-2xl);
  }

  h3 {
    font-size: var(--text-xl);
  }

  h4 {
    font-size: var(--text-lg);
  }

  h5 {
    font-size: var(--text-md);
  }

  h6 {
    font-size: var(--text-base);
  }

  p {
    line-height: 1.6;
  }

  small {
    font-size: var(--text-sm);
  }

  code,
  kbd,
  samp,
  pre {
    font-family: var(--font-mono);
    font-size: 0.9em;
  }

  /* Better button defaults */
  button {
    font-weight: var(--font-medium);
    transition: all var(--transition-base);
  }

  button:hover {
    transform: translateY(-1px);
  }

  button:active {
    transform: translateY(0);
  }
}

@layer utilities {

  /* ==================== SCROLLBARS ==================== */
  .no-scrollbar::-webkit-scrollbar {
    display: none;
  }

  .no-scrollbar {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }

  .custom-scrollbar::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  .custom-scrollbar::-webkit-scrollbar-track {
    background: transparent;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb {
    background: hsl(var(--border) / 0.6);
    border-radius: 10px;
  }

  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    background: hsl(var(--border-hover) / 0.8);
  }

  /* ==================== TYPOGRAPHY UTILITIES ==================== */
  .text-xs {
    font-size: var(--text-xs);
  }

  .text-sm {
    font-size: var(--text-sm);
  }

  .text-base {
    font-size: var(--text-base);
  }

  .text-md {
    font-size: var(--text-md);
  }

  .text-lg {
    font-size: var(--text-lg);
  }

  .text-xl {
    font-size: var(--text-xl);
  }

  .text-2xl {
    font-size: var(--text-2xl);
  }

  .text-3xl {
    font-size: var(--text-3xl);
  }

  .font-normal {
    font-weight: var(--font-normal);
  }

  .font-medium {
    font-weight: var(--font-medium);
  }

  .font-semibold {
    font-weight: var(--font-semibold);
  }

  .font-bold {
    font-weight: var(--font-bold);
  }

  /* ==================== SPACING UTILITIES ==================== */
  .space-1 {
    gap: var(--space-1);
  }

  .space-2 {
    gap: var(--space-2);
  }

  .space-3 {
    gap: var(--space-3);
  }

  .space-4 {
    gap: var(--space-4);
  }

  .space-5 {
    gap: var(--space-5);
  }

  .space-6 {
    gap: var(--space-6);
  }

  .space-8 {
    gap: var(--space-8);
  }

  /* ==================== CARD UTILITIES ==================== */
  .card-elevated {
    background: hsl(var(--card));
    border: 1px solid hsl(var(--border));
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    transition: all var(--transition-base);
  }

  .card-elevated:hover {
    background: hsl(var(--card-hover));
    border-color: hsl(var(--border-hover));
    box-shadow: var(--shadow-md);
  }

  /* ==================== BUTTON UTILITIES ==================== */
  .btn-glow {
    box-shadow: var(--shadow-glow-sm);
  }

  .btn-glow:hover {
    box-shadow: var(--shadow-glow);
  }

  .btn-success-glow {
    box-shadow: var(--shadow-success);
  }

  /* ==================== GRADIENT UTILITIES ==================== */
  .gradient-primary {
    background: var(--gradient-primary);
  }

  .gradient-success {
    background: var(--gradient-success);
  }

  .gradient-overlay {
    background: var(--gradient-overlay);
  }

  /* ==================== STATE UTILITIES ==================== */
  .state-success {
    color: hsl(var(--success));
  }

  .state-warning {
    color: hsl(var(--warning));
  }

  .state-error {
    color: hsl(var(--destructive));
  }

  .state-info {
    color: hsl(var(--info));
  }

  /* Background variants */
  .bg-success {
    background: hsl(var(--success));
    color: hsl(var(--success-foreground));
  }

  .bg-warning {
    background: hsl(var(--warning));
    color: hsl(var(--warning-foreground));
  }

  .bg-error {
    background: hsl(var(--destructive));
    color: hsl(var(--destructive-foreground));
  }

  .bg-info {
    background: hsl(var(--info));
    color: hsl(var(--info-foreground));
  }

  /* ==================== FOCUS UTILITIES ==================== */
  .focus-ring {
    @apply focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background;
  }

  /* ==================== ANIMATION UTILITIES ==================== */
  .transition-fast {
    transition: all var(--transition-fast);
  }

  .transition-base {
    transition: all var(--transition-base);
  }

  .transition-slow {
    transition: all var(--transition-slow);
  }

  /* ==================== GLASSMORPHISM ==================== */
  .glass {
    background: hsl(var(--card) / 0.6);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid hsl(var(--border) / 0.5);
  }

  .glass-strong {
    background: hsl(var(--card) / 0.8);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid hsl(var(--border) / 0.6);
  }
}
</file>

<file path="src/layouts/MainLayout.tsx">
import React from 'react';
import { SidebarProvider, SidebarInset } from '@/components/ui/sidebar';
import { ViewType } from '@/components/AppSidebar';
import { VisualGuide } from '@/components/dashboard/VisualGuide';
import { useAuth } from '@/contexts/AuthContext';
import { AppSidebar } from '@/components/AppSidebar';
import { DashboardHeader } from '@/components/dashboard/DashboardHeader';
import { VideoBackground } from '@/components/Index/VideoBackground';
import { DashboardView } from '@/components/dashboard/views/DashboardView';
import { AnalyticsView } from '@/components/dashboard/views/AnalyticsView';
import { QAView } from '@/components/dashboard/views/QAView';
import { TacticsView } from '@/components/dashboard/views/TacticsView';
import { SettingsView } from '@/components/dashboard/views/SettingsView';
import { CommunityHub } from '@/components/CommunityHub';
import { VideoManager } from '@/components/VideoManager';
import { LiveEventToast } from '@/components/Index/LiveEventToast';
import { SessionModeModal } from '@/components/SessionModeModal';
import { AdminWaitingRoom } from '@/components/AdminWaitingRoom';
import PendingEventsQueue from '@/components/PendingEventsQueue';
import ZoneSelectorOverlay from "@/components/ZoneSelectorOverlay";
import { QuickPlayerSelector } from "@/components/QuickPlayerSelector";
import { Activity } from 'lucide-react';
import { Card } from "@/components/ui/card";

export function MainLayout(props: any) {
    const {
        user,
        activeView,
        setActiveView,
        hasPermission,
        trackingMode,
        setTrackingMode,
        isMatchActive,
        toggleMatch,
        matchTime,
        formatTime,
        voiceLanguage,
        setVoiceLanguage,
        isListening,
        toggleListening,
        isInRoom,
        joinVoiceRoom,
        leaveVoiceRoom,
        toggleMute,
        isMuted,
        peers,
        isEditMode,
        setIsEditMode,
        saveLayout,
        resetLayout,
        videoRef,
        videoStream,
        audioRef,
        // DashboardView props
        layoutConfig,
        toggleComponentVisibility,
        teams,
        selectedTeam,
        handleTeamUpload,
        handleTeamSelect,
        keyboardBuffer,
        showMappings,
        mappings,
        pressedButtons,
        updateMapping,
        resetMappings,
        handleGameEvent,
        isEditingMode,
        setIsEditingMode,
        showAnalysisView,
        videoMode,
        useVideoMode,
        isIPTVConfigured,
        livePlayerRef,
        events,
        showFeed,
        setUseVideoMode,
        setVideoMode,
        showIPTVBrowser,
        setShowIPTVBrowser,
        showFIFAPlusBrowser,
        setShowFIFAPlusBrowser,
        videoFile,
        remoteVideoUrl,
        videoTime,
        setVideoTime,
        seekTime,
        setSeekTime,
        isVideoPlaying,
        setIsVideoPlaying,
        socket,
        axes,
        buttons,
        teamNames,
        handlePlayerSelect,
        analysisResults,
        quickSelectorState,
        thirdsZone,
        setVideoFile,
        setServerVideoPath,
        sessionMode,
        setSessionMode,
        showAdminWaitingRoom,
        setShowAdminWaitingRoom,
        togglePiP,
        toggleWatchMatch,
        setEvents,
        lastEventButtonLabel,
        isSessionStarted,
        setIsSessionStarted,
        selectedPendingEvent,
        setSelectedPendingEvent,
        handleDismissPending,
        handleAssignZone
    } = props;

    // Visual Guide State
    const [runGuide, setRunGuide] = React.useState(false);

    React.useEffect(() => {
        const hasSeenGuide = localStorage.getItem('tacta-guide-seen');
        if (!hasSeenGuide) {
            // Delay slightly to ensure layout is ready
            const timer = setTimeout(() => setRunGuide(true), 1500);
            return () => clearTimeout(timer);
        }
    }, []);

    const handleGuideFinish = () => {
        setRunGuide(false);
        localStorage.setItem('tacta-guide-seen', 'true');
    };

    const handleStartGuide = () => {
        setRunGuide(true);
    };

    return (
        <SidebarProvider>
            <div className="flex h-screen w-screen bg-background overflow-hidden text-xs">
                {user?.role !== 'eye_spotter' && <AppSidebar currentView={activeView} onViewChange={setActiveView} />}

                <SidebarInset className="flex flex-col relative min-w-0 flex-1 h-screen overflow-hidden">
                    <VideoBackground videoRef={videoRef} videoStream={videoStream} />
                    <audio ref={audioRef} autoPlay playsInline />

                    <DashboardHeader
                        userRole={user?.role}
                        activeView={activeView}
                        setActiveView={setActiveView}
                        onStartGuide={handleStartGuide}
                        hasPermission={hasPermission}
                        trackingMode={trackingMode}
                        setTrackingMode={setTrackingMode}
                        isMatchActive={isMatchActive}
                        toggleMatch={toggleMatch}
                        matchTime={matchTime}
                        formatTime={formatTime}
                        voiceLanguage={voiceLanguage}
                        setVoiceLanguage={setVoiceLanguage}
                        isListening={isListening}
                        toggleListening={toggleListening}
                        isInRoom={isInRoom}
                        joinVoiceRoom={joinVoiceRoom}
                        leaveVoiceRoom={leaveVoiceRoom}
                        toggleMute={toggleMute}
                        isMuted={isMuted}
                        peersCount={peers.length}
                        isEditMode={isEditMode}
                        setIsEditMode={setIsEditMode}
                        saveLayout={saveLayout}
                        resetLayout={resetLayout}
                    />

                    <div className="flex-1 overflow-hidden relative flex flex-col">
                        {activeView === 'video_manager' ? (
                            <div className="flex-1 p-4 bg-slate-950 overflow-hidden">
                                <VideoManager />
                            </div>
                        ) : activeView === 'dashboard' ? (
                            <DashboardView
                                userRole={user?.role}
                                isEditMode={isEditMode}
                                layoutConfig={layoutConfig}
                                toggleComponentVisibility={toggleComponentVisibility}
                                teams={teams}
                                selectedTeam={selectedTeam}
                                handleTeamUpload={handleTeamUpload}
                                handleTeamSelect={handleTeamSelect}
                                trackingMode={trackingMode}
                                keyboardBuffer={keyboardBuffer}
                                showMappings={showMappings}
                                mappings={mappings}
                                pressedButtons={pressedButtons}
                                updateMapping={updateMapping}
                                resetMappings={resetMappings}
                                handleGameEvent={handleGameEvent}
                                isEditingMode={isEditingMode}
                                setIsEditingMode={setIsEditingMode}
                                hasPermission={hasPermission}
                                showAnalysisView={showAnalysisView}
                                videoMode={videoMode}
                                useVideoMode={useVideoMode}
                                isIPTVConfigured={isIPTVConfigured}
                                livePlayerRef={livePlayerRef}
                                events={events}
                                showFeed={showFeed}
                                setUseVideoMode={setUseVideoMode}
                                setVideoMode={setVideoMode}
                                showIPTVBrowser={showIPTVBrowser}
                                setShowIPTVBrowser={setShowIPTVBrowser}
                                showFIFAPlusBrowser={showFIFAPlusBrowser}
                                setShowFIFAPlusBrowser={setShowFIFAPlusBrowser}
                                videoFile={videoFile}
                                remoteVideoUrl={remoteVideoUrl}
                                videoTime={videoTime}
                                setVideoTime={setVideoTime}
                                seekTime={seekTime}
                                setSeekTime={setSeekTime}
                                isVideoPlaying={isVideoPlaying}
                                setIsVideoPlaying={setIsVideoPlaying}
                                socket={socket}
                                axes={axes}
                                buttons={buttons}
                                teamNames={teamNames}
                                handlePlayerSelect={handlePlayerSelect}
                                analysisResults={analysisResults}
                                quickSelectorState={quickSelectorState}
                                thirdsZone={thirdsZone}
                                setVideoFile={setVideoFile}
                                setServerVideoPath={setServerVideoPath}
                                sessionMode={sessionMode}
                                setShowAdminWaitingRoom={setShowAdminWaitingRoom}
                                togglePiP={togglePiP}
                                toggleWatchMatch={toggleWatchMatch}
                                setEvents={setEvents}
                                lastEventButtonLabel={lastEventButtonLabel}
                            />
                        ) : activeView === 'analytics' ? (
                            <AnalyticsView events={events} />
                        ) : activeView === 'qa' ? (
                            <QAView
                                events={events}
                                videoFile={videoFile}
                                teamNames={teamNames}
                                availablePlayers={teams.get(selectedTeam)?.PlayerData.map((p: any) => ({
                                    id: p.ID,
                                    name: `${p.Forename} ${p.Surname}`
                                })) || []}
                                setEvents={setEvents}
                                socket={socket}
                                setSeekTime={(time: number) => {
                                    setSeekTime(time);
                                    setTrackingMode('POST_MATCH');
                                    setActiveView('dashboard');
                                }}
                                setTrackingMode={setTrackingMode}
                                setActiveView={setActiveView}
                            />
                        ) : activeView === 'tactics' ? (
                            <TacticsView
                                events={events}
                                teamNames={teamNames}
                                teamARoster={teams.get(Array.from(teams.keys())[0]) || { PlayerData: [] }}
                                teamBRoster={teams.get(Array.from(teams.keys())[1]) || { PlayerData: [] }}
                            />
                        ) : activeView === 'community' ? (
                            <div className="flex-1 overflow-y-auto no-scrollbar">
                                <CommunityHub />
                            </div>
                        ) : activeView === 'settings' ? (
                            <SettingsView
                                mappings={mappings}
                                pressedButtons={pressedButtons}
                                updateMapping={updateMapping}
                                resetMappings={resetMappings}
                                events={events}
                            />
                        ) : null}

                        {sessionMode === null && (
                            <SessionModeModal onSelectMode={(mode) => {
                                setSessionMode(mode);
                                if (mode === 'collab') {
                                    joinVoiceRoom();
                                }
                            }} />
                        )}

                        <div className="fixed bottom-20 left-4 z-[100] flex flex-col gap-2 pointer-events-none">
                            <div className="pointer-events-auto">
                                <PendingEventsQueue
                                    events={events.filter((e: any) => e.id !== -1 && e.isPendingZone)}
                                    onSelectEvent={setSelectedPendingEvent}
                                    onDismiss={handleDismissPending}
                                />
                            </div>
                        </div>

                        {selectedPendingEvent && (
                            <ZoneSelectorOverlay
                                selectedZone={selectedPendingEvent.zone || 1}
                                onConfirm={(z) => handleAssignZone(selectedPendingEvent.id, z)}
                                onCancel={() => setSelectedPendingEvent(null)}
                                eventName={selectedPendingEvent.eventName}
                                pendingEvents={events.filter((e: any) => e.isPendingZone)}
                                onSelectEvent={setSelectedPendingEvent}
                            />
                        )}

                        {quickSelectorState.isOpen && (
                            <QuickPlayerSelector
                                isVisible={quickSelectorState.isOpen}
                                roster={quickSelectorState.roster}
                                selectedIndex={quickSelectorState.selectedIndex}
                                team={quickSelectorState.team}
                            />
                        )}

                        {showAdminWaitingRoom && (
                            <AdminWaitingRoom
                                connectedPeers={peers}
                                onStartSession={() => {
                                    setShowAdminWaitingRoom(false);
                                    setIsSessionStarted(true);
                                    socket?.emit('start-session');
                                }}
                            />
                        )}

                        {!isSessionStarted && sessionMode === 'collab' && user?.role !== 'admin' && (
                            <div className="absolute inset-0 z-50 bg-background/60 backdrop-blur-md flex items-center justify-center p-4">
                                <Card className="max-w-md w-full bg-card shadow-2xl border-primary/20 text-center p-8">
                                    <div className="mx-auto w-16 h-16 rounded-full bg-primary/10 flex items-center justify-center mb-4">
                                        <Activity className="w-8 h-8 text-primary animate-pulse" />
                                    </div>
                                    <h2 className="text-xl font-bold mb-2">Waiting for Admin</h2>
                                    <p className="text-sm text-muted-foreground">
                                        The session hasn't started yet. Please wait for the analyst to initialize the dashboard.
                                    </p>
                                </Card>
                            </div>
                        )}
                    </div >

                    {showFeed && <LiveEventToast events={events} />}
                </SidebarInset >
            </div >
            <VisualGuide run={runGuide} onFinish={handleGuideFinish} />
        </SidebarProvider >
    );
}
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/main.tsx">
import { createRoot } from "react-dom/client";
import App from "./App.tsx";
import "./index.css";
import { EventConfigProvider } from "@/contexts/EventConfigContext";
import { ErrorBoundary } from "@/components/ErrorBoundary";

createRoot(document.getElementById("root")!).render(
    <ErrorBoundary>
        <EventConfigProvider>
            <App />
        </EventConfigProvider>
    </ErrorBoundary>
);
</file>

<file path="src/middleware/authMiddleware.js">
import { verifyToken } from '../services/auth.service.js';

export const authMiddleware = (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Unauthorized' });
    }

    const token = authHeader.split(' ')[1];
    const decoded = verifyToken(token);

    if (!decoded) {
        return res.status(401).json({ error: 'Invalid or expired token' });
    }

    req.user = decoded;
    next();
};

export const roleMiddleware = (allowedRoles) => {
    return (req, res, next) => {
        if (!req.user || !allowedRoles.includes(req.user.role)) {
            return res.status(403).json({ error: 'Forbidden: Insufficient permissions' });
        }
        next();
    };
};
</file>

<file path="src/pages/AdminPortal.tsx">
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Checkbox } from '@/components/ui/checkbox';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/hooks/use-toast';
import { Trash2, UserPlus, Shield, Key, Edit, Save, Video, Settings } from 'lucide-react';
import { Switch } from "@/components/ui/switch";
import { useAuth } from '@/contexts/AuthContext';
import { API_BASE_URL, API_HEADERS } from '@/utils/apiConfig';
import { EventConfigTable } from '@/components/Admin/EventConfigTable';

const PERMISSION_CATEGORIES = {
    'Dashboard': [
        'dashboard.view', 'dashboard.live.view', 'dashboard.live.match_control',
        'dashboard.live.voice', 'dashboard.live.stream.view', 'dashboard.live.stream.manage',
        'dashboard.post.view', 'dashboard.post.upload', 'dashboard.export'
    ],
    'Post-Match Editing': [
        'dashboard.post.edit', 'dashboard.post.delete', 'dashboard.post.assign_player'
    ],
    'Video & Telestration': [
        'video.annotation', 'video.calibration', 'video.player_tracking',
        'video.export_data', 'video.import_data'
    ],
    'Quality & Crowd': [
        'qa.view', 'qa.verify', 'qa.bulk_verify', 'qa.edit_metadata', 'qa.resolve_pass',
        'crowd.request', 'monitoring.view'
    ],
    'Analytics': [
        'analytics.view', 'analytics.advanced', 'analytics.kpi', 'stats.view'
    ],
    'Admin & Config': [
        'admin.view', 'admin.users', 'config.controller', 'config.teams', 'community.view'
    ]
};

export default function AdminPortal() {
    const { toast } = useToast();
    const { logout } = useAuth();
    const [users, setUsers] = useState<any[]>([]);
    const [newUser, setNewUser] = useState({ username: '', password: '', role: 'operational_analyst', name: '' });

    // Permission Editing State
    const [editingUser, setEditingUser] = useState<any | null>(null);
    const [selectedPermissions, setSelectedPermissions] = useState<string[]>([]);

    useEffect(() => {
        fetchUsers();
    }, []);

    const fetchUsers = async () => {
        try {
            const token = localStorage.getItem('tacta_token');
            const response = await fetch(`${API_BASE_URL}/api/users`, {
                headers: {
                    ...API_HEADERS,
                    'Authorization': `Bearer ${token}`
                }
            });
            if (response.ok) {
                const data = await response.json();
                setUsers(data);
            }
        } catch (error) {
            console.error("Failed to fetch users", error);
        }
    };

    const handleAddUser = async () => {
        try {
            const token = localStorage.getItem('tacta_token');
            const response = await fetch(`${API_BASE_URL}/api/users`, {
                method: 'POST',
                headers: {
                    ...API_HEADERS,
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify(newUser)
            });

            if (response.ok) {
                toast({ title: "User Added", description: `${newUser.username} created successfully.` });
                setNewUser({ username: '', password: '', role: 'operational_analyst', name: '' });
                fetchUsers();
            }
        } catch (error) {
            toast({ title: "Error", description: "Failed to create user", variant: "destructive" });
        }
    };

    const handleDeleteUser = async (id: number) => {
        try {
            const token = localStorage.getItem('tacta_token');
            const response = await fetch(`${API_BASE_URL}/api/users/${id}`, {
                method: 'DELETE',
                headers: {
                    ...API_HEADERS,
                    'Authorization': `Bearer ${token}`
                }
            });

            if (response.ok) {
                toast({ title: "User Deleted" });
                fetchUsers();
            }
        } catch (error) {
            toast({ title: "Error", description: "Failed to delete user", variant: "destructive" });
        }
    };

    const openPermissionEditor = (user: any) => {
        setEditingUser(user);
        setSelectedPermissions(user.effectivePermissions || []);
    };

    const togglePermission = (perm: string) => {
        setSelectedPermissions(prev =>
            prev.includes(perm) ? prev.filter(p => p !== perm) : [...prev, perm]
        );
    };

    const [autoExtract, setAutoExtract] = useState(() => localStorage.getItem('tacta_auto_extract') === 'true');

    const toggleAutoExtract = (checked: boolean) => {
        setAutoExtract(checked);
        localStorage.setItem('tacta_auto_extract', checked.toString());
        toast({ title: checked ? "Auto-Clip Enabled" : "Auto-Clip Disabled", description: "Global setting updated." });
    };

    const savePermissions = async () => {
        if (!editingUser) return;
        try {
            const token = localStorage.getItem('tacta_token');
            // We are saving the explicit list. The backend might merge or replace.
            const response = await fetch(`${API_BASE_URL}/api/users/${editingUser.id}`, {
                method: 'PUT',
                headers: {
                    ...API_HEADERS,
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ permissions: selectedPermissions })
            });

            if (response.ok) {
                toast({ title: "Permissions Updated", description: `Access rights updated for ${editingUser.username}` });
                setEditingUser(null);
                fetchUsers();
            }
        } catch (error) {
            toast({ title: "Error", description: "Failed to update permissions", variant: "destructive" });
        }
    };

    return (
        <div className="p-8 space-y-8 bg-slate-950 min-h-screen text-slate-50">
            <div className="flex items-center justify-between">
                <div>
                    <h1 className="text-3xl font-bold tracking-tight text-white mb-2">Admin Portal</h1>
                    <p className="text-slate-400">System Configuration & User Management</p>
                </div>
                <div className="flex gap-2">
                    <Button variant="outline" onClick={() => window.location.href = '/'}>Back to Dashboard</Button>
                    <Button variant="destructive" onClick={logout}>Logout</Button>
                </div>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                {/* Create User */}
                <Card className="bg-slate-900 border-slate-800 lg:col-span-1 h-fit">
                    <CardHeader>
                        <CardTitle className="flex items-center gap-2"><UserPlus className="w-5 h-5 text-emerald-500" /> Create User</CardTitle>
                        <CardDescription>Add a new analyst or controller to the system.</CardDescription>
                    </CardHeader>
                    <CardContent className="space-y-4">
                        <div className="space-y-2">
                            <label className="text-xs font-bold uppercase text-slate-500">Full Name</label>
                            <Input value={newUser.name} onChange={e => setNewUser({ ...newUser, name: e.target.value })} placeholder="John Doe" className="bg-slate-950 border-slate-800" />
                        </div>
                        <div className="space-y-2">
                            <label className="text-xs font-bold uppercase text-slate-500">Username</label>
                            <Input value={newUser.username} onChange={e => setNewUser({ ...newUser, username: e.target.value })} placeholder="jdoe" className="bg-slate-950 border-slate-800" />
                        </div>
                        <div className="space-y-2">
                            <label className="text-xs font-bold uppercase text-slate-500">Password</label>
                            <Input type="password" value={newUser.password} onChange={e => setNewUser({ ...newUser, password: e.target.value })} placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" className="bg-slate-950 border-slate-800" />
                        </div>
                        <div className="space-y-2">
                            <label className="text-xs font-bold uppercase text-slate-500">Role</label>
                            <select
                                className="w-full h-10 rounded-md border border-slate-800 bg-slate-950 px-3 py-2 text-sm text-slate-50 focus:outline-none focus:ring-2 focus:ring-emerald-500"
                                value={newUser.role}
                                onChange={e => setNewUser({ ...newUser, role: e.target.value })}
                            >
                                <option value="operational_analyst">Operational Analyst</option>
                                <option value="tactical_analyst">Tactical Analyst</option>
                                <option value="quality_controller">Quality Controller</option>
                                <option value="admin">Admin</option>
                            </select>
                        </div>
                        <Button className="w-full bg-emerald-600 hover:bg-emerald-700" onClick={handleAddUser}>
                            Create Account
                        </Button>
                    </CardContent>
                </Card>

                {/* User List */}
                <Card className="bg-slate-900 border-slate-800 lg:col-span-2">
                    <CardHeader>
                        <CardTitle className="flex items-center gap-2"><Shield className="w-5 h-5 text-blue-500" /> System Users</CardTitle>
                        <CardDescription>Manage access capabilities and permissions.</CardDescription>
                    </CardHeader>
                    <CardContent>
                        <Table>
                            <TableHeader>
                                <TableRow className="hover:bg-transparent border-slate-800">
                                    <TableHead className="text-slate-400">User</TableHead>
                                    <TableHead className="text-slate-400">Role</TableHead>
                                    <TableHead className="text-slate-400">Permissions</TableHead>
                                    <TableHead className="text-right text-slate-400">Actions</TableHead>
                                </TableRow>
                            </TableHeader>
                            <TableBody>
                                {users.map(u => (
                                    <TableRow key={u.id} className="hover:bg-slate-800/50 border-slate-800">
                                        <TableCell>
                                            <div className="font-medium text-slate-200">{u.name}</div>
                                            <div className="text-xs text-slate-500">@{u.username}</div>
                                        </TableCell>
                                        <TableCell>
                                            <Badge variant="outline" className="bg-slate-950 border-slate-700 text-slate-400 font-mono">
                                                {u.role}
                                            </Badge>
                                        </TableCell>
                                        <TableCell>
                                            <div className="flex flex-wrap gap-1">
                                                {u.effectivePermissions?.includes('*') ? (
                                                    <Badge className="bg-purple-500/10 text-purple-400 border-purple-500/20 text-[10px]">SUPERUSER</Badge>
                                                ) : (
                                                    <>
                                                        <Badge variant="secondary" className="text-[10px]">{u.effectivePermissions?.length || 0} active</Badge>
                                                    </>
                                                )}
                                            </div>
                                        </TableCell>
                                        <TableCell className="text-right">
                                            <div className="flex justify-end gap-2">
                                                <Dialog open={editingUser?.id === u.id} onOpenChange={(open) => !open && setEditingUser(null)}>
                                                    <DialogTrigger asChild>
                                                        <Button
                                                            variant="ghost"
                                                            size="icon"
                                                            onClick={() => openPermissionEditor(u)}
                                                            className="h-8 w-8 text-blue-400 hover:text-blue-300 hover:bg-blue-400/10"
                                                        >
                                                            <Key className="w-4 h-4" />
                                                        </Button>
                                                    </DialogTrigger>
                                                    <DialogContent className="max-w-4xl bg-slate-950 border-slate-800 text-slate-50">
                                                        <DialogHeader>
                                                            <DialogTitle>Edit Permissions: {editingUser?.name}</DialogTitle>
                                                            <DialogDescription>
                                                                Toggle specific capabilities. These override role defaults.
                                                            </DialogDescription>
                                                        </DialogHeader>

                                                        <div className="grid grid-cols-2 lg:grid-cols-3 gap-6 py-4 max-h-[60vh] overflow-y-auto">
                                                            {Object.entries(PERMISSION_CATEGORIES).map(([cat, perms]) => (
                                                                <div key={cat} className="space-y-3 p-4 rounded-lg bg-slate-900/50 border border-slate-800">
                                                                    <h4 className="font-bold text-sm text-slate-400 uppercase tracking-wider border-b border-slate-800 pb-2 mb-2">{cat}</h4>
                                                                    <div className="space-y-2">
                                                                        {perms.map(perm => (
                                                                            <div key={perm} className="flex items-start gap-2">
                                                                                <Checkbox
                                                                                    id={perm}
                                                                                    checked={selectedPermissions.includes(perm) || selectedPermissions.includes('*')}
                                                                                    onCheckedChange={() => togglePermission(perm)}
                                                                                    disabled={selectedPermissions.includes('*')} // Cannot uncheck if superuser
                                                                                    className="data-[state=checked]:bg-blue-600 border-slate-600"
                                                                                />
                                                                                <label
                                                                                    htmlFor={perm}
                                                                                    className="text-xs font-mono text-slate-300 leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 pt-0.5"
                                                                                >
                                                                                    {perm}
                                                                                </label>
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            ))}
                                                        </div>

                                                        <DialogFooter>
                                                            <Button variant="ghost" onClick={() => setEditingUser(null)}>Cancel</Button>
                                                            <Button onClick={savePermissions} className="bg-blue-600 hover:bg-blue-700">
                                                                <Save className="w-4 h-4 mr-2" /> Save Changes
                                                            </Button>
                                                        </DialogFooter>
                                                    </DialogContent>
                                                </Dialog>

                                                <Button
                                                    variant="ghost"
                                                    size="icon"
                                                    onClick={() => handleDeleteUser(u.id)}
                                                    className="h-8 w-8 text-red-500 hover:text-red-400 hover:bg-red-500/10"
                                                >
                                                    <Trash2 className="w-4 h-4" />
                                                </Button>
                                            </div>
                                        </TableCell>
                                    </TableRow>
                                ))}
                            </TableBody>
                        </Table>
                    </CardContent>
                </Card>

                {/* Global System Settings */}
                <Card className="bg-slate-900 border-slate-800 lg:col-span-3">
                    <CardHeader>
                        <CardTitle className="flex items-center gap-2"><Settings className="w-5 h-5 text-gray-400" /> Global System Settings</CardTitle>
                        <CardDescription>Configure system-wide automation and behavior.</CardDescription>
                    </CardHeader>
                    <CardContent className="space-y-4">
                        <div className="flex items-center justify-between p-4 rounded-lg bg-slate-950/50 border border-slate-800">
                            <div className="space-y-0.5">
                                <label className="text-sm font-medium text-white flex items-center gap-2">
                                    <Video className="w-4 h-4 text-purple-400" /> Auto-Clip Extraction
                                </label>
                                <p className="text-xs text-slate-400">
                                    Automatically create 10s video clips when events are tagged (requires video source).
                                </p>
                            </div>
                            <Switch
                                checked={autoExtract}
                                onCheckedChange={toggleAutoExtract}
                                className="data-[state=checked]:bg-purple-600"
                            />
                        </div>
                    </CardContent>
                </Card>

                {/* Event Configuration (Full Width) */}
                <Card className="bg-slate-900 border-slate-800 lg:col-span-3">
                    <CardContent className="p-0">
                        <EventConfigTable />
                    </CardContent>
                </Card>
            </div>
        </div>
    );
}
</file>

<file path="src/pages/AnalystAudit.tsx">
import React, { useState, useEffect } from "react";
import {
    ChevronLeft,
    ChevronRight,
    Laptop,
    Tablet,
    Server,
    X,
    Check,
    Gamepad2,
    Timer,
    DollarSign,
    Brain,
    Wrench,
    TrendingUp,
    Recycle,
    Scale,
    GraduationCap,
    Bot,
    Building,
    BookOpen,
    MessageCircle,
    HeartPulse,
    Crown,
    Shield,
    ArrowRight,
    CheckCircle,
} from "lucide-react";

// Standard UI components to ensure consistency
const Slide = ({ active, children, className = "" }: { active: boolean; children: React.ReactNode; className?: string }) => {
    if (!active) return null;
    return (
        <div className={`w-full h-full flex flex-col p-8 overflow-hidden animate-in fade-in duration-500 ${className}`}>
            {children}
        </div>
    );
};

const AnalystAudit = () => {
    const [currentSlide, setCurrentSlide] = useState(0);
    const [isEditMode, setIsEditMode] = useState(false);
    const totalSlides = 17;

    const nextSlide = () => setCurrentSlide((prev) => Math.min(prev + 1, totalSlides - 1));
    const prevSlide = () => setCurrentSlide((prev) => Math.max(prev - 1, 0));

    // Handle keyboard navigation
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            if (e.key === "ArrowRight") nextSlide();
            if (e.key === "ArrowLeft") prevSlide();
        };
        window.addEventListener("keydown", handleKeyDown);
        return () => window.removeEventListener("keydown", handleKeyDown);
    }, []);

    return (
        <div className="min-h-screen bg-slate-900 text-white font-sans selection:bg-green-500 selection:text-white">
            {/* Navigation */}
            <nav className="fixed top-0 left-0 w-full z-50 bg-slate-900/90 backdrop-blur border-b border-slate-700 px-6 py-3 flex justify-between items-center text-white">
                <div className="flex items-center gap-3">
                    <div className="w-8 h-8 bg-green-600 rounded flex items-center justify-center font-bold">T</div>
                    <span className="font-bold tracking-wider">
                        TACTA <span className="text-slate-400 text-sm font-normal">| AUDIT INTER</span>
                    </span>
                </div>
                <div className="flex gap-2 items-center">
                    <button
                        onClick={() => setIsEditMode(!isEditMode)}
                        className={`px-3 py-1 rounded text-xs font-bold uppercase transition ${isEditMode ? 'bg-red-500 text-white animate-pulse' : 'bg-slate-800 text-slate-400 hover:text-white'}`}
                    >
                        {isEditMode ? 'Editing On' : 'Edit Mode'}
                    </button>
                    <button onClick={prevSlide} disabled={currentSlide === 0} className="p-2 hover:bg-slate-700 rounded-full transition disabled:opacity-50">
                        <ChevronLeft size={20} />
                    </button>
                    <span className="px-4 py-2 bg-slate-800 rounded text-sm font-mono min-w-[80px] text-center">
                        {currentSlide + 1} / {totalSlides}
                    </span>
                    <button onClick={nextSlide} disabled={currentSlide === totalSlides - 1} className="p-2 hover:bg-slate-700 rounded-full transition disabled:opacity-50">
                        <ChevronRight size={20} />
                    </button>
                </div>
            </nav>

            <main className="pt-16 h-screen w-screen overflow-hidden relative font-inter" contentEditable={isEditMode} suppressContentEditableWarning={true}>

                {/* SLIDE 1: Cover */}
                <Slide active={currentSlide === 0} className="bg-white text-black relative !p-0">
                    <div className="h-full w-full flex flex-col justify-center pl-10 md:pl-20 relative z-10">
                        <div className="mb-4 text-green-700 font-bold tracking-widest text-sm uppercase">Rapport Confidentiel</div>
                        <h1 className="text-6xl md:text-8xl font-black leading-none mb-6 font-oswald uppercase">
                            De l'Ombre √†<br />la Lumi√®re
                        </h1>
                        <h2 className="text-3xl md:text-4xl font-light mb-8 text-slate-600 font-oswald uppercase">
                            Audit de la R√©alit√©<br />de l'Analyste Vid√©o
                        </h2>
                        <div className="w-24 h-2 bg-red-600 mb-8"></div>
                        <p className="text-xl max-w-2xl font-light leading-relaxed text-slate-800">
                            Une analyse forensique des <strong>142 points de friction</strong> qui brisent le m√©tier, et la voie vers une pratique durable.
                        </p>
                        <div className="mt-12 flex items-center gap-4">
                            <div className="px-6 py-3 bg-black text-white font-bold rounded">Inter</div>
                            <div className="text-sm text-slate-500 uppercase tracking-widest">Rapport de Situation & Solution Tacta</div>
                        </div>
                    </div>
                    {/* Aesthetic Background Elements */}
                    <div className="absolute top-0 right-0 w-1/2 h-full bg-slate-100 hidden md:block" style={{ clipPath: 'polygon(20% 0, 100% 0, 100% 100%, 0% 100%)' }}></div>
                    <div className="absolute bottom-10 right-10 md:right-32 opacity-90 animate-bounce transition-all duration-1000">
                        <Laptop size={200} className="text-slate-800" strokeWidth={1} />
                    </div>
                </Slide>

                {/* SLIDE 2: The Myth vs Reality (Iceberg) */}
                <Slide active={currentSlide === 1} className="bg-sky-50 text-slate-800">
                    <h2 className="text-4xl font-bold mb-8 text-black font-oswald uppercase">Le Mythe des 90 Minutes vs<br />La R√©alit√© des 70 Heures</h2>

                    <div className="flex-1 relative w-full max-w-5xl mx-auto mt-8 border-b-4 border-sky-200 h-full flex flex-col items-center justify-center">
                        <div className="text-center z-10 mb-12">
                            <div className="text-6xl mb-2">üèîÔ∏è</div>
                            <div className="bg-white p-6 shadow-lg rounded-lg border border-sky-100">
                                <p className="font-bold text-sky-900 text-xl">Le visible : Le match (90 min)</p>
                                <p className="text-sm text-sky-600 mt-1">L'image publique : "Travailler dans le foot"</p>
                            </div>
                        </div>

                        <div className="w-full h-1 bg-sky-300 my-4 relative">
                            <span className="absolute -top-3 left-1/2 -translate-x-1/2 bg-sky-100 px-2 text-xs text-sky-600 font-bold uppercase">Surface</span>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-8 w-full max-w-4xl">
                            <div className="bg-slate-800 p-6 rounded shadow-xl border-l-4 border-red-500 text-white">
                                <h4 className="font-bold text-lg mb-1">L'invisible :</h4>
                                <p>Semaines de 50 √† 70h</p>
                            </div>
                            <div className="bg-slate-800 p-6 rounded shadow-xl border-l-4 border-red-500 text-white md:translate-y-8">
                                <p>Dimanche 2h du matin :<br />Finalisation des rapports</p>
                            </div>
                            <div className="bg-slate-800 p-6 rounded shadow-xl border-l-4 border-red-500 text-white md:col-span-2 md:w-2/3 md:mx-auto">
                                <p className="font-bold text-red-400 text-lg">87% des weekends travaill√©s</p>
                                <p className="text-sm text-slate-400 mt-1">Pas de vie personnelle, pas de vacances</p>
                            </div>
                        </div>
                    </div>
                    <div className="bg-red-600 text-white p-4 mt-8 font-bold text-center rounded">
                        Statistique cl√© : Charge de travail excessive et invisible.
                    </div>
                </Slide>

                {/* SLIDE 3: The Weight of Friction (Waffle Chart) */}
                <Slide active={currentSlide === 2} className="bg-white text-black">
                    <h2 className="text-4xl font-bold mb-8 font-oswald uppercase">Le Poids de la Friction : <span className="text-red-600">142 Probl√®mes Identifi√©s</span></h2>

                    <div className="flex flex-col md:flex-row gap-12 items-center justify-center flex-1 h-full">
                        {/* Waffle Chart Visualization */}
                        {/* Waffle Chart Visualization (SVG) */}
                        <div className="w-full max-w-md aspect-square relative">
                            <svg viewBox="0 0 110 165" className="w-full h-full drop-shadow-lg">
                                <defs>
                                    <rect id="cell" width="9" height="9" rx="2" ry="2" />
                                    <filter id="inner-shadow">
                                        <feOffset dx="0" dy="1" />
                                        <feGaussianBlur stdDeviation="1" result="offset-blur" />
                                        <feComposite operator="out" in="SourceGraphic" in2="offset-blur" result="inverse" />
                                        <feFlood floodColor="black" floodOpacity="0.2" result="color" />
                                        <feComposite operator="in" in="color" in2="inverse" result="shadow" />
                                        <feComposite operator="over" in="shadow" in2="SourceGraphic" />
                                    </filter>
                                </defs>
                                {Array.from({ length: 150 }).map((_, i) => {
                                    const cols = 10;
                                    const x = (i % cols) * 11; // 9 width + 2 gap
                                    const y = Math.floor(i / cols) * 11;

                                    let fill = "#f1f5f9"; // slate-100 (empty)
                                    let className = "transition-all duration-300 hover:opacity-80";

                                    if (i < 20) fill = "#dc2626"; // red-600
                                    else if (i < 36) fill = "#f97316"; // orange-500
                                    else if (i < 51) fill = "#eab308"; // yellow-500
                                    else if (i < 142) fill = "#1e293b"; // slate-800
                                    else fill = "#e2e8f0"; // slate-200 (empty slots)

                                    return (
                                        <rect
                                            key={i}
                                            x={x}
                                            y={y}
                                            width="9"
                                            height="9"
                                            rx="1.5"
                                            fill={fill}
                                            className={className}
                                        />
                                    );
                                })}
                            </svg>
                        </div>

                        {/* Legend */}
                        <div className="flex flex-col gap-6">
                            <div className="flex items-center gap-4">
                                <div className="w-8 h-8 bg-red-600 rounded"></div>
                                <div>
                                    <div className="font-bold text-lg">Technique (20)</div>
                                    <div className="text-sm text-gray-500">√âquipement co√ªteux, crashes.</div>
                                </div>
                            </div>
                            <div className="flex items-center gap-4">
                                <div className="w-8 h-8 bg-orange-500 rounded"></div>
                                <div>
                                    <div className="font-bold text-lg">Temporel (16)</div>
                                    <div className="text-sm text-gray-500">Charge insoutenable, deadlines.</div>
                                </div>
                            </div>
                            <div className="flex items-center gap-4">
                                <div className="w-8 h-8 bg-yellow-500 rounded"></div>
                                <div>
                                    <div className="font-bold text-lg">Cognitif (15)</div>
                                    <div className="text-sm text-gray-500">Surcharge, fatigue d√©cisionnelle.</div>
                                </div>
                            </div>
                            <div className="flex items-center gap-4">
                                <div className="w-8 h-8 bg-slate-800 rounded"></div>
                                <div>
                                    <div className="font-bold text-lg">Autres (91)</div>
                                    <div className="text-sm text-gray-500">Structurel/Financier, etc.</div>
                                </div>
                            </div>
                            <div className="mt-4 p-4 bg-black text-white font-bold text-xl rounded">
                                Total : 142 points de friction distincts
                            </div>
                        </div>
                    </div>
                    <div className="text-center text-xl font-bold italic mt-8 text-slate-500">
                        Ce n'est pas de la malchance, c'est syst√©mique.
                    </div>
                </Slide>

                {/* SLIDE 4: Technical Nightmare */}
                <Slide active={currentSlide === 3} className="bg-slate-50 text-black">
                    <h2 className="text-4xl font-bold mb-12 font-oswald uppercase">Le Cauchemar Technique et la <span className="text-red-600">'Taxe d'Outil'</span></h2>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-16 items-center flex-1 h-full max-w-6xl mx-auto">
                        {/* Visual */}
                        <div className="relative h-96 w-full flex items-center justify-center select-none">
                            <Laptop className="absolute left-10 bottom-10 w-48 h-48 text-slate-400" strokeWidth={1} />
                            <div className="absolute left-16 bottom-52 bg-red-600 text-white font-bold px-3 py-1 rounded shadow-lg transform -rotate-12">1500‚Ç¨</div>

                            <Tablet className="absolute top-10 left-10 w-32 h-32 text-slate-400" strokeWidth={1} />
                            <div className="absolute top-6 left-0 bg-red-600 text-white font-bold px-3 py-1 rounded shadow-lg transform -rotate-12">800‚Ç¨</div>

                            <Server className="absolute right-10 bottom-20 w-40 h-40 text-slate-400" strokeWidth={1} />
                            <div className="absolute right-0 bottom-52 bg-red-600 text-white font-bold px-3 py-1 rounded shadow-lg">5000‚Ç¨/an</div>

                            <div className="absolute inset-x-0 bottom-0 text-center font-bold text-slate-400">Standard Analyst Setup</div>
                        </div>

                        {/* List */}
                        <div className="bg-white p-8 rounded-xl shadow-sm border border-slate-200">
                            <h3 className="text-2xl font-bold border-b-2 border-black pb-4 mb-6 uppercase font-oswald">Grief List</h3>
                            <ul className="space-y-6">
                                <li className="flex items-start gap-4">
                                    <X className="text-red-600 w-6 h-6 shrink-0 mt-1" />
                                    <span><strong className="block text-lg">Co√ªt exorbitant</strong>Mat√©riel + Licences co√ªteuses.</span>
                                </li>
                                <li className="flex items-start gap-4">
                                    <X className="text-red-600 w-6 h-6 shrink-0 mt-1" />
                                    <span><strong className="block text-lg">Instabilit√©</strong>'Sportscode crash' = perte de 2h de travail.</span>
                                </li>
                                <li className="flex items-start gap-4">
                                    <X className="text-red-600 w-6 h-6 shrink-0 mt-1" />
                                    <span><strong className="block text-lg">Lourdeur</strong>Fichiers de 15 Go, exports de 20 minutes.</span>
                                </li>
                                <li className="flex items-start gap-4">
                                    <X className="text-red-600 w-6 h-6 shrink-0 mt-1" />
                                    <span><strong className="block text-lg">Fragmentation</strong>Jongler entre Sportscode, Excel, et PowerPoint.</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </Slide>

                {/* SLIDE 5: Time Trap */}
                <Slide active={currentSlide === 4} className="bg-white text-black">
                    <h2 className="text-4xl font-bold mb-12 font-oswald uppercase">L'√âtau Temporel : Quand le Chronom√®tre ne s'Arr√™te Jamais</h2>

                    <div className="flex-1 flex flex-col justify-center max-w-6xl mx-auto w-full">
                        {/* Timeline */}
                        <div className="grid grid-cols-7 gap-1 mb-2 px-1 text-xs md:text-sm font-bold text-center uppercase tracking-wider text-slate-500">
                            <div>Lun</div><div>Mar</div><div>Mer</div><div>Jeu</div><div>Ven</div><div>Sam</div><div className="text-red-600">Dimanche</div>
                        </div>
                        <div className="flex h-24 w-full gap-1 mb-12">
                            {[1, 2, 3, 4, 5].map(d => (
                                <div key={d} className="flex-1 bg-slate-800 text-white flex flex-col items-center justify-center text-xs md:text-sm rounded-sm">
                                    <span className="opacity-50">TRAVAIL</span>
                                </div>
                            ))}
                            <div className="flex-1 bg-black text-white flex flex-col items-center justify-center font-bold rounded-sm border-2 border-slate-800">
                                MATCH<br />DAY
                            </div>
                            <div className="flex-1 bg-red-600 text-white flex flex-col items-center justify-center font-bold text-center text-xs md:text-sm rounded-sm animate-pulse">
                                POST-MATCH<br />ANALYSIS<br /><span className="text-[10px] opacity-90">02:00 AM</span>
                            </div>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                            <div className="border-l-4 border-red-600 pl-6 py-2">
                                <h4 className="font-bold text-red-600 text-xl font-oswald mb-1">10h</h4>
                                <p className="text-gray-700">de travail par match.</p>
                            </div>
                            <div className="border-l-4 border-red-600 pl-6 py-2">
                                <h4 className="font-bold text-red-600 text-xl font-oswald mb-1">60-70h</h4>
                                <p className="text-gray-700">Moyenne hebdomadaire. Aucune vie sociale.</p>
                            </div>
                            <div className="border-l-4 border-red-600 pl-6 py-2">
                                <h4 className="font-bold text-red-600 text-xl font-oswald mb-1">800 Clics</h4>
                                <p className="text-gray-700">pour taguer seulement 80 clips de jeu.</p>
                            </div>
                            <div className="border-l-4 border-red-600 pl-6 py-2">
                                <h4 className="font-bold text-red-600 text-xl font-oswald mb-1">x2 Efforts</h4>
                                <p className="text-gray-700">Codage temps r√©el suivi d'un recodage post-match.</p>
                            </div>
                        </div>
                    </div>
                </Slide>

                {/* SLIDE 6: Human Cost */}
                <Slide active={currentSlide === 5} className="bg-slate-900 text-white relative overflow-hidden">
                    {/* Background Grid Pattern */}
                    <div className="absolute inset-0 opacity-10 pointer-events-none" style={{ backgroundImage: 'linear-gradient(#fff 1px, transparent 1px), linear-gradient(90deg, #fff 1px, transparent 1px)', backgroundSize: '40px 40px' }}></div>

                    <h2 className="text-4xl font-bold mb-16 text-center font-oswald uppercase relative z-10">Le Co√ªt Humain : Corps et Esprit √† l'√âpreuve</h2>

                    <div className="flex flex-col md:flex-row justify-center items-center flex-1 gap-16 relative z-10 max-w-6xl mx-auto">

                        <div className="w-full md:w-1/3 space-y-8 bg-slate-800/50 p-6 rounded-xl border border-slate-700">
                            <h3 className="text-2xl font-bold border-b border-white pb-3 font-oswald">Physique (Corps)</h3>
                            <ul className="space-y-4">
                                <li className="flex gap-4"><X className="text-red-500 w-6 h-6 mt-1 shrink-0" /> <span className="text-slate-200">TMS : Syndrome du canal carpien, tendinites chroniques.</span></li>
                                <li className="flex gap-4"><X className="text-red-500 w-6 h-6 mt-1 shrink-0" /> <span className="text-slate-200">Douleurs cervicales et lombaires (assis 10h/jour).</span></li>
                                <li className="flex gap-4"><X className="text-red-500 w-6 h-6 mt-1 shrink-0" /> <span className="text-slate-200">Fatigue visuelle et maux de t√™te.</span></li>
                            </ul>
                        </div>

                        {/* Center Visual */}
                        <div className="relative">
                            <div className="w-80 h-96 border border-slate-700/50 rounded-3xl flex items-center justify-center bg-slate-800/80 backdrop-blur-sm relative overflow-hidden group shadow-2xl">
                                <div className="absolute inset-0 bg-gradient-to-b from-slate-700/20 to-transparent pointer-events-none"></div>
                                <svg viewBox="0 0 200 400" className="h-72 w-auto drop-shadow-2xl">
                                    <defs>
                                        <linearGradient id="bodyGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" stopColor="#94a3b8" />
                                            <stop offset="100%" stopColor="#cbd5e1" />
                                        </linearGradient>
                                        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                                            <feGaussianBlur stdDeviation="4" result="coloredBlur" />
                                            <feMerge>
                                                <feMergeNode in="coloredBlur" />
                                                <feMergeNode in="SourceGraphic" />
                                            </feMerge>
                                        </filter>
                                        <radialGradient id="pulseGradient">
                                            <stop offset="0%" stopColor="#ef4444" stopOpacity="1" />
                                            <stop offset="100%" stopColor="#ef4444" stopOpacity="0" />
                                        </radialGradient>
                                    </defs>

                                    {/* Tech/Grid Background lines for futuristic feel */}
                                    <path d="M0 50 H200 M0 150 H200 M0 250 H200 M0 350 H200" stroke="white" strokeWidth="0.5" opacity="0.1" />
                                    <path d="M50 0 V400 M150 0 V400" stroke="white" strokeWidth="0.5" opacity="0.1" />

                                    {/* Stylized Human Silhouette */}
                                    <path
                                        d="M100 30 C115 30 125 42 125 55 C125 68 115 80 100 80 C85 80 75 68 75 55 C75 42 85 30 100 30 Z 
                                           M100 85 C125 85 150 95 160 120 L170 170 C172 180 165 190 155 190 L145 190 L150 260 L155 380 C156 390 145 395 140 385 L115 300 L105 300 L85 300 L60 385 C55 395 44 390 45 380 L50 260 L55 190 L45 190 C35 190 28 180 30 170 L40 120 C50 95 75 85 100 85 Z"
                                        fill="url(#bodyGradient)"
                                        opacity="0.9"
                                        stroke="white"
                                        strokeWidth="1"
                                        strokeOpacity="0.5"
                                    />

                                    {/* Internal "Skeleton" or Tech Lines */}
                                    <path d="M100 80 L100 300" stroke="white" strokeWidth="2" opacity="0.2" strokeDasharray="5,5" />
                                    <line x1="100" y1="120" x2="160" y2="170" stroke="white" strokeWidth="1" opacity="0.2" />
                                    <line x1="100" y1="120" x2="40" y2="170" stroke="white" strokeWidth="1" opacity="0.2" />

                                    {/* Pain Points (Animated overlay) */}
                                    {/* Head */}
                                    <circle cx="100" cy="55" r="6" className="fill-red-500 animate-pulse" filter="url(#glow)">
                                        <animate attributeName="opacity" values="0.5;1;0.5" dur="2s" repeatCount="indefinite" />
                                    </circle>

                                    {/* Neck/Shoulders */}
                                    <circle cx="100" cy="90" r="8" className="fill-red-500 animate-pulse" filter="url(#glow)">
                                        <animate attributeName="r" values="6;9;6" dur="3s" repeatCount="indefinite" />
                                    </circle>

                                    {/* Wrists (Carpal Tunnel) */}
                                    <circle cx="35" cy="180" r="8" className="fill-red-500 animate-pulse" filter="url(#glow)" />
                                    <circle cx="165" cy="180" r="8" className="fill-red-500 animate-pulse" filter="url(#glow)" />

                                    {/* Lower Back */}
                                    <circle cx="100" cy="220" r="10" className="fill-red-500 animate-pulse" filter="url(#glow)">
                                        <animate attributeName="opacity" values="0.8;0.4;0.8" dur="1.5s" repeatCount="indefinite" />
                                    </circle>
                                </svg>
                                <div className="absolute top-4 right-4 bg-slate-900/80 p-2 rounded-full border border-slate-700"><HeartPulse className="text-red-500 animate-pulse" size={24} /></div>
                            </div>
                        </div>

                        <div className="w-full md:w-1/3 space-y-8 bg-slate-800/50 p-6 rounded-xl border border-slate-700">
                            <h3 className="text-2xl font-bold border-b border-white pb-3 font-oswald">Psychologique</h3>
                            <ul className="space-y-4">
                                <li className="flex gap-4"><X className="text-red-500 w-6 h-6 mt-1 shrink-0" /> <span className="text-slate-200">Charge mentale : Suivre 22 joueurs + ballon simultan√©ment.</span></li>
                                <li className="flex gap-4"><X className="text-red-500 w-6 h-6 mt-1 shrink-0" /> <span className="text-slate-200">Burnout : 60% des analystes touch√©s apr√®s 2-3 ans.</span></li>
                                <li className="flex gap-4"><X className="text-red-500 w-6 h-6 mt-1 shrink-0" /> <span className="text-slate-200">Isolement social et anxi√©t√© de performance.</span></li>
                            </ul>
                        </div>
                    </div>
                </Slide>

                {/* SLIDE 7: Professional Deadlock (Scale) */}
                <Slide active={currentSlide === 6} className="bg-white text-black">
                    <h2 className="text-4xl font-bold mb-12 text-center font-oswald uppercase">L'Impasse Professionnelle : Beaucoup d'Efforts, Peu de Retour</h2>

                    <div className="flex-1 flex flex-col items-center justify-center overflow-hidden">

                        <div className="relative w-full max-w-2xl h-64 mb-16">
                            <svg viewBox="0 0 400 300" className="w-full h-full drop-shadow-xl overflow-visible">
                                {/* Base Stand */}
                                <rect x="195" y="100" width="10" height="150" rx="2" fill="#334155" />
                                <rect x="150" y="250" width="100" height="10" rx="2" fill="#1e293b" />

                                {/* Rotating Beam Assembly */}
                                <g transform="rotate(12, 200, 100)">
                                    {/* Main Beam */}
                                    <rect x="50" y="95" width="300" height="10" rx="2" fill="#1e293b" />

                                    {/* Pivot Point */}
                                    <circle cx="200" cy="100" r="8" fill="#475569" stroke="#1e293b" strokeWidth="2" />

                                    {/* Left Pan (Heavy) - Hanging down vertically regardless of beam angle */}
                                    <g transform="translate(60, 100)">
                                        {/* Counter-rotate to keep vertical */}
                                        <g transform="rotate(-12)">
                                            <line x1="0" y1="0" x2="0" y2="100" stroke="#94a3b8" strokeWidth="2" />
                                            <circle cx="0" cy="130" r="45" fill="#1e293b" className="drop-shadow-lg" />
                                            <text x="0" y="125" textAnchor="middle" fill="#cbd5e1" fontSize="10" letterSpacing="2" fontWeight="bold">EFFORT</text>
                                            <text x="0" y="145" textAnchor="middle" fill="white" fontSize="14" fontWeight="bold">60h/sem</text>
                                        </g>
                                    </g>

                                    {/* Right Pan (Light) - Hanging down vertically */}
                                    <g transform="translate(340, 100)">
                                        {/* Counter-rotate to keep vertical */}
                                        <g transform="rotate(-12)">
                                            <line x1="0" y1="0" x2="0" y2="80" stroke="#94a3b8" strokeWidth="2" />
                                            <circle cx="0" cy="105" r="35" fill="#ecfdf5" stroke="#16a34f" strokeWidth="3" className="drop-shadow-lg" />
                                            <text x="0" y="110" textAnchor="middle" fill="#166534" fontSize="10" fontWeight="bold" letterSpacing="1">RETOUR</text>
                                        </g>
                                    </g>
                                </g>
                            </svg>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 w-full max-w-5xl">
                            <div className="border border-red-200 p-6 bg-red-50 rounded-lg">
                                <DollarSign className="text-red-600 mb-3" />
                                <h4 className="font-bold text-lg mb-2">Salaire R√©el</h4>
                                <p className="text-sm text-slate-700">25-35K‚Ç¨ pour 60h/sem = 8-11‚Ç¨/heure r√©elle.</p>
                            </div>
                            <div className="border border-red-200 p-6 bg-red-50 rounded-lg">
                                <Scale className="text-red-600 mb-3" />
                                <h4 className="font-bold text-lg mb-2">Pr√©carit√©</h4>
                                <p className="text-sm text-slate-700">CDD d'un an, licenciement facile. Pas de s√©curit√©.</p>
                            </div>
                            <div className="border border-red-200 p-6 bg-red-50 rounded-lg">
                                <DollarSign className="text-red-600 mb-3" />
                                <h4 className="font-bold text-lg mb-2">Investissement</h4>
                                <p className="text-sm text-slate-700">Abonnements personnels, mat√©riel propre (~1500‚Ç¨).</p>
                            </div>
                            <div className="border border-red-200 p-6 bg-red-50 rounded-lg">
                                <GraduationCap className="text-red-600 mb-3" />
                                <h4 className="font-bold text-lg mb-2">Plafond</h4>
                                <p className="text-sm text-slate-700">Consid√©r√© comme 'technicien', pas d'√©volution coaching.</p>
                            </div>
                        </div>
                    </div>
                </Slide>

                {/* SLIDE 8: Top 10 Killers */}
                <Slide active={currentSlide === 7} className="bg-white text-black">
                    <h2 className="text-4xl font-bold mb-8 font-oswald uppercase text-center">Les 'Top 10 Killers' : Les Menaces Critiques</h2>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-x-16 gap-y-6 max-w-5xl mx-auto items-center h-full pb-10">
                        <div className="space-y-4">
                            {[
                                { icon: Timer, title: "Charge de travail 60-70h", sub: "(Insoutenable)" },
                                { icon: DollarSign, title: "Salaire faible vs temps", sub: "(Pr√©carit√©)" },
                                { icon: Brain, title: "Fatigue mentale √©puisante", sub: "(Risque d'erreur)" },
                                { icon: Wrench, title: "Outils archa√Øques et lents", sub: "(Frustration)" },
                                { icon: Shield, title: "Manque de reconnaissance", sub: "(Invisibilit√©)" },
                            ].map((item, i) => (
                                <div key={i} className="flex items-center gap-4 p-4 hover:bg-slate-50 rounded-lg transition border border-transparent hover:border-slate-100 shadow-sm">
                                    <div className="text-4xl font-black text-red-600 w-12 text-center font-oswald">{i + 1}</div>
                                    <item.icon className="text-slate-400 w-8 h-8" strokeWidth={1.5} />
                                    <div>
                                        <div className="font-bold text-lg">{item.title}</div>
                                        <div className="text-red-600 text-sm font-semibold">{item.sub}</div>
                                    </div>
                                </div>
                            ))}
                        </div>
                        <div className="space-y-4">
                            {[
                                { icon: Recycle, title: "T√¢ches r√©p√©titives abrutissantes", sub: "" },
                                { icon: Scale, title: "Pr√©carit√© contractuelle", sub: "" },
                                { icon: GraduationCap, title: "Absence de formation acad√©mique", sub: "" },
                                { icon: Bot, title: "Menace d'automatisation IA", sub: "(Obsolescence)" },
                                { icon: Building, title: "Isolement professionnel", sub: "" },
                            ].map((item, i) => (
                                <div key={i} className="flex items-center gap-4 p-4 hover:bg-slate-50 rounded-lg transition border border-transparent hover:border-slate-100 shadow-sm">
                                    <div className="text-4xl font-black text-red-600 w-12 text-center font-oswald">{i + 6}</div>
                                    <item.icon className="text-slate-400 w-8 h-8" strokeWidth={1.5} />
                                    <div>
                                        <div className="font-bold text-lg">{item.title}</div>
                                        {item.sub && <div className="text-red-600 text-sm font-semibold">{item.sub}</div>}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </Slide>

                {/* SLIDE 9: What Tech Cannot Solve */}
                <Slide active={currentSlide === 8} className="bg-white text-black">
                    <h2 className="text-4xl font-bold mb-4 font-oswald uppercase">Ce que la Technologie NE PEUT PAS R√©soudre</h2>
                    <p className="text-2xl text-slate-500 mb-12 font-oswald uppercase">(La Liste Impossible)</p>

                    <div className="bg-slate-100 p-10 border-l-8 border-slate-400 shadow-inner max-w-4xl mx-auto rounded-r-lg">
                        <h3 className="text-2xl font-bold mb-8 text-slate-700">94 probl√®mes (66%) sont structurels et hors de contr√¥le.</h3>
                        <ul className="space-y-6 text-xl">
                            <li className="flex items-center gap-4"><X className="text-slate-400" /> Salaires et Contrats : D√©cisions des clubs.</li>
                            <li className="flex items-center gap-4"><X className="text-slate-400" /> Ego des Coachs et Joueurs.</li>
                            <li className="flex items-center gap-4"><X className="text-slate-400" /> March√© de l'emploi : Saturation.</li>
                            <li className="flex items-center gap-4"><X className="text-slate-400" /> Cadre Juridique : RGPD et droits TV.</li>
                            <li className="flex items-center gap-4"><X className="text-slate-400" /> Reconnaissance Hi√©rarchique.</li>
                        </ul>
                    </div>

                    <div className="mt-auto text-3xl font-black text-center border-t-2 border-black pt-8 max-w-3xl mx-auto">
                        Aucun logiciel ne peut changer la culture du football.
                    </div>
                </Slide>

                {/* SLIDE 10: Addressable Chaos */}
                <Slide active={currentSlide === 9} className="bg-white text-black">
                    <h2 className="text-4xl font-bold mb-16 font-oswald uppercase">Le Chaos Adressable : Les <span className="text-green-600">34%</span> qui Changent Tout</h2>

                    <div className="flex flex-col md:flex-row items-center justify-center gap-16 flex-1 max-w-5xl mx-auto w-full">
                        <div className="relative w-72 h-72 rounded-full" style={{ background: 'conic-gradient(#16a34f 0% 34%, #e2e8f0 34% 100%)' }}>
                            <div className="absolute inset-4 bg-white rounded-full flex flex-col items-center justify-center shadow-inner">
                                <span className="text-5xl font-bold text-green-600 font-oswald">34%</span>
                                <span className="text-sm font-bold text-center mt-2 uppercase tracking-wide px-4">Probl√®mes Solubles</span>
                            </div>
                        </div>

                        <div className="space-y-6 w-full max-w-md">
                            <div className="border-l-4 border-green-600 pl-6 py-2 bg-green-50 rounded-r">
                                <h4 className="font-bold text-green-800 text-xl font-oswald">Technique</h4>
                                <p className="text-slate-700">Stabilit√©, co√ªt, mobilit√©.</p>
                            </div>
                            <div className="border-l-4 border-green-600 pl-6 py-2 bg-green-50 rounded-r">
                                <h4 className="font-bold text-green-800 text-xl font-oswald">Temporel</h4>
                                <p className="text-slate-700">Automatisation, vitesse d'export.</p>
                            </div>
                            <div className="border-l-4 border-green-600 pl-6 py-2 bg-green-50 rounded-r">
                                <h4 className="font-bold text-green-800 text-xl font-oswald">Cognitif</h4>
                                <p className="text-slate-700">Ergonomie, r√©duction de charge mentale.</p>
                            </div>
                            <div className="pt-4 text-green-700 font-bold flex items-center gap-2">
                                <CheckCircle size={20} />
                                48 probl√®mes solubles par TACTA
                            </div>
                        </div>
                    </div>
                </Slide>

                {/* SLIDE 11: TACTA Intro */}
                <Slide active={currentSlide === 10} className="bg-white text-black items-center justify-center text-center">
                    <h2 className="text-6xl font-bold mb-12 font-oswald uppercase">TACTA</h2>
                    <h3 className="text-2xl font-light mb-16 uppercase tracking-widest text-slate-500">Une Campagne pour le Temps et la Dignit√©</h3>

                    <div className="flex items-center justify-center gap-12 mb-16 relative">
                        <div className="w-64 h-40 bg-slate-200 rounded-3xl shadow-2xl skew-y-3 transform hover:scale-105 transition duration-500 relative overflow-hidden flex items-center justify-center">
                            <Gamepad2 size={80} className="text-slate-700" />
                            <div className="absolute top-4 left-4 w-4 h-4 bg-red-500 rounded-full animate-pulse"></div>
                        </div>
                    </div>

                    <div className="max-w-3xl mx-auto space-y-4">
                        <p className="text-2xl text-slate-700">Ce n'est pas juste un logiciel d'analyse.</p>
                        <p className="text-2xl font-bold text-black group">
                            C'est un <span className="underline decoration-green-500 underline-offset-4">antidote</span> aux t√¢ches chronophages.
                        </p>
                    </div>

                    <div className="mt-16 text-4xl font-black font-oswald uppercase animate-bounce">
                        Moins de friction = <span className="text-green-600">Plus de vision.</span>
                    </div>
                </Slide>

                {/* SLIDE 12: Technical Response */}
                <Slide active={currentSlide === 11} className="bg-slate-50 text-black">
                    <h2 className="text-4xl font-bold mb-12 text-center font-oswald uppercase">La R√©ponse Technique</h2>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-6xl mx-auto w-full flex-1">
                        {/* Before */}
                        <div className="bg-white border-2 border-red-100 rounded-xl p-8 shadow-sm flex flex-col relative overflow-hidden">
                            <div className="absolute top-0 left-0 w-full h-2 bg-red-400"></div>
                            <h3 className="text-2xl font-bold mb-8 text-center text-red-800 uppercase font-oswald">Avant</h3>
                            <div className="flex-1 flex flex-col items-center justify-center gap-6 mb-8 text-slate-300">
                                <Tablet size={80} />
                                <Server size={60} />
                            </div>
                            <ul className="space-y-4">
                                <li className="flex items-center gap-3 font-medium text-red-900"><X className="text-red-500 w-5 h-5" /> Tablette √† 800‚Ç¨ + Setup lourd</li>
                                <li className="flex items-center gap-3 font-medium text-red-900"><X className="text-red-500 w-5 h-5" /> Interface complexe (200 boutons)</li>
                                <li className="flex items-center gap-3 font-medium text-red-900"><X className="text-red-500 w-5 h-5" /> Crashes et instabilit√©</li>
                            </ul>
                        </div>

                        {/* After (Tacta) */}
                        <div className="bg-white border-2 border-green-100 rounded-xl p-8 shadow-lg flex flex-col relative overflow-hidden transform md:scale-105 transition">
                            <div className="absolute top-0 left-0 w-full h-2 bg-green-500"></div>
                            <h3 className="text-2xl font-bold mb-8 text-center text-green-700 uppercase font-oswald">TACTA</h3>
                            <div className="flex-1 flex flex-col items-center justify-center gap-6 mb-8 text-green-600">
                                <Gamepad2 size={100} strokeWidth={1.5} />
                            </div>
                            <ul className="space-y-4">
                                <li className="flex items-center gap-3 font-bold text-green-900"><Check className="text-green-500 w-5 h-5" /> Manette √† 60‚Ç¨ (Ergonomie)</li>
                                <li className="flex items-center gap-3 font-bold text-green-900"><Check className="text-green-500 w-5 h-5" /> Interface √©pur√©e (15 boutons)</li>
                                <li className="flex items-center gap-3 font-bold text-green-900"><Check className="text-green-500 w-5 h-5" /> SaaS Cloud / Z√©ro install</li>
                            </ul>
                        </div>
                    </div>

                    <div className="mt-12 text-center text-slate-500 font-mono text-sm uppercase tracking-widest">
                        Stockage Cloud inclus ‚Ä¢ Pas de 'Tooling Tax' ‚Ä¢ Automatisation
                    </div>
                </Slide>

                {/* SLIDE 13: Time Response */}
                <Slide active={currentSlide === 12} className="bg-white text-black">
                    <h2 className="text-4xl font-bold mb-16 text-center font-oswald uppercase">La R√©ponse Temporelle : <span className="text-green-600 bg-green-50 px-2 rounded">-36%</span> de Temps</h2>

                    <div className="flex flex-col md:flex-row items-center justify-center gap-20 flex-1 max-w-6xl mx-auto">
                        {/* Circle Chart */}
                        <div className="relative w-80 h-80 drop-shadow-2xl">
                            <svg className="w-full h-full transform -rotate-90" viewBox="0 0 100 100">
                                <defs>
                                    <linearGradient id="chartGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" stopColor="#4ade80" />
                                        <stop offset="100%" stopColor="#16a34f" />
                                    </linearGradient>
                                    <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                                        <feDropShadow dx="0" dy="2" stdDeviation="2" floodOpacity="0.3" />
                                    </filter>
                                </defs>
                                {/* Track */}
                                <circle cx="50" cy="50" r="42" fill="none" stroke="#f1f5f9" strokeWidth="8" strokeLinecap="round" />
                                {/* Progress */}
                                <circle
                                    cx="50" cy="50" r="42"
                                    fill="none"
                                    stroke="url(#chartGradient)"
                                    strokeWidth="8"
                                    strokeDasharray="263.89"
                                    strokeDashoffset={263.89 * 0.64}
                                    strokeLinecap="round"
                                    filter="url(#shadow)"
                                />
                            </svg>
                            <div className="absolute inset-0 flex flex-col items-center justify-center">
                                <span className="text-5xl font-bold text-green-600 font-oswald">-36%</span>
                                <span className="text-xs text-slate-400 mt-2 uppercase">Temps de travail</span>
                            </div>
                            <div className="absolute -top-4 -right-4 bg-slate-100 text-slate-600 px-3 py-1 text-xs font-bold rounded-full border border-slate-200">55h Avant</div>
                            <div className="absolute bottom-4 -left-4 bg-green-100 text-green-800 px-3 py-1 text-xs font-bold rounded-full border border-green-200">35h Apr√®s</div>
                        </div>

                        <div className="space-y-8 max-w-lg">
                            <div>
                                <h4 className="text-xl font-bold text-green-700 flex items-center gap-2 mb-2"><CheckCircle size={24} /> Un m√©tier √† 35h</h4>
                                <p className="text-slate-600 ml-8">Passage de semaines "Survivor" √† des semaines humaines.</p>
                            </div>
                            <div>
                                <h4 className="text-xl font-bold text-green-700 flex items-center gap-2 mb-2"><CheckCircle size={24} /> Post-Match / 2</h4>
                                <p className="text-slate-600 ml-8">De 10h √† 5h d'analyse. Rentrez dormir.</p>
                            </div>

                            <div className="bg-slate-50 p-6 rounded-lg border border-slate-100">
                                <h4 className="font-bold text-slate-900 mb-3 uppercase text-sm tracking-wide">Comment ?</h4>
                                <ul className="space-y-2 text-slate-700 text-sm">
                                    <li className="flex gap-2"><span>1.</span> Automatisation des t√¢ches r√©p√©titives.</li>
                                    <li className="flex gap-2"><span>2.</span> Codage Live = D√©finitif (Fin du double travail).</li>
                                    <li className="flex gap-2"><span>3.</span> Exports instantan√©s.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </Slide>

                {/* SLIDE 14: Physical & Cognitive Response */}
                <Slide active={currentSlide === 13} className="bg-white text-black">
                    <h2 className="text-4xl font-bold mb-12 text-center font-oswald uppercase">La R√©ponse Physique et Cognitive</h2>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-12 max-w-6xl mx-auto flex-1 h-full items-center">
                        <div className="flex flex-col items-center text-center p-8 bg-slate-50 rounded-2xl">
                            <div className="w-24 h-24 bg-green-100 rounded-full flex items-center justify-center mb-6 text-green-600">
                                <HeartPulse size={40} />
                            </div>
                            <h3 className="font-bold text-2xl mb-4 font-oswald uppercase">Sant√© (Physique)</h3>
                            <p className="text-slate-600 mb-6 leading-relaxed">
                                L'ergonomie de la manette permet de travailler le dos droit, les yeux sur le terrain, pas sur un √©cran tactile.
                            </p>
                            <div className="text-sm font-bold text-green-700 bg-green-100 px-4 py-2 rounded-full">
                                Adieu Canal Carpien
                            </div>
                        </div>

                        <div className="flex flex-col items-center text-center p-8 bg-slate-50 rounded-2xl">
                            <div className="w-24 h-24 bg-blue-100 rounded-full flex items-center justify-center mb-6 text-blue-600">
                                <Brain size={40} />
                            </div>
                            <h3 className="font-bold text-2xl mb-4 font-oswald uppercase">Mental (Cognitif)</h3>
                            <p className="text-slate-600 mb-6 leading-relaxed">
                                L'automatisation g√®re le "bruit". Vous ne d√©cidez plus "o√π cliquer", mais "quoi taguer". Charge mentale -50%.
                            </p>
                            <div className="text-sm font-bold text-blue-700 bg-blue-100 px-4 py-2 rounded-full">
                                Lucidit√© Pr√©serv√©e
                            </div>
                        </div>
                    </div>
                </Slide>

                {/* SLIDE 15: True Value */}
                <Slide active={currentSlide === 14} className="bg-white text-black items-center justify-center">
                    <h2 className="text-4xl font-bold mb-4 font-oswald uppercase text-slate-800">La Vraie Valeur</h2>
                    <div className="text-[12rem] leading-none font-black text-green-600 mb-8 drop-shadow-2xl font-oswald">20h</div>
                    <p className="text-2xl mb-16 text-slate-500 font-light">Lib√©r√©es par semaine.</p>

                    <div className="grid grid-cols-2 md:grid-cols-4 gap-8 w-full max-w-5xl">
                        {[
                            { icon: BookOpen, text: "Se former et apprendre" },
                            { icon: MessageCircle, text: "Parler aux joueurs" },
                            { icon: HeartPulse, text: "Dormir et r√©cup√©rer" },
                            { icon: Crown, text: "Strat√©gie > M√©canique" }
                        ].map((item, i) => (
                            <div key={i} className="flex flex-col items-center gap-4 p-6 bg-slate-50 rounded-xl hover:bg-slate-100 transition duration-300">
                                <item.icon className="text-green-600 w-10 h-10" />
                                <p className="font-bold text-center text-slate-700">{item.text}</p>
                            </div>
                        ))}
                    </div>
                </Slide>

                {/* SLIDE 16: Future Proofing */}
                <Slide active={currentSlide === 15} className="bg-white text-black">
                    <h2 className="text-4xl font-bold mb-16 text-center font-oswald uppercase">S√©curiser l'Avenir face √† l'IA</h2>

                    <div className="flex flex-col md:flex-row items-center justify-center gap-12 flex-1 max-w-6xl mx-auto">
                        {/* Old Way */}
                        <div className="flex flex-col items-center opacity-40 hover:opacity-100 transition duration-500 group">
                            <h3 className="text-xl font-bold mb-4 uppercase text-slate-500">L'Ex√©cutant</h3>
                            <Bot size={80} className="text-red-500 mb-4" />
                            <div className="bg-red-100 text-red-800 px-3 py-1 rounded-full text-xs font-bold mb-4">Remplac√© dans 3 ans</div>
                            <p className="text-center text-sm text-slate-500 max-w-[200px]">Celui qui clique manuellement pour taguer des passes.</p>
                        </div>

                        <ArrowRight size={40} className="text-slate-300 hidden md:block" />

                        {/* New Way */}
                        <div className="flex flex-col items-center transform scale-110">
                            <h3 className="text-2xl font-bold mb-4 uppercase text-green-700">Le Strat√®ge</h3>
                            <div className="w-40 h-40 bg-green-50 border-4 border-green-500 rounded-full flex items-center justify-center shadow-2xl shadow-green-100 mb-6">
                                <Shield size={60} className="text-green-600" />
                            </div>
                            <div className="bg-green-100 text-green-800 px-3 py-1 rounded-full text-xs font-bold mb-4">Futur Assur√©</div>
                            <p className="text-center text-sm text-slate-700 max-w-[250px] font-bold">Celui qui interpr√®te la donn√©e et conseille le coach.</p>
                        </div>
                    </div>

                    <div className="mt-16 bg-slate-100 p-6 rounded-lg max-w-2xl mx-auto text-center">
                        <p className="text-lg text-slate-700">
                            <span className="font-bold">Transition :</span> Ne soyez pas celui qui clique 800 fois. Soyez celui qui gagne le match.
                        </p>
                    </div>
                </Slide>

                {/* SLIDE 17: Final */}
                <Slide active={currentSlide === 16} className="bg-black text-white items-center justify-center text-center">
                    <div className="mb-8 w-20 h-20 bg-green-600 rounded flex items-center justify-center font-bold text-4xl mx-auto">T</div>
                    <h2 className="text-5xl md:text-7xl font-bold mb-8 font-oswald uppercase tracking-tight">TACTA</h2>
                    <h3 className="text-2xl md:text-4xl font-light mb-16 text-slate-400">Le Pont vers une Carri√®re Durable.</h3>

                    <button onClick={() => setCurrentSlide(0)} className="px-8 py-4 bg-white text-black font-bold uppercase tracking-widest hover:bg-green-500 hover:text-white transition duration-300 rounded">
                        Recommencer
                    </button>
                </Slide>

            </main>
        </div>
    );
};

export default AnalystAudit;
</file>

<file path="src/pages/Analytics.tsx">
import { useState, useMemo } from "react";
import { useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Progress } from "@/components/ui/progress";
import {
    ArrowLeft,
    BarChart2,
    Target,
    ArrowRightLeft,
    Shield,
    Zap,
    TrendingUp,
    Activity,
    Crosshair,
    AlertTriangle,
    Timer,
    Users,
    Footprints,
    Flag,
    CircleDot,
    Repeat,
    Eye,
    Brain,
    ChevronRight,
    Search,
    Database,
    Layers,
    Shuffle
} from "lucide-react";
import { useMatchContext } from "@/contexts/MatchContext";
import { AnalysisMode } from "@/components/AnalysisModeSelector";
import { LoggedEvent } from "@/hooks/useGamepad";

// ============================================================================
// PROFESSIONAL KPI ENGINE - CLUB STANDARDS (GUIDE COMPLIANT)
// ============================================================================

interface TeamKPIs {
    // 1. OFF-BALL MOVEMENT
    offBallRuns: number;
    overlaps: number;
    underlaps: number;
    thirdManRuns: number;
    dummyRuns: number;
    runsPerPossession: number; // Metric
    offBallImpactIndex: number; // KPI (0-100)
    spaceCreationEfficiency: number; // KPI (0-100)

    // 2. SPACE CREATION & OCCUPATION (Derived from spatial events)
    zoneEntriesFinalThird: number;
    centralPenetrations: number;
    halfSpaceOccupation: number; // %
    centralThreatIndex: number; // KPI (0-100)
    widthStretchScore: number; // KPI (0-100)

    // 3. QUALITY CONTROL & AI
    aiPrecisionRate: number; // %
    analystAgreementRate: number; // %
    aiReliabilityScore: number; // KPI (0-100)
    dataTrustIndex: number; // KPI (0-100)

    // 4. OUTCOME & PERFORMANCE
    chancesCreated: number;
    keyPasses: number;
    xG: number;
    passCompletion: number;
    attackingProductivity: number; // KPI (0-100)
    gameControlIndex: number; // KPI (0-100)

    // 5. SITUATIONAL ANALYSIS
    overloadsCreated: number;
    defensiveImbalance: number;
    tacticalSuperiorityIndex: number; // KPI (0-100)
    chaosCreationRating: number; // KPI (0-100)

    // 6. SPECIALIZED TACTICAL
    pressResistanceSuccess: number;
    restDefenseIntegrity: number; // KPI (0-100)
    pressResistanceIndex: number; // KPI (0-100)

    // 7. HYBRID EVENTS
    offsideFrequency: number;
    tacticalFouls: number;
    switchSuccess: number;
    fieldExploitationAbility: number; // KPI (0-100)

    // 8. GLOBAL COMPOSITE KPIs (Executive)
    tacticalControlIndex: number; // 0-100
    attackingEfficiencyIndex: number; // 0-100
    defensiveOrganizationScore: number; // 0-100
    teamIntelligenceRating: number; // 0-100

    // RAW COUNTS (Legacy/Foundation)
    goals: number;
    shots: number;
    shotsOnTarget: number;
    passes: number;
    tackles: number;
    interceptions: number;
    clearances: number;
    duelsWon: number;
    duelsLost: number;
    fouls: number;
    cardsYellow: number;
    cardsRed: number;
    corners: number;
    possessionWon: number;
    possessionLost: number;
    // Additional metrics
    switchesOfPlay: number;
    turnoversWon: number;
    pressTraps: number;
    carries: number;
}

const createEmptyKPIs = (): TeamKPIs => ({
    offBallRuns: 0, overlaps: 0, underlaps: 0, thirdManRuns: 0, dummyRuns: 0,
    runsPerPossession: 0, offBallImpactIndex: 0, spaceCreationEfficiency: 0,
    zoneEntriesFinalThird: 0, centralPenetrations: 0, halfSpaceOccupation: 0, centralThreatIndex: 0, widthStretchScore: 0,
    aiPrecisionRate: 0, analystAgreementRate: 0, aiReliabilityScore: 0, dataTrustIndex: 0,
    chancesCreated: 0, keyPasses: 0, xG: 0, passCompletion: 0, attackingProductivity: 0, gameControlIndex: 0,
    overloadsCreated: 0, defensiveImbalance: 0, tacticalSuperiorityIndex: 0, chaosCreationRating: 0,
    pressResistanceSuccess: 0, restDefenseIntegrity: 0, pressResistanceIndex: 0,
    offsideFrequency: 0, tacticalFouls: 0, switchSuccess: 0, fieldExploitationAbility: 0,
    tacticalControlIndex: 0, attackingEfficiencyIndex: 0, defensiveOrganizationScore: 0, teamIntelligenceRating: 0,
    goals: 0, shots: 0, shotsOnTarget: 0, passes: 0, tackles: 0, interceptions: 0, clearances: 0,
    duelsWon: 0, duelsLost: 0, fouls: 0, cardsYellow: 0, cardsRed: 0, corners: 0, possessionWon: 0, possessionLost: 0,
    switchesOfPlay: 0, turnoversWon: 0, pressTraps: 0, carries: 0
});

const calculateKPIs = (events: LoggedEvent[], team: "TEAM_A" | "TEAM_B"): TeamKPIs => {
    const kpis = createEmptyKPIs();
    const teamEvents = events.filter(e => e.team === team);

    // 1. Raw Data Aggregation
    teamEvents.forEach(e => {
        const n = e.eventName;
        // Basic Stats
        if (n.includes('pass')) kpis.passes++;
        if (n.includes('shot')) kpis.shots++;
        if (n === 'shot_outcome') kpis.shotsOnTarget++;
        if (n === 'goal') { kpis.goals++; kpis.xG += 0.8; } // Simplified xG
        if (n === 'tackle_success' || n === 'duel_won') kpis.duelsWon++;
        if (n === 'duel_lost') kpis.duelsLost++;
        if (n === 'interception') kpis.interceptions++;
        if (n === 'clearance') kpis.clearances++;
        if (n === 'foul') kpis.fouls++;
        if (n === 'card_yellow') kpis.cardsYellow++;
        if (n === 'corner') kpis.corners++;

        // Advanced Tags (if present)
        if (n === 'off_ball_run') kpis.offBallRuns++;
        if (n === 'overlap') kpis.overlaps++;
        if (n === 'underlap') kpis.underlaps++;
        if (n === 'third_man') kpis.thirdManRuns++;
        if (n === 'dummy_run') kpis.dummyRuns++;
        if (n === 'key_pass') kpis.keyPasses++;
        if (n === 'chance_created') kpis.chancesCreated++;
        if (n === 'final_third_entry') kpis.zoneEntriesFinalThird++;
        if (n === 'central_penetration') kpis.centralPenetrations++;
        if (n === 'possession_won') kpis.possessionWon++;
        if (n === 'possession_lost') kpis.possessionLost++;
    });

    // 2. Metric Calculation (Derived)
    const totalDuels = kpis.duelsWon + kpis.duelsLost;
    const duelSuccess = totalDuels > 0 ? kpis.duelsWon / totalDuels : 0.5;

    // 3. KPI Indices Calculation (Weighted Algorithms to simulate pro metrics)

    // Off-Ball Impact: Weighted sum of runs + outcome
    kpis.offBallImpactIndex = Math.min(100, Math.round((kpis.offBallRuns * 5 + kpis.overlaps * 8 + kpis.thirdManRuns * 10) / 2));
    kpis.spaceCreationEfficiency = Math.min(100, Math.round((kpis.dummyRuns * 12 + kpis.widthStretchScore * 0.5) + 50));

    // Space Creation
    kpis.centralThreatIndex = Math.min(100, Math.round((kpis.centralPenetrations * 15 + kpis.xG * 10)));
    kpis.widthStretchScore = Math.min(100, Math.round((kpis.switchesOfPlay * 10 + kpis.overlaps * 5)));

    // Quality Control (Real Data from Event Quality Ratings)
    const ratedEvents = teamEvents.filter(e => e.qualityRating);
    const avgQuality = ratedEvents.length > 0
        ? ratedEvents.reduce((acc, e) => acc + (e.qualityRating || 0), 0) / ratedEvents.length
        : 0;

    // Normalize 5-star rating to 0-100 scale
    // If no ratings, default to 0 (or N/A behavior in UI)
    kpis.aiPrecisionRate = ratedEvents.length > 0 ? Math.round((avgQuality / 5) * 100) : 0;

    // Analyst Agreement - Placeholder for when we have multiple taggers
    // For now, if events exist and are validated, we assume agreement
    const validatedEvents = teamEvents.filter(e => e.isValidated);
    kpis.analystAgreementRate = teamEvents.length > 0
        ? Math.round((validatedEvents.length / teamEvents.length) * 100)
        : 100;

    // AI Reliability Score based on validation rate
    // If we have validated events, reliability goes up
    const validationRate = teamEvents.length > 0 ? (validatedEvents.length / teamEvents.length) : 0;
    kpis.aiReliabilityScore = Math.round(50 + (validationRate * 50)); // Base 50 + up to 50 for validation

    // Data Trust Index based on sample size (e.g., need > 50 events for high trust)
    const sampleConfidence = Math.min(100, (teamEvents.length / 50) * 100);
    kpis.dataTrustIndex = Math.round((sampleConfidence + kpis.aiReliabilityScore) / 2);

    // Outcome & Performance
    kpis.attackingProductivity = Math.min(100, Math.round((kpis.xG * 20 + kpis.chancesCreated * 10 + kpis.shotsOnTarget * 5)));
    kpis.gameControlIndex = Math.min(100, Math.round((kpis.passes * 0.1) + (duelSuccess * 50) + (kpis.possessionWon * 2)));

    // Situational
    kpis.tacticalSuperiorityIndex = Math.min(100, Math.round(50 + (kpis.goals * 10) - (kpis.fouls * 2) + (kpis.turnoversWon * 3)));

    // Executive Global KPIs
    kpis.tacticalControlIndex = Math.round((kpis.gameControlIndex + kpis.tacticalSuperiorityIndex) / 2);
    kpis.attackingEfficiencyIndex = Math.min(100, Math.round((kpis.goals * 30 + kpis.xG * 20) / (kpis.shots || 1) * 100));
    kpis.defensiveOrganizationScore = Math.min(100, Math.round((kpis.interceptions * 5 + kpis.clearances * 2 + duelSuccess * 40)));
    kpis.teamIntelligenceRating = Math.min(100, Math.round((kpis.offBallRuns * 2 + kpis.pressTraps * 5 + kpis.dummyRuns * 10 + 50)));

    // New Calculations
    kpis.runsPerPossession = kpis.possessionWon > 0
        ? parseFloat((kpis.offBallRuns / kpis.possessionWon).toFixed(2))
        : 0;

    const hsEvents = teamEvents.filter(e => e.corridor === 'LHS' || e.corridor === 'RHS').length;
    kpis.halfSpaceOccupation = teamEvents.length > 0
        ? Math.round((hsEvents / teamEvents.length) * 100)
        : 0;

    return kpis;
};

// ============================================================================
// MAIN COMPONENT
// ============================================================================

export default function Analytics() {
    const navigate = useNavigate();
    const { events, teams } = useMatchContext();
    const [mode, setMode] = useState<AnalysisMode>('LIVE');

    const teamNames = {
        teamA: Array.from(teams.keys())[0] || "Team A",
        teamB: Array.from(teams.keys())[1] || "Team B"
    };

    const kpisA = useMemo(() => calculateKPIs(events, "TEAM_A"), [events]);
    const kpisB = useMemo(() => calculateKPIs(events, "TEAM_B"), [events]);
    const totalEvents = events.length;

    // Simple Possession Calc
    const teamAEvents = events.filter(e => e.team === "TEAM_A").length;
    const possession = totalEvents > 0 ? Math.round((teamAEvents / totalEvents) * 100) : 50;

    return (
        <div className="min-h-screen bg-slate-950 text-slate-50">
            {/* Header */}
            <header className="border-b border-white/10 bg-slate-900/80 backdrop-blur-sm px-4 py-1.5 sticky top-0 z-50">
                <div className="flex items-center justify-between max-w-7xl mx-auto">
                    <div className="flex items-center gap-2">
                        <Button variant="ghost" size="sm" className="h-7 w-7 p-0 hover:bg-white/10" onClick={() => navigate('/')}>
                            <ArrowLeft className="w-4 h-4" />
                        </Button>
                        <div className="flex items-center gap-2">
                            <BarChart2 className="w-4 h-4 text-emerald-400" />
                            <span className="text-sm font-bold tracking-tight">ProAnalytics Suite</span>
                            <Badge variant="outline" className="text-[10px] h-5 border-white/20 text-slate-400">
                                {totalEvents} events
                            </Badge>
                        </div>
                    </div>

                    <div className="flex items-center gap-1 bg-slate-800/50 p-0.5 rounded-lg border border-white/5">
                        <Button
                            variant={mode === 'LIVE' ? 'secondary' : 'ghost'}
                            size="sm"
                            className={`h-6 text-[10px] px-3 ${mode === 'LIVE' ? 'bg-red-500/20 text-red-400 hover:bg-red-500/30' : 'text-slate-400'}`}
                            onClick={() => setMode('LIVE')}
                        >
                            ‚ö° LIVE
                        </Button>
                        <Button
                            variant={mode === 'POST_MATCH' ? 'secondary' : 'ghost'}
                            size="sm"
                            className={`h-6 text-[10px] px-3 ${mode === 'POST_MATCH' ? 'bg-emerald-500/20 text-emerald-400 hover:bg-emerald-500/30' : 'text-slate-400'}`}
                            onClick={() => setMode('POST_MATCH')}
                        >
                            üìä POST
                        </Button>
                    </div>
                </div>
            </header>

            {/* Main Content */}
            <main className="max-w-7xl mx-auto p-4 space-y-6">

                {/* Score & Possession Bar (Always Visible) */}
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <ScoreCard team={teamNames.teamA} goals={kpisA.goals} xg={kpisA.xG} color="blue" />
                    <PossessionBar possessionA={possession} />
                    <ScoreCard team={teamNames.teamB} goals={kpisB.goals} xg={kpisB.xG} color="red" isRight />
                </div>

                {/* ================= LIVE MODE ================= */}
                {mode === 'LIVE' && (
                    <div className="space-y-4 animate-in fade-in duration-300">
                        <div className="flex items-center justify-between">
                            <h2 className="text-xl font-bold flex items-center gap-2">
                                <Activity className="w-5 h-5 text-red-500" /> Real-Time Feed
                            </h2>
                            <Badge className="bg-red-500/10 text-red-400 border-red-500/20 animate-pulse">‚óè Live Recording</Badge>
                        </div>

                        <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-3">
                            <LiveMetricCard label="Passes" valA={kpisA.passes} valB={kpisB.passes} />
                            <LiveMetricCard label="Shots" valA={kpisA.shots} valB={kpisB.shots} />
                            <LiveMetricCard label="Duels" valA={kpisA.duelsWon} valB={kpisB.duelsWon} />
                            <LiveMetricCard label="Tackles" valA={kpisA.tackles} valB={kpisB.tackles} />
                            <LiveMetricCard label="Intcpt" valA={kpisA.interceptions} valB={kpisB.interceptions} />
                            <LiveMetricCard label="Corners" valA={kpisA.corners} valB={kpisB.corners} />
                        </div>

                        <Card className="bg-slate-900/50 border-white/10">
                            <CardHeader className="border-b border-white/5 py-3">
                                <CardTitle className="text-sm font-medium text-slate-300">Recent Events</CardTitle>
                            </CardHeader>
                            <CardContent className="p-0">
                                <div className="divide-y divide-white/5 max-h-[400px] overflow-y-auto">
                                    {events.slice().reverse().slice(0, 10).map((evt, i) => (
                                        <div key={i} className="flex items-center justify-between p-3 text-sm hover:bg-white/5">
                                            <div className="flex items-center gap-3">
                                                <Badge variant="outline" className="font-mono text-[10px] border-white/20 text-slate-500">
                                                    {evt.matchTime || '--:--'}
                                                </Badge>
                                                <span className={`font-semibold ${evt.team === 'TEAM_A' ? 'text-blue-400' : 'text-red-400'}`}>
                                                    {evt.team === 'TEAM_A' ? teamNames.teamA : teamNames.teamB}
                                                </span>
                                            </div>
                                            <span className="text-slate-300 flex items-center gap-2">
                                                <span className="capitalize">{evt.eventName.replace(/_/g, ' ')}</span>
                                            </span>
                                        </div>
                                    ))}
                                </div>
                            </CardContent>
                        </Card>
                    </div>
                )}

                {/* ================= POST-MATCH MODE (PROFESSIONAL) ================= */}
                {mode === 'POST_MATCH' && (
                    <Tabs defaultValue="executive" className="space-y-6 animate-in fade-in duration-300">
                        <TabsList className="bg-slate-900/50 border border-white/10 p-1 w-full justify-start overflow-x-auto h-auto grid grid-cols-3 md:grid-cols-6 gap-1">
                            <ProfessionalTabTrigger value="executive" icon={<BarChart2 className="w-3 h-3" />} label="Executive" />
                            <ProfessionalTabTrigger value="offball" icon={<Footprints className="w-3 h-3" />} label="Off-Ball" />
                            <ProfessionalTabTrigger value="space" icon={<Layers className="w-3 h-3" />} label="Space" />
                            <ProfessionalTabTrigger value="quality" icon={<Brain className="w-3 h-3" />} label="AI Quality" />
                            <ProfessionalTabTrigger value="outcome" icon={<Target className="w-3 h-3" />} label="Outcome" />
                            <ProfessionalTabTrigger value="tactical" icon={<Shield className="w-3 h-3" />} label="Tactical" />
                        </TabsList>

                        {/* 1. EXECUTIVE SUMMARY */}
                        <TabsContent value="executive" className="space-y-6">
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                <CompositeScoreCard label="Tactical Control Index" scoreA={kpisA.tacticalControlIndex} scoreB={kpisB.tacticalControlIndex} />
                                <CompositeScoreCard label="Attacking Efficiency" scoreA={kpisA.attackingEfficiencyIndex} scoreB={kpisB.attackingEfficiencyIndex} />
                                <CompositeScoreCard label="Defensive Org." scoreA={kpisA.defensiveOrganizationScore} scoreB={kpisB.defensiveOrganizationScore} />
                                <CompositeScoreCard label="Team Intelligence" scoreA={kpisA.teamIntelligenceRating} scoreB={kpisB.teamIntelligenceRating} />
                            </div>
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                <DetailedStatTable title="Key Performance Indicators"
                                    headers={["Metric", teamNames.teamA, teamNames.teamB]}
                                    rows={[
                                        { label: "xG (Expected Goals)", valA: kpisA.xG.toFixed(2), valB: kpisB.xG.toFixed(2) },
                                        { label: "Chances Created", valA: kpisA.chancesCreated, valB: kpisB.chancesCreated },
                                        { label: "Off-Ball Impact", valA: kpisA.offBallImpactIndex, valB: kpisB.offBallImpactIndex, isIndex: true },
                                        { label: "Press Resistance", valA: kpisA.pressResistanceIndex, valB: kpisB.pressResistanceIndex, isIndex: true },
                                    ]}
                                />
                                <DetailedStatTable title="Game State Dominance"
                                    headers={["Phase", teamNames.teamA, teamNames.teamB]}
                                    rows={[
                                        { label: "Possession Time", valA: `${possession}%`, valB: `${100 - possession}%` },
                                        { label: "Field Tilt (Final 3rd)", valA: `${kpisA.zoneEntriesFinalThird + kpisB.zoneEntriesFinalThird > 0 ? Math.round((kpisA.zoneEntriesFinalThird / (kpisA.zoneEntriesFinalThird + kpisB.zoneEntriesFinalThird)) * 100) : 50}%`, valB: `${kpisA.zoneEntriesFinalThird + kpisB.zoneEntriesFinalThird > 0 ? Math.round((kpisB.zoneEntriesFinalThird / (kpisA.zoneEntriesFinalThird + kpisB.zoneEntriesFinalThird)) * 100) : 50}%` },
                                        { label: "Duels Won", valA: kpisA.duelsWon, valB: kpisB.duelsWon },
                                        { label: "Game Control Index", valA: kpisA.gameControlIndex, valB: kpisB.gameControlIndex, isIndex: true },
                                    ]}
                                />
                            </div>
                        </TabsContent>

                        {/* 2. OFF-BALL MOVEMENT */}
                        <TabsContent value="offball" className="space-y-6">
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <KPICard title="Off-Ball Impact" valA={kpisA.offBallImpactIndex} valB={kpisB.offBallImpactIndex} max={100} unit="/100" />
                                <KPICard title="Space Creation" valA={kpisA.spaceCreationEfficiency} valB={kpisB.spaceCreationEfficiency} max={100} unit="/100" />
                                <KPICard title="Total Runs" valA={kpisA.offBallRuns} valB={kpisB.offBallRuns} max={100} />
                            </div>
                            <DetailedStatTable title="Movement Types Breakdown"
                                headers={["Run Type", teamNames.teamA, teamNames.teamB]}
                                rows={[
                                    { label: "Runs in Behind", valA: Math.round(kpisA.offBallRuns * 0.4), valB: Math.round(kpisB.offBallRuns * 0.3) },
                                    { label: "Checking Runs", valA: Math.round(kpisA.offBallRuns * 0.3), valB: Math.round(kpisB.offBallRuns * 0.4) },
                                    { label: "Overlaps", valA: kpisA.overlaps, valB: kpisB.overlaps },
                                    { label: "Underlaps", valA: kpisA.underlaps, valB: kpisB.underlaps },
                                    { label: "Third Man Runs", valA: kpisA.thirdManRuns, valB: kpisB.thirdManRuns },
                                    { label: "Dummy Runs", valA: kpisA.dummyRuns, valB: kpisB.dummyRuns },
                                ]}
                            />
                        </TabsContent>

                        {/* 3. SPACE CREATION */}
                        <TabsContent value="space" className="space-y-6">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <CompositeScoreCard label="Central Threat Index" scoreA={kpisA.centralThreatIndex} scoreB={kpisB.centralThreatIndex} />
                                <CompositeScoreCard label="Width Utilization" scoreA={kpisA.widthStretchScore} scoreB={kpisB.widthStretchScore} />
                            </div>
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                                <Card className="bg-slate-900/50 border-white/10">
                                    <CardHeader><CardTitle className="text-sm">Zone Occupation</CardTitle></CardHeader>
                                    <CardContent>
                                        <div className="flex gap-1 h-32 items-end">
                                            {/* Simplified Zone Viz */}
                                            <div className="w-1/3 bg-blue-500/20 h-[40%] border-t border-blue-500 relative"><span className="absolute -top-6 text-[10px] w-full text-center">Left HS</span></div>
                                            <div className="w-1/3 bg-blue-500/40 h-[70%] border-t border-blue-500 relative"><span className="absolute -top-6 text-[10px] w-full text-center">Central</span></div>
                                            <div className="w-1/3 bg-blue-500/20 h-[30%] border-t border-blue-500 relative"><span className="absolute -top-6 text-[10px] w-full text-center">Right HS</span></div>
                                        </div>
                                    </CardContent>
                                </Card>
                                <DetailedStatTable title="Penetration Metrics"
                                    headers={["Metric", teamNames.teamA, teamNames.teamB]}
                                    rows={[
                                        { label: "Final Third Entries", valA: kpisA.zoneEntriesFinalThird, valB: kpisB.zoneEntriesFinalThird },
                                        { label: "Central Penetrations", valA: kpisA.centralPenetrations, valB: kpisB.centralPenetrations },
                                        { label: "Carries into Box", valA: Math.round(kpisA.carries * 0.2), valB: Math.round(kpisB.carries * 0.15) },
                                        { label: "Switch of Play", valA: kpisA.switchesOfPlay, valB: kpisB.switchesOfPlay },
                                    ]}
                                />
                            </div>
                        </TabsContent>

                        {/* 4. AI QUALITY */}
                        <TabsContent value="quality" className="space-y-6">
                            <div className="p-4 rounded-lg bg-emerald-500/10 border border-emerald-500/20 flex items-center gap-3">
                                <Database className="w-8 h-8 text-emerald-400" />
                                <div>
                                    <h3 className="font-bold text-emerald-400">System Reliability Status: OPTIMAL</h3>
                                    <p className="text-xs text-emerald-300/80">All data streams validated against reference models.</p>
                                </div>
                            </div>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                <KPICard title="AI Precision" valA={kpisA.aiPrecisionRate} valB={0} singleVal max={100} unit="%" />
                                <KPICard title="Analyst Agreement" valA={kpisA.analystAgreementRate} valB={0} singleVal max={100} unit="%" />
                                <KPICard title="Data Trust Index" valA={kpisA.dataTrustIndex} valB={0} singleVal max={100} unit="/100" />
                                <KPICard title="Latency" valA={0} valB={0} singleVal max={500} unit="ms" inverse />
                            </div>
                        </TabsContent>

                        {/* 5. OUTCOME & PERFORMANCE */}
                        <TabsContent value="outcome" className="space-y-6">
                            <DetailedStatTable title="Attacking Output"
                                headers={["Metric", teamNames.teamA, teamNames.teamB]}
                                rows={[
                                    { label: "Goals", valA: kpisA.goals, valB: kpisB.goals },
                                    { label: "exp. Goals (xG)", valA: kpisA.xG.toFixed(2), valB: kpisB.xG.toFixed(2) },
                                    { label: "Attacking Productivity", valA: kpisA.attackingProductivity, valB: kpisB.attackingProductivity, isIndex: true },
                                    { label: "Shots / On Target", valA: `${kpisA.shots} / ${kpisA.shotsOnTarget}`, valB: `${kpisB.shots} / ${kpisB.shotsOnTarget}` },
                                    { label: "Goals / xG Delta", valA: (kpisA.goals - kpisA.xG).toFixed(2), valB: (kpisB.goals - kpisB.xG).toFixed(2) },
                                ]}
                            />
                        </TabsContent>

                        {/* 6. TACTICAL & SITUATIONAL */}
                        <TabsContent value="tactical" className="space-y-6">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <CompositeScoreCard label="Tactical Superiority" scoreA={kpisA.tacticalSuperiorityIndex} scoreB={kpisB.tacticalSuperiorityIndex} />
                                <CompositeScoreCard label="Chaos Creation" scoreA={kpisA.chaosCreationRating} scoreB={kpisB.chaosCreationRating} />
                            </div>
                            <DetailedStatTable title="Situational Metrics"
                                headers={["Metric", teamNames.teamA, teamNames.teamB]}
                                rows={[
                                    { label: "Overloads Created", valA: kpisA.overloadsCreated, valB: kpisB.overloadsCreated },
                                    { label: "Tackles Won", valA: kpisA.tackles, valB: kpisB.tackles },
                                    { label: "Interceptions", valA: kpisA.interceptions, valB: kpisB.interceptions },
                                    { label: "Press Resistance", valA: kpisA.pressResistanceIndex, valB: kpisB.pressResistanceIndex, isIndex: true },
                                    { label: "Defensive Imbalance", valA: kpisA.defensiveImbalance, valB: kpisB.defensiveImbalance },
                                ]}
                            />
                        </TabsContent>

                    </Tabs>
                )}
            </main>
        </div>
    );
}

// ============================================================================
// HELPER COMPONENTS
// ============================================================================

const ScoreCard = ({ team, goals, xg, color, isRight }: { team: string, goals: number, xg: number, color: 'blue' | 'red', isRight?: boolean }) => (
    <Card className={`bg-${color}-500/5 border-${color}-500/20`}>
        <CardContent className={`p-4 ${isRight ? 'text-right' : 'text-left'}`}>
            <h3 className={`text-4xl font-bold text-${color}-400 mb-1`}>{goals}</h3>
            <p className="font-semibold text-slate-100 uppercase tracking-wider text-sm">{team}</p>
            <p className="text-xs text-slate-500 mt-1">xG: <span className="text-slate-300">{xg.toFixed(2)}</span></p>
        </CardContent>
    </Card>
);

const PossessionBar = ({ possessionA }: { possessionA: number }) => (
    <Card className="bg-slate-900/50 border-white/10 flex flex-col justify-center">
        <CardContent className="p-4">
            <div className="flex justify-between text-xs text-slate-400 mb-2 font-mono uppercase">
                <span>Possession</span>
                <span>{possessionA}% vs {100 - possessionA}%</span>
            </div>
            <div className="h-4 bg-slate-800 rounded-full overflow-hidden flex">
                <div style={{ width: `${possessionA}%` }} className="bg-blue-500 h-full" />
                <div style={{ width: `${100 - possessionA}%` }} className="bg-red-500 h-full" />
            </div>
        </CardContent>
    </Card>
);

const LiveMetricCard = ({ label, valA, valB }: { label: string, valA: number, valB: number }) => (
    <Card className="bg-slate-900/50 border-white/10 p-3">
        <div className="text-[10px] text-slate-500 uppercase tracking-widest text-center mb-1">{label}</div>
        <div className="flex justify-between items-end">
            <span className="text-xl font-bold text-blue-400">{valA}</span>
            <span className="text-xs text-slate-600 mb-1">vs</span>
            <span className="text-xl font-bold text-red-400">{valB}</span>
        </div>
    </Card>
);

const CompositeScoreCard = ({ label, scoreA, scoreB }: { label: string, scoreA: number, scoreB: number }) => (
    <Card className="bg-slate-900/40 border-white/5">
        <CardContent className="p-4">
            <div className="text-xs text-slate-400 uppercase tracking-wider mb-3 text-center border-b border-white/5 pb-2">{label}</div>
            <div className="flex items-center justify-between gap-6">
                <div className="text-center">
                    <div className="text-3xl font-black text-blue-500">{scoreA}</div>
                    <div className="text-[9px] text-white/20">TEAM A</div>
                </div>
                <div className="text-center">
                    <div className="text-3xl font-black text-red-500">{scoreB}</div>
                    <div className="text-[9px] text-white/20">TEAM B</div>
                </div>
            </div>
            <div className="h-1.5 bg-slate-800 rounded-full mt-3 flex overflow-hidden">
                <div style={{ width: `${scoreA}%` }} className="bg-blue-500/50 h-full" />
                <div className="flex-1" />
                <div style={{ width: `${scoreB}%` }} className="bg-red-500/50 h-full" />
            </div>
        </CardContent>
    </Card>
);

const ProfessionalTabTrigger = ({ value, icon, label }: { value: string, icon: any, label: string }) => (
    <TabsTrigger value={value} className="text-xs data-[state=active]:bg-emerald-500/20 data-[state=active]:text-emerald-400 data-[state=active]:border-emerald-500/30 border border-transparent flex items-center gap-2">
        {icon}
        <span className="hidden md:inline">{label}</span>
    </TabsTrigger>
);

const DetailedStatTable = ({ title, rows, headers }: { title: string, headers: string[], rows: any[] }) => (
    <Card className="bg-slate-900/40 border-white/10 overflow-hidden">
        <CardHeader className="py-3 px-4 bg-slate-900/80 border-b border-white/5">
            <CardTitle className="text-xs font-bold uppercase tracking-widest text-emerald-400/80 flex items-center gap-2">
                <Layers className="w-3 h-3" /> {title}
            </CardTitle>
        </CardHeader>
        <CardContent className="p-0">
            <table className="w-full text-sm text-left">
                <thead className="bg-white/5 text-slate-400 text-xs">
                    <tr>
                        {headers.map((h, i) => <th key={i} className={`p-3 font-normal ${i > 0 ? 'text-center' : ''}`}>{h}</th>)}
                    </tr>
                </thead>
                <tbody className="divide-y divide-white/5">
                    {rows.map((row, i) => (
                        <tr key={i} className="hover:bg-white/5 transition-colors">
                            <td className="p-3 text-slate-300 font-medium">
                                {row.label}
                                {row.isIndex && <Badge className="ml-2 bg-purple-500/20 text-purple-300 text-[9px] border-0">INDEX</Badge>}
                            </td>
                            <td className="p-3 text-center font-mono text-blue-300">{row.valA}</td>
                            <td className="p-3 text-center font-mono text-red-300">{row.valB}</td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </CardContent>
    </Card>
);

const KPICard = ({ title, valA, valB, max, unit = "", singleVal = false, inverse = false }: any) => {
    const pA = Math.min(100, (valA / max) * 100);
    const pB = Math.min(100, (valB / max) * 100);

    return (
        <Card className="bg-slate-900/40 border-white/10 p-4">
            <div className="text-xs text-slate-500 uppercase tracking-widest mb-2 truncate">{title}</div>
            {singleVal ? (
                <div className="flex items-baseline gap-1">
                    <span className={`text-2xl font-bold ${valA > 90 ? 'text-emerald-400' : 'text-slate-200'}`}>{valA}</span>
                    <span className="text-xs text-slate-600">{unit}</span>
                </div>
            ) : (
                <div className="space-y-3">
                    <div className="flex justify-between items-center">
                        <span className="text-blue-400 font-bold">{valA}<span className="text-[9px] text-slate-600 font-normal ml-0.5">{unit}</span></span>
                        <Progress value={pA} className="h-1.5 w-16 bg-slate-800 [&>div]:bg-blue-500" />
                    </div>
                    <div className="flex justify-between items-center">
                        <span className="text-red-400 font-bold">{valB}<span className="text-[9px] text-slate-600 font-normal ml-0.5">{unit}</span></span>
                        <Progress value={pB} className="h-1.5 w-16 bg-slate-800 [&>div]:bg-red-500" />
                    </div>
                </div>
            )}
        </Card>
    );
};
</file>

<file path="src/pages/Index.tsx">
import { IndexContent } from './IndexContent';

export default function Index() {
  return <IndexContent />;
}
</file>

<file path="src/pages/Index.tsx.backup">
import { useState, useEffect, useRef, useCallback } from "react";
import { createPortal } from "react-dom";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Download, Gamepad2, Users, Mic, MicOff, Monitor, X, Wifi, WifiOff, RefreshCw, Upload } from "lucide-react";
import { exportToCSV } from "@/utils/csvExport";
import { ControllerGrid } from "@/components/ControllerGrid";
import { EventLog } from "@/components/EventLog";
import { StatisticsDashboard } from "@/components/StatisticsDashboard";
import { VideoUpload } from "@/components/VideoUpload";
import { VideoPlayer } from "@/components/VideoPlayer";
import { AnalysisVideoPlayer } from "@/components/VideoPlayer/AnalysisVideoPlayer";
import { PlayerUpload } from "@/components/PlayerUpload";
import { TeamGrid } from "@/components/TeamGrid";
import { PlayerSelectionSidebar } from "@/components/PlayerSelectionSidebar";
import { StartingLineup } from "@/components/StartingLineup";
import { Dashboard } from "@/components/Dashboard";
import { TeamRoster, Player } from "@/types/player";
import { useToast } from "@/hooks/use-toast";
import { useGamepad, LoggedEvent } from "@/hooks/useGamepad";
import { TacticalAnalysisDashboard } from "@/components/TacticalAnalysisDashboard";
import { AnalysisResultsViewer } from "@/components/AnalysisResultsViewer";
import { ButtonMappingConfig } from "@/components/ButtonMappingConfig";
import LiveStreamPlayer from "@/components/LiveStreamPlayer";
import { SmartPlayerSelector } from "@/components/SmartPlayerSelector";

import { useVoiceRecognition } from "@/hooks/useVoiceRecognition";
import { useAudioBroadcast } from "@/hooks/useAudioBroadcast";
import { COMMANDS, matchCommand, parseNumber } from "@/utils/voiceUtils";
import { io, Socket } from 'socket.io-client';

import { API_BASE_URL } from "@/utils/apiConfig";

// Initialize socket outside component to avoid reconnection on re-renders
const socket: Socket = io(API_BASE_URL, {
  autoConnect: true,
  reconnection: true
});

const Index = () => {
  const [events, setEvents] = useState<LoggedEvent[]>([]);
  const [teams, setTeams] = useState<Map<string, TeamRoster>>(new Map());
  const [selectedTeam, setSelectedTeam] = useState<string>("");
  const [lastEventButtonLabel, setLastEventButtonLabel] = useState<string>();
  const [voiceLanguage, setVoiceLanguage] = useState<'en' | 'fr' | 'ar'>('en');

  const [gamepadConnected, setGamepadConnected] = useState(false);
  const [editingEventId, setEditingEventId] = useState<number | null>(null);
  const [isSocketConnected, setIsSocketConnected] = useState(socket.connected);
  const [role, setRole] = useState<'broadcaster' | 'viewer' | null>(null);
  const { toast } = useToast();

  const [matchTime, setMatchTime] = useState(0);
  const [isMatchActive, setIsMatchActive] = useState(false);
  const matchTimeRef = useRef(0); // Ref to access current time without re-rendering callback
  const videoTimeRef = useRef(0); // Ref for video time to avoid callback recreation

  // Video state
  const [videoFile, setVideoFile] = useState<File | null>(null);
  const [remoteVideoUrl, setRemoteVideoUrl] = useState<string | null>(null);
  const [videoTime, setVideoTime] = useState(0);
  const [useVideoMode, setUseVideoMode] = useState(false);
  const [seekTime, setSeekTime] = useState<number | null>(null);
  const [analysisResults, setAnalysisResults] = useState<any>(null);
  const [isVideoPlaying, setIsVideoPlaying] = useState(false);
  const [videoMode, setVideoMode] = useState<'upload' | 'live'>('upload'); // Tab state for video source
  const [showAnalysisView, setShowAnalysisView] = useState(false);

  // Socket.io Logic
  useEffect(() => {
    function onConnect() {
      setIsSocketConnected(true);
      console.log("Socket connected");
    }

    function onDisconnect() {
      setIsSocketConnected(false);
      console.log("Socket disconnected");
    }

    function onSyncState(state: any) {
      console.log("Syncing state:", state);
      if (state.events && state.events.length > events.length) {
        setEvents(state.events);
      }
      if (state.matchTime > matchTimeRef.current) {
        setMatchTime(state.matchTime);
        matchTimeRef.current = state.matchTime;
      }
      if (state.isMatchActive !== undefined) setIsMatchActive(state.isMatchActive);

      // FIX: Always respect server's selected team on connect
      if (state.selectedTeam) setSelectedTeam(state.selectedTeam);

      if (state.teams && state.teams.length > 0) {
        try {
          const newTeams = new Map<string, TeamRoster>();
          // If it comes as array of entries [[name, roster], ...]
          if (Array.isArray(state.teams)) {
            state.teams.forEach((t: any) => {
              if (Array.isArray(t) && t.length === 2) newTeams.set(t[0], t[1]);
            });
          }
          if (newTeams.size > 0) setTeams(newTeams);
        } catch (e) {
          console.error("Error syncing teams:", e);
        }
      }
    }

    function onSyncTeams(teamsData: any[]) {
      console.log("Received synced teams:", teamsData);
      try {
        const newTeams = new Map<string, TeamRoster>();
        if (Array.isArray(teamsData)) {
          teamsData.forEach((t: any) => {
            if (Array.isArray(t) && t.length === 2) newTeams.set(t[0], t[1]);
          });
        }
        if (newTeams.size > 0) setTeams(newTeams);
        toast({ title: "Teams Synced", description: "Received team data from broadcaster." });
      } catch (e) {
        console.error("Error handling sync-teams:", e);
      }
    }

    function onNewEvent(event: LoggedEvent) {
      console.log("Received remote event:", event);
      setEvents(prev => [...prev, event]);
    }

    function onSyncTimer(data: { matchTime: number, isMatchActive: boolean }) {
      setMatchTime(data.matchTime);
      matchTimeRef.current = data.matchTime;
      setIsMatchActive(data.isMatchActive);
    }

    // FIX: Renamed listener function and event name to match server
    function onSelectTeam(teamId: string) {
      console.log("Broadcaster switched team to:", teamId);
      setSelectedTeam(teamId);
    }

    function onRoleAssignment(assignedRole: 'broadcaster' | 'viewer') {
      console.log("Assigned role:", assignedRole);
      setRole(assignedRole);
      toast({
        title: "Role Assigned",
        description: `You are the ${assignedRole === 'broadcaster' ? 'Broadcaster (Host)' : 'Viewer'}`,
      });
    }

    socket.on('connect', onConnect);
    socket.on('disconnect', onDisconnect);
    socket.on('sync-state', onSyncState);
    socket.on('new-event', onNewEvent);
    socket.on('sync-timer', onSyncTimer);

    // FIX: Changed 'update-team' to 'select-team'
    socket.on('select-team', onSelectTeam);
    socket.on('sync-teams', onSyncTeams);
    socket.on('role-assignment', onRoleAssignment);

    socket.on('undo-event', (eventId: number) => {
      console.log("Received undo event:", eventId);
      setEvents(prev => prev.filter(e => e.id !== eventId));
      toast({
        title: "Event Annulled",
        description: `Event #${eventId} was removed by broadcaster`,
      });
    });

    socket.on('update-event', (updatedEvent: LoggedEvent) => {
      console.log("Received update event:", updatedEvent);
      setEvents(prev => prev.map(e => e.id === updatedEvent.id ? updatedEvent : e));
    });

    // ===== VIDEO SYNC LISTENERS =====
    socket.on('video-sync', (data: any) => {
      console.log("Received video sync:", data);
      if (data.videoUrl && data.videoUrl !== videoFile?.name) { // Simple check, ideally check URL
        // If it's a remote URL (starts with /uploads), we might need to handle it
        // For now, we assume handleVideoUpload sets local state for broadcaster
        // But for viewer, we need to set videoUrl.
        // Since videoFile is File object, we might need a separate videoUrl state in Index or pass string to VideoPlayer
      }
    });

    socket.on('video-loaded', (url: string) => {
      console.log("Broadcaster loaded video:", url);
      console.log("Setting remoteVideoUrl to:", url);
      setRemoteVideoUrl(url);
      setUseVideoMode(true);
      setVideoMode('upload');
      console.log("Video mode set to: upload");
    });

    socket.on('video-play', (time: number) => {
      console.log("Broadcaster played at:", time);
      setIsVideoPlaying(true);
      setVideoTime(time);
    });

    socket.on('video-pause', (time: number) => {
      console.log("Broadcaster paused at:", time);
      setIsVideoPlaying(false);
      setVideoTime(time);
    });

    socket.on('video-seek', (time: number) => {
      console.log("Broadcaster seeked to:", time);
      setSeekTime(time);
    });
    // ===============================

    return () => {
      socket.off('connect', onConnect);
      socket.off('disconnect', onDisconnect);
      socket.off('sync-state', onSyncState);
      socket.off('new-event', onNewEvent);
      socket.off('sync-timer', onSyncTimer);

      // FIX: Changed 'update-team' to 'select-team'
      socket.off('select-team', onSelectTeam);
      socket.off('sync-teams', onSyncTeams);
      socket.off('role-assignment', onRoleAssignment);
      socket.off('undo-event');
      socket.off('update-event');
      socket.off('video-sync');
      socket.off('video-loaded');
      socket.off('video-play');
      socket.off('video-pause');
      socket.off('video-seek');
    };
  }, []);

  // Broadcast Timer Changes
  useEffect(() => {
    socket.emit('sync-timer', { matchTime, isMatchActive });
  }, [isMatchActive]);

  // Match Timer Logic
  useEffect(() => {
    let interval: NodeJS.Timeout;
    if (isMatchActive && !useVideoMode) {
      interval = setInterval(() => {
        setMatchTime((prev) => {
          const newTime = prev + 1;
          matchTimeRef.current = newTime; // Update ref
          return newTime;
        });
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [isMatchActive, useVideoMode]);

  // Sync Match Time & Refs with Video Time
  useEffect(() => {
    if (useVideoMode) {
      videoTimeRef.current = videoTime;
      const timeInSeconds = Math.floor(videoTime);
      if (matchTimeRef.current !== timeInSeconds) {
        setMatchTime(timeInSeconds);
        matchTimeRef.current = timeInSeconds;
      }
    }
  }, [videoTime, useVideoMode]);

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // Stable callback for gamepad events
  const handleEventLogged = useCallback((event: LoggedEvent) => {
    const currentTime = matchTimeRef.current;
    const currentVideoTime = videoTimeRef.current;

    const eventWithTime = {
      ...event,
      matchTime: formatTime(currentTime),
      ...(useVideoMode && videoFile ? { videoTime: currentVideoTime } : {})
    };
    setEvents((prev) => [eventWithTime, ...prev]);
    setLastEventButtonLabel(event.buttonLabel);

    // Broadcast event to other clients
    socket.emit('new-event', eventWithTime);
  }, [useVideoMode, videoFile]);

  const {
    isConnected,
    manualCheck,
    pressedButtons,
    axes,
    buttons,
    mappings,
    updateMapping,
    resetMappings,
    playerSelection
  } = useGamepad(handleEventLogged, {
    // Pass the selected team's roster as Team A (primary)
    teamARoster: teams.get(selectedTeam)?.PlayerData?.map(p => ({
      id: p.ID,
      name: `${p.Forename} ${p.Surname}`,
      number: p.Number
    })) || [],
    // Try to find another team for Team B if exists
    teamBRoster: Array.from(teams.entries())
      .find(([id]) => id !== selectedTeam)?.[1]?.PlayerData?.map(p => ({
        id: p.ID,
        name: `${p.Forename} ${p.Surname}`,
        number: p.Number
      })) || [],
    // Pass starting numbers if available (currently hardcoded for Algeria)
    teamAStartingNumbers: selectedTeam === "Algeria" ? [1, 2, 5, 6, 7, 8, 9, 10, 11, 15, 22] : undefined
  });

  const handleTeamUpload = (newTeams: Map<string, TeamRoster>) => {
    const updatedTeams = new Map(teams);
    newTeams.forEach((roster, teamName) => {
      updatedTeams.set(teamName, roster);
    });

    setTeams(updatedTeams);

    // Emit sync-teams to server
    const teamsArray = Array.from(updatedTeams.entries());
    socket.emit('sync-teams', teamsArray);

    if (newTeams.size > 0) {
      setSelectedTeam("");
    }
  };

  const handleTeamSelect = (teamId: string) => {
    setSelectedTeam(teamId);
    // FIX: Changed 'update-team' to 'select-team' to match server expectations
    socket.emit('select-team', teamId);
  };

  const handleUndoEvent = (eventId: number) => {
    setEvents(prev => prev.filter(e => e.id !== eventId));
    socket.emit('undo-event', eventId);
    toast({
      title: "Event Annulled",
      description: `Event #${eventId} removed`,
    });
  };

  const handlePlayerSelect = (playerId: number) => {
    setEvents((prevEvents) => {
      const newEvents = [...prevEvents];
      let targetIndex = -1;

      // If we are editing a specific event, find it
      if (editingEventId !== null) {
        targetIndex = newEvents.findIndex(e => e.id === editingEventId);
      } else {
        // Fallback to finding the last unassigned event
        const searchLimit = Math.min(newEvents.length, 10);
        for (let i = searchLimit - 1; i >= 0; i--) {
          if (!newEvents[i].player && !newEvents[i].isCalculated) {
            targetIndex = i;
            break;
          }
        }
        // If no unassigned event found, try to assign to the last event (even if assigned, maybe?)
        // The original logic had a fallback to just the last event if it wasn't calculated
        if (targetIndex === -1 && newEvents.length > 0) {
          for (let i = 0; i < newEvents.length; i++) {
            if (!newEvents[i].isCalculated) {
              targetIndex = i;
              break;
            }
          }
        }
      }

      if (targetIndex !== -1) {
        const targetEvent = newEvents[targetIndex];
        const roster = teams.get(selectedTeam);
        const player = roster?.PlayerData.find((p) => p.ID === playerId);

        if (player) {
          const updatedEvent = {
            ...targetEvent,
            player: {
              id: player.ID,
              name: `${player.Forename} ${player.Surname}`,
            },
          };
          newEvents[targetIndex] = updatedEvent;

          // Emit update to server
          socket.emit('update-event', updatedEvent);

          toast({
            title: "Player Assigned",
            description: `Assigned ${player.Surname} to ${targetEvent.eventName}`,
          });

          // Clear editing state if we were editing
          if (editingEventId !== null) {
            setEditingEventId(null);
          }
        }
      }

      return newEvents;
    });
  };

  const handleGameEvent = (eventName: string, source: string = "Manual") => {
    const newEvent: LoggedEvent = {
      id: Date.now(),
      timestamp: new Date().toISOString(),
      eventName: eventName,
      team: selectedTeam || "TEAM_A",
      buttonLabel: source,
      matchTime: formatTime(matchTimeRef.current)
    };
    handleEventLogged(newEvent);
  };

  const handleVoiceResult = (transcript: string) => {
    console.log("Voice result:", transcript);
    const lowerTranscript = transcript.toLowerCase();

    // 1. Check for Player Number Selection
    const number = parseNumber(lowerTranscript);
    if (number !== null) {
      const currentTeamRoster = teams.get(selectedTeam)?.PlayerData;
      if (currentTeamRoster) {
        const player = currentTeamRoster.find(p => p.Number === number);
        if (player) {
          handlePlayerSelect(player.ID);
          toast({
            title: "Voice Selection",
            description: `Selected Player #${number}: ${player.Forename} ${player.Surname}`,
          });
        } else {
          toast({
            title: "Voice Selection",
            description: `Player #${number} not found in ${selectedTeam}`,
            variant: "destructive"
          });
        }
      }
    }

    // 2. Check for Commands
    let matchedCommand = null;

    if (matchCommand(lowerTranscript, COMMANDS.PASS)) matchedCommand = "PASS";
    else if (matchCommand(lowerTranscript, COMMANDS.SHOOT)) matchedCommand = "SHOT";
    else if (matchCommand(lowerTranscript, COMMANDS.GOAL)) matchedCommand = "GOAL";
    else if (matchCommand(lowerTranscript, COMMANDS.FOUL)) matchedCommand = "FOUL";
    else if (matchCommand(lowerTranscript, COMMANDS.OFFSIDE)) matchedCommand = "OFFSIDE";
    else if (matchCommand(lowerTranscript, COMMANDS.PENALTY)) matchedCommand = "PENALTY";
    else if (matchCommand(lowerTranscript, COMMANDS.CORNER)) matchedCommand = "CORNER";
    else if (matchCommand(lowerTranscript, COMMANDS.SUBSTITUTION)) matchedCommand = "SUBSTITUTION";

    if (matchedCommand) {
      handleGameEvent(matchedCommand, "Voice");
      toast({
        title: "Voice Command",
        description: `Executed: ${matchedCommand}`,
      });
    } else if (number === null) {
      if (transcript.length > 2) {
        toast({
          title: "Voice Unrecognized",
          description: `Heard: "${transcript}"`,
          variant: "secondary"
        });
      }
    }
  };

  const handleVoiceError = (error: string) => {
    toast({
      title: "Voice Error",
      description: error,
      variant: "destructive",
    });
  };

  const { isListening, toggleListening, isSupported, availableDevices, startListening } = useVoiceRecognition({
    onResult: handleVoiceResult,
    onError: handleVoiceError,
    language: voiceLanguage
  });

  const toggleMatch = () => {
    console.log("toggleMatch called. Current state:", isMatchActive);
    if (!isMatchActive) {
      // Start Match
      setIsMatchActive(true);
      if (useVideoMode) {
        setIsVideoPlaying(true);
      }

      if (!isListening) {
        console.log("Attempting to auto-start voice control...");
        try {
          startListening();
          toast({
            title: "Match Started",
            description: "Timer started and Voice Control activated.",
          });
        } catch (err) {
          console.error("Auto-start voice failed:", err);
          toast({
            title: "Match Started",
            description: "Timer started, but Voice Control failed to start.",
            variant: "destructive"
          });
        }
      } else {
        toast({
          title: "Match Started",
          description: "Timer started.",
        });
      }
    } else {
      // Pause Match
      setIsMatchActive(false);
      if (useVideoMode) {
        setIsVideoPlaying(false);
      }
      toast({
        title: "Match Paused",
        description: "Timer paused.",
      });
    }
  };

  // Document Picture-in-Picture Logic
  const [pipWindow, setPipWindow] = useState<Window | null>(null);

  const togglePiP = async () => {
    if (pipWindow) {
      pipWindow.close();
      setPipWindow(null);
      return;
    }

    const setupWindow = (win: Window) => {
      [...document.styleSheets].forEach((styleSheet) => {
        try {
          if (styleSheet.href) {
            const link = win.document.createElement("link");
            link.rel = "stylesheet";
            link.href = styleSheet.href;
            win.document.head.appendChild(link);
          } else {
            const style = win.document.createElement("style");
            [...styleSheet.cssRules].forEach((rule) => {
              style.appendChild(win.document.createTextNode(rule.cssText));
            });
            win.document.head.appendChild(style);
          }
        } catch (e) {
          console.error("Error copying style:", e);
        }
      });

      win.addEventListener("pagehide", () => {
        setPipWindow(null);
      });

      win.addEventListener("unload", () => {
        setPipWindow(null);
      });

      setPipWindow(win);
    };

    if ("documentPictureInPicture" in window) {
      try {
        const pip = await (window as any).documentPictureInPicture.requestWindow({
          width: 1000,
          height: 800,
        });
        setupWindow(pip);
        return;
      } catch (err) {
        console.warn("Document PiP failed, falling back to popup:", err);
      }
    }

    try {
      const popup = window.open("", "SoccerLoggerPopup", "width=1000,height=800,popup=yes");
      if (popup) {
        if (!popup.document.body) {
          popup.document.write('<body></body>');
        }
        popup.document.title = "Soccer Event Logger (Overlay)";
        setupWindow(popup);
      } else {
        toast({
          title: "Popup Blocked",
          description: "Please allow popups for this site to use the overlay.",
          variant: "destructive",
        });
      }
    } catch (err) {
      console.error("Failed to open popup:", err);
      toast({
        title: "Error",
        description: "Failed to open Pop-out window.",
        variant: "destructive",
      });
    }
  };

  // HUD Mode (Video Background) Logic
  const [videoStream, setVideoStream] = useState<MediaStream | null>(null);

  const videoRef = useRef<HTMLVideoElement>(null);
  const audioRef = useRef<HTMLAudioElement>(null);

  // Audio Broadcasting Integration
  const { localAudioStream, remoteAudioStream, isBroadcasting, startAudioBroadcast, stopAudioBroadcast } = useAudioBroadcast(socket, role);

  // Auto-play remote audio for viewers
  useEffect(() => {
    if (audioRef.current && remoteAudioStream) {
      audioRef.current.srcObject = remoteAudioStream;
      audioRef.current.play().catch(err => console.error('Error playing audio:', err));
    }
  }, [remoteAudioStream]);

  const toggleWatchMatch = async () => {
    if (videoStream) {
      videoStream.getTracks().forEach(track => track.stop());
      setVideoStream(null);
    } else {
      try {
        toast({
          title: "Select Window or Screen",
          description: "Use 'Window' tab for apps. If your app is missing from the list, use 'Entire Screen' and switch to the app.",
          duration: 8000,
        });

        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: {
            // @ts-ignore
            displaySurface: "window",
          },
          audio: false
        });

        setVideoStream(stream);

        stream.getVideoTracks()[0].onended = () => {
          setVideoStream(null);
        };

      } catch (err) {
        console.error("Error sharing screen:", err);
      }
    }
  };

  useEffect(() => {
    if (videoRef.current && videoStream) {
      videoRef.current.srcObject = videoStream;
    }
  }, [videoStream]);

  const handleExport = () => {
    if (events.length === 0) {
      toast({
        title: "No events to export",
        description: "Log some events first!",
        variant: "destructive",
      });
      return;
    }
    exportToCSV(events);
    toast({
      title: "Export Successful",
      description: "Events exported to CSV",
    });
  };

  const MainContent = (
    <div className="min-h-screen bg-background overflow-hidden flex flex-col relative">
      {/* Video Background Layer */}
      {videoStream && (
        <video
          ref={videoRef}
          autoPlay
          playsInline
          muted
          className="absolute inset-0 w-full h-full object-cover z-0"
        />
      )}

      {/* Smart Player Selector Overlay */}
      {playerSelection && (
        <SmartPlayerSelector
          currentBallHolder={playerSelection.currentBallHolder}
          predictedTargets={playerSelection.predictedTargets}
          selectedTargetIndex={playerSelection.selectedTargetIndex}
          isActive={playerSelection.isSelecting}
        />
      )}

      {/* Hidden Audio Element for Remote Audio */}
      <audio ref={audioRef} autoPlay />

      {/* Header Layer */}
      <div className={`border-b border-border p-2 md:p-4 bg-card relative z-10 transition-colors duration-300 ${videoStream ? 'bg-black/40 backdrop-blur-sm border-white/10 text-white' : ''}`}>
        <div className="max-w-7xl mx-auto flex flex-col md:flex-row items-start md:items-center justify-between gap-2 md:gap-4">
          <div className="flex items-center gap-2 md:gap-4 w-full md:w-auto">
            <h1 className="text-lg md:text-2xl font-bold flex items-center gap-2">
              <Gamepad2 className="w-6 h-6 md:w-8 md:h-8 text-primary" />
              <span className="hidden sm:inline">Soccer Event Logger</span>
              <span className="sm:hidden">Logger</span>
            </h1>

            {/* Connection Status Indicator */}
            <div className={`flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${isSocketConnected ? 'bg-green-500/20 text-green-500' : 'bg-red-500/20 text-red-500'}`}>
              {isSocketConnected ? <Wifi className="w-3 h-3" /> : <WifiOff className="w-3 h-3" />}
              <span className="hidden sm:inline">{isSocketConnected ? 'Synced' : 'Offline'}</span>
            </div>
          </div>
          {/* Match Timer Control */}
          <div className="flex items-center gap-2 md:gap-4 md:ml-8 md:border-l md:pl-8 w-full md:w-auto justify-between md:justify-start">
            <div className="flex flex-col items-center">
              <span className="text-2xl md:text-3xl font-mono font-bold tabular-nums text-primary">
                {formatTime(matchTime)}
              </span>
              <span className="text-[10px] md:text-xs text-muted-foreground uppercase tracking-wider">Match Time</span>
            </div>
            <Button
              variant={isMatchActive ? "secondary" : "default"}
              size="sm"
              onClick={toggleMatch}
              className="min-w-[80px] md:min-w-[120px] text-xs md:text-sm"
            >
              {isMatchActive ? "Pause" : matchTime === 0 ? "Start" : "Resume"}
            </Button>
          </div>
          <div className="flex flex-wrap items-center gap-1 md:gap-2 w-full md:w-auto">
            {/* Watch Match Button (HUD Mode) */}
            <Button
              variant={videoStream ? "destructive" : "secondary"}
              size="sm"
              onClick={toggleWatchMatch}
              className="gap-1 text-xs"
              title={videoStream ? "Stop Watching" : "Watch Match (HUD Mode)"}
            >
              {videoStream ? <X className="h-3 w-3 md:h-4 md:w-4" /> : <Monitor className="h-3 w-3 md:h-4 md:w-4" />}
              <span className="hidden sm:inline">{videoStream ? "Stop Match" : "Watch Match"}</span>
            </Button>

            {/* Audio Broadcast Button */}
            {role === 'broadcaster' && (
              <Button
                variant={isBroadcasting ? "destructive" : "outline"}
                size="sm"
                onClick={isBroadcasting ? stopAudioBroadcast : startAudioBroadcast}
                className="gap-1 text-xs"
                title={isBroadcasting ? "Stop Audio Broadcast" : "Start Audio Broadcast"}
              >
                {isBroadcasting ? <MicOff className="h-3 w-3 md:h-4 md:w-4 animate-pulse" /> : <Mic className="h-3 w-3 md:h-4 md:w-4" />}
                <span className="hidden sm:inline">{isBroadcasting ? "Broadcasting" : "Broadcast Audio"}</span>
              </Button>
            )}
            {role === 'viewer' && remoteAudioStream && (
              <div className="flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-green-500/20 text-green-500">
                <Mic className="w-3 h-3 animate-pulse" />
                <span className="hidden sm:inline">Receiving Audio</span>
              </div>
            )}

            {/* Pop Out Button */}
            <Button
              variant="outline"
              size="sm"
              onClick={togglePiP}
              className="gap-1 text-xs hidden md:flex"
              title={pipWindow ? "Restore to Tab" : "Pop Out Window"}
            >
              <Download className="h-3 w-3 md:h-4 md:w-4 rotate-180" />
              <span className="hidden lg:inline">{pipWindow ? "Restore" : "Pop Out"}</span>
            </Button>

            {isSupported && (
              <div className="flex items-center gap-1 md:gap-2">
                <Select value={voiceLanguage} onValueChange={(value: 'en' | 'fr' | 'ar') => setVoiceLanguage(value)}>
                  <SelectTrigger className="w-[70px] md:w-[100px] h-8 md:h-9 text-xs">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="en">üá¨üáß EN</SelectItem>
                    <SelectItem value="fr">üá´üá∑ FR</SelectItem>
                    <SelectItem value="ar">üá∏üá¶ AR</SelectItem>
                  </SelectContent>
                </Select>
                <div className="flex flex-col items-center gap-1">
                  <Button
                    variant={isListening ? "destructive" : "outline"}
                    size="sm"
                    onClick={toggleListening}
                    className="gap-1 text-xs"
                    title={isListening ? "Stop Listening" : "Start Voice Control"}
                  >
                    {isListening ? <Mic className="h-3 w-3 md:h-4 md:w-4 animate-pulse" /> : <MicOff className="h-3 w-3 md:h-4 md:w-4" />}
                    <span className="hidden sm:inline">{isListening ? "Listening..." : "Voice"}</span>
                  </Button>
                  {availableDevices && availableDevices.length > 0 && (
                    <span className="text-[10px] text-muted-foreground max-w-[150px] truncate hidden md:inline" title="To use a specific mic (like controller), set it as Default in Windows Sound Settings">
                      {availableDevices.length} mics detected
                    </span>
                  )}
                </div>
                {role === 'broadcaster' && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => socket.emit('switch-role')}
                    className="gap-1 text-xs"
                    title="Switch role with viewer"
                  >
                    <RefreshCw className="h-3 w-3 md:h-4 md:w-4" />
                    <span className="hidden sm:inline">Switch Role</span>
                  </Button>
                )}
                <div className="flex items-center gap-2">
                  {/* Video Mode Tabs */}
                  <div className="flex items-center gap-1 bg-muted rounded-md p-1">
                    <Button
                      variant={videoMode === 'upload' ? 'default' : 'ghost'}
                      size="sm"
                      onClick={() => setVideoMode('upload')}
                      className="h-7 text-xs"
                    >
                      üìÅ Upload
                    </Button>
                    <Button
                      variant={videoMode === 'live' ? 'default' : 'ghost'}
                      size="sm"
                      onClick={() => setVideoMode('live')}
                      className="h-7 text-xs"
                    >
                      üì° Live
                    </Button>
                  </div>


                  {/* Upload Video Button - Only show in upload mode and when no video is loaded */}
                  {videoMode === 'upload' && !videoFile && !remoteVideoUrl && (
                    <>
                      <input
                        type="file"
                        accept="video/*"
                        id="video-upload-input"
                        className="hidden"
                        onChange={async (e) => {
                          const file = e.target.files?.[0];
                          if (!file) return;

                          setVideoFile(file);
                          setUseVideoMode(true);

                          // Upload to server for viewers
                          const formData = new FormData();
                          formData.append('video', file);

                          try {
                            const response = await fetch(`${API_BASE_URL}/api/upload-video`, {
                              method: 'POST',
                              body: formData
                            });
                            const data = await response.json();
                            if (data.success) {
                              console.log("Video uploaded to server:", data.videoUrl);
                              socket.emit('video-loaded', data.videoUrl);
                            }
                          } catch (e) {
                            console.error("Failed to upload video:", e);
                          }

                          // Reset input
                          e.target.value = '';
                        }}
                      />
                      <Button
                        variant="default"
                        size="sm"
                        onClick={() => document.getElementById('video-upload-input')?.click()}
                        className="gap-2"
                      >
                        <Upload className="h-4 w-4" />
                        <span className="hidden sm:inline">Upload Video</span>
                      </Button>
                    </>
                  )}

                  {/* Clear Video Button - Show when video is loaded */}
                  {videoMode === 'upload' && (videoFile || remoteVideoUrl) && (
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => {
                        setVideoFile(null);
                        setRemoteVideoUrl(null);
                        setUseVideoMode(false);
                        setVideoTime(0);
                      }}
                      className="gap-2"
                    >
                      <X className="h-4 w-4" />
                      <span className="hidden sm:inline">Clear Video</span>
                    </Button>
                  )}
                </div>
              </div>
            )}
            <div className="flex items-center gap-1 md:gap-2">
              <Gamepad2 className={`w-4 h-4 md:w-5 md:h-5 ${isConnected ? 'text-success animate-glow-pulse' : 'text-muted-foreground'}`} />
              <span className={`text-xs md:text-sm font-bold ${isConnected ? 'text-success' : 'text-muted-foreground'}`}>
                {isConnected ? "Connected" : "Disconnected"}
              </span>
              {isConnected && pressedButtons.length > 0 && (
                <span className="text-xs font-mono bg-primary/20 px-2 py-1 rounded hidden lg:inline">
                  Buttons: {pressedButtons.join(', ')}
                </span>
              )}
              {!isConnected && (
                <Button
                  onClick={() => {
                    const result = manualCheck();
                    toast({
                      title: result ? "Controller Found!" : "No Controller Detected",
                      description: result ? "Gamepad connected successfully" : "Please connect a controller and press any button, then try again",
                      variant: result ? "default" : "destructive",
                    });
                  }}
                  variant="ghost"
                  size="sm"
                  className="h-6 md:h-7 text-xs hidden md:flex"
                >
                  Test Connection
                </Button>
              )}
              <ButtonMappingConfig
                mappings={mappings}
                pressedButtons={pressedButtons}
                onUpdateMapping={updateMapping}
                onResetMappings={resetMappings}
              />
            </div>
            <Button
              onClick={handleExport}
              variant="outline"
              size="sm"
              disabled={events.length === 0}
              className="gap-1 text-xs"
            >
              <Download className="w-3 h-3 md:w-4 md:h-4" />
              <span className="hidden sm:inline">Export CSV</span>
            </Button>
          </div>
        </div>
      </div>

      {/* Main Content Area */}
      <div className={`flex-1 overflow-hidden relative z-10 transition-colors duration-300 ${videoStream ? 'bg-black/20' : ''}`}>
        {role === 'viewer' ? (
          // Viewer Layout: Statistics + Event Log + Starting Lineup
          <div className="h-full max-w-7xl mx-auto p-2 md:p-4 grid grid-cols-1 lg:grid-cols-12 gap-2 md:gap-4">
            {/* Left Column: Starting Lineup (3 cols) */}
            <div className={`lg:col-span-3 flex flex-col overflow-hidden rounded-lg border border-border bg-card shadow-sm transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
              {teams.get(selectedTeam) ? (
                <StartingLineup
                  players={teams.get(selectedTeam)!.PlayerData}
                  teamName={selectedTeam}
                />
              ) : (
                <div className="p-4 text-center text-muted-foreground">
                  Waiting for team selection...
                </div>
              )}
            </div>

            {/* Middle Column: Stats (6 cols) */}
            <div className={`lg:col-span-6 rounded-lg border border-border bg-card shadow-sm p-2 md:p-4 transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
              <h2 className="text-lg md:text-xl font-bold mb-2 md:mb-4">Match Statistics</h2>
              <StatisticsDashboard events={events} />
            </div>

            {/* Right Column: Event Log (3 cols) */}
            <div className={`lg:col-span-3 flex flex-col overflow-hidden rounded-lg border border-border bg-card shadow-sm transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
              <EventLog
                events={events}
                teamNames={{
                  teamA: Array.from(teams.keys())[0] || "Team A",
                  teamB: Array.from(teams.keys())[1] || "Team B"
                }}
                onUndoEvent={handleUndoEvent}
              />
            </div>
          </div>
        ) : (
          // Broadcaster Layout: Full Grid
          <div className="h-full max-w-7xl mx-auto p-2 md:p-4 grid grid-cols-1 lg:grid-cols-12 gap-2 md:gap-4">
            {/* Left Sidebar - Player Selection */}
            <div className={`lg:col-span-3 flex flex-col overflow-hidden rounded-lg border border-border bg-card shadow-sm transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
              {!selectedTeam ? (
                <div className="space-y-6 p-4 overflow-y-auto">
                  <PlayerUpload onUpload={handleTeamUpload} />
                  {teams.size > 0 && (
                    <TeamGrid
                      teams={Array.from(teams.keys())}
                      onSelectTeam={handleTeamSelect}
                    />
                  )}
                </div>
              ) : (
                <>
                  <div className="flex justify-between items-center p-2 border-b border-border">
                    <Button variant="ghost" size="sm" onClick={() => handleTeamSelect("")}>
                      ‚Üê Back to Teams
                    </Button>
                  </div>
                  {teams.get(selectedTeam) && (
                    <PlayerSelectionSidebar
                      players={teams.get(selectedTeam)!.PlayerData}
                      selectedPlayerId={null}
                      onSelectPlayer={handlePlayerSelect}
                      teamName={selectedTeam}
                      startingNumbers={selectedTeam === "Algeria" ? [1, 2, 5, 6, 7, 8, 9, 10, 11, 15, 22] : undefined}
                    />
                  )}
                </>
              )}
            </div>

            {/* Center - Dashboard & Controller */}
            <div className="lg:col-span-6 flex flex-col gap-2 md:gap-4 overflow-y-auto no-scrollbar">
              {/* Live Stream Player */}
              {videoMode === 'live' && (
                <div className={`rounded-lg border border-border bg-card shadow-sm p-2 md:p-4 transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
                  <LiveStreamPlayer />
                </div>
              )}

              {/* Video Player */}
              {(() => {
                const shouldShow = (videoFile || remoteVideoUrl) && videoMode === 'upload';
                console.log("Video Player Render Check:", {
                  videoFile: !!videoFile,
                  remoteVideoUrl,
                  videoMode,
                  shouldShow
                });
                return shouldShow;
              })() && (
                  <div className={`rounded-lg border border-border bg-card shadow-sm p-2 md:p-4 transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
                    {/* Analysis View Toggle */}
                    <div className="flex justify-end mb-2">
                      <Button
                        variant={showAnalysisView ? "default" : "outline"}
                        size="sm"
                        onClick={() => setShowAnalysisView(!showAnalysisView)}
                        className="gap-2"
                      >
                        <Monitor className="h-4 w-4" />
                        {showAnalysisView ? 'Hide' : 'Show'} Analysis View
                      </Button>
                    </div>
                    <div className="space-y-4">
                      {/* Only show upload if we don't have a file/url OR if we want to replace it */}
                      {(!videoFile && !remoteVideoUrl) && (
                        <VideoUpload onVideoUpload={async (file) => {
                          setVideoFile(file);
                          setUseVideoMode(true);

                          // Upload to server for viewers
                          const formData = new FormData();
                          formData.append('video', file);

                          try {
                            const response = await fetch(`${API_BASE_URL}/api/upload-video`, {
                              method: 'POST',
                              body: formData
                            });
                            const data = await response.json();
                            if (data.success) {
                              console.log("Video uploaded to server:", data.videoUrl);
                              socket.emit('video-loaded', data.videoUrl);
                            }
                          } catch (e) {
                            console.error("Failed to upload video:", e);
                          }
                        }} />
                      )}

                      {(videoFile || remoteVideoUrl) && (
                        <div className="space-y-4">
                          <div className="aspect-video bg-black rounded-lg overflow-hidden border border-border relative group">
                            <VideoPlayer
                              videoFile={videoFile}
                              videoUrl={remoteVideoUrl}
                              events={events}
                              onTimeUpdate={(t) => {
                                setVideoTime(t);
                              }}
                              seekTo={seekTime}
                              isPlaying={isVideoPlaying}
                              onPlayPause={(playing) => {
                                setIsVideoPlaying(playing);
                                if (playing) socket.emit('video-play', videoTime);
                                else socket.emit('video-pause', videoTime);
                              }}
                              onSeekComplete={() => {
                                setSeekTime(null);
                              }}
                              onSeek={(time) => {
                                socket.emit('video-seek', time);
                              }}
                              axes={axes}
                              buttons={buttons}
                              teams={teams}
                              selectedTeam={selectedTeam}
                              teamNames={{
                                teamA: Array.from(teams.keys())[0] || "Team A",
                                teamB: Array.from(teams.keys())[1] || "Team B"
                              }}
                              onPlayerSelect={handlePlayerSelect}
                            />
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                )}

              <div className={`rounded-lg border border-border bg-card shadow-sm p-2 md:p-4 transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
                <Dashboard
                  events={events}
                  teamNames={{
                    teamA: Array.from(teams.keys())[0] || "Team A",
                    teamB: Array.from(teams.keys())[1] || "Team B"
                  }}
                />
              </div>

              {/* Analysis Dashboard */}
              <div className={`rounded-lg border border-border bg-card shadow-sm p-2 md:p-4 transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
                <TacticalAnalysisDashboard
                  events={events}
                  hasVideo={!!videoFile}
                  videoFile={videoFile}
                  onJumpToTime={(time) => {
                    console.log("Index.tsx: onJumpToTime called with:", time);
                    console.log("Index.tsx: videoFile exists:", !!videoFile);
                    setSeekTime(time);
                  }}
                  teamNames={{
                    teamA: Array.from(teams.keys())[0] || "Team A",
                    teamB: Array.from(teams.keys())[1] || "Team B"
                  }}
                  onRunClipAnalysis={async (clipStart, clipEnd) => {
                    if (!videoFile) {
                      toast({
                        title: "No Video",
                        description: "Please upload a video first.",
                        variant: "destructive"
                      });
                      return;
                    }

                    toast({
                      title: "Starting Analysis",
                      description: `Analyzing clip from ${Math.floor(clipStart)}s to ${Math.floor(clipEnd)}s...`,
                    });

                    const formData = new FormData();
                    formData.append('video', videoFile);
                    formData.append('clips', JSON.stringify([{ start: clipStart, end: clipEnd }]));

                    try {
                      const response = await fetch('http://localhost:3003/api/analyze-match', {
                        method: 'POST',
                        body: formData
                      });

                      const data = await response.json();

                      if (data.success) {
                        setAnalysisResults(data.results);
                        toast({
                          title: "Analysis Complete",
                          description: `Tracked ${Object.keys(data.results.tracks || {}).length} players in this clip.`,
                        });
                      } else {
                        throw new Error(data.error || 'Analysis failed');
                      }
                    } catch (error) {
                      console.error(error);
                      toast({
                        title: "Error",
                        description: "Failed to run analysis. Check console.",
                        variant: "destructive"
                      });
                    }
                  }}
                />
              </div>

              {/* Analysis Results Viewer */}
              {analysisResults && (
                <div className={`rounded-lg border border-border bg-card shadow-sm transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
                  <AnalysisResultsViewer results={analysisResults} />
                </div>
              )}

              {/* Controller Grid - Also transparent */}
              <div className={`rounded-lg border border-border bg-card shadow-sm p-2 md:p-4 flex-1 transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
                <ControllerGrid
                  pressedButtons={pressedButtons}
                  onManualInput={(event, button) => {
                    const newEvent: LoggedEvent = {
                      id: Date.now(),
                      timestamp: new Date().toISOString(),
                      eventName: event,
                      team: "TEAM_A", // Default for manual input
                      buttonLabel: button,
                      matchTime: formatTime(matchTimeRef.current)
                    };
                    handleEventLogged(newEvent);
                  }}
                  lastEventButtonLabel={lastEventButtonLabel}
                  mappings={mappings}
                />
              </div>
            </div>

            {/* Right Sidebar - Event Log */}
            <div className={`lg:col-span-3 flex flex-col overflow-hidden rounded-lg border border-border bg-card shadow-sm transition-all duration-300 ${videoStream ? 'bg-black/60 backdrop-blur-md border-white/10' : ''}`}>
              <EventLog
                events={events}
                teamNames={{
                  teamA: Array.from(teams.keys())[0] || "Team A",
                  teamB: Array.from(teams.keys())[1] || "Team B"
                }}
                onUndoEvent={handleUndoEvent}
              />
            </div>
          </div>
        )}
      </div>
    </div>
  );

  return pipWindow ? createPortal(MainContent, pipWindow.document.body) : MainContent;
};

export default Index;
</file>

<file path="src/pages/IndexContent.tsx">
import React from 'react';
import { createPortal } from 'react-dom';
import { useAuth } from '@/contexts/AuthContext';
import { useMatchContext } from '@/contexts/MatchContext';
import { useSocket as useSocketContext } from '@/contexts/SocketContext';
import { useIndexState } from '@/hooks/index/useIndexState';
import { useIndexEffects } from '@/hooks/index/useIndexEffects';
import { useIndexHandlers } from '@/hooks/index/useIndexHandlers';
import { useGamepad } from '@/hooks/useGamepad';
import { useDashboardLayout } from '@/hooks/useDashboardLayout';
import { MainLayout } from '@/layouts/MainLayout';
import { SafetyBoundary } from '@/components/common/SafetyBoundary';

export function IndexContent() {
    const auth = useAuth();
    const match = useMatchContext();
    const socketContext = useSocketContext();
    const layout = useDashboardLayout();

    // 1. Compose State
    const indexState = useIndexState(auth, match, socketContext);

    // 2. Compose side-effects
    useIndexEffects(indexState);

    // 3. Compose Handlers
    const handlers = useIndexHandlers(indexState);

    // 4. Gamepad integration (lives in a grey area between state and handlers)
    const gamepad = useGamepad(
        handlers.handleEventLogged,
        indexState.gamepadConfig,
        indexState.setIsVideoPlaying
    );

    // Combine everything for the layout
    const allProps = {
        ...indexState,
        ...handlers,
        ...gamepad,
        ...layout
    };

    const layoutComponent = <MainLayout {...allProps} />;

    return (
        <SafetyBoundary name="IndexContent">
            <>
                {layoutComponent}
                {indexState.pipWindow && createPortal(layoutComponent, indexState.pipWindow.document.body)}
            </>
        </SafetyBoundary>
    );
}
</file>

<file path="src/pages/KPIEngine.tsx">
import { useState } from "react";
import { KPISidebar } from "@/components/kpi/KPISidebar";
import { DashboardTab } from "@/components/kpi/tabs/DashboardTab";

import { MarketTab } from "@/components/kpi/tabs/MarketTab";
import { FinancialsTab } from "@/components/kpi/tabs/FinancialsTab";
import { UnitEconomicsTab } from "@/components/kpi/tabs/UnitEconomicsTab";
import { BusinessModelTab } from "@/components/kpi/tabs/BusinessModelTab";
import { DataSourcesTab } from "@/components/kpi/tabs/DataSourcesTab";

export default function KPIEngine() {
    const [activeTab, setActiveTab] = useState("dash");

    const tabs = [
        { id: "dash", label: "üìä Dashboard", Component: DashboardTab },
        { id: "market", label: "üéØ Market Analysis", Component: MarketTab },
        { id: "finance", label: "üí∞ Financials", Component: FinancialsTab },
        { id: "metrics", label: "üìà Unit Economics", Component: UnitEconomicsTab },
        { id: "bmc", label: "üè¢ Business Model", Component: BusinessModelTab },
        { id: "data", label: "üìã Data Sources", Component: DataSourcesTab },
    ];

    const ActiveComponent = tabs.find(t => t.id === activeTab)?.Component || DashboardTab;

    return (
        <div className="flex h-screen bg-slate-100 font-sans text-slate-800 overflow-hidden">
            <KPISidebar />

            <div className="flex flex-1 flex-col overflow-hidden">
                <div className="flex h-16 items-center gap-8 border-b border-slate-200 bg-white px-8">
                    {tabs.map(tab => (
                        <button
                            key={tab.id}
                            onClick={() => setActiveTab(tab.id)}
                            className={`flex h-full items-center border-b-2 px-1 text-sm font-medium transition-colors ${activeTab === tab.id
                                ? "border-blue-600 text-blue-600"
                                : "border-transparent text-slate-500 hover:text-blue-600"
                                }`}
                        >
                            {tab.label}
                        </button>
                    ))}
                </div>

                <div className="flex-1 overflow-y-auto p-10 print:p-0 print:overflow-visible">
                    <ActiveComponent />
                </div>
            </div>
        </div>
    );
}
</file>

<file path="src/pages/Login.tsx">
import React, { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { LogIn, ShieldCheck, AlertCircle } from 'lucide-react';
import { Alert, AlertDescription } from '@/components/ui/alert';

const Login: React.FC = () => {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const { login } = useAuth();
    const navigate = useNavigate();
    const location = useLocation();

    const from = (location.state as any)?.from?.pathname || "/";

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);
        setIsLoading(true);

        try {
            await login(username, password);
            navigate(from, { replace: true });
        } catch (err: any) {
            setError(err.message || 'Login failed. Please check your credentials.');
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="flex min-h-screen items-center justify-center bg-[#020617] p-4 relative overflow-hidden">
            {/* Background elements for premium feel */}
            <div className="absolute top-[-10%] left-[-10%] w-[40%] h-[40%] bg-primary/10 blur-[120px] rounded-full animate-pulse" />
            <div className="absolute bottom-[-10%] right-[-10%] w-[40%] h-[40%] bg-blue-500/10 blur-[120px] rounded-full animate-delay-1000" />

            <Card className="w-full max-w-md border-border/50 bg-card/50 backdrop-blur-xl shadow-2xl relative z-10">
                <CardHeader className="space-y-4 text-center">
                    <div className="mx-auto flex h-14 w-14 items-center justify-center rounded-2xl bg-primary/20 text-primary shadow-inner">
                        <ShieldCheck size={32} />
                    </div>
                    <div className="space-y-1">
                        <CardTitle className="text-3xl font-bold tracking-tight bg-gradient-to-br from-white to-gray-400 bg-clip-text text-transparent">
                            Tacta Pro
                        </CardTitle>
                        <CardDescription className="text-muted-foreground/80 font-medium">
                            Enter your credentials to access the analytics suite
                        </CardDescription>
                    </div>
                </CardHeader>
                <form onSubmit={handleSubmit}>
                    <CardContent className="space-y-5">
                        {error && (
                            <Alert variant="destructive" className="bg-destructive/10 border-destructive/20 animate-in fade-in zoom-in-95 duration-200">
                                <AlertCircle className="h-4 w-4" />
                                <AlertDescription>{error}</AlertDescription>
                            </Alert>
                        )}
                        <div className="space-y-2">
                            <Label htmlFor="username" className="text-xs font-bold uppercase tracking-widest text-muted-foreground/70">Username</Label>
                            <Input
                                id="username"
                                type="text"
                                placeholder="analyst_name"
                                value={username}
                                onChange={(e) => setUsername(e.target.value)}
                                className="bg-background/30 border-border/40 h-11 focus:ring-primary/40 focus:border-primary/40 transition-all"
                                required
                            />
                        </div>
                        <div className="space-y-2">
                            <Label htmlFor="password" className="text-xs font-bold uppercase tracking-widest text-muted-foreground/70">Password</Label>
                            <Input
                                id="password"
                                type="password"
                                placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                className="bg-background/30 border-border/40 h-11 focus:ring-primary/40 focus:border-primary/40 transition-all"
                                required
                            />
                        </div>
                    </CardContent>
                    <CardFooter className="pt-2">
                        <Button
                            className="w-full h-11 text-sm font-bold shadow-lg shadow-primary/20 hover:shadow-primary/30 transition-all duration-300"
                            disabled={isLoading}
                        >
                            {isLoading ? (
                                <span className="flex items-center gap-2">
                                    <div className="h-4 w-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                                    Authenticating...
                                </span>
                            ) : (
                                <span className="flex items-center gap-2">
                                    <LogIn size={18} />
                                    Sign In
                                </span>
                            )}
                        </Button>
                    </CardFooter>
                </form>
            </Card>

            {/* Version info or footer link */}
            <div className="absolute bottom-8 text-[10px] font-bold uppercase tracking-[0.2em] text-muted-foreground/40">
                Authorized Access Only ‚Ä¢ v2.4.0
            </div>
        </div>
    );
};

export default Login;
</file>

<file path="src/pages/Monitoring.tsx">
import React, { useEffect } from 'react';
import { useMatchContext } from '@/contexts/MatchContext';
import { useSocket as useSocketContext } from '@/contexts/SocketContext';
import { MatchStateIndicator } from '@/components/MatchStateIndicator';
import { SequenceAssistant, PredictorStats } from '@/components/SequenceAssistant';
import { PossessionTimeline } from '@/components/PossessionTimeline';
import { Brain, Activity, Shield, Users, LayoutDashboard, Database, ArrowLeft } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Card } from '@/components/ui/card';

const Monitoring = () => {
    const {
        matchState,
        stateLabel,
        isInTransition,
        predictions,
        learningStats,
        possessionId
    } = useMatchContext();

    const { connected, role, socket } = useSocketContext();

    // Ensure we are in viewer mode for monitoring
    // In a real app, this might be handled by auth/permissions
    useEffect(() => {
        if (socket && connected) {
            console.log('Monitoring mode active - Syncing from broadcaster...');
        }
    }, [socket, connected]);

    return (
        <div className="min-h-screen bg-[#0a0a0c] text-slate-200 font-sans selection:bg-purple-500/30">
            {/* TOP NAVIGATION / HEADER */}
            <header className="h-16 border-b border-border/40 bg-card/30 backdrop-blur-md px-6 flex items-center justify-between sticky top-0 z-50">
                <div className="flex items-center gap-4">
                    <button
                        onClick={() => window.location.href = '/'}
                        className="p-2 rounded-lg hover:bg-white/10 text-slate-400 hover:text-white transition-colors"
                    >
                        <ArrowLeft className="w-5 h-5" />
                    </button>
                    <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-purple-600 to-blue-600 flex items-center justify-center shadow-lg shadow-purple-500/20">
                        <Shield className="w-6 h-6 text-white" />
                    </div>
                    <div>
                        <h1 className="text-lg font-bold tracking-tight bg-gradient-to-r from-white to-slate-400 bg-clip-text text-transparent">
                            TACTA <span className="text-purple-500">ADMIN</span>
                        </h1>
                        <p className="text-[10px] text-muted-foreground uppercase tracking-widest font-semibold flex items-center gap-1.5 font-mono">
                            <Activity className="w-3 h-3 text-green-500 animate-pulse" />
                            Live Monitoring System
                        </p>
                    </div>
                </div>

                <div className="flex items-center gap-6">
                    {/* Status Indicators */}
                    <div className="flex items-center gap-3 px-4 py-2 rounded-full border border-border/40 bg-slate-900/50 backdrop-blur-sm self-center">
                        <div className="flex items-center gap-2 pr-3 border-r border-border/40">
                            <div className={cn(
                                "w-2 h-2 rounded-full shadow-[0_0_8px]",
                                connected ? "bg-green-500 shadow-green-500/50" : "bg-red-500 shadow-red-500/50"
                            )} />
                            <span className="text-xs font-medium">{connected ? 'CONNECTED' : 'OFFLINE'}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <Users className="w-3.5 h-3.5 text-blue-400" />
                            <span className="text-xs font-bold text-blue-400 uppercase tracking-wider">{role || 'GUEST'}</span>
                        </div>
                    </div>
                </div>
            </header>

            <main className="p-6 max-w-[1600px] mx-auto grid grid-cols-12 gap-6">
                {/* LEFT SIDEBAR - STATS & ENGINE STATUS */}
                <div className="col-span-12 lg:col-span-3 flex flex-col gap-6">
                    <Card className="bg-slate-900/40 border-border/40 backdrop-blur-sm p-4 ring-1 ring-white/5 shadow-2xl">
                        <div className="flex items-center gap-2 mb-4 text-purple-400">
                            <Brain className="w-5 h-5" />
                            <h2 className="text-sm font-bold uppercase tracking-wider">Predictor Engine</h2>
                        </div>
                        <PredictorStats className="bg-transparent border-none p-0 shadow-none" />
                    </Card>

                    <Card className="bg-slate-900/40 border-border/40 backdrop-blur-sm p-4 ring-1 ring-white/5 shadow-2xl">
                        <div className="flex items-center gap-2 mb-4 text-blue-400">
                            <Database className="w-5 h-5" />
                            <h2 className="text-sm font-bold uppercase tracking-wider">Session Context</h2>
                        </div>
                        <div className="space-y-3">
                            <div className="flex justify-between items-center py-2 border-b border-border/20">
                                <span className="text-xs text-muted-foreground">Current Chain ID</span>
                                <span className="text-xs font-mono font-bold text-white">#{possessionId || 'NONE'}</span>
                            </div>
                            <div className="flex justify-between items-center py-2 border-b border-border/20">
                                <span className="text-xs text-muted-foreground">Team Possession</span>
                                <span className={cn(
                                    "text-xs font-bold px-2 py-0.5 rounded",
                                    matchState.teamInPossession === 'TEAM_A' ? "bg-blue-500/20 text-blue-300" :
                                        matchState.teamInPossession === 'TEAM_B' ? "bg-red-500/20 text-red-300" : "bg-slate-800 text-slate-400"
                                )}>
                                    {matchState.teamInPossession || 'NEUTRAL'}
                                </span>
                            </div>
                            <div className="flex justify-between items-center py-2">
                                <span className="text-xs text-muted-foreground">Transition State</span>
                                <span className={cn(
                                    "text-xs font-bold px-2 py-0.5 rounded animate-pulse",
                                    isInTransition ? "bg-orange-500/20 text-orange-400 ring-1 ring-orange-500/50" : "bg-slate-800 text-slate-500"
                                )}>
                                    {isInTransition ? 'ACTIVE' : 'IDLE'}
                                </span>
                            </div>
                        </div>
                    </Card>
                </div>

                {/* MAIN DASHBOARD AREA */}
                <div className="col-span-12 lg:col-span-9 flex flex-col gap-6">
                    {/* Live State Visualization Wrapper */}
                    <div className="grid grid-cols-12 gap-6">
                        <div className="col-span-12 xl:col-span-7">
                            <div className="relative group">
                                <div className="absolute -inset-1 bg-gradient-to-r from-purple-500 to-blue-500 rounded-2xl blur opacity-20 group-hover:opacity-40 transition duration-1000 group-hover:duration-200"></div>
                                <MatchStateIndicator className="relative bg-slate-900/80 border-border/60 backdrop-blur-xl h-full shadow-inner" />
                            </div>
                        </div>

                        <div className="col-span-12 xl:col-span-5">
                            <SequenceAssistant className="bg-slate-900/80 border-border/60 backdrop-blur-xl h-full shadow-2xl" maxPredictions={4} />
                        </div>
                    </div>

                    {/* Timeline & Flow Section */}
                    <Card className="bg-slate-900/40 border-border/40 backdrop-blur-sm p-6 ring-1 ring-white/5 shadow-2xl flex-1">
                        <div className="flex items-center justify-between mb-6 border-b border-border/20 pb-4">
                            <div className="flex items-center gap-3">
                                <div className="p-2 rounded-lg bg-blue-500/10 text-blue-400 border border-blue-500/20">
                                    <LayoutDashboard className="w-5 h-5" />
                                </div>
                                <h2 className="text-lg font-bold">Possession Analysis Flow</h2>
                            </div>
                            <div className="flex items-center gap-2">
                                <span className="text-[10px] font-bold uppercase text-muted-foreground tracking-widest">Historical View</span>
                                <div className="w-1.5 h-1.5 rounded-full bg-blue-500 animate-pulse" />
                            </div>
                        </div>

                        <div className="min-h-[300px]">
                            <PossessionTimeline maxVisible={12} />
                        </div>
                    </Card>
                </div>
            </main>

            {/* DECORATIVE BACKGROUND ELEMENTS */}
            <div className="fixed top-0 right-0 w-[500px] h-[500px] bg-purple-600/5 blur-[120px] -z-10 rounded-full pointer-events-none" />
            <div className="fixed bottom-0 left-0 w-[500px] h-[500px] bg-blue-600/5 blur-[120px] -z-10 rounded-full pointer-events-none" />
        </div>
    );
};

export default Monitoring;
</file>

<file path="src/pages/NotFound.tsx">
import { useLocation } from "react-router-dom";
import { useEffect } from "react";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error("404 Error: User attempted to access non-existent route:", location.pathname);
  }, [location.pathname]);

  return (
    <div className="flex min-h-screen items-center justify-center bg-muted">
      <div className="text-center">
        <h1 className="mb-4 text-4xl font-bold">404</h1>
        <p className="mb-4 text-xl text-muted-foreground">Oops! Page not found</p>
        <a href="/" className="text-primary underline hover:text-primary/90">
          Return to Home
        </a>
      </div>
    </div>
  );
};

export default NotFound;
</file>

<file path="src/PITCH.PY">
import cv2
import numpy as np

# -----------------------------
# Load image
# -----------------------------
image = cv2.imread("screenshot.jpg")
if image is None:
    raise ValueError("Image not found")

original = image.copy()

# -----------------------------
# Convert to HSV
# -----------------------------
hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

# -----------------------------
# Mask white pitch lines
# -----------------------------
# White color range in HSV
lower_white = np.array([0, 0, 180])
upper_white = np.array([180, 60, 255])

mask = cv2.inRange(hsv, lower_white, upper_white)

# -----------------------------
# Morphological cleanup
# -----------------------------
kernel = np.ones((5, 5), np.uint8)
mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

# -----------------------------
# Edge detection
# -----------------------------
edges = cv2.Canny(mask, 50, 150, apertureSize=3)

# -----------------------------
# Hough Line Transform
# -----------------------------
lines = cv2.HoughLinesP(
    edges,
    rho=1,
    theta=np.pi / 180,
    threshold=120,
    minLineLength=80,
    maxLineGap=20
)

# -----------------------------
# Draw detected lines
# -----------------------------
if lines is not None:
    for line in lines:
        x1, y1, x2, y2 = line[0]
        cv2.line(original, (x1, y1), (x2, y2), (0, 0, 255), 2)

# -----------------------------
# Display results
# -----------------------------
cv2.imshow("Original", image)
cv2.imshow("White Mask", mask)
cv2.imshow("Edges", edges)
cv2.imshow("Detected Pitch Lines", original)

cv2.waitKey(0)
cv2.destroyAllWindows()
</file>

<file path="src/routes/analysis.routes.js">
// src/routes/analysis.routes.js - Analysis API routes
import express from 'express';
import { upload } from '../config/multer.js';
import { analyzeMatch } from '../services/analysis.service.js';

const router = express.Router();

router.post('/analyze-match', upload.single('video'), async (req, res) => {
    if (!req.file) {
        return res.status(400).json({ success: false, error: 'No video file uploaded' });
    }

    const videoPath = req.file.path;
    const clips = req.body.clips ? JSON.parse(req.body.clips) : null;
    const generateVideo = req.body.generate_annotated_video === 'true';

    console.log(`üìπ Analyzing: ${videoPath}, Clips: ${clips ? clips.length : 'full'}, Video: ${generateVideo}`);

    const result = await analyzeMatch(videoPath, {
        clips,
        generateVideo,
        conf: 0.3,
        remoteUrl: req.headers['x-remote-url'] || req.headers['x-runpod-url'] || req.headers['x-vast-ai-url']
    });

    if (result.success) {
        res.json(result);
    } else {
        res.status(500).json(result);
    }
});

router.post('/detect-players', upload.none(), async (req, res) => {
    const { image, homography } = req.body;

    if (!image) {
        return res.status(400).json({ success: false, error: 'No image data provided' });
    }

    const { detectPlayers } = await import('../services/analysis.service.js');
    const result = await detectPlayers(image, homography, req.body.high_contrast === 'true');

    if (result.success) {
        res.json(result);
    } else {
        res.status(500).json(result);
    }
});

export default router;
</file>

<file path="src/routes/auth.routes.js">
import express from 'express';
import { login } from '../services/auth.service.js';

const router = express.Router();

router.post('/login', async (req, res) => {
    const { username, password } = req.body;
    console.log(`[Auth] Login attempt for: ${username}`);
    try {
        const result = await login(username, password);
        console.log(`[Auth] Login result: ${result ? 'Success' : 'Failed'}`);

        if (!result) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        res.json(result);
    } catch (err) {
        console.error('[Auth] Login error:', err);
        res.status(401).json({ error: err.message });
    }
});

export default router;
</file>

<file path="src/routes/export.routes.js">
import express from 'express';
import { exec } from 'child_process';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';

const router = express.Router();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ensure public/extracted exists
const EXTRACTED_DIR = path.join(__dirname, '../../public/extracted');
if (!fs.existsSync(EXTRACTED_DIR)) {
    fs.mkdirSync(EXTRACTED_DIR, { recursive: true });
}

router.post('/extract-clip', async (req, res) => {
    try {
        const { videoPath, startTime, duration, eventType, eventName, outputRelativePath } = req.body;

        if (!videoPath || startTime === undefined) {
            return res.status(400).json({ success: false, error: "Missing videoPath or startTime" });
        }

        let finalOutputPath;
        let publicUrl;

        // NEW: If a full relative path (folder+filename) is provided, use it directly (under EXTRACTED_DIR)
        if (outputRelativePath) {
            // Remove leading slashes to prevent root escape
            const safeRelativePath = outputRelativePath.replace(/^(\.\.(\/|\\|$))+/, '');
            finalOutputPath = path.join(EXTRACTED_DIR, safeRelativePath);
            publicUrl = `/extracted/${safeRelativePath.replace(/\\/g, '/')}`; // Ensure web-safe URL
        } else {
            // LEGACY: Construct from eventType/Name
            const safeEventType = (eventType || 'unknown').replace(/[^a-zA-Z0-9_-]/g, '_');
            const safeEventName = (eventName || 'event').replace(/[^a-zA-Z0-9_-]/g, '_');
            const typeDir = path.join(EXTRACTED_DIR, safeEventType);

            if (!fs.existsSync(typeDir)) {
                fs.mkdirSync(typeDir, { recursive: true });
            }

            const timestamp = Date.now();
            const filename = `${timestamp}_${safeEventName}.mp4`;
            finalOutputPath = path.join(typeDir, filename);
            publicUrl = `/extracted/${safeEventType}/${filename}`;
        }

        // Ensure parent directory exists for the final output path
        const parentDir = path.dirname(finalOutputPath);
        if (!fs.existsSync(parentDir)) {
            fs.mkdirSync(parentDir, { recursive: true });
        }

        // Calculate start time (ensure non-negative)
        const start = Math.max(0, parseFloat(startTime));
        const dur = parseFloat(duration) || 10;

        // Construct FFmpeg command
        const command = `ffmpeg -ss ${start} -i "${videoPath}" -t ${dur} -c copy "${finalOutputPath}" -y`;

        console.log(`[Export] Executing: ${command}`);

        exec(command, (error, stdout, stderr) => {
            if (error) {
                console.error(`[Export] FFmpeg error: ${error.message}`);
                return res.status(500).json({ success: false, error: "FFmpeg execution failed" });
            }

            console.log(`[Export] Success: ${finalOutputPath}`);
            res.json({
                success: true,
                message: "Clip extracted successfully",
                path: finalOutputPath,
                url: publicUrl
            });
        });

    } catch (error) {
        console.error("[Export] Error:", error);
        res.status(500).json({ success: false, error: "Internal Server Error" });
    }
});

// NEW: List all extracted videos
router.get('/videos', async (req, res) => {
    try {
        if (!fs.existsSync(EXTRACTED_DIR)) {
            return res.json([]);
        }

        const getFilesRecursively = (dir) => {
            let results = [];
            const list = fs.readdirSync(dir);
            list.forEach((file) => {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat && stat.isDirectory()) {
                    results = results.concat(getFilesRecursively(filePath));
                } else if (file.endsWith('.mp4')) {
                    // Create web-accessible URL
                    // filePath is absolute, need relative to EXTRACTED_DIR
                    const relativePath = path.relative(EXTRACTED_DIR, filePath);
                    // Standardize slashes for URL
                    const urlPath = relativePath.replace(/\\/g, '/');

                    results.push({
                        filename: file,
                        path: relativePath, // logical path relative to /public/extracted
                        url: `/extracted/${urlPath}`,
                        date: stat.mtime,
                        size: stat.size
                    });
                }
            });
            return results;
        };

        const videos = getFilesRecursively(EXTRACTED_DIR);
        // Sort by newest first
        videos.sort((a, b) => new Date(b.date) - new Date(a.date));

        res.json(videos);
    } catch (error) {
        console.error("[Export] Error listing videos:", error);
        res.status(500).json({ success: false, error: "Failed to list videos" });
    }
});

export default router;
</file>

<file path="src/routes/heatmap.routes.js">
// src/routes/heatmap.routes.js - Heatmap API routes
import express from 'express';
import { spawn } from 'child_process';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { upload } from '../config/multer.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '../..');

const router = express.Router();

router.post('/extract-positions', upload.single('video'), (req, res) => {
    if (!req.file) return res.status(400).json({ error: 'No video file uploaded' });

    const videoPath = req.file.path;
    const startTime = req.body.startTime || 0;
    const endTime = req.body.endTime || null;
    const outputPath = path.join(rootDir, 'public', 'heatmaps', 'positions.json');
    const pythonScript = path.join(rootDir, 'python', 'extract_positions.py');

    const args = [pythonScript, '--video', videoPath, '--output', outputPath, '--frame-skip', '5', '--start-time', startTime.toString()];
    if (endTime) args.push('--end-time', endTime.toString());

    console.log(`Extracting positions: ${videoPath}`);
    const python = spawn('python', args);
    let stderr = '';

    python.stderr.on('data', (data) => stderr += data.toString());
    python.on('close', (code) => {
        if (code !== 0) return res.status(500).json({ error: 'Position extraction failed', details: stderr });
        fs.readFile(outputPath, 'utf8', (err, data) => {
            if (err) return res.status(500).json({ error: 'Failed to read positions file' });
            try { res.json({ success: true, positions: JSON.parse(data) }); }
            catch (e) { res.status(500).json({ error: 'Failed to parse positions data' }); }
        });
    });
});

router.post('/generate-heatmap', (req, res) => {
    const { team } = req.body;
    const scatter = req.body.scatter === true;
    const positionsPath = path.join(rootDir, 'public', 'heatmaps', 'positions.json');
    const outputFilename = team ? `heatmap_team_${team}.png` : 'heatmap_both.png';
    const outputPath = path.join(rootDir, 'public', 'heatmaps', outputFilename);
    const pythonScript = path.join(rootDir, 'python', 'generate_heatmap.py');

    if (!fs.existsSync(positionsPath)) return res.status(400).json({ error: 'No position data found.' });

    const args = [pythonScript, '--positions', positionsPath, '--output', outputPath];
    if (team) args.push('--team', team);
    if (scatter) args.push('--scatter');

    const python = spawn('python', args);
    let stderr = '';

    python.stderr.on('data', (data) => stderr += data.toString());
    python.on('close', (code) => {
        if (code !== 0) return res.status(500).json({ error: 'Heatmap generation failed', details: stderr });
        res.json({ success: true, heatmap: `/heatmaps/${outputFilename}` });
    });
});

export default router;
</file>

<file path="src/routes/lfp.routes.js">
import express from 'express';
import puppeteer from 'puppeteer';

const router = express.Router();

router.get('/scrape-lfp', async (req, res) => {
    console.log("Starting LFP scraping...");
    let browser;
    try {
        browser = await puppeteer.launch({
            headless: "new",
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        const page = await browser.newPage();

        // Anti-bot detection measures
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');

        // 1. Go to Clubs page
        const clubsUrl = 'https://www.lfp.dz/clubs';
        console.log(`Navigating to ${clubsUrl}`);
        await page.goto(clubsUrl, { waitUntil: 'domcontentloaded', timeout: 60000 });

        // Debug: Log page title to ensure we are not blocked
        const pageTitle = await page.title();
        console.log(`Page Title: ${pageTitle}`);

        // 2. Get all Club Links
        const clubLinks = await page.evaluate(() => {
            const links = Array.from(document.querySelectorAll('a'));
            return links
                // Use a broader filter to catch any club-related link
                .filter(a => a.href.includes('/club/view') || a.href.includes('/clubs/') || a.innerHTML.toLowerCase().includes('club'))
                .map(a => a.href.replace('/ar/', '/fr/')) // FORCE FRENCH
                .filter((v, i, a) => a.indexOf(v) === i); // Unique
        });

        console.log(`Found ${clubLinks.length} potential club links.`);

        const linksToScrape = clubLinks;
        const scrapedData = {};

        // 3. Visit each club page
        for (const link of linksToScrape) {
            try {
                // Ensure we are visiting the French version even if the link scraping got it wrong
                const frenchLink = link.replace('/ar/', '/fr/');
                console.log(`Scraping club: ${frenchLink}`);

                await page.goto(frenchLink, { waitUntil: 'networkidle2', timeout: 30000 });

                // Wait for the dynamic content to load (cards or table)
                try {
                    await page.waitForSelector('.club-player-card, table', { timeout: 5000 });
                } catch (e) {
                    console.log("Timeout waiting for player cards/table, proceeding anyway...");
                }

                const clubData = await page.evaluate(() => {
                    const url = window.location.href;

                    // ID-Based Mapping inside evaluate (browser context)
                    const CLUB_NAME_MAPPING = {
                        524: "ASO Chlef",
                        670: "CR Belouizdad",
                        678: "CS Constantine",
                        755: "ES Ben Aknoun",
                        694: "ES Mostaganem",
                        676: "ES Setif",
                        674: "JS Kabylie",
                        672: "JS Saoura",
                        409: "Mostakbal Rouissat",
                        677: "MC Alger",
                        657: "MC El Bayadh",
                        675: "MC Oran",
                        758: "Olympique Akbou",
                        680: "Paradou AC",
                        673: "USM Alger",
                        653: "USM Khenchela",
                        671: "US Biskra",
                        679: "NC Magra"
                    };

                    let teamName = "Unknown Club";

                    // Extract ID from URL (e.g., /club/524)
                    const idMatch = url.match(/\/club\/(\d+)/);
                    if (idMatch && idMatch[1]) {
                        const id = parseInt(idMatch[1]);
                        if (CLUB_NAME_MAPPING[id]) {
                            teamName = CLUB_NAME_MAPPING[id];
                        }
                    }

                    // Fallback to DOM if mapping fails
                    if (teamName === "Unknown Club") {
                        // Try to find a more specific header. The main H1 is often "Ligue de Football..."
                        // Try finding the second H2 or a breadcrumb
                        const breadcrumb = document.querySelector('.breadcrumb-item.active');
                        if (breadcrumb) teamName = breadcrumb.innerText.trim();
                    }

                    const players = [];
                    // STRATEGY: Card Based (based on user provided HTML)
                    const cards = Array.from(document.querySelectorAll('.club-player-card'));

                    cards.forEach(card => {
                        try {
                            const nameEl = card.querySelector('.card-title');
                            const numberEl = card.querySelector('.player-jersey');

                            if (nameEl && numberEl) {
                                const fullName = nameEl.innerText.trim();
                                const numberStr = numberEl.innerText.trim();
                                const number = parseInt(numberStr);

                                if (fullName && !isNaN(number)) {
                                    const nameSplit = fullName.split(' ');
                                    const forename = nameSplit[0] || "";
                                    const surname = nameSplit.slice(1).join(' ') || "";

                                    players.push({
                                        ID: Math.floor(Math.random() * 1000000),
                                        Forename: forename,
                                        Surname: surname,
                                        Number: number
                                    });
                                }
                            }
                        } catch (e) {
                            // ignore bad card
                        }
                    });

                    // Fallback to table if cards not found
                    if (players.length === 0) {
                        const rows = Array.from(document.querySelectorAll('table tr'));
                        rows.forEach((row) => {
                            const cols = Array.from(row.querySelectorAll('td'));
                            if (cols.length >= 2) {
                                const textContent = cols.map(c => c.innerText.trim());
                                let number = parseInt(textContent.find(t => /^\d{1,3}$/.test(t)));
                                let nameParts = textContent.filter(t => t.length > 3 && !/^\d+$/.test(t));
                                if (nameParts.length > 0 && number && number < 99) {
                                    players.push({
                                        ID: Math.floor(Math.random() * 1000000),
                                        Forename: nameParts[0].split(' ')[0],
                                        Surname: nameParts[0].split(' ').slice(1).join(' '),
                                        Number: number
                                    });
                                }
                            }
                        });
                    }

                    return { teamName, players, cardCount: cards.length };
                });

                console.log(`Debug ${clubData.teamName}: Found ${clubData.cardCount} cards. Extracted ${clubData.players.length} players.`);

                if (clubData.players.length > 0) {
                    scrapedData[clubData.teamName] = {
                        teamName: clubData.teamName,
                        PlayerData: clubData.players
                    };
                }

            } catch (err) {
                console.error(`Error scraping ${link}:`, err.message);
            }
        }

        await browser.close();

        console.log(`Scraping complete. Found ${Object.keys(scrapedData).length} teams.`);
        res.json(scrapedData);

    } catch (error) {
        console.error("Scraping failed:", error);
        if (browser) await browser.close();
        res.status(500).json({ error: "Scraping failed", details: error.message });
    }
});

export default router;
</file>

<file path="src/routes/proxy.routes.js">
// src/routes/proxy.routes.js - Check Content-Type before rewriting
import express from 'express';
import http from 'http';
import https from 'https';
import { URL } from 'url';

const router = express.Router();

router.get(/^\/proxy(\/.*)?$/, async (req, res) => {
    let targetUrl = '';

    const originalUrl = req.originalUrl;
    if (originalUrl.includes('?url=')) {
        targetUrl = originalUrl.split('?url=')[1];
    } else if (req.query.url) {
        targetUrl = req.query.url;
    } else if (req.params[0]) {
        targetUrl = req.params[0].substring(1);
    }

    if (targetUrl) {
        try {
            targetUrl = decodeURIComponent(targetUrl);
        } catch (e) {
            console.error('[Proxy] Decode error:', targetUrl.substring(0, 50));
        }
    }

    if (!targetUrl) return res.status(400).send('URL required');

    try {
        new URL(targetUrl);
    } catch (e) {
        return res.status(400).send('Invalid URL');
    }

    const fetchUrl = (url, redirectCount = 0) => {
        if (redirectCount > 5) {
            console.error('[Proxy] Too many redirects');
            return res.status(502).send('Too many redirects');
        }

        try {
            const parsedUrl = new URL(url);
            const isHttps = parsedUrl.protocol === 'https:';
            const client = isHttps ? https : http;

            const requestOptions = {
                hostname: parsedUrl.hostname,
                port: parsedUrl.port || (isHttps ? 443 : 80),
                path: parsedUrl.pathname + parsedUrl.search,
                method: 'GET',
                headers: {
                    'Host': parsedUrl.hostname,
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': '*/*',
                    'Accept-Encoding': 'identity',
                    'Connection': 'keep-alive',
                    'Referer': parsedUrl.origin + '/'
                },
                timeout: 30000
            };

            if (req.headers.range) {
                requestOptions.headers['Range'] = req.headers.range;
            }

            const shortUrl = url.length > 80 ? url.substring(0, 80) + '...' : url;
            console.log(`[Proxy] GET: ${shortUrl}`);

            const proxyReq = client.request(requestOptions, (proxyRes) => {
                const statusCode = proxyRes.statusCode;

                // Handle redirects
                if (statusCode >= 300 && statusCode < 400 && proxyRes.headers.location) {
                    let nextUrl = proxyRes.headers.location;
                    if (!nextUrl.startsWith('http')) {
                        nextUrl = new URL(nextUrl, url).toString();
                    }
                    const shortNext = nextUrl.length > 80 ? nextUrl.substring(0, 80) + '...' : nextUrl;
                    console.log(`[Proxy] Redirect ${statusCode} -> ${shortNext}`);
                    proxyRes.resume();
                    return fetchUrl(nextUrl, redirectCount + 1);
                }

                if (statusCode === 411) {
                    console.error('[Proxy] ‚ùå 411 error');
                    proxyRes.resume();
                    if (!res.headersSent) {
                        res.status(502).send('Server requires Content-Length');
                    }
                    return;
                }

                // CRITICAL: Check Content-Type to determine if this is ACTUALLY a manifest
                const contentType = (proxyRes.headers['content-type'] || '').toLowerCase();
                const isActualManifest = contentType.includes('mpegurl') ||
                    contentType.includes('m3u8') ||
                    contentType.includes('m3u') ||
                    contentType.includes('x-mpegurl');

                // Check if URL ends with .m3u8 (but handle query parameters)
                const urlLower = url.toLowerCase();
                const urlPath = urlLower.split('?')[0]; // Remove query params
                const isM3U8URL = urlPath.endsWith('.m3u8') || urlPath.endsWith('.m3u');

                // Only rewrite if:
                // 1. Status is 200 (success)
                // 2. Content-Type indicates it's a playlist/manifest
                // 3. URL suggests it's a manifest
                const shouldRewrite = statusCode === 200 &&
                    isActualManifest;

                console.log(`[Proxy] Content-Type: ${contentType}, isManifest: ${isActualManifest}, shouldRewrite: ${shouldRewrite}`);

                // If we expected a manifest but got HTML, log the error
                if (isM3U8URL && contentType.includes('html') && statusCode === 200) {
                    console.error('[Proxy] ‚ö†Ô∏è Expected manifest but got HTML! Reading error page...');

                    let errorBody = '';
                    proxyRes.setEncoding('utf8');
                    proxyRes.on('data', chunk => errorBody += chunk);
                    proxyRes.on('end', () => {
                        console.error('[Proxy] HTML Response:', errorBody.substring(0, 500));
                        if (!res.headersSent) {
                            res.status(502).json({
                                error: 'Expected m3u8 manifest but got HTML',
                                serverResponse: errorBody.substring(0, 200)
                            });
                        }
                    });
                    return;
                }

                if (shouldRewrite) {
                    console.log('[Proxy] üìã ACTUAL Manifest - rewriting URLs');

                    let body = '';
                    proxyRes.setEncoding('utf8');

                    proxyRes.on('data', chunk => {
                        body += chunk;
                    });

                    proxyRes.on('end', () => {
                        try {
                            const lines = body.split('\n');
                            let urlCount = 0;

                            const rewrittenLines = lines.map(line => {
                                const trimmed = line.trim();

                                // Skip comments and empty lines
                                if (!trimmed || trimmed.startsWith('#')) {
                                    return line;
                                }

                                // This is a URL - rewrite it
                                let segmentUrl;

                                if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
                                    segmentUrl = trimmed;
                                } else if (trimmed.startsWith('/')) {
                                    segmentUrl = parsedUrl.origin + trimmed;
                                } else {
                                    const baseUrl = url.substring(0, url.lastIndexOf('/') + 1);
                                    segmentUrl = baseUrl + trimmed;
                                }

                                urlCount++;
                                const proxiedUrl = `/api/proxy?url=${encodeURIComponent(segmentUrl)}`;

                                if (urlCount <= 3) {
                                    const shortSeg = trimmed.length > 40 ? trimmed.substring(0, 40) + '...' : trimmed;
                                    const shortProxy = proxiedUrl.length > 60 ? proxiedUrl.substring(0, 60) + '...' : proxiedUrl;
                                    console.log(`[Proxy] ‚Üí ${shortSeg} => ${shortProxy}`);
                                }

                                return proxiedUrl;
                            });

                            const rewrittenBody = rewrittenLines.join('\n');

                            res.status(200);
                            res.setHeader('Content-Type', 'application/vnd.apple.mpegurl');
                            res.setHeader('Content-Length', Buffer.byteLength(rewrittenBody));
                            res.setHeader('Access-Control-Allow-Origin', '*');
                            res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS');
                            res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Type, Accept, Origin');
                            res.setHeader('Access-Control-Expose-Headers', 'Content-Length, Content-Range, Content-Type');
                            res.setHeader('Cache-Control', 'no-cache');

                            console.log(`[Proxy] ‚úÖ Rewrote ${urlCount} URLs`);
                            res.send(rewrittenBody);

                        } catch (err) {
                            console.error('[Proxy] Rewrite error:', err.message);
                            if (!res.headersSent) {
                                res.status(500).send('Manifest rewrite failed');
                            }
                        }
                    });

                    proxyRes.on('error', (err) => {
                        console.error('[Proxy] Manifest read error:', err.message);
                        if (!res.headersSent) {
                            res.status(500).send('Error reading manifest');
                        }
                    });

                } else {
                    // NOT a manifest - pipe as binary
                    // Filter 401/407 to avoid browser proxy auth dialogs
                    const finalStatus = (statusCode === 401 || statusCode === 407) ? 502 : statusCode;
                    res.status(finalStatus);

                    // Copy headers
                    const skipHeaders = ['connection', 'keep-alive', 'transfer-encoding', 'upgrade',
                        'access-control-allow-origin', 'access-control-allow-methods',
                        'access-control-allow-headers', 'access-control-expose-headers'];

                    Object.keys(proxyRes.headers).forEach(key => {
                        if (!skipHeaders.includes(key.toLowerCase())) {
                            res.setHeader(key, proxyRes.headers[key]);
                        }
                    });

                    // Fix Content-Type if needed
                    let finalContentType = contentType;

                    if (url.includes('.ts') && (!finalContentType || finalContentType.includes('octet-stream'))) {
                        finalContentType = 'video/MP2T';
                        res.setHeader('Content-Type', finalContentType);
                    }

                    // CORS
                    res.setHeader('Access-Control-Allow-Origin', '*');
                    res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS');
                    res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Type, Accept, Origin');
                    res.setHeader('Access-Control-Expose-Headers', 'Content-Length, Content-Range, Content-Type, Accept-Ranges');

                    const size = proxyRes.headers['content-length'] || 'chunked';
                    const shortCT = finalContentType.length > 30 ? finalContentType.substring(0, 30) : finalContentType;
                    console.log(`[Proxy] ‚úÖ ${statusCode}: ${shortCT} (${size})`);

                    // Pipe binary data
                    proxyRes.pipe(res);
                }
            });

            proxyReq.on('error', (err) => {
                console.error('[Proxy] Request error:', err.message);
                if (!res.headersSent) {
                    res.status(502).json({ error: err.message });
                }
            });

            proxyReq.on('timeout', () => {
                console.error('[Proxy] Timeout');
                proxyReq.destroy();
                if (!res.headersSent) {
                    res.status(504).send('Timeout');
                }
            });

            proxyReq.end();

        } catch (err) {
            console.error('[Proxy] Exception:', err.message);
            if (!res.headersSent) {
                res.status(500).send('Internal error');
            }
        }
    };

    fetchUrl(targetUrl);
});

router.options(/^\/proxy(\/.*)?$/, (req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Range, Content-Type, Accept, Origin');
    res.setHeader('Access-Control-Expose-Headers', 'Content-Length, Content-Range, Content-Type, Accept-Ranges');
    res.sendStatus(204);
});

export default router;
</file>

<file path="src/routes/roboflow.routes.js">
// src/routes/roboflow.routes.js - Roboflow Pitch Keypoints Detection API
import express from 'express';

const router = express.Router();

// Roboflow model configuration
const ROBOFLOW_MODEL = 'pitch-keypoints-detection';
const ROBOFLOW_WORKSPACE = 'hacenbarb';
const ROBOFLOW_VERSION = '2';
const ROBOFLOW_API_URL = `https://detect.roboflow.com/${ROBOFLOW_MODEL}/${ROBOFLOW_VERSION}`;

/**
 * POST /api/detect-keypoints
 * Proxy endpoint for Roboflow pitch keypoint detection
 * 
 * Request body:
 * {
 *   image: string (base64 encoded image)
 * }
 * 
 * Response:
 * {
 *   predictions: [{ class, confidence, x, y, width, height }],
 *   image: { width, height }
 * }
 */
router.post('/detect-keypoints', async (req, res) => {
    try {
        const { image } = req.body;

        if (!image) {
            return res.status(400).json({
                success: false,
                error: 'Image data is required'
            });
        }

        const apiKey = process.env.ROBOFLOW_API_KEY;

        if (!apiKey) {
            return res.status(500).json({
                success: false,
                error: 'ROBOFLOW_API_KEY not configured. Please add it to your .env file.'
            });
        }

        // Call Roboflow API
        const roboflowResponse = await fetch(`${ROBOFLOW_API_URL}?api_key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: image, // Send base64 directly
        });

        if (!roboflowResponse.ok) {
            const errorText = await roboflowResponse.text();
            console.error('Roboflow API error:', errorText);
            return res.status(roboflowResponse.status).json({
                success: false,
                error: `Roboflow API error: ${roboflowResponse.status}`,
                details: errorText
            });
        }

        const data = await roboflowResponse.json();

        // Transform response to match our expected format
        const result = {
            success: true,
            predictions: data.predictions || [],
            image: {
                width: data.image?.width || 0,
                height: data.image?.height || 0
            }
        };

        console.log(`‚úÖ Detected ${result.predictions.length} keypoints`);
        res.json(result);

    } catch (error) {
        console.error('Keypoint detection error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to detect keypoints',
            details: error.message
        });
    }
});

/**
 * GET /api/roboflow-status
 * Check if Roboflow API is configured
 */
router.get('/roboflow-status', (req, res) => {
    const isConfigured = !!process.env.ROBOFLOW_API_KEY;
    res.json({
        success: true,
        configured: isConfigured,
        model: `${ROBOFLOW_WORKSPACE}/${ROBOFLOW_MODEL}`,
        version: ROBOFLOW_VERSION
    });
});

export default router;
</file>

<file path="src/routes/stream-info.routes.js">
// src/routes/stream-info.routes.js
// Diagnostic route to check stream codec and format
import express from 'express';
import { exec } from 'child_process';
import { promisify } from 'util';

const execPromise = promisify(exec);
const router = express.Router();

/**
 * Endpoint to get stream codec information using ffprobe
 * GET /api/stream-info?url=<stream_url>
 */
router.get('/stream-info', async (req, res) => {
    try {
        const { url } = req.query;

        if (!url) {
            return res.status(400).json({ error: 'URL parameter required' });
        }

        const streamUrl = decodeURIComponent(url);
        console.log('[Stream Info] Checking:', streamUrl);

        // Use ffprobe to get stream information
        const command = `ffprobe -v quiet -print_format json -show_format -show_streams "${streamUrl}"`;

        try {
            const { stdout, stderr } = await execPromise(command, { timeout: 10000 });

            if (stderr) {
                console.error('[Stream Info] ffprobe stderr:', stderr);
            }

            const info = JSON.parse(stdout);

            // Extract useful information
            const videoStream = info.streams?.find((s: any) => s.codec_type === 'video');
            const audioStream = info.streams?.find((s: any) => s.codec_type === 'audio');

            const result = {
                video: videoStream ? {
                    codec: videoStream.codec_name,
                    profile: videoStream.profile,
                    width: videoStream.width,
                    height: videoStream.height,
                    fps: videoStream.r_frame_rate,
                    bitrate: videoStream.bit_rate,
                    pixelFormat: videoStream.pix_fmt,
                    supported: checkBrowserSupport(videoStream.codec_name)
                } : null,
                audio: audioStream ? {
                    codec: audioStream.codec_name,
                    sampleRate: audioStream.sample_rate,
                    channels: audioStream.channels,
                    bitrate: audioStream.bit_rate
                } : null,
                format: info.format ? {
                    name: info.format.format_name,
                    duration: info.format.duration,
                    size: info.format.size,
                    bitrate: info.format.bit_rate
                } : null
            };

            console.log('[Stream Info] Result:', JSON.stringify(result, null, 2));
            res.json(result);

        } catch (execError: any) {
            console.error('[Stream Info] ffprobe error:', execError.message);
            return res.status(500).json({
                error: 'Failed to analyze stream',
                message: 'ffprobe not available or stream inaccessible',
                details: execError.message
            });
        }

    } catch (error: any) {
        console.error('[Stream Info] Error:', error);
        res.status(500).json({
            error: 'Internal error',
            message: error.message
        });
    }
});

/**
 * Check if a codec is supported in browsers
 */
function checkBrowserSupport(codec: string): {
    chrome: boolean;
    firefox: boolean;
    safari: boolean;
    edge: boolean;
    notes: string;
} {
    const lowerCodec = codec?.toLowerCase() || '';

    // H.264 / AVC
    if (lowerCodec.includes('h264') || lowerCodec.includes('avc')) {
        return {
            chrome: true,
            firefox: true,
            safari: true,
            edge: true,
            notes: 'Fully supported in all browsers'
        };
    }

    // H.265 / HEVC
    if (lowerCodec.includes('h265') || lowerCodec.includes('hevc')) {
        return {
            chrome: false,
            firefox: false,
            safari: true, // macOS/iOS only with hardware support
            edge: false, // Requires HEVC extension on Windows
            notes: 'Limited support. Only Safari on Apple devices. Not recommended for web.'
        };
    }

    // VP8
    if (lowerCodec.includes('vp8')) {
        return {
            chrome: true,
            firefox: true,
            safari: true,
            edge: true,
            notes: 'WebM codec, good browser support'
        };
    }

    // VP9
    if (lowerCodec.includes('vp9')) {
        return {
            chrome: true,
            firefox: true,
            safari: false, // Limited
            edge: true,
            notes: 'Modern WebM codec, good Chrome/Firefox support'
        };
    }

    // AV1
    if (lowerCodec.includes('av1')) {
        return {
            chrome: true,
            firefox: true,
            safari: false,
            edge: true,
            notes: 'Next-gen codec, growing support'
        };
    }

    return {
        chrome: false,
        firefox: false,
        safari: false,
        edge: false,
        notes: 'Unknown codec, likely unsupported'
    };
}

export default router;
</file>

<file path="src/routes/upload.routes.js">
// src/routes/upload.routes.js - Video upload routes
import express from 'express';
import { upload } from '../config/multer.js';

const router = express.Router();

router.post('/upload-video', (req, res, next) => {
    upload.single('video')(req, res, (err) => {
        if (err) {
            console.error("Upload Error:", err);
            return res.status(500).json({ success: false, error: err.message || "File upload failed" });
        }
        next();
    });
}, (req, res) => {
    if (!req.file) return res.status(400).json({ error: 'No video file uploaded' });

    const videoUrl = `/uploads/${req.file.filename}`;
    // Construct absolute path for FFmpeg usage later
    const filePath = req.file.path;
    console.log(`Video uploaded: ${videoUrl}`);

    res.json({ success: true, videoUrl, filePath });
});

router.post('/upload-image', upload.single('image'), (req, res) => {
    if (!req.file) return res.status(400).json({ error: 'No image file uploaded' });

    const imageUrl = `/uploads/${req.file.filename}`;
    console.log(`Image uploaded: ${imageUrl}`);

    res.json({ success: true, imageUrl });
});

export default router;
</file>

<file path="src/routes/user.routes.js">
import express from 'express';
import * as authService from '../services/auth.service.js';
import { authMiddleware, roleMiddleware } from '../middleware/authMiddleware.js';

const router = express.Router();

// All user routes require admin role
router.use(authMiddleware);
router.use(roleMiddleware(['admin']));

// Get all users
router.get('/', async (req, res) => {
    try {
        const users = await authService.getAllUsers();
        res.json(users);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Add new user
router.post('/', async (req, res) => {
    try {
        const result = await authService.addUser(req.body);
        res.json(result);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// Update user
router.put('/:username', async (req, res) => {
    try {
        const result = await authService.updateUser(req.params.username, req.body);
        res.json(result);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// Delete user
router.delete('/:username', async (req, res) => {
    try {
        const result = await authService.deleteUser(req.params.username);
        res.json(result);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

export default router;
</file>

<file path="src/services/analysis.service.js">
// src/services/analysis.service.js - Analysis service (local Python or Replicate)
import { spawn } from 'child_process';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { ReplicateAnalyzer } from '../../replicate-analyzer.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '../..');

const replicateAnalyzer = new ReplicateAnalyzer();

export async function analyzeMatch(videoPath, options = {}) {
    // Check for Remote URL (RunPod)
    if (options.remoteUrl) {
        console.log(`üöÄ Using Remote Server: ${options.remoteUrl}`);
        return await analyzeWithRemote(videoPath, options);
    }

    // Use Replicate if configured
    if (replicateAnalyzer.isEnabled()) {
        console.log('üöÄ Using Replicate GPU for analysis');
        return await analyzeWithReplicate(videoPath, options);
    } else {
        console.log('üíª Using local Python for analysis');
        return await analyzeWithPython(videoPath, options);
    }
}

async function analyzeWithRemote(videoPath, options) {
    try {
        const FormData = (await import('form-data')).default;
        const fetch = (await import('node-fetch')).default;
        const fs = (await import('fs')).default;

        const form = new FormData();
        form.append('video', fs.createReadStream(videoPath));

        if (options.clips) {
            form.append('clips', JSON.stringify(options.clips));
        }

        form.append('generate_video', String(options.generateVideo || false));
        form.append('conf', String(options.conf || 0.3));

        const remoteUrl = options.remoteUrl.replace(/\/$/, ''); // Remove trailing slash
        const response = await fetch(`${remoteUrl}/analyze`, {
            method: 'POST',
            body: form,
            headers: form.getHeaders()
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Remote server error (${response.status}): ${errorText}`);
        }

        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Remote analysis failed:', error);
        return { success: false, error: error.message };
    }
}

async function analyzeWithReplicate(videoPath, options) {
    try {
        const results = await replicateAnalyzer.analyze(videoPath, {
            confidenceThreshold: options.conf || 0.3,
            generateVideo: options.generateVideo || false
        });

        return { success: true, results };
    } catch (error) {
        console.error('Replicate analysis failed:', error);
        return { success: false, error: error.message };
    }
}

function analyzeWithPython(videoPath, options) {
    return new Promise((resolve, reject) => {
        const pythonScript = path.join(rootDir, 'python', 'analyze_match.py');
        const outputPath = path.join(rootDir, 'public', 'analysis', `analysis-${Date.now()}.json`);

        const outputDir = path.dirname(outputPath);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        const args = [pythonScript, '--video', videoPath, '--output', outputPath];

        if (options.clips && options.clips.length > 0) {
            args.push('--clips', JSON.stringify(options.clips));
        }

        if (options.generateVideo) {
            args.push('--generate-video');
        }

        const python = spawn('python', args);
        let stdout = '';
        let stderr = '';

        python.stdout.on('data', (data) => {
            stdout += data.toString();
            console.log('[Python]:', data.toString().trim());
        });

        python.stderr.on('data', (data) => {
            stderr += data.toString();
            console.error('[Python Error]:', data.toString().trim());
        });

        python.on('close', (code) => {
            if (code !== 0) {
                return resolve({ success: false, error: 'Analysis failed', details: stderr });
            }

            try {
                const results = JSON.parse(fs.readFileSync(outputPath, 'utf8'));
                resolve({ success: true, results });
            } catch (e) {
                resolve({ success: false, error: 'Failed to parse results', details: e.message });
            }
        });
    });
}

export async function detectPlayers(image, homography, useHighContrast = false) {
    try {
        const fetch = (await import('node-fetch')).default;
        const FormData = (await import('form-data')).default;

        const form = new FormData();
        form.append('image', image);
        if (homography) {
            form.append('homography', homography);
        }
        form.append('high_contrast', useHighContrast ? 'true' : 'false');

        // Try local Python API or remote analysis URL
        const analysisBaseUrl = process.env.VITE_ANALYSIS_API_URL || 'http://localhost:8000';
        const response = await fetch(`${analysisBaseUrl}/api/detect-players`, {
            method: 'POST',
            body: form,
            headers: form.getHeaders()
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Python API error (${response.status}): ${errorText}`);
        }

        return await response.json();
    } catch (error) {
        console.error('Player detection failed:', error);
        return { success: false, error: error.message };
    }
}
</file>

<file path="src/services/auth.service.js">
import { API_BASE_URL } from '../utils/apiConfig.js';

export const DEFAULT_ROLE_PERMISSIONS = {
    'admin': ['*'], // Superuser access
    'operational_analyst': [
        'dashboard.view',
        'dashboard.live.view',
        'dashboard.live.match_control',
        'dashboard.live.voice',
        'dashboard.live.stream.view',
        'dashboard.export',
        'stats.view'
    ],
    'tactical_analyst': [
        'dashboard.view',
        'dashboard.post.view',
        'dashboard.post.upload',
        'dashboard.post.edit',
        'dashboard.post.delete',
        'dashboard.post.assign_player',
        'dashboard.export',
        'video.annotation',
        'video.player_tracking',
        'analytics.view',
        'analytics.advanced',
        'stats.view'
    ],
    'quality_controller': [
        'dashboard.view',
        'dashboard.live.view', // Can view live feed
        'dashboard.post.view', // Can view post match
        'qa.view',
        'qa.verify',
        'qa.bulk_verify',
        'qa.edit_metadata',
        'qa.resolve_pass',
        'monitoring.view',
        'stats.view',
        'community.view'
    ],
    'early_tester': [
        'dashboard.view',
        'dashboard.live.view',
        'dashboard.live.match_control', // Added for Collaboration (Live Input)
        'dashboard.post.view',
        'dashboard.post.edit',        // Added for Collaboration (Post-Match Input)
        'dashboard.export',
        'qa.view',
        'qa.verify',
        'qa.edit_metadata',
        'stats.view'
    ],
    'lead_analyst': [
        'dashboard.view',
        'dashboard.live.view',
        'stats.view',
        'qa.view',
        'monitoring.view'
    ],
    'live_tagger': [
        'dashboard.view',
        'dashboard.live.view',
        'dashboard.live.match_control',
        'dashboard.live.tagging' // Only this role can tag
    ],
    'eye_spotter': [
        'dashboard.view',
        'dashboard.live.view',
        'dashboard.live.voice'
    ],
    'logger': [
        'dashboard.view',
        'dashboard.live.view',
        'qa.view',
        'qa.verify',
        'monitoring.view'
    ]
};

// Mock In-Memory Database
// In a real app, this would be in a DB
const USERS = [
    { id: 1, username: 'admin', password: 'password', role: 'admin', name: 'Admin User', permissions: [] },
    { id: 2, username: 'analyst', password: 'password', role: 'operational_analyst', name: 'Operational Analyst', permissions: [] },
    { id: 3, username: 'tactical', password: 'password', role: 'tactical_analyst', name: 'Tactical Analyst', permissions: [] },
    { id: 4, username: 'qc', password: 'password', role: 'quality_controller', name: 'Quality Controller', permissions: [] },
    { id: 5, username: 'tester', password: 'password', role: 'early_tester', name: 'Early Tester', permissions: [] },
    { id: 6, username: 'lead', password: 'password', role: 'lead_analyst', name: 'Lead Analyst', permissions: [] },
    { id: 7, username: 'tagger', password: 'password', role: 'live_tagger', name: 'Live Tagger', permissions: [] },
    { id: 8, username: 'spotter', password: 'password', role: 'eye_spotter', name: 'Eye Spotter', permissions: [] },
    { id: 9, username: 'logger', password: 'password', role: 'logger', name: 'Logger', permissions: [] }
];

export const login = async (username, password) => {
    // In a real app, verify password hash
    console.log(`[AuthService] Verifying user: ${username}`);
    const user = USERS.find(u => u.username === username && u.password === password);
    if (!user) {
        console.log('[AuthService] User not found');
        return null;
    }

    // Merge default role permissions with any user-specific overrides
    const roleDefaults = DEFAULT_ROLE_PERMISSIONS[user.role] || [];
    const userSpecific = user.permissions || [];
    const effectivePermissions = [...new Set([...roleDefaults, ...userSpecific])];

    console.log(`[AuthService] User ${username} Role: ${user.role} Permissions: ${effectivePermissions.length}`);

    const token = Buffer.from(`${username}:${Date.now()}`).toString('base64');

    // Return user without password but WITH permissions
    const { password: _, ...userWithoutPass } = user;
    return { token, user: { ...userWithoutPass, permissions: effectivePermissions } };
};

export const verifyToken = (token) => {
    // Real token verification and user lookup
    if (!token) return null;
    try {
        const decoded = Buffer.from(token, 'base64').toString('utf-8');
        const [username, timestamp] = decoded.split(':');

        const user = USERS.find(u => u.username === username);
        if (!user) return null;

        // Re-calculate permissions
        const roleDefaults = DEFAULT_ROLE_PERMISSIONS[user.role] || [];
        const userSpecific = user.permissions || [];
        const effectivePermissions = [...new Set([...roleDefaults, ...userSpecific])];

        const { password: _, ...userWithoutPass } = user;
        return { ...userWithoutPass, permissions: effectivePermissions };
    } catch (err) {
        console.error('[AuthService] Token verification failed:', err.message);
        return null;
    }
};

export const getAllUsers = async () => {
    return USERS.map(({ password, ...user }) => ({
        ...user,
        // Calculate and send their effective permissions so Admin UI can show them
        effectivePermissions: [...new Set([...(DEFAULT_ROLE_PERMISSIONS[user.role] || []), ...(user.permissions || [])])]
    }));
};

export const addUser = async (userData) => {
    const newUser = {
        id: USERS.length + 1,
        ...userData,
        permissions: userData.permissions || []
    };
    USERS.push(newUser);
    return { ...newUser, password: undefined };
};

export const deleteUser = async (id) => {
    const idx = USERS.findIndex(u => u.id === parseInt(id));
    if (idx !== -1) {
        USERS.splice(idx, 1);
        return true;
    }
    return false;
};

export const updateUser = async (id, updates) => {
    const idx = USERS.findIndex(u => u.id === parseInt(id));
    if (idx !== -1) {
        USERS[idx] = { ...USERS[idx], ...updates };
        const { password, ...userWithoutPass } = USERS[idx];
        return userWithoutPass;
    }
    return null;
};
</file>

<file path="src/socket/handlers.js">
// src/socket/handlers.js
import { state, broadcasterId, setBroadcasterId, resetBroadcaster } from '../config/state.js';
import OBSWebSocket from 'obs-websocket-js';

const obsInstances = new Map(); // Map socket.id -> OBSWebSocket instance

export function setupSocketHandlers(io) {
    io.on('connection', (socket) => {
        console.log('New client connected:', socket.id);

        // Send current state to new client
        socket.emit('sync-state', state);
        console.log(`Sent initial state. Teams: ${state.teams.length}, Selected: ${state.selectedTeam}`);

        // Assign broadcaster/viewer role based on authenticated user data
        const role = (socket.user?.role === 'admin' || socket.user?.role === 'live_tagger') ? 'broadcaster' : 'viewer';

        if (role === 'broadcaster') {
            setBroadcasterId(socket.id);
            console.log(`üé≠ Assigned AUTHORITATIVE role to ${socket.id} (${socket.user?.role})`);
        }

        socket.emit('role-assignment', role);
        console.log(`üë§ Client ${socket.id} role: ${role}`);

        // Test Connection Handler
        socket.on('test-connection', (data) => {
            console.log('‚úÖ‚úÖ‚úÖ TEST CONNECTION RECEIVED:', data);
            socket.emit('test-response', {
                message: 'Socket is working!',
                received: data,
                timestamp: new Date().toISOString()
            });
        });

        // WebRTC Signaling (Video)
        socket.on('watcher', () => {
            if (broadcasterId) io.to(broadcasterId).emit('watcher', socket.id);
        });
        socket.on('offer', (id, message) => io.to(id).emit('offer', socket.id, message));
        socket.on('answer', (id, message) => io.to(id).emit('answer', socket.id, message));
        socket.on('candidate', (id, message) => io.to(id).emit('candidate', socket.id, message));

        // WebRTC Signaling (Audio)
        socket.on('audio-watcher', () => {
            if (broadcasterId) io.to(broadcasterId).emit('audio-watcher', socket.id);
        });
        socket.on('audio-broadcaster-ready', () => socket.broadcast.emit('audio-broadcaster-ready'));
        socket.on('audio-offer', (data) => io.to(data.to).emit('audio-offer', { offer: data.offer, from: socket.id }));
        socket.on('audio-answer', (data) => io.to(data.to).emit('audio-answer', { answer: data.answer, from: socket.id }));
        socket.on('audio-candidate', (data) => io.to(data.to).emit('audio-candidate', { candidate: data.candidate, from: socket.id }));
        socket.on('audio-broadcast-stopped', () => socket.broadcast.emit('audio-broadcast-stopped'));

        // WebRTC Signaling (Audio - Multi-User Voice Room)
        socket.on('join-voice-room', () => {
            // 1. Get existing users with their info
            const voiceUsers = Array.from(io.sockets.sockets.values())
                .filter(s => s.voiceRoomJoined && s.id !== socket.id)
                .map(s => ({
                    id: s.id,
                    name: s.user?.username || 'Unknown',
                    role: s.user?.role || 'user'
                }));

            socket.voiceRoomJoined = true;
            console.log(`üéôÔ∏è User joined voice room: ${socket.id} (${socket.user?.username})`);

            // 2. Tell existing users about the new user (with info)
            const newUserInfo = {
                id: socket.id,
                name: socket.user?.username || 'Unknown',
                role: socket.user?.role || 'user'
            };

            Array.from(io.sockets.sockets.values())
                .filter(s => s.voiceRoomJoined && s.id !== socket.id)
                .forEach(s => {
                    io.to(s.id).emit('voice-user-joined', newUserInfo);
                });

            // 3. Send list of existing users to the new user
            socket.emit('voice-existing-users', voiceUsers);
        });

        socket.on('leave-voice-room', () => {
            socket.voiceRoomJoined = false;
            console.log(`üîá User left voice room: ${socket.id}`);
            socket.broadcast.emit('voice-user-left', socket.id);
        });

        socket.on('voice-signal', (data) => {
            // Relay WebRTC signals (offer, answer, candidate) to the specific peer
            io.to(data.to).emit('voice-signal', {
                signal: data.signal,
                from: socket.id
            });
        });

        // Data Synchronization
        socket.on('new-event', (event) => {
            console.log('New event received:', event.eventName);
            state.events.push(event);
            socket.broadcast.emit('new-event', event);
        });

        socket.on('update-event', (updatedEvent) => {
            console.log('Event update received:', updatedEvent.id);
            const index = state.events.findIndex(e => e.id === updatedEvent.id);
            if (index !== -1) {
                state.events[index] = updatedEvent;
                socket.broadcast.emit('update-event', updatedEvent);
            }
        });

        socket.on('sync-timer', (data) => {
            state.matchTime = data.matchTime;
            state.isMatchActive = data.isMatchActive;
            socket.broadcast.emit('sync-timer', data);
        });

        socket.on('sync-teams', (teams) => {
            console.log(`Syncing teams: Received ${teams.length} teams.`);
            state.teams = teams;
            socket.broadcast.emit('sync-teams', teams);
        });

        socket.on('select-team', (teamId) => {
            console.log(`Team Selected: ${teamId}`);
            state.selectedTeam = teamId;
            socket.broadcast.emit('select-team', teamId);
        });

        socket.on('undo-event', (eventId) => {
            console.log(`Undo event: ${eventId}`);
            state.events = state.events.filter(e => e.id !== eventId);
            socket.broadcast.emit('undo-event', eventId);
        });

        // Video Sync
        socket.on('video-sync', (data) => {
            console.log(`Video sync: time=${data.currentTime?.toFixed(2)}s, playing=${data.isPlaying}, rate=${data.playbackRate}`);
            state.videoState = {
                currentTime: data.currentTime || 0,
                isPlaying: data.isPlaying || false,
                playbackRate: data.playbackRate || 1.0,
                videoUrl: data.videoUrl || state.videoState.videoUrl
            };
            socket.broadcast.emit('video-sync', state.videoState);
        });

        socket.on('video-play', (currentTime) => {
            console.log(`Video play at: ${currentTime?.toFixed(2)}s`);
            state.videoState.isPlaying = true;
            state.videoState.currentTime = currentTime || 0;
            socket.broadcast.emit('video-play', currentTime);
        });

        socket.on('video-pause', (currentTime) => {
            console.log(`Video pause at: ${currentTime?.toFixed(2)}s`);
            state.videoState.isPlaying = false;
            state.videoState.currentTime = currentTime || 0;
            socket.broadcast.emit('video-pause', currentTime);
        });

        socket.on('video-seek', (currentTime) => {
            console.log(`Video seek to: ${currentTime?.toFixed(2)}s`);
            state.videoState.currentTime = currentTime || 0;
            socket.broadcast.emit('video-seek', currentTime);
        });

        socket.on('video-loaded', (videoUrl) => {
            console.log(`Video loaded: ${videoUrl}`);
            state.videoState.videoUrl = videoUrl;
            state.videoState.currentTime = 0;
            state.videoState.isPlaying = false;
            socket.broadcast.emit('video-loaded', videoUrl);
        });

        // Session Controls
        socket.on('start-session', () => {
            console.log('üöÄ Session started by admin');
            state.isSessionStarted = true;
            io.emit('session-started');
        });

        socket.on('video-mode-sync', (data) => {
            console.log(`üìπ Video mode sync: ${data.mode}, useVideo: ${data.useVideoMode}`);
            state.videoMode = data.mode;
            state.useVideoMode = data.useVideoMode;
            socket.broadcast.emit('video-mode-change', data);
        });

        socket.on('match-state-sync', (data) => {
            // Update global state
            if (data.streamUrl !== undefined) state.streamUrl = data.streamUrl;
            if (data.videoMode !== undefined) state.videoMode = data.videoMode;
            if (data.useVideoMode !== undefined) state.useVideoMode = data.useVideoMode;
            if (data.isSessionStarted !== undefined) state.isSessionStarted = data.isSessionStarted;

            // Broadcast to all other clients
            socket.broadcast.emit('match-state-remote-sync', data);
        });

        // ===== OBS PROXY ===== (SUPER VERBOSE LOGGING)
        socket.on('obs-proxy-connect', async ({ address, password }) => {
            console.log('');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üîå OBS PROXY CONNECT EVENT RECEIVED');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('Socket ID:', socket.id);
            console.log('Address:', address);
            console.log('Password:', password ? '[SET]' : '[NOT SET]');
            console.log('Time:', new Date().toISOString());
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('');

            try {
                // Validate input
                if (!address || typeof address !== 'string') {
                    throw new Error('Invalid OBS WebSocket address');
                }

                // Cleanup existing connection if any
                if (obsInstances.has(socket.id)) {
                    console.log(`üßπ Cleaning up existing OBS connection for ${socket.id}`);
                    try {
                        await obsInstances.get(socket.id).disconnect();
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Error disconnecting previous OBS:', e.message);
                    }
                    obsInstances.delete(socket.id);
                }

                // Create new OBS instance
                console.log('üì¶ Creating new OBS WebSocket instance...');
                const obs = new OBSWebSocket();
                console.log('‚úÖ OBS WebSocket instance created');

                // Set up event listeners BEFORE connecting
                obs.on('ConnectionClosed', () => {
                    console.log(`‚ùå OBS Connection Closed for ${socket.id}`);
                    socket.emit('obs-proxy-disconnected');
                    obsInstances.delete(socket.id);
                });

                obs.on('RecordStateChanged', (data) => {
                    console.log(`üìπ Record State Changed for ${socket.id}:`, data);
                    socket.emit('obs-proxy-event', {
                        event: 'RecordStateChanged',
                        data
                    });
                });

                obs.on('StreamStateChanged', (data) => {
                    console.log(`üì° Stream State Changed for ${socket.id}:`, data);
                    socket.emit('obs-proxy-event', {
                        event: 'StreamStateChanged',
                        data
                    });
                });

                obs.on('ConnectionError', (err) => {
                    console.error(`‚ùå OBS Connection Error for ${socket.id}:`, err);
                    socket.emit('obs-proxy-error', {
                        message: `Connection error: ${err.message}`
                    });
                });

                console.log('üéß Event listeners attached');

                // Connect with proper configuration
                const connectionOptions = {
                    rpcVersion: 1,
                    eventSubscriptions: 0xFFFF
                };

                console.log('üîÑ Calling obs.connect()...');
                console.log('   Address:', address);
                console.log('   Password:', password ? '[HIDDEN]' : 'undefined');
                console.log('   Options:', connectionOptions);

                await obs.connect(address, password || undefined, connectionOptions);

                console.log('‚úÖ‚úÖ‚úÖ OBS CONNECTED SUCCESSFULLY! ‚úÖ‚úÖ‚úÖ');

                // Store the instance
                obsInstances.set(socket.id, obs);

                console.log('üì§ Emitting obs-proxy-connected to client...');
                socket.emit('obs-proxy-connected', { address });
                console.log('‚úÖ Event emitted');

            } catch (err) {
                console.log('');
                console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                console.log('‚ïë  ‚ùå OBS CONNECTION FAILED                         ‚ïë');
                console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                console.error('Error Type:', err.constructor.name);
                console.error('Error Message:', err.message);
                console.error('Error Code:', err.code);
                console.error('Error Stack:', err.stack);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                let errorMessage = 'Failed to connect to OBS';
                let errorCode = err.code;

                if (err.code === 'ECONNREFUSED') {
                    errorMessage = 'Connection refused. Make sure OBS is running and WebSocket server is enabled (Tools ‚Üí WebSocket Server Settings).';
                } else if (err.code === 'ETIMEDOUT' || err.code === 'TIMEOUT') {
                    errorMessage = 'Connection timeout. Check the OBS address and ensure port 4455 is not blocked by firewall.';
                } else if (err.code === 'ENOTFOUND') {
                    errorMessage = `Host not found. Check the OBS WebSocket address: ${address}`;
                } else if (err.message?.toLowerCase().includes('authentication') ||
                    err.message?.toLowerCase().includes('password')) {
                    errorMessage = 'Authentication failed. Check your OBS WebSocket password in Tools ‚Üí WebSocket Server Settings.';
                } else if (err.message?.toLowerCase().includes('rpc')) {
                    errorMessage = 'OBS WebSocket version mismatch. Make sure you have OBS Studio v28.0+ installed.';
                } else if (err.message) {
                    errorMessage = err.message;
                }

                // Cleanup
                if (obsInstances.has(socket.id)) {
                    try {
                        await obsInstances.get(socket.id).disconnect();
                    } catch (e) {
                        // Ignore cleanup errors
                    }
                    obsInstances.delete(socket.id);
                }

                console.log('üì§ Emitting obs-proxy-error to client...');
                socket.emit('obs-proxy-error', {
                    message: errorMessage,
                    code: errorCode
                });
                console.log('‚úÖ Error event emitted');
            }
        });

        socket.on('obs-proxy-call', async ({ requestType, requestData, requestId }) => {
            console.log(`üìû OBS Proxy Call [${requestId}] from ${socket.id}: ${requestType}`);

            const obs = obsInstances.get(socket.id);

            if (!obs) {
                console.error(`‚ùå No OBS instance for ${socket.id}`);
                return socket.emit('obs-proxy-error', {
                    message: 'OBS not connected. Please connect to OBS first.',
                    requestId
                });
            }

            try {
                const response = await obs.call(requestType, requestData || {});
                console.log(`‚úÖ OBS Call Success [${requestId}]:`, requestType);
                socket.emit('obs-proxy-response', { response, requestId });
            } catch (err) {
                console.error(`‚ùå OBS Call Failed [${requestId}]:`, err.message);

                let errorMessage = err.message || 'OBS request failed';

                // Provide more context for common errors
                if (err.message?.includes('not recording')) {
                    errorMessage = 'OBS is not currently recording';
                } else if (err.message?.includes('already recording')) {
                    errorMessage = 'OBS is already recording';
                } else if (err.message?.includes('not streaming')) {
                    errorMessage = 'OBS is not currently streaming';
                } else if (err.message?.includes('already streaming')) {
                    errorMessage = 'OBS is already streaming';
                }

                socket.emit('obs-proxy-error', {
                    message: errorMessage,
                    code: err.code,
                    requestId
                });
            }
        });

        socket.on('obs-proxy-disconnect', async () => {
            console.log(`üîå OBS Proxy Disconnect Request from ${socket.id}`);

            const obs = obsInstances.get(socket.id);
            if (obs) {
                try {
                    await obs.disconnect();
                    console.log(`‚úÖ OBS disconnected for ${socket.id}`);
                } catch (err) {
                    console.warn(`‚ö†Ô∏è Error disconnecting OBS for ${socket.id}:`, err.message);
                }
                obsInstances.delete(socket.id);
                socket.emit('obs-proxy-disconnected');
            } else {
                console.log(`‚ÑπÔ∏è No OBS connection to disconnect for ${socket.id}`);
                socket.emit('obs-proxy-disconnected');
            }
        });

        // Disconnect
        socket.on('disconnect', () => {
            console.log('Client disconnected:', socket.id);

            // Cleanup OBS if any
            if (obsInstances.has(socket.id)) {
                console.log(`üßπ Cleaning up OBS connection for disconnected socket ${socket.id}`);
                obsInstances.get(socket.id).disconnect()
                    .then(() => console.log(`‚úÖ OBS cleaned up for ${socket.id}`))
                    .catch((err) => console.warn(`‚ö†Ô∏è Error cleaning up OBS:`, err.message));
                obsInstances.delete(socket.id);
            }

            // Cleanup voice room
            if (socket.voiceRoomJoined) {
                socket.broadcast.emit('voice-user-left', socket.id);
            }

            if (socket.id === broadcasterId) {
                resetBroadcaster();
                socket.broadcast.emit('stream-ended');
                console.log('Broadcaster disconnected. Role reset.');
            }
        });
    });
}
</file>

<file path="src/types/gamepad.ts">
// src/types/gamepad.ts

/**
 * Gamepad and Controller Type Definitions
 * These types support string-based button identifiers for flexibility
 */

export interface GamepadButtonMapping {
  button: string;
  action: string;
  eventName: string;
}

export type ButtonMappings = Record<string, string>;
export type PressedButtons = Set<string>;
export type UpdateMappingHandler = (button: string, action: string) => void;

// Additional helper types for controller events
export interface ControllerEvent {
  button: string;
  eventName: string;
  timestamp: number;
}

export interface KeyboardShortcut {
  key: string;
  eventName: string;
  description?: string;
}
</file>

<file path="src/types/player.ts">
export interface Player {
  ID: number;
  Forename: string;
  Surname: string;
  ImageURL: string;
  Position?: string;
  Number?: number;
}

export interface TeamRoster {
  PlayerData: Player[];
  teamName?: string;
}

export interface MultiTeamRoster {
  [teamKey: string]: {
    name?: string;
    PlayerData: Player[];
  };
}

export interface Club {
  ClubID: number;
  ClubName: string;
  Players: Player[];
}

export interface LFPData {
  TotalClubs: number;
  TotalPlayers: number;
  Clubs: Club[];
}
</file>

<file path="src/types/xtream.ts">
export interface XtreamCategory {
    category_id: string;
    category_name: string;
    parent_id: string;
    direct_source?: string;
}

export interface XtreamStream {
    num: number;
    name: string;
    stream_type: string;
    stream_id: number;
    stream_icon?: string;
    epg_channel_id?: string;
    category_id: string;
    custom_sid?: string;
    tv_archive_duration?: number;
    added?: string;
}

export interface ChannelStream {
    id: number;
    name: string;
    streamType: string;
    streamIcon: string | null;
    streamUrl: string;
    added?: string;
}

export interface ChannelCategory {
    id: string;
    name: string;
    order: number;
    parentId: string;
    streams: ChannelStream[];
}

export interface IPTVCredentials {
    apiBase: string;
    username: string;
    password: string;
    sessionCookie?: string;
    userAgent?: string;
    streamReferer?: string;
}
</file>

<file path="src/utils/analysisEngine.ts">
import { LoggedEvent } from "@/hooks/useGamepad";
import { buildPassingNetwork, PassingNetwork } from "./passingNetwork";

// --- Types ---

export interface TacticalAnalysis {
    possession: {
        teamA: TeamPossessionStats;
        teamB: TeamPossessionStats;
        momentum: MomentumSegment[];
    };
    passing: {
        teamA: TeamPassingStats;
        teamB: TeamPassingStats;
    };
    passingNetworks: {
        teamA: PassingNetwork;
        teamB: PassingNetwork;
    };
    transitions: {
        teamA: TeamTransitionStats;
        teamB: TeamTransitionStats;
    };
    stability: {
        teamA: TeamStabilityStats;
        teamB: TeamStabilityStats;
    };
    tempo: {
        teamA: TeamTempoStats;
        teamB: TeamTempoStats;
    };
    style: {
        teamA: TeamStyleStats;
        teamB: TeamStyleStats;
    };
    kpis: {
        teamA: TeamKPIs;
        teamB: TeamKPIs;
    };
    recommendations: {
        teamA: string[];
        teamB: string[];
    };
    chainPerformance?: {
        teamA: ChainPerformance;
        teamB: ChainPerformance;
    };
    derivedEvents: DerivedEvent[];
}

export interface ChainPerformance {
    avgVerticality: number;
    avgBuildUpSpeed: number;
    finalThirdEntryRate: number;
    shotConversionRate: number;
    transitionConversionRate: number;
}

export interface TeamKPIs {
    attackEfficiency: number; // 0-100
    defenseSolidity: number; // 0-100
    possessionControl: number; // 0-100
    transitionSpeed: number; // 0-100 (based on counter attack duration)
}

export interface TeamPossessionStats {
    totalTime: number;
    percentage: number;
    phases: {
        count: number;
        avgDuration: number;
        longest: number;
        shortest: number;
        types: {
            short: number; // < 10s
            medium: number; // 10-30s
            long: number; // > 30s
        };
    };
}

export interface MomentumSegment {
    startTime: number;
    endTime: number;
    dominantTeam: "TEAM_A" | "TEAM_B" | "NEUTRAL";
    intensity: number; // 0-100
}

export interface TeamPassingStats {
    total: number;
    perMinute: number;
    perPossession: number;
    accuracy: number; // Inferred from turnovers
    streaks: {
        longest: number;
        commonLength: number;
    };
    buildUp: {
        short: number; // 1-3 passes
        medium: number; // 4-10 passes
        long: number; // 10+ passes
    };
}

export interface TeamTransitionStats {
    counterAttacks: number;
    turnovers: {
        high: number; // Zone 3
        mid: number; // Zone 2
        low: number; // Zone 1
        total: number;
    };
    efficiency: number; // % of turnovers leading to >5 passes
}

export interface TeamStabilityStats {
    pressResistance: number; // % of possessions > 1 pass
    onePassLosses: number;
}

export interface TeamTempoStats {
    passesPerMinute: number;
    fastPossessions: number; // > 1 pass/sec
    slowPossessions: number; // < 0.5 pass/sec
}

export interface TeamStyleStats {
    classification: "Direct" | "Possession" | "Balanced";
    directness: number; // 0-100
}

export type DerivedEventType =
    | "BUILD_UP_PASS"
    | "LINE_BREAKING_PASS"
    | "SUCCESSFUL_PRESS"
    | "COUNTER_ATTACK"
    | "POSSESSION_SEQUENCE"
    | "LONG_BUILDUP"
    | "DIRECT_ATTACK"
    | "LONG_BUILDUP"
    | "DIRECT_ATTACK"
    | "HIGH_TURNOVER"
    | "TRANSITION_SEQUENCE";

export interface DerivedEvent {
    id: string;
    type: DerivedEventType;
    name: string;
    startTime: number;
    endTime: number;
    description: string;
    relatedEventIds: number[];
    team?: "TEAM_A" | "TEAM_B";
}

// --- Helpers ---

const calculateDistance = (x1: number, y1: number, x2: number, y2: number) => {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
};

const getTeamEvents = (events: LoggedEvent[], team: "TEAM_A" | "TEAM_B") => {
    return events.filter(e => e.team === team);
};

const isPass = (e: LoggedEvent) => e.eventName === "PASS" || e.eventName === "Successful Pass";
const isLoss = (e: LoggedEvent) => e.eventName === "Possession Lost";
const isWon = (e: LoggedEvent) => e.eventName === "Possession Won";

// --- Main Analysis Function ---

export const analyzeTactics = (events: LoggedEvent[]): TacticalAnalysis => {
    // Filter and sort
    const sortedEvents = [...events]
        .filter(e => e.videoTime !== undefined)
        .sort((a, b) => (a.videoTime || 0) - (b.videoTime || 0));

    if (sortedEvents.length === 0) {
        return createEmptyAnalysis();
    }

    const matchDuration = sortedEvents[sortedEvents.length - 1].videoTime || 0;
    const derivedEvents: DerivedEvent[] = [];

    // 1. Organize into Possessions
    // A possession starts with Won or first event, ends with Lost or Won by other team
    interface Possession {
        team: "TEAM_A" | "TEAM_B";
        startTime: number;
        endTime: number;
        events: LoggedEvent[];
        passCount: number;
        startZone?: number;
        endZone?: number;
    }

    const possessions: Possession[] = [];
    let currentPossession: Possession | null = null;

    sortedEvents.forEach((event) => {
        if (!currentPossession) {
            // Start new possession
            currentPossession = {
                team: event.team,
                startTime: event.videoTime || 0,
                endTime: event.videoTime || 0,
                events: [event],
                passCount: isPass(event) ? 1 : 0,
                startZone: event.zone
            };
        } else {
            if (event.team === currentPossession.team) {
                // Continue possession
                currentPossession.events.push(event);
                currentPossession.endTime = event.videoTime || 0;
                if (isPass(event)) currentPossession.passCount++;
                currentPossession.endZone = event.zone;
            } else {
                // Switch possession
                possessions.push(currentPossession);
                currentPossession = {
                    team: event.team,
                    startTime: event.videoTime || 0,
                    endTime: event.videoTime || 0,
                    events: [event],
                    passCount: isPass(event) ? 1 : 0,
                    startZone: event.zone
                };
            }
        }
    });

    if (currentPossession) possessions.push(currentPossession);

    // --- Generate Sequence Events ---

    // 1. Possession Sequences (All of them)
    possessions.forEach((p, index) => {
        derivedEvents.push({
            id: `pos-${p.startTime}-${index}`,
            type: "POSSESSION_SEQUENCE",
            name: `Possession: ${p.team}`,
            startTime: Math.max(0, p.startTime - 2),
            endTime: p.endTime + 2,
            description: `${p.passCount} passes, ${(p.endTime - p.startTime).toFixed(1)}s`,
            relatedEventIds: p.events.map(e => e.id),
            team: p.team
        });
    });

    // 2. Transition Sequences (High Value)
    // Start: Exact moment of possession change
    // End: 10 seconds after
    possessions.forEach((p, index) => {
        if (index > 0) {
            // The start of this possession is a transition from the previous one
            derivedEvents.push({
                id: `trans-${p.startTime}-${index}`,
                type: "TRANSITION_SEQUENCE",
                name: `Transition: To ${p.team}`,
                startTime: Math.max(0, p.startTime - 2), // Start slightly before to capture the change
                endTime: p.startTime + 10, // 10 seconds after
                description: `Transition to ${p.team}`,
                relatedEventIds: [p.events[0].id],
                team: p.team
            });
        }
    });

    // --- Calculate Stats ---

    const calculateTeamStats = (team: "TEAM_A" | "TEAM_B") => {
        const teamPossessions = possessions.filter(p => p.team === team);
        const teamEvents = getTeamEvents(sortedEvents, team);
        const passes = teamEvents.filter(isPass);
        const turnovers = teamEvents.filter(isLoss);

        // 1. Possession
        const totalTime = teamPossessions.reduce((sum, p) => sum + (p.endTime - p.startTime), 0);
        const percentage = matchDuration > 0 ? (totalTime / matchDuration) * 100 : 50;

        const phases = {
            count: teamPossessions.length,
            avgDuration: teamPossessions.length > 0 ? totalTime / teamPossessions.length : 0,
            longest: Math.max(0, ...teamPossessions.map(p => p.endTime - p.startTime)),
            shortest: teamPossessions.length > 0 ? Math.min(...teamPossessions.map(p => p.endTime - p.startTime)) : 0,
            types: {
                short: teamPossessions.filter(p => (p.endTime - p.startTime) < 10).length,
                medium: teamPossessions.filter(p => (p.endTime - p.startTime) >= 10 && (p.endTime - p.startTime) < 30).length,
                long: teamPossessions.filter(p => (p.endTime - p.startTime) >= 30).length,
            }
        };

        // 2. Passing
        const passCounts = teamPossessions.map(p => p.passCount);
        const streaks = {
            longest: Math.max(0, ...passCounts),
            commonLength: mode(passCounts)
        };
        const buildUp = {
            short: passCounts.filter(c => c >= 1 && c <= 3).length,
            medium: passCounts.filter(c => c >= 4 && c <= 10).length,
            long: passCounts.filter(c => c > 10).length
        };

        // 3. Transitions
        const turnoverZones = {
            high: turnovers.filter(t => t.zone === 3).length,
            mid: turnovers.filter(t => t.zone === 2).length,
            low: turnovers.filter(t => t.zone === 1).length,
            total: turnovers.length
        };

        // Generate High Turnover Events
        turnovers.filter(t => t.zone === 3).forEach(t => {
            derivedEvents.push({
                id: `ht-${t.id}`,
                type: "HIGH_TURNOVER",
                name: "High Turnover",
                startTime: Math.max(0, (t.videoTime || 0) - 5),
                endTime: (t.videoTime || 0) + 2,
                description: `${team} lost possession in attacking third.`,
                relatedEventIds: [t.id],
                team: team
            });
        });

        // Counter Attacks
        const counterAttacks = teamPossessions.filter((p, index) => {
            const isCounter = p.startZone === 1 && p.passCount <= 3 && (p.endTime - p.startTime) < 10 && p.endZone === 3;
            if (isCounter) {
                derivedEvents.push({
                    id: `ca-${team}-${p.startTime}-${index}`,
                    type: "COUNTER_ATTACK",
                    name: "Counter Attack",
                    startTime: Math.max(0, p.startTime - 2),
                    endTime: p.endTime + 2,
                    description: `${team} fast transition from defense to attack.`,
                    relatedEventIds: p.events.map(e => e.id),
                    team: team
                });
            }
            return isCounter;
        }).length;

        // Long Build-ups
        teamPossessions.filter(p => p.passCount >= 10).forEach((p) => {
            derivedEvents.push({
                id: `lb-${team}-${p.startTime}-${crypto.randomUUID()}`,
                type: "LONG_BUILDUP",
                name: "Long Build-up",
                startTime: Math.max(0, p.startTime - 2),
                endTime: p.endTime + 2,
                description: `${team} sustained possession (${p.passCount} passes).`,
                relatedEventIds: p.events.map(e => e.id),
                team: team
            });
        });

        // Direct Attacks
        teamPossessions.filter(p => p.passCount <= 3 && p.endZone === 3 && p.startZone !== 3).forEach((p, index) => {
            derivedEvents.push({
                id: `da-${team}-${p.startTime}-${index}`,
                type: "DIRECT_ATTACK",
                name: "Direct Attack",
                startTime: Math.max(0, p.startTime - 2),
                endTime: p.endTime + 2,
                description: `${team} direct play to attacking zone.`,
                relatedEventIds: p.events.map(e => e.id),
                team: team
            });
        });

        // 4. Stability
        const onePassLosses = teamPossessions.filter(p => p.passCount <= 1).length;
        const pressResistance = teamPossessions.length > 0 ? ((teamPossessions.length - onePassLosses) / teamPossessions.length) * 100 : 0;

        // 5. Tempo
        const passesPerMinute = matchDuration > 0 ? (passes.length / (matchDuration / 60)) : 0;
        const fastPossessions = teamPossessions.filter(p => p.passCount > 0 && (p.passCount / (p.endTime - p.startTime || 1)) > 0.8).length;
        const slowPossessions = teamPossessions.filter(p => p.passCount > 0 && (p.passCount / (p.endTime - p.startTime || 1)) < 0.4).length;

        // 6. Style
        const directness = buildUp.short / (teamPossessions.length || 1) * 100;
        let classification: "Direct" | "Possession" | "Balanced" = "Balanced";
        if (directness > 60) classification = "Direct";
        if (directness < 30) classification = "Possession";

        return {
            possession: { totalTime, percentage, phases },
            passing: {
                total: passes.length,
                perMinute: passesPerMinute,
                perPossession: teamPossessions.length > 0 ? passes.length / teamPossessions.length : 0,
                accuracy: 100 - (turnovers.length / (passes.length + turnovers.length || 1) * 100), // Rough estimate
                streaks,
                buildUp
            },
            transitions: {
                counterAttacks,
                turnovers: turnoverZones,
                efficiency: 0 // Placeholder
            },
            stability: {
                pressResistance,
                onePassLosses
            },
            tempo: {
                passesPerMinute,
                fastPossessions,
                slowPossessions
            },
            style: {
                classification,
                directness
            }
        };
    };

    // 7. Advanced Chain Analysis
    const getAdvancedChainStats = (team: "TEAM_A" | "TEAM_B"): ChainPerformance => {
        // Find events that have possessionId (from the new system)
        const teamEvents = sortedEvents.filter(e => e.team === team && e.possessionId !== undefined);

        // Group by possessionId
        const chainGroups = new Map<number, LoggedEvent[]>();
        teamEvents.forEach(e => {
            const id = e.possessionId!;
            if (!chainGroups.has(id)) chainGroups.set(id, []);
            chainGroups.get(id)!.push(e);
        });

        const chains = Array.from(chainGroups.values());
        if (chains.length === 0) return {
            avgVerticality: 0,
            avgBuildUpSpeed: 0,
            finalThirdEntryRate: 0,
            shotConversionRate: 0,
            transitionConversionRate: 0
        };

        const finalThirdEntries = chains.filter(c => c.some(e => e.eventName === 'final_third_entry')).length;
        const shots = chains.filter(c => c.some(e => e.eventName === 'shot_start')).length;
        const transitionChains = chains.filter(c => c.some(e => e.inTransitionWindow));
        const transitionShots = transitionChains.filter(c => c.some(e => e.eventName === 'shot_start')).length;

        // Calculate verticality (simple version: end zone higher than start zone)
        let totalVerticality = 0;
        chains.forEach(c => {
            const startZone = c[0].zone || 0;
            const endZone = c[c.length - 1].zone || 0;
            if (endZone > startZone) totalVerticality += 1;
        });

        return {
            avgVerticality: (totalVerticality / chains.length) * 100,
            avgBuildUpSpeed: 0, // Placeholder
            finalThirdEntryRate: (finalThirdEntries / chains.length) * 100,
            shotConversionRate: (shots / chains.length) * 100,
            transitionConversionRate: transitionChains.length > 0 ? (transitionShots / transitionChains.length) * 100 : 0
        };
    };

    // Momentum (Simple: Sliding window of pass differential)
    const momentum: MomentumSegment[] = [];
    // ... (Momentum logic can be added here, for now placeholder)

    // Generate Derived Events (Legacy support + new ones)
    // ... (Keep existing logic or adapt)

    // Build passing networks from controller events
    const passingNetworks = {
        teamA: buildPassingNetwork(sortedEvents, "TEAM_A", []),
        teamB: buildPassingNetwork(sortedEvents, "TEAM_B", [])
    };

    const kpis = {
        teamA: calculateKPIs(calculateTeamStats("TEAM_A"), "TEAM_A"),
        teamB: calculateKPIs(calculateTeamStats("TEAM_B"), "TEAM_B")
    };

    const recommendations = {
        teamA: generateRecommendations(calculateTeamStats("TEAM_A"), kpis.teamA, "TEAM_A"),
        teamB: generateRecommendations(calculateTeamStats("TEAM_B"), kpis.teamB, "TEAM_B")
    };

    return {
        possession: {
            teamA: calculateTeamStats("TEAM_A").possession,
            teamB: calculateTeamStats("TEAM_B").possession,
            momentum
        },
        passing: {
            teamA: calculateTeamStats("TEAM_A").passing,
            teamB: calculateTeamStats("TEAM_B").passing,
        },
        passingNetworks,
        transitions: {
            teamA: calculateTeamStats("TEAM_A").transitions,
            teamB: calculateTeamStats("TEAM_B").transitions,
        },
        stability: {
            teamA: calculateTeamStats("TEAM_A").stability,
            teamB: calculateTeamStats("TEAM_B").stability,
        },
        tempo: {
            teamA: calculateTeamStats("TEAM_A").tempo,
            teamB: calculateTeamStats("TEAM_B").tempo,
        },
        style: {
            teamA: calculateTeamStats("TEAM_A").style,
            teamB: calculateTeamStats("TEAM_B").style,
        },
        kpis,
        recommendations,
        chainPerformance: {
            teamA: getAdvancedChainStats("TEAM_A"),
            teamB: getAdvancedChainStats("TEAM_B")
        },
        derivedEvents: derivedEvents.sort((a, b) => a.startTime - b.startTime)
    };
};

// --- KPI & Recommendation Logic ---

const calculateKPIs = (stats: any, team: string): TeamKPIs => {
    // 1. Attack Efficiency
    // Based on: Shots (if avail), Deep Completions (Zone 3), and Possession conversion
    // For now, using proxy: (Zone 3 entries / Total Possessions) * 100
    // We don't have explicit Zone 3 entries count easily, so using (Long Build-ups + Counter Attacks) / Total Possessions
    const totalPossessions = stats.possession.phases.count || 1;
    const attackingSequences = stats.transitions.counterAttacks + (stats.passing.buildUp.long * 0.5); // Weight long build-ups less
    const attackEfficiency = Math.min(100, (attackingSequences / totalPossessions) * 100 * 2); // Multiplier to normalize

    // 2. Defense Solidity
    // Inverse of opponent's attack efficiency + Press Resistance
    // Proxy: 100 - (Turnovers in Zone 1 + Zone 2) / Total Possessions * 100
    const dangerousTurnovers = stats.transitions.turnovers.low + stats.transitions.turnovers.mid;
    const defenseSolidity = Math.max(0, 100 - ((dangerousTurnovers / totalPossessions) * 100));

    // 3. Possession Control
    // Combination of Possession % and Pass Accuracy
    const possessionControl = (stats.possession.percentage * 0.6) + (stats.passing.accuracy * 0.4);

    // 4. Transition Speed
    // Based on % of possessions that are "Fast" (Tempo)
    const transitionSpeed = Math.min(100, (stats.tempo.fastPossessions / totalPossessions) * 100 * 3);

    return {
        attackEfficiency,
        defenseSolidity,
        possessionControl,
        transitionSpeed
    };
};

const generateRecommendations = (stats: any, kpis: TeamKPIs, team: string): string[] => {
    const recs: string[] = [];

    // Possession
    if (stats.possession.percentage < 40) {
        recs.push("Increase possession retention to relieve defensive pressure.");
    }
    if (stats.possession.phases.types.short > stats.possession.phases.count * 0.6) {
        recs.push("Possessions are too short. Look to recycle the ball rather than forcing play.");
    }

    // Passing
    if (stats.passing.accuracy < 75) {
        recs.push("Passing accuracy is low. Focus on safer, shorter passes to build rhythm.");
    }
    if (stats.passing.buildUp.long < 2 && stats.possession.percentage > 50) {
        recs.push("Dominating possession but lacking sustained build-ups. Be more patient in the final third.");
    }

    // Transitions
    if (stats.transitions.turnovers.low > 5) {
        recs.push("Critical: Too many turnovers in defensive third. Clear lines faster.");
    }
    if (stats.transitions.counterAttacks < 2 && kpis.transitionSpeed < 30) {
        recs.push("Transition speed is slow. Look for forward runners immediately upon winning possession.");
    }

    // Stability
    if (stats.stability.onePassLosses > 5) {
        recs.push("High number of one-pass losses. Improve support angles for the ball carrier.");
    }

    // KPIs
    if (kpis.attackEfficiency < 30) {
        recs.push("Attack efficiency is low. Work on converting possession into final third entries.");
    }

    if (recs.length === 0) {
        recs.push("Maintain current performance levels.");
    }

    return recs.slice(0, 5); // Return top 5
};

// Helper for mode
function mode(arr: number[]) {
    if (arr.length === 0) return 0;
    const counts: Record<number, number> = {};
    let maxCount = 0;
    let maxKey = 0;
    for (const n of arr) {
        counts[n] = (counts[n] || 0) + 1;
        if (counts[n] > maxCount) {
            maxCount = counts[n];
            maxKey = n;
        }
    }
    return maxKey;
}

function createEmptyAnalysis(): TacticalAnalysis {
    const emptyStats = {
        possession: { totalTime: 0, percentage: 0, phases: { count: 0, avgDuration: 0, longest: 0, shortest: 0, types: { short: 0, medium: 0, long: 0 } } },
        passing: { total: 0, perMinute: 0, perPossession: 0, accuracy: 0, streaks: { longest: 0, commonLength: 0 }, buildUp: { short: 0, medium: 0, long: 0 } },
        transitions: { counterAttacks: 0, turnovers: { high: 0, mid: 0, low: 0, total: 0 }, efficiency: 0 },
        stability: { pressResistance: 0, onePassLosses: 0 },
        tempo: { passesPerMinute: 0, fastPossessions: 0, slowPossessions: 0 },
        style: { classification: "Balanced" as const, directness: 0 }
    };

    const emptyNetwork = {
        team: "",
        connections: [],
        nodes: [],
        metrics: {
            totalPasses: 0,
            uniquePassers: 0,
            uniqueReceivers: 0,
            avgPassesPerPlayer: 0,
            keyPasser: null,
            keyReceiver: null,
            mostFrequentConnection: null
        }
    };

    return {
        possession: { teamA: emptyStats.possession, teamB: emptyStats.possession, momentum: [] },
        passing: { teamA: emptyStats.passing, teamB: emptyStats.passing },
        passingNetworks: { teamA: { ...emptyNetwork, team: "TEAM_A" }, teamB: { ...emptyNetwork, team: "TEAM_B" } },
        transitions: { teamA: emptyStats.transitions, teamB: emptyStats.transitions },
        stability: { teamA: emptyStats.stability, teamB: emptyStats.stability },
        tempo: { teamA: emptyStats.tempo, teamB: emptyStats.tempo },
        style: { teamA: emptyStats.style, teamB: emptyStats.style },
        kpis: {
            teamA: { attackEfficiency: 0, defenseSolidity: 0, possessionControl: 0, transitionSpeed: 0 },
            teamB: { attackEfficiency: 0, defenseSolidity: 0, possessionControl: 0, transitionSpeed: 0 }
        },
        recommendations: { teamA: [], teamB: [] },
        derivedEvents: []
    };
}

// Export legacy function wrapper if needed, or replace
export const analyzeEvents = (events: LoggedEvent[]): DerivedEvent[] => {
    // Re-implement legacy derived events logic here if we want to keep the list
    // For now, returning empty or we can merge the logic.
    // ... (Previous logic for derived events)
    return [];
};
</file>

<file path="src/utils/apiConfig.js">
/**
 * Safely get environment variables in both Vite (frontend) and Node (backend)
 */
const getEnv = (key) => {
    // Vite (frontend)
    if (typeof import.meta !== 'undefined' && import.meta.env) {
        return import.meta.env[key];
    }

    // Node (backend)
    if (typeof process !== 'undefined' && process.env) {
        return process.env[key];
    }

    return undefined;
};

/**
 * HTTP API base URL
 * Empty in production since we serve from same domain
 * Routes already include /api prefix
 */
export const API_BASE_URL = (() => {
    const envUrl = getEnv('VITE_API_BASE_URL');

    // If explicitly set (even if empty string), use it
    if (envUrl !== undefined) {
        return envUrl;
    }

    // Same-origin fallback - EMPTY because routes already have /api
    if (typeof window !== 'undefined') {
        return '';  // ‚úÖ FIXED: Changed from '/api' to ''
    }

    // Development fallback
    return 'http://localhost:3001';
})();

/**
 * Socket.IO base URL
 * MUST NOT include `/api`
 * Example: http://localhost:3001
 */
export const API_SOCKET_URL = (() => {
    const envUrl = getEnv('VITE_SOCKET_URL') || API_BASE_URL;

    // Remove /api if present for socket connection
    return envUrl.replace(/\/api$/, '');
})();

/**
 * Optional secondary API (analysis, AI, etc.)
 */
export const ANALYSIS_API_URL =
    getEnv('VITE_ANALYSIS_API_URL') || API_BASE_URL;

/**
 * Default API headers
 */
export const API_HEADERS = {
    'Content-Type': 'application/json',
    'ngrok-skip-browser-warning': 'true',
    'Bypass-Tunnel-Reminder': 'true',
};

/**
 * Headers forbidden by browsers
 */
export const FORBIDDEN_HEADERS = [
    'user-agent',
    'referer',
    'host',
    'origin',
    'connection',
    'cookie',
    'accept-charset',
    'accept-encoding',
];

/**
 * Remove forbidden headers
 */
export const filterSafeHeaders = (headers) => {
    if (!headers || typeof headers !== 'object') return {};

    const safeHeaders = {};

    Object.entries(headers).forEach(([key, value]) => {
        const lowerKey = key.toLowerCase();

        const isForbidden = FORBIDDEN_HEADERS.some(
            (forbidden) =>
                lowerKey === forbidden ||
                lowerKey.startsWith('sec-') ||
                lowerKey.startsWith('proxy-')
        );

        if (!isForbidden) {
            safeHeaders[key] = value;
        } else {
            console.warn(`Skipping forbidden header: ${key}`);
        }
    });

    return safeHeaders;
};

/**
 * Create safe fetch options
 */
export const createFetchOptions = (customHeaders = {}) => {
    return {
        headers: filterSafeHeaders({
            ...API_HEADERS,
            ...customHeaders,
        }),
    };
};

// Debug log
console.log('API Configuration Loaded:', {
    API_BASE_URL,
    API_SOCKET_URL,
    ANALYSIS_API_URL,
});
</file>

<file path="src/utils/coords.ts">
export interface Point { x: number; y: number; }

export const getMediaLayout = (containerRect: DOMRect, naturalWidth: number, naturalHeight: number) => {
    const containerWidth = containerRect.width;
    const containerHeight = containerRect.height;
    const containerAspect = containerWidth / containerHeight;
    const videoAspect = naturalWidth / naturalHeight;

    let renderWidth, renderHeight, offsetX, offsetY;

    if (videoAspect > containerAspect) {
        // Video is wider than container (bars top/bottom)
        renderWidth = containerWidth;
        renderHeight = containerWidth / videoAspect;
        offsetX = 0;
        offsetY = (containerHeight - renderHeight) / 2;
    } else {
        // Video is taller than container (bars left/right)
        renderHeight = containerHeight;
        renderWidth = containerHeight * videoAspect;
        offsetX = (containerWidth - renderWidth) / 2;
        offsetY = 0;
    }

    return { renderWidth, renderHeight, offsetX, offsetY };
};

// Converts Screen Click -> Natural Video Pixel
export const screenToVideo = (clientX: number, clientY: number, containerRect: DOMRect, natW: number, natH: number) => {
    const { renderWidth, renderHeight, offsetX, offsetY } = getMediaLayout(containerRect, natW, natH);
    const clickX = clientX - containerRect.left;
    const clickY = clientY - containerRect.top;

    return {
        x: ((clickX - offsetX) / renderWidth) * natW,
        y: ((clickY - offsetY) / renderHeight) * natH,
        isOutOfBounds: (clickX < offsetX || clickX > offsetX + renderWidth || clickY < offsetY || clickY > offsetY + renderHeight)
    };
};

// Converts Natural Video Pixel -> Screen Percentage (for CSS)
export const videoToCSS = (videoPt: Point, containerRect: DOMRect, natW: number, natH: number) => {
    const { renderWidth, renderHeight, offsetX, offsetY } = getMediaLayout(containerRect, natW, natH);
    const screenX = offsetX + (videoPt.x / natW) * renderWidth;
    const screenY = offsetY + (videoPt.y / natH) * renderHeight;

    return {
        left: `${(screenX / containerRect.width) * 100}%`,
        top: `${(screenY / containerRect.height) * 100}%`
    };
};
</file>

<file path="src/utils/csvExport.ts">
import { LoggedEvent } from "@/hooks/useGamepad";

export const exportToCSV = (events: LoggedEvent[]) => {
  if (events.length === 0) {
    return;
  }

  // CSV Header
  const headers = [
    "ID",
    "Timestamp",
    "Match Time",
    "Mode",
    "Team",
    "Event",
    "Player",
    "Zone",
    "Sub Type",
    "X",
    "Y"
  ];

  // CSV Rows
  const rows = events.map(event => [
    event.id,
    event.timestamp,
    event.matchTime || "",
    event.mode || "POST_MATCH", // Default to POST_MATCH if undefined
    event.team,
    `"${event.eventName}"`, // Quote event name to handle commas
    event.player ? `"${event.player.name}"` : "",
    event.zone || "",
    event.subType || "",
    event.x || "",
    event.y || ""
  ]);

  // Combine headers and rows
  const csvContent = [
    headers.join(","),
    ...rows.map(row => row.join(","))
  ].join("\n");

  // Create blob and download
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  const url = URL.createObjectURL(blob);

  link.setAttribute("href", url);
  link.setAttribute("download", `soccer_events_${new Date().toISOString()}.csv`);
  link.style.visibility = "hidden";

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};
</file>

<file path="src/utils/eventNaming.ts">
import { LoggedEvent } from '../hooks/useGamepad';
import { EVENT_REGISTRY, EventDefinition } from '../config/eventRegistry';

/**
 * Generates the conventional filename for an event based on the user's specification.
 * Format: NAME_SNAKE_CASE_MIN_SEC.mp4
 * Returns full path: /Match_DATE/Category/Event/Filename
 */
export const generateEventFilename = (event: LoggedEvent, matchDate: string, eventsList: EventDefinition[] = EVENT_REGISTRY): string => {
    // 1. Find the event definition
    const definition = eventsList.find(e => e.eventName === event.eventName);
    if (!definition) return '';

    // 2. Parse Time (MM_SS)
    // event.matchTime is typicaly "45:00"
    let timeStr = event.matchTime || "00:00";
    if (timeStr.includes('+')) timeStr = timeStr.split('+')[0]; // simple handling for now

    const [minStr, secStr] = timeStr.split(':');
    const min = minStr ? minStr.padStart(2, '0') : "00";
    const sec = secStr ? secStr.padStart(2, '0') : "00";

    // 3. Replace Placeholders
    let filename = definition.filenameConvention
        .replace('MIN', min)
        .replace('SEC', sec);

    let folderPath = definition.folderPath.replace('DATE', matchDate); // e.g. 2024-01-19

    return `${folderPath}${filename}`;
};
</file>

<file path="src/utils/heatmapApi.ts">
/**
 * API client for heatmap operations
 */

import { API_BASE_URL } from "./apiConfig";

export interface PositionData {
    video_info: {
        total_frames: number;
        fps: number;
        width: number;
        height: number;
        duration: number;
    };
    positions: Array<{
        frame: number;
        timestamp: number;
        x: number;
        y: number;
        team: 'A' | 'B';
        confidence: number;
    }>;
}

export interface HeatmapResponse {
    success: boolean;
    imageUrl?: string;
    filename?: string;
    error?: string;
    details?: string;
}

/**
 * Extract player positions from video file
 */
export async function extractPositions(
    videoFile: File,
    startTime?: number,
    endTime?: number
): Promise<PositionData> {
    const formData = new FormData();
    formData.append('video', videoFile);

    if (startTime !== undefined) {
        formData.append('startTime', startTime.toString());
    }

    if (endTime !== undefined) {
        formData.append('endTime', endTime.toString());
    }

    const response = await fetch(`${API_BASE_URL}/api/extract-positions`, {
        method: 'POST',
        body: formData, // Content-Type is set automatically
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to extract positions');
    }

    const data = await response.json();
    return data.positions;
}

/**
 * Generate heatmap from position data
 */
export async function generateHeatmap(
    team?: 'A' | 'B',
    scatter: boolean = false
): Promise<HeatmapResponse> {
    const response = await fetch(`${API_BASE_URL}/api/generate-heatmap`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ team, scatter }),
    });

    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to generate heatmap');
    }

    return await response.json();
}

/**
 * Get full URL for heatmap image
 */
export function getHeatmapImageUrl(filename: string): string {
    return `${API_BASE_URL}/heatmaps/${filename}`;
}
</file>

<file path="src/utils/homography.ts">
/**
 * Homography Utility for Soccer Pitch Transformation
 * Maps Pixel Coordinates (x, y) <-> Field Coordinates (meters)
 */

export interface Point {
    x: number;
    y: number;
}

export type HomographyMatrix = number[][];

/**
 * Calculates the homography matrix from N source points to N destination points.
 * Uses Least Squares with coordinate normalization to solve the linear system for N >= 4.
 */
export function solveHomography(src: Point[], dst: Point[]): HomographyMatrix | null {
    if (src.length < 4 || dst.length < 4 || src.length !== dst.length) return null;

    // 1. Normalize coordinates for numerical stability
    const Tsrc = getNormalizationMatrix(src);
    const Tdst = getNormalizationMatrix(dst);

    const normSrc = src.map(p => transformPoint(p, Tsrc));
    const normDst = dst.map(p => transformPoint(p, Tdst));

    const n = normSrc.length;
    const A: number[][] = [];
    const b: number[] = [];

    for (let i = 0; i < n; i++) {
        const { x: sx, y: sy } = normSrc[i];
        const { x: dx, y: dy } = normDst[i];

        // Equation 1: sx*h0 + sy*h1 + h2 - sx*dx*h6 - sy*dx*h7 = dx
        A.push([sx, sy, 1, 0, 0, 0, -sx * dx, -sy * dx]);
        b.push(dx);

        // Equation 2: sx*h3 + sy*h4 + h5 - sx*dy*h6 - sy*dy*h7 = dy
        A.push([0, 0, 0, sx, sy, 1, -sx * dy, -sy * dy]);
        b.push(dy);
    }

    // Solve the overdetermined system A * h = b using Normal Equations: (A^T * A) * h = A^T * b
    const At = transpose(A);
    const AtA = multiplyMatrices(At, A);
    const Atb = multiplyMatrixVector(At, b);

    const h = gaussElimination(AtA, Atb);

    if (!h) return null;

    const Hnorm: HomographyMatrix = [
        [h[0], h[1], h[2]],
        [h[3], h[4], h[5]],
        [h[6], h[7], 1]
    ];

    // 2. Denormalize: H = Tdst^-1 * Hnorm * Tsrc
    const TdstInv = invertHomography(Tdst);
    if (!TdstInv) return null;

    const temp = multiplyMatrices(TdstInv, Hnorm);
    return multiplyMatrices(temp, Tsrc);
}

/**
 * Normalization matrix: Centroid to origin and average distance to sqrt(2).
 */
function getNormalizationMatrix(points: Point[]): HomographyMatrix {
    const n = points.length;
    let centroidX = 0, centroidY = 0;
    for (const p of points) {
        centroidX += p.x;
        centroidY += p.y;
    }
    centroidX /= n;
    centroidY /= n;

    let avgDist = 0;
    for (const p of points) {
        const dx = p.x - centroidX;
        const dy = p.y - centroidY;
        avgDist += Math.sqrt(dx * dx + dy * dy);
    }
    avgDist /= n;

    const scale = avgDist > 1e-10 ? Math.sqrt(2) / avgDist : 1;

    return [
        [scale, 0, -scale * centroidX],
        [0, scale, -scale * centroidY],
        [0, 0, 1]
    ];
}

/** Helper for matrix transposition */
function transpose(A: number[][]): number[][] {
    const m = A.length;
    const n = A[0].length;
    const res = Array.from({ length: n }, () => new Array(m).fill(0));
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            res[j][i] = A[i][j];
        }
    }
    return res;
}

/** Helper for matrix multiplication */
function multiplyMatrices(A: number[][], B: number[][]): number[][] {
    const m = A.length;
    const n = A[0].length;
    const p = B[0].length;
    const res = Array.from({ length: m }, () => new Array(p).fill(0));
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < p; j++) {
            for (let k = 0; k < n; k++) {
                res[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    return res;
}

/** Helper for matrix-vector multiplication */
function multiplyMatrixVector(A: number[][], v: number[]): number[] {
    const m = A.length;
    const n = A[0].length;
    const res = new Array(m).fill(0);
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            res[i] += A[i][j] * v[j];
        }
    }
    return res;
}


/**
 * Applies a 3x3 homography matrix to a point.
 */
export function transformPoint(p: Point, matrix: HomographyMatrix): Point {
    const [a, b, c] = matrix[0];
    const [d, e, f] = matrix[1];
    const [g, h, i] = matrix[2];

    const w = g * p.x + h * p.y + i;
    return {
        x: (a * p.x + b * p.y + c) / w,
        y: (d * p.x + e * p.y + f) / w
    };
}

/**
 * Standard Gaussian elimination for solving a system of linear equations.
 */
function gaussElimination(A: number[][], b: number[]): number[] | null {
    const n = b.length;
    for (let i = 0; i < n; i++) {
        // Find pivot
        let max = i;
        for (let k = i + 1; k < n; k++) {
            if (Math.abs(A[k][i]) > Math.abs(A[max][i])) max = k;
        }

        // Swap rows
        [A[i], A[max]] = [A[max], A[i]];
        [b[i], b[max]] = [b[max], b[i]];

        // Eliminate
        if (Math.abs(A[i][i]) < 1e-10) return null; // Singular matrix
        for (let k = i + 1; k < n; k++) {
            const factor = A[k][i] / A[i][i];
            b[k] -= factor * b[i];
            for (let j = i; j < n; j++) {
                A[k][j] -= factor * A[i][j];
            }
        }
    }

    // Back substitution
    const x = new Array(n).fill(0);
    for (let i = n - 1; i >= 0; i--) {
        let sum = 0;
        for (let j = i + 1; j < n; j++) {
            sum += A[i][j] * x[j];
        }
        x[i] = (b[i] - sum) / A[i][i];
    }
    return x;
}

/**
 * Invert a 3x3 matrix (adjugate method).
 */
export function invertHomography(m: HomographyMatrix): HomographyMatrix | null {
    const [[a, b, c], [d, e, f], [g, h, i]] = m;
    const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
    if (Math.abs(det) < 1e-10) return null;

    const invDet = 1 / det;
    return [
        [(e * i - f * h) * invDet, (c * h - b * i) * invDet, (b * f - c * e) * invDet],
        [(f * g - d * i) * invDet, (a * i - c * g) * invDet, (c * d - a * f) * invDet],
        [(d * h - e * g) * invDet, (g * b - a * h) * invDet, (a * e - b * d) * invDet]
    ];
}
</file>

<file path="src/utils/kpiEngine.ts">
export interface Constituent {
    id: string;
    name: string;
    tier: string;
    revenue: number;
    status: 'Active' | 'Lead' | 'Prospect' | 'Churned';
}

export interface MarketSegment {
    id: string;
    name: string;
    count: number;     // Number of organizations
    price: number;     // ARPU/Price
    penRate: number;   // Target penetration rate (0-100)
    constituents?: Constituent[]; // Drilldown data
}

export interface Competitor {
    id: string;
    name: string;
    threat: string;
    strength: string;
    advantage: string;
}

export interface Risk {
    id: string;
    name: string;
    prob: number; // 0-100
    impact: string; // Low/Med/High/Critical
    impactLevel: number; // 1-10
    score: number;
    mitigation: string;
}

export interface KPIModel {
    // Market
    marketSegments: MarketSegment[];
    // Competitors
    competitors: Competitor[];
    // Risks
    risks: Risk[];

    // Pricing (globals / averages)
    p_arpu: number;
    // Growth
    g_y1: number; g_y2: number; g_y3: number; g_y4: number; g_y5: number;
    ch_y1: number; ch_y2: number; ch_stable: number; g_pen: number;
    // Revenue mix
    rev_saas: number; rev_train: number; rev_prof: number;
    // Costs
    c_head: number; c_hire: number; c_sal: number; tax_cnas: number;
    c_pay_pct: number; c_infra_pct: number; c_mkt_pct: number; c_ops_pct: number;
    // Sales
    s_cycle: number; s_lead: number; s_demo: number; s_poc: number; s_comm: number; s_cac: number;
    s_lead_time: string; s_demo_time: string; s_poc_time: string; // New editable times

    // Channels
    ch_b2b: number; ch_inst: number; ch_ref: number;
    // Fiscal
    cash_delay: number; tax_tva: number; tax_ibs: number; f_margin: number;
    // Unit econ
    u_ltv: number; u_ltv_cac: number; u_breakeven: number;
    // Investment
    inv_seed: number; inv_pre: number; inv_a: number;
    bud_p1: number; bud_p2: number; bud_p3: number;

    // Benchmarks & Targets
    bench_churn: string;
    bench_nrr: string;
    bench_life: string;
    target_cycle: string;
    target_lead: string;
    target_demo: string;
    target_poc: string;
    target_conv: string;
}

const LIGUE_1_CLUBS: Constituent[] = [
    { id: '1', name: "CR Belouizdad", tier: "Elite", revenue: 216000, status: "Active" },
    { id: '2', name: "MC Alger", tier: "Elite", revenue: 216000, status: "Active" },
    { id: '3', name: "USM Alger", tier: "Elite", revenue: 216000, status: "Lead" },
    { id: '4', name: "JS Kabylie", tier: "Elite", revenue: 216000, status: "Lead" },
    { id: '5', name: "ES Setif", tier: "Elite", revenue: 216000, status: "Prospect" },
    { id: '6', name: "MC Oran", tier: "Elite", revenue: 216000, status: "Prospect" },
    { id: '7', name: "CS Constantine", tier: "Elite", revenue: 216000, status: "Prospect" },
    { id: '8', name: "Paradou AC", tier: "Elite", revenue: 216000, status: "Active" },
    { id: '9', name: "JS Saoura", tier: "Elite", revenue: 216000, status: "Prospect" },
    { id: '10', name: "ASO Chlef", tier: "Elite", revenue: 216000, status: "Prospect" },
    { id: '11', name: "US Biskra", tier: "Elite", revenue: 216000, status: "Prospect" },
    { id: '12', name: "NC Magra", tier: "Elite", revenue: 216000, status: "Prospect" },
    { id: '13', name: "MC El Bayadh", tier: "Elite", revenue: 216000, status: "Prospect" },
    { id: '14', name: "USM Khenchela", tier: "Elite", revenue: 216000, status: "Prospect" },
    { id: '15', name: "ES Ben Aknoun", tier: "Elite", revenue: 216000, status: "Prospect" },
    { id: '16', name: "US Souf", tier: "Elite", revenue: 216000, status: "Prospect" }
];

export const initialKPI: KPIModel = {
    // Market
    marketSegments: [
        { id: '1', name: 'Ligue 1 Elite', count: 16, price: 216000, penRate: 67, constituents: LIGUE_1_CLUBS },
        { id: '2', name: 'Ligue 1 Standard', count: 32, price: 144000, penRate: 30 },
        { id: '3', name: 'Ligue 2 Progressive', count: 8, price: 72000, penRate: 17 },
        { id: '4', name: 'FAF Centers', count: 6, price: 100000, penRate: 75 }
    ],
    // Competitors
    competitors: [
        { id: '1', name: "Stats Perform/Opta", threat: "High", strength: "Global leader, 30+ sports", advantage: "Local compliance, FAF relations" },
        { id: '2', name: "Sportradar", threat: "High", strength: "85+ sports, video integration", advantage: "First-mover, training integration" },
        { id: '3', name: "Excel/Manual tools", threat: "Medium", strength: "Zero cost, familiarity", advantage: "Automation, compliance, insights" },
        { id: '4', name: "Hudl/Wyscout", threat: "Low", strength: "Video analysis focus", advantage: "Full SaaS platform, local support" }
    ],
    // Risks
    risks: [
        { id: '1', name: "Adoption Resistance", prob: 70, impact: "High", impactLevel: 3, score: 2.1, mitigation: "POC programs, FAF endorsement" },
        { id: '2', name: "Competitor Entry", prob: 40, impact: "High", impactLevel: 3, score: 1.2, mitigation: "Community moat, exclusive partnerships" },
        { id: '3', name: "Regulatory Change", prob: 30, impact: "Medium", impactLevel: 2, score: 0.6, mitigation: "Flexible architecture, legal monitoring" },
        { id: '4', name: "Validation Failure", prob: 40, impact: "Critical", impactLevel: 4, score: 1.6, mitigation: "Milestone-based funding, pivot" }
    ],

    // Pricing
    p_arpu: 150000,
    // Growth
    g_y1: 6, g_y2: 5, g_y3: 3, g_y4: 3, g_y5: 2,
    ch_y1: 15, ch_y2: 12, ch_stable: 8, g_pen: 30,
    // Revenue mix
    rev_saas: 70, rev_train: 25, rev_prof: 5,
    // Costs
    c_head: 3, c_hire: 0.5, c_sal: 60000, tax_cnas: 35,
    c_pay_pct: 63, c_infra_pct: 10, c_mkt_pct: 14, c_ops_pct: 13,
    // Sales
    s_cycle: 6, s_lead: 40, s_demo: 60, s_poc: 70, s_comm: 5, s_cac: 48,
    s_lead_time: "1-2 months", s_demo_time: "2-4 weeks", s_poc_time: "3-6 months",
    // Channels
    ch_b2b: 80, ch_inst: 15, ch_ref: 5,
    // Fiscal
    cash_delay: 3, tax_tva: 19, tax_ibs: 19, f_margin: 85,
    // Unit econ
    u_ltv: 425, u_ltv_cac: 8.9, u_breakeven: 25,
    // Investment
    inv_seed: 1.0, inv_pre: 4.0, inv_a: 17.5,
    bud_p1: 400, bud_p2: 800, bud_p3: 600,

    // Benchmarks & Targets
    bench_churn: "5-10% (B2B SaaS)",
    bench_nrr: "100-120%",
    bench_life: "36-60 months",

    target_cycle: "6-9 months",
    target_lead: "30-50%",
    target_demo: "50-70%",
    target_poc: "60-80%",
    target_conv: "10-20%"
};

export interface YearProjection {
    year: number;
    newClients: number;
    churnRate: number;
    activeClients: number;
    arpu: number;
    arr: number;
    headcount: number;
    personnel: number;
    infrastructure: number;
    marketing: number;
    operations: number;
    totalCosts: number;
    ebitda: number;
    tax: number;
    netIncome: number;
    margin: number;
}

export interface CashFlowProjection {
    year: number;
    cashIn: number;
    cashOut: number;
    netCashFlow: number;
    cumulativeCash: number;
}

export interface EngineResult {
    years: YearProjection[];
    cashFlow: CashFlowProjection[];
    y5: YearProjection;
    ltv: number;
    ltv_cac: number;
    paybackMonths: number;
    customerLifeMonths: number;
    nrr: number;
    tam: number;
    sam: number;
    som: number;
    minCash: number;
    breakEvenClients: number;
    breakEvenARR: number;
}

export const calculateKPIs = (KPI: KPIModel): EngineResult => {
    // === MARKET CALCULATIONS ===
    const tam = KPI.marketSegments.reduce((sum, seg) => sum + (seg.count * seg.price), 0);
    const sam = tam * 0.70; // 70% technologically receptive
    const som = KPI.marketSegments.reduce((sum, seg) => sum + (seg.count * seg.price * (seg.penRate / 100)), 0);

    // === GROWTH & CHURN MODEL ===
    const years: YearProjection[] = [];
    let activeClients = 0;

    for (let y = 1; y <= 5; y++) {
        // @ts-ignore - dynamic key access for growth years
        const newClients = KPI[`g_y${y}` as keyof KPIModel] as number || 0;
        const churnRate = y === 1 ? KPI.ch_y1 / 100 : y === 2 ? KPI.ch_y2 / 100 : KPI.ch_stable / 100;
        activeClients = activeClients * (1 - churnRate) + newClients;

        const arpuGrowth = 1 + (y - 1) * 0.03; // 3% annual ARPU growth
        const arpu = KPI.p_arpu * arpuGrowth;
        const arr = activeClients * arpu;

        // Cost structure
        const headcount = KPI.c_head + (y - 1) * KPI.c_hire;
        const monthlyGrossSal = headcount * KPI.c_sal;
        const loadedPayroll = monthlyGrossSal * 12 * (1 + KPI.tax_cnas / 100);

        // Derived costs based on percentages
        // Careful with calculation: HTML says: totalCosts = loadedPayroll / (KPI.c_pay_pct/100);
        const totalCosts = loadedPayroll / (KPI.c_pay_pct / 100);

        const personnel = totalCosts * (KPI.c_pay_pct / 100);
        const infrastructure = totalCosts * (KPI.c_infra_pct / 100);
        const marketing = totalCosts * (KPI.c_mkt_pct / 100);
        const operations = totalCosts * (KPI.c_ops_pct / 100);

        const ebitda = arr - totalCosts;
        const tax = ebitda > 0 ? ebitda * KPI.tax_ibs / 100 : 0;
        const netIncome = ebitda - tax;

        years.push({
            year: y,
            newClients,
            churnRate,
            activeClients,
            arpu,
            arr,
            headcount,
            personnel,
            infrastructure,
            marketing,
            operations,
            totalCosts,
            ebitda,
            tax,
            netIncome,
            margin: arr > 0 ? (netIncome / arr) * 100 : -100
        });
    }

    const y5 = years[4];

    // === UNIT ECONOMICS ===
    const ltv = KPI.p_arpu / (KPI.ch_stable / 100);
    const ltv_cac = ltv / (KPI.s_cac * 1000);
    const paybackMonths = (KPI.s_cac * 1000) / ((KPI.p_arpu / 12) * (KPI.f_margin / 100));
    const customerLifeMonths = 1 / (KPI.ch_stable / 100) * 12;
    const nrr = 100 - KPI.ch_stable + 5; // Assume 5% expansion

    // === CASH FLOW ===
    let cumulativeCash = KPI.inv_seed * 1000000;
    const cashFlow: CashFlowProjection[] = [];

    for (let y = 1; y <= 5; y++) {
        const yrData = years[y - 1];
        const collectionRate = y === 1 ? 0.6 : y === 2 ? 0.8 : 0.95; // Gradual improvement
        const cashIn = yrData.arr * collectionRate;
        const cashOut = yrData.totalCosts;
        const netCashFlow = cashIn - cashOut;
        cumulativeCash += netCashFlow;
        cashFlow.push({ year: y, cashIn, cashOut, netCashFlow, cumulativeCash });
    }

    const minCash = Math.min(...cashFlow.map(c => c.cumulativeCash));

    // === BREAK-EVEN ===
    const breakEvenARR = y5.totalCosts;
    const breakEvenClients = breakEvenARR / KPI.p_arpu;

    return {
        years,
        cashFlow,
        y5,
        ltv,
        ltv_cac,
        paybackMonths,
        customerLifeMonths,
        nrr,
        tam,
        sam,
        som,
        minCash,
        breakEvenClients,
        breakEvenARR
    };
};
</file>

<file path="src/utils/MatchStateMachine.ts">
// src/utils/MatchStateMachine.ts
// Core state machine for tracking match state in real-time

import { LoggedEvent } from "@/hooks/useGamepad";

// ============================================================================
// TYPES
// ============================================================================

export type TeamId = "TEAM_A" | "TEAM_B";

export type MatchPhase =
    | "BUILD_UP"
    | "CONSOLIDATION"
    | "FINAL_THIRD"
    | "TRANSITION_OFF"
    | "TRANSITION_DEF"
    | "SET_PIECE"
    | "NEUTRAL";

export type PitchThird = "DEFENSIVE" | "MIDDLE" | "FINAL";
export type PitchLane = "LEFT" | "HALF_SPACE_LEFT" | "CENTER" | "HALF_SPACE_RIGHT" | "RIGHT";
export type PressureLevel = "HIGH" | "MEDIUM" | "LOW";
export type ThreatLevel = "HIGH" | "MEDIUM" | "LOW";

export interface PitchZone {
    third: PitchThird;
    lane: PitchLane;
    zoneNumber: number; // 1-18
}

export interface TransitionWindow {
    active: boolean;
    type: "OFFENSIVE" | "DEFENSIVE" | null;
    startTime: number | null;
    duration: number; // ms, default 5000
}

export interface PressingContext {
    active: boolean;
    triggerTime: number | null;
    location?: PitchZone;
    outcome?: "RECOVERY" | "LOSS" | "CLEAR" | null;
}

export interface MatchState {
    teamInPossession: TeamId | null;
    phase: MatchPhase;
    zone: PitchZone;
    pressure: PressureLevel;
    threatLevel: ThreatLevel;
    transitionWindow: TransitionWindow;
    pressingContext: PressingContext;

    // Metadata
    lastEventTime: number;
    lastEventName: string | null;
    stateVersion: number; // Increments on each change
}

export interface StateTransition {
    from: Partial<MatchState>;
    to: Partial<MatchState>;
    trigger: string;
    timestamp: number;
}

// ============================================================================
// CONSTANTS
// ============================================================================

const TRANSITION_WINDOW_DURATION = 5000; // 5 seconds
const PRESSING_CONTEXT_DURATION = 8000; // 8 seconds for pressing outcome tracking

// Zone number to zone mapping (1-18 grid)
const ZONE_MAP: Record<number, PitchZone> = {
    // Defensive third
    1: { third: "DEFENSIVE", lane: "LEFT", zoneNumber: 1 },
    2: { third: "DEFENSIVE", lane: "HALF_SPACE_LEFT", zoneNumber: 2 },
    3: { third: "DEFENSIVE", lane: "CENTER", zoneNumber: 3 },
    4: { third: "DEFENSIVE", lane: "HALF_SPACE_RIGHT", zoneNumber: 4 },
    5: { third: "DEFENSIVE", lane: "RIGHT", zoneNumber: 5 },
    6: { third: "DEFENSIVE", lane: "CENTER", zoneNumber: 6 }, // GK zone

    // Middle third
    7: { third: "MIDDLE", lane: "LEFT", zoneNumber: 7 },
    8: { third: "MIDDLE", lane: "HALF_SPACE_LEFT", zoneNumber: 8 },
    9: { third: "MIDDLE", lane: "CENTER", zoneNumber: 9 },
    10: { third: "MIDDLE", lane: "HALF_SPACE_RIGHT", zoneNumber: 10 },
    11: { third: "MIDDLE", lane: "RIGHT", zoneNumber: 11 },
    12: { third: "MIDDLE", lane: "CENTER", zoneNumber: 12 },

    // Final third
    13: { third: "FINAL", lane: "LEFT", zoneNumber: 13 },
    14: { third: "FINAL", lane: "HALF_SPACE_LEFT", zoneNumber: 14 },
    15: { third: "FINAL", lane: "CENTER", zoneNumber: 15 },
    16: { third: "FINAL", lane: "HALF_SPACE_RIGHT", zoneNumber: 16 },
    17: { third: "FINAL", lane: "RIGHT", zoneNumber: 17 },
    18: { third: "FINAL", lane: "CENTER", zoneNumber: 18 }, // Box
};

// Events that indicate possession gain
const POSSESSION_GAIN_EVENTS = [
    "interception",
    "goal_kick",
    "throw_in_tactical",
    "free_kick",
    "corner_start",
];

// Events that indicate possession loss
const POSSESSION_LOSS_EVENTS = [
    "turnover",
    "shot_start", // May lose possession
    "foul",
    "offside",
];

// Events that indicate high threat
const HIGH_THREAT_EVENTS = [
    "shot_start",
    "big_chance",
    "dangerous_attack",
    "penalty",
];

// ============================================================================
// STATE MACHINE
// ============================================================================

export function createInitialState(): MatchState {
    return {
        teamInPossession: null,
        phase: "NEUTRAL",
        zone: { third: "MIDDLE", lane: "CENTER", zoneNumber: 9 },
        pressure: "MEDIUM",
        threatLevel: "LOW",
        transitionWindow: {
            active: false,
            type: null,
            startTime: null,
            duration: TRANSITION_WINDOW_DURATION,
        },
        pressingContext: {
            active: false,
            triggerTime: null,
            outcome: null,
        },
        lastEventTime: Date.now(),
        lastEventName: null,
        stateVersion: 0,
    };
}

export function getZoneFromNumber(zoneNumber: number): PitchZone {
    return ZONE_MAP[zoneNumber] || ZONE_MAP[9]; // Default to center
}

export function processEvent(
    currentState: MatchState,
    event: LoggedEvent | { eventName: string; team: TeamId; zone?: number }
): { newState: MatchState; transition: StateTransition } {
    const now = Date.now();
    const eventName = event.eventName;
    const team = event.team as TeamId;

    // Clone current state
    const newState: MatchState = {
        ...currentState,
        transitionWindow: { ...currentState.transitionWindow },
        pressingContext: { ...currentState.pressingContext },
        zone: { ...currentState.zone },
    };

    // Track what's changing
    const previousState = { ...currentState };

    // -------------------------------------------------------------------------
    // 1. Check Transition Window Expiry
    // -------------------------------------------------------------------------
    if (newState.transitionWindow.active && newState.transitionWindow.startTime) {
        const elapsed = now - newState.transitionWindow.startTime;
        if (elapsed > newState.transitionWindow.duration) {
            newState.transitionWindow.active = false;
            newState.transitionWindow.type = null;
            newState.transitionWindow.startTime = null;

            // Transition window expired - revert to build-up if we're in transition phase
            if (newState.phase === "TRANSITION_OFF" || newState.phase === "TRANSITION_DEF") {
                newState.phase = newState.zone.third === "FINAL" ? "FINAL_THIRD" : "BUILD_UP";
            }
        }
    }

    // -------------------------------------------------------------------------
    // 2. Check Pressing Context Expiry
    // -------------------------------------------------------------------------
    if (newState.pressingContext.active && newState.pressingContext.triggerTime) {
        const elapsed = now - newState.pressingContext.triggerTime;
        if (elapsed > PRESSING_CONTEXT_DURATION) {
            newState.pressingContext.active = false;
            newState.pressingContext.outcome = null;
        }
    }

    // -------------------------------------------------------------------------
    // 3. Process Event-Specific State Changes
    // -------------------------------------------------------------------------

    // Update zone if provided
    if ('zone' in event && typeof event.zone === 'number' && event.zone > 0) {
        newState.zone = getZoneFromNumber(event.zone);
    }

    switch (eventName) {
        // ----- POSSESSION CHANGES -----
        case "interception":
            // RB: Possession gained
            if (newState.teamInPossession !== team) {
                newState.teamInPossession = team;
                newState.phase = "TRANSITION_OFF";
                newState.transitionWindow = {
                    active: true,
                    type: "OFFENSIVE",
                    startTime: now,
                    duration: TRANSITION_WINDOW_DURATION,
                };
                newState.threatLevel = "MEDIUM";

                // Complete pressing context if active
                if (newState.pressingContext.active) {
                    newState.pressingContext.outcome = "RECOVERY";
                }
            }
            break;

        case "turnover":
            // LB: Possession lost
            if (newState.teamInPossession === team) {
                // Switch possession to other team
                newState.teamInPossession = team === "TEAM_A" ? "TEAM_B" : "TEAM_A";
                newState.phase = "TRANSITION_DEF";
                newState.transitionWindow = {
                    active: true,
                    type: "DEFENSIVE",
                    startTime: now,
                    duration: TRANSITION_WINDOW_DURATION,
                };
                newState.threatLevel = "LOW";

                // Complete pressing context if active (other team won it)
                if (newState.pressingContext.active) {
                    newState.pressingContext.outcome = "LOSS";
                }
            }
            break;

        // ----- TRANSITION PHASES -----
        case "transition_off_start":
            // RT: Offensive transition
            newState.phase = "TRANSITION_OFF";
            newState.transitionWindow = {
                active: true,
                type: "OFFENSIVE",
                startTime: now,
                duration: TRANSITION_WINDOW_DURATION,
            };
            newState.pressure = "LOW"; // Defense is disorganized
            break;

        case "transition_def_start":
            // LT: Defensive transition
            newState.phase = "TRANSITION_DEF";
            newState.transitionWindow = {
                active: true,
                type: "DEFENSIVE",
                startTime: now,
                duration: TRANSITION_WINDOW_DURATION,
            };
            newState.pressure = "HIGH"; // Need immediate reaction
            break;

        // ----- ZONE CHANGES -----
        case "final_third_entry":
            // D-Right: Ball entered final third
            newState.zone.third = "FINAL";
            newState.phase = "FINAL_THIRD";
            newState.threatLevel = "MEDIUM";
            break;

        case "switch_of_play":
            // D-Left: Switch of play (lane change)
            // Toggle between left and right lanes
            if (newState.zone.lane === "LEFT" || newState.zone.lane === "HALF_SPACE_LEFT") {
                newState.zone.lane = "RIGHT";
            } else if (newState.zone.lane === "RIGHT" || newState.zone.lane === "HALF_SPACE_RIGHT") {
                newState.zone.lane = "LEFT";
            }
            break;

        // ----- PRESSING -----
        case "pressing_trigger":
            // D-Up: Pressing trigger activated
            newState.pressingContext = {
                active: true,
                triggerTime: now,
                location: { ...newState.zone },
                outcome: null,
            };
            newState.pressure = "HIGH";
            break;

        case "phase_highpress":
            // D-Up Hold: High press phase
            newState.pressure = "HIGH";
            newState.phase = "BUILD_UP"; // Opponent's build-up phase
            break;

        case "phase_lowblock":
            // D-Down: Low block phase
            newState.pressure = "LOW";
            newState.phase = "CONSOLIDATION";
            break;

        // ----- THREATS -----
        case "dangerous_attack":
            // R3: Dangerous attack tag
            newState.threatLevel = "HIGH";
            break;

        case "big_chance":
            // RT+R3: Big chance
            newState.threatLevel = "HIGH";
            break;

        case "shot_start":
            // Y: Shot taken
            newState.threatLevel = "HIGH";
            // Shot doesn't automatically end possession (could be saved, blocked)
            break;

        // ----- SET PIECES -----
        case "free_kick":
        case "penalty":
        case "corner_start":
            newState.phase = "SET_PIECE";
            newState.transitionWindow.active = false;
            newState.teamInPossession = team;
            if (eventName === "penalty") {
                newState.threatLevel = "HIGH";
            }
            break;

        case "foul":
            // Foul committed - possession switches, set piece context
            newState.phase = "SET_PIECE";
            newState.transitionWindow.active = false;
            newState.pressingContext.active = false;
            // Possession to the fouled team (opposite of current)
            if (newState.teamInPossession === team) {
                newState.teamInPossession = team === "TEAM_A" ? "TEAM_B" : "TEAM_A";
            }
            break;

        // ----- PHASE CHANGES -----
        case "phase_buildup_end":
            newState.phase = "BUILD_UP";
            break;

        case "phase_consolidation":
            newState.phase = "CONSOLIDATION";
            break;

        case "phase_final_third":
            newState.phase = "FINAL_THIRD";
            break;

        // ----- PASSES & CARRIES -----
        case "pass_start":
        case "pass_end":
            // Passes maintain current state but update team if needed
            if (!newState.teamInPossession) {
                newState.teamInPossession = team;
            }
            break;

        case "carry_start":
            // Ball carry - player is dribbling
            if (!newState.teamInPossession) {
                newState.teamInPossession = team;
            }
            break;

        case "clearance":
            // Clearance - likely ends immediate threat
            newState.threatLevel = "LOW";
            break;

        default:
            // Other events - just update metadata
            break;
    }

    // -------------------------------------------------------------------------
    // 4. Infer Pressure Level from Zone and Phase
    // -------------------------------------------------------------------------
    if (newState.phase !== "TRANSITION_OFF" && newState.phase !== "TRANSITION_DEF") {
        if (newState.zone.third === "FINAL") {
            newState.pressure = "HIGH";
        } else if (newState.zone.third === "DEFENSIVE") {
            newState.pressure = "MEDIUM";
        }
    }

    // -------------------------------------------------------------------------
    // 5. Update Metadata
    // -------------------------------------------------------------------------
    newState.lastEventTime = now;
    newState.lastEventName = eventName;
    newState.stateVersion += 1;

    // Create transition record
    const transition: StateTransition = {
        from: previousState,
        to: newState,
        trigger: eventName,
        timestamp: now,
    };

    return { newState, transition };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

export function isInTransitionWindow(state: MatchState): boolean {
    if (!state.transitionWindow.active || !state.transitionWindow.startTime) {
        return false;
    }
    const elapsed = Date.now() - state.transitionWindow.startTime;
    return elapsed < state.transitionWindow.duration;
}

export function getTransitionTimeRemaining(state: MatchState): number {
    if (!state.transitionWindow.active || !state.transitionWindow.startTime) {
        return 0;
    }
    const elapsed = Date.now() - state.transitionWindow.startTime;
    const remaining = state.transitionWindow.duration - elapsed;
    return Math.max(0, remaining);
}

export function getStateLabel(state: MatchState): string {
    const team = state.teamInPossession || "N/A";
    const phase = state.phase.replace(/_/g, " ");
    const zone = `${state.zone.third} ${state.zone.lane}`.toLowerCase();
    const pressure = `${state.pressure} press`.toLowerCase();
    const threat = `${state.threatLevel} threat`.toLowerCase();

    return `${team} | ${phase} | ${zone} | ${pressure} | ${threat}`;
}

export function shouldApplyTransitionXGBoost(state: MatchState): boolean {
    return state.transitionWindow.active && state.transitionWindow.type === "OFFENSIVE";
}

export function getZoneNumber(third: PitchThird, lane: PitchLane): number {
    // Find matching zone
    for (const [num, zone] of Object.entries(ZONE_MAP)) {
        if (zone.third === third && zone.lane === lane) {
            return parseInt(num);
        }
    }
    return 9; // Default center
}
</file>

<file path="src/utils/passingNetwork.ts">
import { LoggedEvent } from "@/hooks/useGamepad";

// --- Types ---

export interface PassConnection {
    from: number;      // Player ID who made the pass
    to: number;        // Player ID who received the pass
    count: number;     // Number of passes between these players
    team: string;      // Team identifier
    bidirectional?: boolean; // Whether passes go both ways
}

export interface PlayerNetworkNode {
    playerId: number;
    playerName: string;
    team: string;
    passesGiven: number;      // Total passes made by this player
    passesReceived: number;   // Total passes received by this player
    centrality: number;       // Network centrality score (0-1)
}

export interface PassingNetwork {
    team: string;
    connections: PassConnection[];
    nodes: PlayerNetworkNode[];
    metrics: {
        totalPasses: number;
        uniquePassers: number;
        uniqueReceivers: number;
        avgPassesPerPlayer: number;
        keyPasser: PlayerNetworkNode | null;
        keyReceiver: PlayerNetworkNode | null;
        mostFrequentConnection: PassConnection | null;
    };
}

// --- Helper Functions ---

const isPass = (e: LoggedEvent) => e.eventName === "PASS" || e.eventName === "Successful Pass";

function getPlayerName(playerId: number, roster: any[]): string {
    const player = roster?.find(p => p.id === playerId || p.number === playerId);
    return player?.name || `Player #${playerId}`;
}

// --- Main Function ---

export function buildPassingNetwork(
    events: LoggedEvent[],
    team: "TEAM_A" | "TEAM_B",
    roster: any[] = []
): PassingNetwork {
    // Step 1: Filter pass events for this team and sort by time
    const teamPasses = events
        .filter(e => e.team === team && isPass(e))
        .sort((a, b) => (a.videoTime || 0) - (b.videoTime || 0));

    if (teamPasses.length === 0) {
        return createEmptyNetwork(team);
    }

    // Check if any passes have player data
    const passesWithPlayers = teamPasses.filter(p => p.player?.id);

    if (passesWithPlayers.length === 0) {
        console.warn(`‚ö†Ô∏è No player data found in pass events for ${team}. Please assign players to events to see the passing network.`);
        return createEmptyNetwork(team);
    }

    // Step 2: Infer connections from consecutive passes (only use passes with player data)
    const connections: PassConnection[] = [];

    for (let i = 0; i < passesWithPlayers.length - 1; i++) {
        const passer = passesWithPlayers[i];
        const receiver = passesWithPlayers[i + 1];

        // Only create connection if:
        // 1. Both have player IDs
        // 2. They're different players
        // 3. Within reasonable time window (10 seconds)
        if (
            passer.player?.id &&
            receiver.player?.id &&
            passer.player.id !== receiver.player.id &&
            (receiver.videoTime || 0) - (passer.videoTime || 0) < 10
        ) {
            connections.push({
                from: passer.player.id,
                to: receiver.player.id,
                count: 1,
                team: team
            });
        }
    }

    // Step 3: Aggregate connections (group by passer-receiver pair)
    const connectionMap = new Map<string, PassConnection>();

    connections.forEach(conn => {
        const key = `${conn.from}-${conn.to}`;
        if (connectionMap.has(key)) {
            connectionMap.get(key)!.count++;
        } else {
            connectionMap.set(key, conn);
        }
    });

    const aggregatedConnections = Array.from(connectionMap.values());

    // Step 4: Build player nodes with stats
    const playerStatsMap = new Map<number, PlayerNetworkNode>();

    aggregatedConnections.forEach(conn => {
        // Initialize passer if not exists
        if (!playerStatsMap.has(conn.from)) {
            playerStatsMap.set(conn.from, {
                playerId: conn.from,
                playerName: getPlayerName(conn.from, roster),
                team: team,
                passesGiven: 0,
                passesReceived: 0,
                centrality: 0
            });
        }

        // Initialize receiver if not exists
        if (!playerStatsMap.has(conn.to)) {
            playerStatsMap.set(conn.to, {
                playerId: conn.to,
                playerName: getPlayerName(conn.to, roster),
                team: team,
                passesGiven: 0,
                passesReceived: 0,
                centrality: 0
            });
        }

        // Update stats
        playerStatsMap.get(conn.from)!.passesGiven += conn.count;
        playerStatsMap.get(conn.to)!.passesReceived += conn.count;
    });

    // Step 5: Calculate centrality for each player
    const maxDegree = playerStatsMap.size > 1 ? playerStatsMap.size - 1 : 1;

    playerStatsMap.forEach(player => {
        const degree = player.passesGiven + player.passesReceived;
        player.centrality = degree / maxDegree;
    });

    const nodes = Array.from(playerStatsMap.values());

    // Step 6: Calculate metrics
    const totalPasses = aggregatedConnections.reduce((sum, conn) => sum + conn.count, 0);
    const uniquePassers = new Set(aggregatedConnections.map(c => c.from)).size;
    const uniqueReceivers = new Set(aggregatedConnections.map(c => c.to)).size;
    const avgPassesPerPlayer = nodes.length > 0 ? totalPasses / nodes.length : 0;

    // Find key players
    const keyPasser = nodes.length > 0
        ? nodes.reduce((max, player) => player.passesGiven > max.passesGiven ? player : max)
        : null;

    const keyReceiver = nodes.length > 0
        ? nodes.reduce((max, player) => player.passesReceived > max.passesReceived ? player : max)
        : null;

    // Find most frequent connection
    const mostFrequentConnection = aggregatedConnections.length > 0
        ? aggregatedConnections.reduce((max, conn) => conn.count > max.count ? conn : max)
        : null;

    return {
        team,
        connections: aggregatedConnections,
        nodes,
        metrics: {
            totalPasses,
            uniquePassers,
            uniqueReceivers,
            avgPassesPerPlayer: Math.round(avgPassesPerPlayer * 10) / 10,
            keyPasser,
            keyReceiver,
            mostFrequentConnection
        }
    };
}

function createEmptyNetwork(team: string): PassingNetwork {
    return {
        team,
        connections: [],
        nodes: [],
        metrics: {
            totalPasses: 0,
            uniquePassers: 0,
            uniqueReceivers: 0,
            avgPassesPerPlayer: 0,
            keyPasser: null,
            keyReceiver: null,
            mostFrequentConnection: null
        }
    };
}

// --- Export ---
export { isPass };
</file>

<file path="src/utils/passPredictor.ts">
export interface PlayerPosition {
    id: number;
    name: string;
    number: number;
    position: "GK" | "DEF" | "MID" | "FWD";
    team: "TEAM_A" | "TEAM_B";
    x?: number; // 0-105 (0=Left Goal, 105=Right Goal)
    y?: number; // 0-68 (0=Top, 68=Bottom)
    score?: number;
}

/**
 * Classify player position based on jersey number
 * Updated to catch common defender numbers like 15, 2, 3, 4, 5, 20-25
 */
export const classifyPosition = (playerNumber: number): PlayerPosition["position"] => {
    if (playerNumber === 1) return "GK";
    // Expanded DEF range to catch common fullbacks/centerbacks
    if ((playerNumber >= 2 && playerNumber <= 5) || playerNumber === 15 || (playerNumber >= 20 && playerNumber <= 25)) return "DEF";
    if (playerNumber >= 6 && playerNumber <= 8) return "MID";
    if (playerNumber >= 9 && playerNumber <= 11) return "FWD";
    return "MID"; // Default
};

// Default 4-3-3 Formation Coordinates (x, y) - Standard 105x68m
// Team A attacks Left -> Right (0 -> 105)
const DEFAULT_FORMATION_A: Record<number, { x: number, y: number }> = {
    1: { x: 5.25, y: 34 },   // GK (5% of 105, 50% of 68)
    2: { x: 26.25, y: 57.8 }, // RB (25% of 105, 85% of 68)
    3: { x: 26.25, y: 10.2 }, // LB
    4: { x: 21, y: 40.8 },    // CB
    5: { x: 21, y: 27.2 },    // CB
    6: { x: 47.25, y: 34 },   // CDM
    7: { x: 63, y: 54.4 },    // RM
    8: { x: 63, y: 13.6 },    // LM
    9: { x: 89.25, y: 34 },   // ST
    10: { x: 78.75, y: 20.4 }, // LF
    11: { x: 78.75, y: 47.6 }  // RF
};

// Team B attacks Right -> Left (105 -> 0)
const DEFAULT_FORMATION_B: Record<number, { x: number, y: number }> = {
    1: { x: 99.75, y: 34 },
    2: { x: 78.75, y: 10.2 },
    3: { x: 78.75, y: 57.8 },
    4: { x: 84, y: 27.2 },
    5: { x: 84, y: 40.8 },
    6: { x: 57.75, y: 34 },
    7: { x: 42, y: 13.6 },
    8: { x: 42, y: 54.4 },
    9: { x: 15.75, y: 34 },
    10: { x: 26.25, y: 47.6 },
    11: { x: 26.25, y: 20.4 }
};

const ensureCoordinates = (player: PlayerPosition): PlayerPosition => {
    if (player.x !== undefined && player.y !== undefined) return player;

    const defaults = player.team === "TEAM_A" ? DEFAULT_FORMATION_A : DEFAULT_FORMATION_B;
    // Map jersey number to 1-11 range for default positions
    const lookupId = ((player.number - 1) % 11) + 1;
    const coords = defaults[lookupId] || { x: 52.5, y: 34 };

    return { ...player, ...coords };
};

export const predictPassTargets = (
    currentPlayer: PlayerPosition,
    roster: PlayerPosition[],
    currentZone?: 1 | 2 | 3
): PlayerPosition[] => {
    const ballHolder = ensureCoordinates(currentPlayer);

    const candidates = roster
        .filter(p => p.id !== currentPlayer.id && p.team === currentPlayer.team)
        .map(p => ensureCoordinates(p));

    if (candidates.length === 0) return [];

    const scoredCandidates = candidates.map(p => {
        // 1. Distance
        const dist = Math.hypot(p.x! - ballHolder.x!, p.y! - ballHolder.y!);

        // 2. Forward Progress
        let forward = 0;
        if (ballHolder.team === "TEAM_A") {
            forward = p.x! - ballHolder.x!;
        } else {
            forward = ballHolder.x! - p.x!;
        }

        // 3. Lane Alignment
        const lane = -Math.abs(p.y! - ballHolder.y!);

        // Base Score - Adjusted weights for meter scale
        let score = (-dist * 0.5) + (forward * 1.5) + (lane * 0.4);

        // --- CRITICAL FIX FOR GK PASSING ---
        if (currentPlayer.position === 'GK') {
            // Instead of simple distance, check if player is in the "Defensive Zone"
            // Team A Defenders are roughly 0-40. Team B Defenders are roughly 60-100.

            let isBackLine = false;
            if (ballHolder.team === "TEAM_A" && p.x! < 45) isBackLine = true;
            if (ballHolder.team === "TEAM_B" && p.x! > 55) isBackLine = true;

            if (isBackLine) {
                // HUGE boost to ensure #2, #15, #5, #4 are ALWAYS at the top for GK
                score += 50;
            }
        }

        return { ...p, score };
    });

    // Sort by score descending
    scoredCandidates.sort((a, b) => (b.score || 0) - (a.score || 0));

    // --- DYNAMIC LIMIT ---
    let limit = 5;

    switch (currentPlayer.position) {
        case "GK":
            limit = 20; // Show EVERYONE. Never hide options for GK.
            break;
        case "DEF":
            limit = 8;  // Defenders need wide options
            break;
        case "MID":
            limit = 6;
            break;
        case "FWD":
            limit = 5;
            break;
        default:
            limit = 5;
    }

    return scoredCandidates.slice(0, Math.min(limit, scoredCandidates.length));
};

/**
 * TACTA Standard 18-Zone Calculation
 * Pitch: 105x68m
 * Grid: 3 sections long (h), 6 sections wide (v)
 * Zones: 1-6 Attacking, 7-12 Middle, 13-18 Defensive
 */
export const calculateZone = (x: number, y: number): number => {
    // Horizontal (x): 3 sections (Thirds)
    let h: number;
    if (x >= 70) {
        h = 0; // Final Third
    } else if (x >= 35) {
        h = 1; // Middle Third
    } else {
        h = 2; // Defensive Third
    }

    // Vertical (y): 6 sections
    // 68 / 6 = 11.33m per slice
    let v: number;
    if (y < 11.33) v = 0;
    else if (y < 22.66) v = 1;
    else if (y < 34) v = 2;
    else if (y < 45.33) v = 3;
    else if (y < 56.66) v = 4;
    else v = 5;

    return (h * 6) + v + 1;
};

/**
 * Map y-coordinate to TACTA Corridor
 */
export const calculateCorridor = (y: number): 'LW' | 'LHS' | 'C' | 'RHS' | 'RW' => {
    // Five-Corridor System (approx 13.6m each? No, Central is Zone 14 width)
    // Based on doc: LW (~10m), LH, C, RH, RW (~10m)
    if (y > 58) return 'LW';       // Top (Left)
    if (y > 44) return 'LHS';
    if (y > 24) return 'C';
    if (y > 10) return 'RHS';
    return 'RW';                  // Bottom (Right)
};

export const convertToPlayerPosition = (
    roster: Array<{ id: number; name: string; number?: number }>,
    team: "TEAM_A" | "TEAM_B"
): PlayerPosition[] => {
    return roster.map(player => ({
        id: player.id,
        name: player.name,
        number: player.number || player.id,
        position: classifyPosition(player.number || player.id),
        team
    }));
};

export const createDefaultRoster = (team: "TEAM_A" | "TEAM_B"): PlayerPosition[] => {
    return Array.from({ length: 11 }, (_, i) => {
        const number = i + 1;
        return {
            id: number,
            name: `Player #${number}`,
            number,
            position: classifyPosition(number),
            team
        };
    });
};
</file>

<file path="src/utils/PossessionChain.ts">
// src/utils/PossessionChain.ts
// Possession chain management - tracks linked sequences of events within a possession

import { LoggedEvent } from "@/hooks/useGamepad";
import { MatchState, PitchZone, TeamId } from "./MatchStateMachine";

// ============================================================================
// TYPES
// ============================================================================

export type PossessionOutcome =
    | "SHOT"
    | "GOAL"
    | "LOSS"
    | "SET_PIECE"
    | "OUT_OF_PLAY"
    | "ONGOING";

export interface PossessionChain {
    id: number;
    team: TeamId;
    startTime: number;
    endTime?: number;
    events: LoggedEvent[];

    // Zone tracking
    startZone: PitchZone;
    endZone?: PitchZone;
    zonesVisited: Set<number>;

    // Calculated metrics
    passCount: number;
    progressivePassCount: number;
    enteredFinalThird: boolean;
    enteredBox: boolean;
    shotTaken: boolean;

    // Context flags
    fromTransition: boolean; // Started from offensive transition
    fromSetPiece: boolean;
    underPressure: boolean; // Started under high pressing

    // Outcome
    outcome: PossessionOutcome;

    // Analytics (calculated when chain ends)
    durationMs?: number;
    buildUpSpeed?: "FAST" | "MEDIUM" | "SLOW";
    verticality?: number; // 0-1, how direct was the progression
    xgContext?: number; // Bonus multiplier for xG based on context
}

export interface ChainStats {
    totalChains: number;
    avgDuration: number;
    avgPassesPerChain: number;

    // Outcome distribution
    shotsPerChain: number;
    goalsPerChain: number;
    lossRate: number;

    // Transition stats
    transitionChains: number;
    transitionToShotRate: number;
    transitionToGoalRate: number;

    // Progression stats
    finalThirdEntryRate: number;
    boxEntryRate: number;
    progressivePassRate: number;

    // Build-up profile
    fastBuildUps: number;
    slowBuildUps: number;
}

export interface PossessionManager {
    currentChain: PossessionChain | null;
    completedChains: PossessionChain[];
    chainIdCounter: number;
}

// ============================================================================
// FACTORY FUNCTIONS
// ============================================================================

export function createPossessionManager(): PossessionManager {
    return {
        currentChain: null,
        completedChains: [],
        chainIdCounter: 1,
    };
}

export function createNewChain(
    team: TeamId,
    event: LoggedEvent,
    state: MatchState,
    manager: PossessionManager
): PossessionChain {
    const chainId = manager.chainIdCounter++;

    return {
        id: chainId,
        team,
        startTime: Date.now(),
        events: [event],

        startZone: { ...state.zone },
        zonesVisited: new Set([state.zone.zoneNumber]),

        passCount: event.eventName.includes("pass") ? 1 : 0,
        progressivePassCount: 0,
        enteredFinalThird: state.zone.third === "FINAL",
        enteredBox: state.zone.zoneNumber === 18,
        shotTaken: event.eventName === "shot_start",

        fromTransition: state.phase === "TRANSITION_OFF",
        fromSetPiece: state.phase === "SET_PIECE",
        underPressure: state.pressure === "HIGH",

        outcome: "ONGOING",
    };
}

// ============================================================================
// CHAIN OPERATIONS
// ============================================================================

export function startNewPossession(
    manager: PossessionManager,
    team: TeamId,
    event: LoggedEvent,
    state: MatchState
): PossessionManager {
    // End current chain if exists
    let updatedManager = manager;
    if (manager.currentChain) {
        updatedManager = endPossession(manager, "LOSS");
    }

    // Create new chain
    const newChain = createNewChain(team, event, state, updatedManager);

    return {
        ...updatedManager,
        currentChain: newChain,
    };
}

export function addEventToChain(
    manager: PossessionManager,
    event: LoggedEvent,
    state: MatchState
): PossessionManager {
    if (!manager.currentChain) {
        // No active chain - start one
        return startNewPossession(manager, event.team as TeamId, event, state);
    }

    const chain = manager.currentChain;

    // Check if event belongs to same team
    if (event.team !== chain.team) {
        // Possession changed - end current chain and start new one
        const endedManager = endPossession(manager, "LOSS");
        return startNewPossession(endedManager, event.team as TeamId, event, state);
    }

    // Add event to current chain
    const updatedChain: PossessionChain = {
        ...chain,
        events: [...chain.events, event],
        zonesVisited: new Set([...chain.zonesVisited, state.zone.zoneNumber]),
    };

    // Update metrics based on event type
    if (event.eventName.includes("pass")) {
        updatedChain.passCount++;

        // Check if progressive (moved ball toward goal)
        if (isProgressivePass(event, chain.startZone, state.zone)) {
            updatedChain.progressivePassCount++;
        }
    }

    if (state.zone.third === "FINAL" && !chain.enteredFinalThird) {
        updatedChain.enteredFinalThird = true;
    }

    if (state.zone.zoneNumber === 18 && !chain.enteredBox) {
        updatedChain.enteredBox = true;
    }

    if (event.eventName === "shot_start") {
        updatedChain.shotTaken = true;
    }

    // Update end zone
    updatedChain.endZone = { ...state.zone };

    return {
        ...manager,
        currentChain: updatedChain,
    };
}

export function endPossession(
    manager: PossessionManager,
    outcome: PossessionOutcome
): PossessionManager {
    if (!manager.currentChain) {
        return manager;
    }

    const chain = manager.currentChain;
    const endTime = Date.now();
    const durationMs = endTime - chain.startTime;

    // Calculate analytics
    const completedChain: PossessionChain = {
        ...chain,
        endTime,
        outcome,
        durationMs,
        buildUpSpeed: calculateBuildUpSpeed(durationMs, chain.passCount),
        verticality: calculateVerticality(chain),
        xgContext: calculateXGContext(chain),
    };

    return {
        ...manager,
        currentChain: null,
        completedChains: [...manager.completedChains, completedChain],
    };
}

// ============================================================================
// ANALYTICS HELPERS
// ============================================================================

function isProgressivePass(
    event: LoggedEvent,
    startZone: PitchZone,
    currentZone: PitchZone
): boolean {
    // Progressive if moved ball closer to goal
    const thirdOrder = { "DEFENSIVE": 0, "MIDDLE": 1, "FINAL": 2 };
    return thirdOrder[currentZone.third] > thirdOrder[startZone.third];
}

function calculateBuildUpSpeed(
    durationMs: number,
    passCount: number
): "FAST" | "MEDIUM" | "SLOW" {
    if (passCount === 0) return "FAST"; // Quick action

    const passesPerSecond = passCount / (durationMs / 1000);

    if (passesPerSecond > 1) return "FAST";
    if (passesPerSecond > 0.5) return "MEDIUM";
    return "SLOW";
}

function calculateVerticality(chain: PossessionChain): number {
    if (!chain.endZone) return 0;

    const thirdOrder = { "DEFENSIVE": 0, "MIDDLE": 1, "FINAL": 2 };
    const startThird = thirdOrder[chain.startZone.third];
    const endThird = thirdOrder[chain.endZone.third];

    // Verticality = how much progress toward goal relative to passes
    const progressMade = endThird - startThird;
    const maxProgress = 2 - startThird;

    if (maxProgress === 0) return 1; // Already in final third
    if (chain.passCount === 0) return progressMade > 0 ? 1 : 0;

    // Fewer passes to progress = more vertical
    const efficiency = progressMade / Math.max(1, chain.passCount / 3);
    return Math.min(1, Math.max(0, efficiency));
}

function calculateXGContext(chain: PossessionChain): number {
    let multiplier = 1.0;

    // Transition bonus: Higher xG for shots from transition
    if (chain.fromTransition) {
        multiplier *= 1.3;
    }

    // Fast build-up bonus
    if (chain.buildUpSpeed === "FAST") {
        multiplier *= 1.15;
    }

    // High verticality bonus
    if (chain.verticality && chain.verticality > 0.7) {
        multiplier *= 1.1;
    }

    // Under pressure penalty (team was pressing, may indicate counter)
    if (chain.underPressure && !chain.fromTransition) {
        multiplier *= 0.9;
    }

    return multiplier;
}

// ============================================================================
// STATISTICS
// ============================================================================

export function calculateChainStats(
    chains: PossessionChain[],
    team?: TeamId
): ChainStats {
    const filtered = team
        ? chains.filter(c => c.team === team)
        : chains;

    if (filtered.length === 0) {
        return {
            totalChains: 0,
            avgDuration: 0,
            avgPassesPerChain: 0,
            shotsPerChain: 0,
            goalsPerChain: 0,
            lossRate: 0,
            transitionChains: 0,
            transitionToShotRate: 0,
            transitionToGoalRate: 0,
            finalThirdEntryRate: 0,
            boxEntryRate: 0,
            progressivePassRate: 0,
            fastBuildUps: 0,
            slowBuildUps: 0,
        };
    }

    const totalChains = filtered.length;
    const totalDuration = filtered.reduce((sum, c) => sum + (c.durationMs || 0), 0);
    const totalPasses = filtered.reduce((sum, c) => sum + c.passCount, 0);
    const totalProgressivePasses = filtered.reduce((sum, c) => sum + c.progressivePassCount, 0);

    const shots = filtered.filter(c => c.shotTaken).length;
    const goals = filtered.filter(c => c.outcome === "GOAL").length;
    const losses = filtered.filter(c => c.outcome === "LOSS").length;

    const transitionChains = filtered.filter(c => c.fromTransition);
    const transitionShots = transitionChains.filter(c => c.shotTaken).length;
    const transitionGoals = transitionChains.filter(c => c.outcome === "GOAL").length;

    const finalThirdEntries = filtered.filter(c => c.enteredFinalThird).length;
    const boxEntries = filtered.filter(c => c.enteredBox).length;

    const fastBuildUps = filtered.filter(c => c.buildUpSpeed === "FAST").length;
    const slowBuildUps = filtered.filter(c => c.buildUpSpeed === "SLOW").length;

    return {
        totalChains,
        avgDuration: totalDuration / totalChains,
        avgPassesPerChain: totalPasses / totalChains,
        shotsPerChain: shots / totalChains,
        goalsPerChain: goals / totalChains,
        lossRate: losses / totalChains,
        transitionChains: transitionChains.length,
        transitionToShotRate: transitionChains.length > 0
            ? transitionShots / transitionChains.length
            : 0,
        transitionToGoalRate: transitionChains.length > 0
            ? transitionGoals / transitionChains.length
            : 0,
        finalThirdEntryRate: finalThirdEntries / totalChains,
        boxEntryRate: boxEntries / totalChains,
        progressivePassRate: totalPasses > 0
            ? totalProgressivePasses / totalPasses
            : 0,
        fastBuildUps,
        slowBuildUps,
    };
}

// ============================================================================
// SERIALIZATION
// ============================================================================

export function serializeManager(manager: PossessionManager): string {
    const serializable = {
        ...manager,
        currentChain: manager.currentChain
            ? {
                ...manager.currentChain,
                zonesVisited: Array.from(manager.currentChain.zonesVisited),
            }
            : null,
        completedChains: manager.completedChains.map(c => ({
            ...c,
            zonesVisited: Array.from(c.zonesVisited),
        })),
    };
    return JSON.stringify(serializable);
}

export function deserializeManager(json: string): PossessionManager {
    const parsed = JSON.parse(json);
    return {
        ...parsed,
        currentChain: parsed.currentChain
            ? {
                ...parsed.currentChain,
                zonesVisited: new Set(parsed.currentChain.zonesVisited),
            }
            : null,
        completedChains: parsed.completedChains.map((c: any) => ({
            ...c,
            zonesVisited: new Set(c.zonesVisited),
        })),
    };
}
</file>

<file path="src/utils/roboflowApi.ts">
/**
 * Roboflow Pitch Keypoints Detection API
 * Uses the hacenbarb/pitch-keypoints-detection model to detect football pitch landmarks
 */

import { API_BASE_URL } from './apiConfig';

export interface Point {
    x: number;
    y: number;
}

export interface DetectedKeypoint {
    class: string;
    confidence: number;
    x: number;  // center x in pixels
    y: number;  // center y in pixels
    width: number;
    height: number;
}

export interface KeypointDetectionResult {
    predictions: DetectedKeypoint[];
    image: {
        width: number;
        height: number;
    };
}

export interface DetectedPlayer {
    id: number;
    bbox: [number, number, number, number];
    center: [number, number];
    pitch_coords: [number, number] | null;
    team: string;
    confidence: number;
    cls: number;
}

export interface PlayerDetectionResult {
    success: boolean;
    players: DetectedPlayer[];
    error?: string;
}

export interface CalibrationPair {
    src: Point;  // Video/image pixel coordinates
    dst: Point;  // Pitch coordinates in meters (105x68m)
    class: string;
    confidence: number;
    isAutoDetected: boolean;
}

/**
 * Mapping of Roboflow class codes to FIFA pitch coordinates (105x68m pitch)
 * Expanded to 29 points based on the Soccana/SoccerNet standard
 */
export const KEYPOINT_PITCH_MAPPING: Record<string, { x: number; y: number; name: string }> = {
    // Corners (4)
    'TLC': { x: 0, y: 0, name: 'Top-Left Corner' },
    'TRC': { x: 105, y: 0, name: 'Top-Right Corner' },
    'BLC': { x: 0, y: 68, name: 'Bottom-Left Corner' },
    'BRC': { x: 105, y: 68, name: 'Bottom-Right Corner' },

    // Halfway Line (2)
    'TMC': { x: 52.5, y: 0, name: 'Halfway Line Top' },
    'BMC': { x: 52.5, y: 68, name: 'Halfway Line Bottom' },

    // Center Circle (5 points)
    'CC': { x: 52.5, y: 34, name: 'Center Circle Center' },
    'CCL': { x: 43.35, y: 34, name: 'Center Circle Left' },
    'CCR': { x: 61.65, y: 34, name: 'Center Circle Right' },
    'CCT': { x: 52.5, y: 24.85, name: 'Center Circle Top' },
    'CCB': { x: 52.5, y: 43.15, name: 'Center Circle Bottom' },

    // Left Penalty Area (4 corners + penalty spot)
    'LPA_TL': { x: 0, y: 13.84, name: 'Left Penalty Top-Left' },
    'LPA_BL': { x: 0, y: 54.16, name: 'Left Penalty Bottom-Left' },
    'LPA_TR': { x: 16.5, y: 13.84, name: 'Left Penalty Top-Right' },
    'LPA_BR': { x: 16.5, y: 54.16, name: 'Left Penalty Bottom-Right' },
    'LPS': { x: 11, y: 34, name: 'Left Penalty Spot' },

    // Right Penalty Area (4 corners + penalty spot)
    'RPA_TL': { x: 88.5, y: 13.84, name: 'Right Penalty Top-Left' },
    'RPA_BL': { x: 88.5, y: 54.16, name: 'Right Penalty Bottom-Left' },
    'RPA_TR': { x: 105, y: 13.84, name: 'Right Penalty Top-Right' },
    'RPA_BR': { x: 105, y: 54.16, name: 'Right Penalty Bottom-Right' },
    'RPS': { x: 94, y: 34, name: 'Right Penalty Spot' },

    // Left Goal Area (4 points)
    'LGA_TL': { x: 0, y: 24.84, name: 'Left Goal Area Top-Left' },
    'LGA_BL': { x: 0, y: 43.16, name: 'Left Goal Area Bottom-Left' },
    'LGA_TR': { x: 5.5, y: 24.84, name: 'Left Goal Area Top-Right' },
    'LGA_BR': { x: 5.5, y: 43.16, name: 'Left Goal Area Bottom-Right' },

    // Right Goal Area (4 points)
    'RGA_TL': { x: 99.5, y: 24.84, name: 'Right Goal Area Top-Left' },
    'RGA_BL': { x: 99.5, y: 43.16, name: 'Right Goal Area Bottom-Left' },
    'RGA_TR': { x: 105, y: 24.84, name: 'Right Goal Area Top-Right' },
    'RGA_BR': { x: 105, y: 43.16, name: 'Right Goal Area Bottom-Right' }
};

/**
 * Convert image/video file to base64 string
 */
export async function fileToBase64(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
            const result = reader.result as string;
            // Remove data URL prefix (e.g., "data:image/jpeg;base64,")
            const base64 = result.split(',')[1];
            resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}

/**
 * Convert a video frame at a specific time to base64
 */
export async function videoFrameToBase64(videoUrl: string, time: number = 0): Promise<string> {
    return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.crossOrigin = 'anonymous';
        video.src = videoUrl;

        video.onloadedmetadata = () => {
            video.currentTime = time;
        };

        video.onseeked = () => {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                reject(new Error('Could not get canvas context'));
                return;
            }

            ctx.drawImage(video, 0, 0);
            const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
            const base64 = dataUrl.split(',')[1];
            resolve(base64);
        };

        video.onerror = () => reject(new Error('Failed to load video'));
    });
}

/**
 * Detect pitch keypoints using Roboflow API (proxied through backend)
 */
export async function detectPitchKeypoints(imageBase64: string): Promise<KeypointDetectionResult> {
    const response = await fetch(`${API_BASE_URL}/api/detect-keypoints`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            image: imageBase64,
        }),
    });

    if (!response.ok) {
        const error = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(error.error || `API request failed: ${response.status}`);
    }

    return response.json();
}

/**
 * Detect players in a single frame using the local backend
 */
export async function detectPlayers(imageBase64: string, homography?: string, highContrast: boolean = false): Promise<PlayerDetectionResult> {
    const formData = new FormData();
    formData.append('image', imageBase64);
    if (homography) {
        formData.append('homography', homography);
    }
    formData.append('high_contrast', highContrast ? 'true' : 'false');

    const response = await fetch(`${API_BASE_URL}/api/detect-players`, {
        method: 'POST',
        body: formData,
    });

    if (!response.ok) {
        const error = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(error.error || `API request failed: ${response.status}`);
    }

    return response.json();
}

/**
 * Convert detected keypoints to calibration pairs
 * Maps pixel coordinates to FIFA pitch coordinates (105x68m)
 */
export function keypointsToCalibrationPairs(
    detections: DetectedKeypoint[],
    minConfidence: number = 0.5
): CalibrationPair[] {
    const pairs: CalibrationPair[] = [];

    for (const detection of detections) {
        if (detection.confidence < minConfidence) continue;

        const pitchMapping = KEYPOINT_PITCH_MAPPING[detection.class];
        if (!pitchMapping) {
            console.warn(`Unknown keypoint class: ${detection.class}`);
            continue;
        }

        pairs.push({
            src: { x: detection.x, y: detection.y },
            dst: { x: pitchMapping.x, y: pitchMapping.y },
            class: detection.class,
            confidence: detection.confidence,
            isAutoDetected: true,
        });
    }

    // Sort by confidence (highest first)
    pairs.sort((a, b) => b.confidence - a.confidence);

    return pairs;
}

/**
 * Get class name for a keypoint
 */
export function getKeypointName(classCode: string): string {
    return KEYPOINT_PITCH_MAPPING[classCode]?.name || classCode;
}
</file>

<file path="src/utils/SequencePredictor.ts">
// src/utils/SequencePredictor.ts
// Pattern learning and sequence prediction for analyst assistance

// ============================================================================
// TYPES
// ============================================================================

export interface EventPattern {
    sequence: string[]; // The sequence of events leading up to this pattern
    sequenceKey: string; // Stringified version for map key
    followers: Map<string, number>; // Next event -> occurrence count
    totalOccurrences: number;
}

export interface Prediction {
    eventName: string;
    probability: number;
    confidence: "HIGH" | "MEDIUM" | "LOW";
    buttonLabel: string;
    description: string;
}

export interface SequencePredictorState {
    patterns: Map<string, EventPattern>;
    recentSequence: string[];
    windowSize: number;
    minOccurrences: number; // Minimum occurrences to make a prediction
    totalEventsProcessed: number;
}

export interface LearningStats {
    totalPatterns: number;
    totalEventsProcessed: number;
    averageFollowersPerPattern: number;
    topPatterns: Array<{
        sequence: string[];
        occurrences: number;
        topFollower: string;
        topFollowerProbability: number;
    }>;
}

// ============================================================================
// CONSTANTS
// ============================================================================

const DEFAULT_WINDOW_SIZE = 3; // Look at last 3 events to predict next
const DEFAULT_MIN_OCCURRENCES = 2; // Need at least 2 occurrences to predict
const MAX_PREDICTIONS = 5;
const STORAGE_KEY = "tacta_sequence_patterns";

// Event name to button label mapping
const EVENT_BUTTON_MAP: Record<string, { label: string; description: string }> = {
    // Face buttons
    "pass_start": { label: "X", description: "Pass" },
    "shot_start": { label: "Y", description: "Shot" },
    "ui_confirm": { label: "A", description: "Confirm" },
    "ui_cancel": { label: "B", description: "Cancel" },

    // Shoulder buttons
    "turnover": { label: "LB", description: "Possession Lost" },
    "interception": { label: "RB", description: "Interception" },

    // Triggers
    "transition_def_start": { label: "LT", description: "Defensive Transition" },
    "transition_off_start": { label: "RT", description: "Offensive Transition" },

    // D-Pad
    "pressing_trigger": { label: "D-Up", description: "Pressing Trigger" },
    "phase_lowblock": { label: "D-Down", description: "Low Block" },
    "switch_of_play": { label: "D-Left", description: "Switch of Play" },
    "final_third_entry": { label: "D-Right", description: "Final Third Entry" },

    // Special
    "foul": { label: "View", description: "Foul" },
    "dangerous_attack": { label: "R3", description: "Dangerous Attack" },
    "press_trap": { label: "L3", description: "Pressing Trap" },

    // Combos
    "cross_start": { label: "RT+B", description: "Cross" },
    "duel_ground": { label: "RT+X", description: "Ground Duel" },
    "clearance": { label: "RT+RB", description: "Clearance" },
    "big_chance": { label: "RT+R3", description: "Big Chance" },
    "free_kick": { label: "RT+View", description: "Free Kick" },
    "penalty": { label: "LT+View", description: "Penalty" },
    "card_yellow": { label: "View+Y", description: "Yellow Card" },
    "card_red": { label: "View+B", description: "Red Card" },
    "offside": { label: "View+A", description: "Offside" },
    "dribble_attempt": { label: "RB+X", description: "Dribble Attempt" },
    "counter_attack": { label: "RB+Y", description: "Counter Attack" },

    // Keyboard events
    "goal": { label: "Shift+2", description: "Goal" },
    "assist": { label: "Ctrl+1", description: "Assist" },
    "key_pass": { label: "Shift+1", description: "Key Pass" },
};

// ============================================================================
// FACTORY & PERSISTENCE
// ============================================================================

export function createSequencePredictor(
    windowSize: number = DEFAULT_WINDOW_SIZE,
    minOccurrences: number = DEFAULT_MIN_OCCURRENCES
): SequencePredictorState {
    // Try to load from localStorage
    const stored = loadPatternsFromStorage();
    if (stored) {
        return {
            ...stored,
            windowSize,
            minOccurrences,
        };
    }

    return {
        patterns: new Map(),
        recentSequence: [],
        windowSize,
        minOccurrences,
        totalEventsProcessed: 0,
    };
}

export function loadPatternsFromStorage(): SequencePredictorState | null {
    try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) return null;

        const parsed = JSON.parse(stored);

        // Reconstruct Maps from serialized data
        const patterns = new Map<string, EventPattern>();
        for (const [key, value] of Object.entries(parsed.patterns)) {
            const patternData = value as any;
            patterns.set(key, {
                ...patternData,
                followers: new Map(Object.entries(patternData.followers)),
            });
        }

        return {
            patterns,
            recentSequence: parsed.recentSequence || [],
            windowSize: parsed.windowSize || DEFAULT_WINDOW_SIZE,
            minOccurrences: parsed.minOccurrences || DEFAULT_MIN_OCCURRENCES,
            totalEventsProcessed: parsed.totalEventsProcessed || 0,
        };
    } catch (e) {
        console.warn("Failed to load sequence patterns:", e);
        return null;
    }
}

export function savePatternsToStorage(state: SequencePredictorState): void {
    try {
        // Convert Maps to serializable objects
        const patternsObj: Record<string, any> = {};
        for (const [key, pattern] of state.patterns.entries()) {
            patternsObj[key] = {
                ...pattern,
                followers: Object.fromEntries(pattern.followers),
            };
        }

        const toStore = {
            patterns: patternsObj,
            recentSequence: state.recentSequence,
            windowSize: state.windowSize,
            minOccurrences: state.minOccurrences,
            totalEventsProcessed: state.totalEventsProcessed,
        };

        localStorage.setItem(STORAGE_KEY, JSON.stringify(toStore));
    } catch (e) {
        console.warn("Failed to save sequence patterns:", e);
    }
}

// ============================================================================
// CORE OPERATIONS
// ============================================================================

export function recordEvent(
    state: SequencePredictorState,
    eventName: string
): SequencePredictorState {
    // Skip UI events that don't contribute to patterns
    if (eventName.startsWith("ui_")) {
        return state;
    }

    const newRecentSequence = [...state.recentSequence, eventName];

    // Keep only the window size
    while (newRecentSequence.length > state.windowSize) {
        newRecentSequence.shift();
    }

    // If we have enough history, learn this pattern
    let newPatterns = state.patterns;
    if (state.recentSequence.length >= 1) {
        newPatterns = learnPattern(state.patterns, state.recentSequence, eventName);
    }

    const newState = {
        ...state,
        patterns: newPatterns,
        recentSequence: newRecentSequence,
        totalEventsProcessed: state.totalEventsProcessed + 1,
    };

    // Auto-save periodically (every 10 events)
    if (newState.totalEventsProcessed % 10 === 0) {
        savePatternsToStorage(newState);
    }

    return newState;
}

function learnPattern(
    patterns: Map<string, EventPattern>,
    sequence: string[],
    nextEvent: string
): Map<string, EventPattern> {
    const newPatterns = new Map(patterns);

    // Learn patterns of different lengths (1 to sequence length)
    for (let len = 1; len <= sequence.length; len++) {
        const subSeq = sequence.slice(-len);
        const key = subSeq.join("‚Üí");

        const existing = newPatterns.get(key);

        if (existing) {
            // Update existing pattern
            const newFollowers = new Map(existing.followers);
            newFollowers.set(nextEvent, (newFollowers.get(nextEvent) || 0) + 1);

            newPatterns.set(key, {
                ...existing,
                followers: newFollowers,
                totalOccurrences: existing.totalOccurrences + 1,
            });
        } else {
            // Create new pattern
            const followers = new Map<string, number>();
            followers.set(nextEvent, 1);

            newPatterns.set(key, {
                sequence: subSeq,
                sequenceKey: key,
                followers,
                totalOccurrences: 1,
            });
        }
    }

    return newPatterns;
}

// ============================================================================
// PREDICTIONS
// ============================================================================

export function getPredictions(
    state: SequencePredictorState
): Prediction[] {
    if (state.recentSequence.length === 0) {
        return [];
    }

    // Try to find matching patterns from longest to shortest
    const predictions: Map<string, { probability: number; occurrences: number }> = new Map();

    for (let len = Math.min(state.recentSequence.length, state.windowSize); len >= 1; len--) {
        const subSeq = state.recentSequence.slice(-len);
        const key = subSeq.join("‚Üí");
        const pattern = state.patterns.get(key);

        if (pattern && pattern.totalOccurrences >= state.minOccurrences) {
            // Calculate probabilities for followers
            for (const [follower, count] of pattern.followers.entries()) {
                const probability = count / pattern.totalOccurrences;

                // Weight by pattern length (longer patterns = more specific = higher weight)
                const weight = len / state.windowSize;
                const weightedProb = probability * (0.5 + 0.5 * weight);

                const existing = predictions.get(follower);
                if (!existing || existing.probability < weightedProb) {
                    predictions.set(follower, {
                        probability: weightedProb,
                        occurrences: pattern.totalOccurrences
                    });
                }
            }
        }
    }

    // Convert to prediction objects and sort by probability
    const results: Prediction[] = [];

    for (const [eventName, data] of predictions.entries()) {
        const buttonInfo = EVENT_BUTTON_MAP[eventName] || {
            label: "?",
            description: eventName.replace(/_/g, " ")
        };

        results.push({
            eventName,
            probability: data.probability,
            confidence: getConfidenceLevel(data.probability, data.occurrences),
            buttonLabel: buttonInfo.label,
            description: buttonInfo.description,
        });
    }

    // Sort by probability and take top predictions
    results.sort((a, b) => b.probability - a.probability);
    return results.slice(0, MAX_PREDICTIONS);
}

function getConfidenceLevel(
    probability: number,
    occurrences: number
): "HIGH" | "MEDIUM" | "LOW" {
    // High confidence: High probability AND many observations
    if (probability > 0.5 && occurrences >= 10) return "HIGH";
    if (probability > 0.3 && occurrences >= 5) return "MEDIUM";
    return "LOW";
}

// ============================================================================
// ANALYTICS
// ============================================================================

export function getLearningStats(state: SequencePredictorState): LearningStats {
    const patterns = Array.from(state.patterns.values());

    if (patterns.length === 0) {
        return {
            totalPatterns: 0,
            totalEventsProcessed: state.totalEventsProcessed,
            averageFollowersPerPattern: 0,
            topPatterns: [],
        };
    }

    const totalFollowers = patterns.reduce((sum, p) => sum + p.followers.size, 0);

    // Get top 5 most frequent patterns
    const sortedPatterns = patterns
        .filter(p => p.totalOccurrences >= 3)
        .sort((a, b) => b.totalOccurrences - a.totalOccurrences)
        .slice(0, 5);

    const topPatterns = sortedPatterns.map(p => {
        // Find top follower
        let topFollower = "";
        let topCount = 0;
        for (const [follower, count] of p.followers.entries()) {
            if (count > topCount) {
                topCount = count;
                topFollower = follower;
            }
        }

        return {
            sequence: p.sequence,
            occurrences: p.totalOccurrences,
            topFollower,
            topFollowerProbability: topCount / p.totalOccurrences,
        };
    });

    return {
        totalPatterns: patterns.length,
        totalEventsProcessed: state.totalEventsProcessed,
        averageFollowersPerPattern: totalFollowers / patterns.length,
        topPatterns,
    };
}

// ============================================================================
// UTILITIES
// ============================================================================

export function resetPredictor(): SequencePredictorState {
    localStorage.removeItem(STORAGE_KEY);
    return createSequencePredictor();
}

export function getButtonLabelForEvent(eventName: string): string {
    return EVENT_BUTTON_MAP[eventName]?.label || "?";
}

export function getDescriptionForEvent(eventName: string): string {
    return EVENT_BUTTON_MAP[eventName]?.description || eventName.replace(/_/g, " ");
}

// Format probability as percentage string
export function formatProbability(probability: number): string {
    return `${Math.round(probability * 100)}%`;
}
</file>

<file path="src/utils/voiceUtils.ts">
/**
 * Utility functions for voice command parsing and number recognition.
 */

// Command Mappings
export const COMMANDS = {
    PASS: ["pass", "past", "path", "bass", "passe", "tamrir"],
    SHOOT: ["shoot", "shot", "chute", "suit", "tir", "tasdid"],
    GOAL: ["goal", "go", "gold", "cold", "but", "hadaf"],
    FOUL: ["foul", "fall", "full", "fail", "faute", "khata"],
    OFFSIDE: ["offside", "hors-jeu", "tasallul"],
    PENALTY: ["penalty", "peno", "rkalat"],
    CORNER: ["corner", "ruknya"],
    SUBSTITUTION: ["substitution", "sub", "change", "remplacement", "tabdil"],
};

// Number Mappings
const NUMBERS_EN: Record<string, number> = {
    "one": 1, "two": 2, "three": 3, "four": 4, "five": 5,
    "six": 6, "seven": 7, "eight": 8, "nine": 9, "mine": 9, "ten": 10,
    "eleven": 11, "twelve": 12, "thirteen": 13, "fourteen": 14, "fifteen": 15,
    "sixteen": 16, "seventeen": 17, "eighteen": 18, "nineteen": 19, "twenty": 20,
    "thirty": 30, "forty": 40, "fifty": 50, "sixty": 60, "seventy": 70, "eighty": 80, "ninety": 90
};

const NUMBERS_FR: Record<string, number> = {
    "un": 1, "une": 1, "deux": 2, "trois": 3, "quatre": 4, "cinq": 5,
    "six": 6, "sept": 7, "huit": 8, "neuf": 9, "dix": 10,
    "onze": 11, "douze": 12, "treize": 13, "quatorze": 14, "quinze": 15,
    "seize": 16, "dix-sept": 17, "dix-huit": 18, "dix-neuf": 19, "vingt": 20,
    "trente": 30, "quarante": 40, "cinquante": 50, "soixante": 60, "soixante-dix": 70, "quatre-vingt": 80, "quatre-vingt-dix": 90
};

const NUMBERS_AR: Record<string, number> = {
    "wahid": 1, "ithnan": 2, "thalatha": 3, "arbaa": 4, "khamsa": 5,
    "sitta": 6, "sab'a": 7, "thamaniya": 8, "tis'a": 9, "ashara": 10,
    "ahada ashara": 11, "ithna ashara": 12, "thalatha ashara": 13, "arbaa ashara": 14, "khamsa ashara": 15,
    "sitta ashara": 16, "sab'a ashara": 17, "thamaniya ashara": 18, "tis'a ashara": 19, "ishrun": 20,
    "thalathun": 30, "arba'un": 40, "khamsun": 50, "sittun": 60, "sab'un": 70, "thamanun": 80, "tis'un": 90
};

/**
 * Levenshtein distance for fuzzy matching
 */
export const levenshteinDistance = (a: string, b: string): number => {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;

    const matrix = [];

    for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
    }

    for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
    }

    for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1, // substitution
                    Math.min(
                        matrix[i][j - 1] + 1, // insertion
                        matrix[i - 1][j] + 1 // deletion
                    )
                );
            }
        }
    }

    return matrix[b.length][a.length];
};

/**
 * Match a transcript against a list of known commands using fuzzy logic
 */
export const matchCommand = (transcript: string, commandList: string[]): boolean => {
    const words = transcript.toLowerCase().split(/\s+/);

    for (const word of words) {
        for (const cmd of commandList) {
            // Exact match
            if (word === cmd) return true;

            // Fuzzy match (allow 1 edit for short words, 2 for longer)
            const threshold = cmd.length > 4 ? 2 : 1;
            if (levenshteinDistance(word, cmd) <= threshold) return true;
        }
    }
    return false;
};

/**
 * Parse a number from the transcript, supporting EN, FR, AR and digits.
 */
export const parseNumber = (transcript: string): number | null => {
    const lowerTranscript = transcript.toLowerCase();

    // 1. Check for digits directly (e.g., "10", "5")
    const digitMatch = lowerTranscript.match(/\d+/);
    if (digitMatch) {
        return parseInt(digitMatch[0], 10);
    }

    // 2. Check word mappings
    const words = lowerTranscript.split(/\s+/);

    for (const word of words) {
        // English
        if (NUMBERS_EN[word]) return NUMBERS_EN[word];
        // French
        if (NUMBERS_FR[word]) return NUMBERS_FR[word];
        // Arabic (simplified single word check)
        if (NUMBERS_AR[word]) return NUMBERS_AR[word];
    }

    // 3. Handle compound numbers (e.g., "twenty two", "vingt deux") - Simplified
    // This is complex for full coverage, but we can catch common ones by iterating pairs
    for (let i = 0; i < words.length - 1; i++) {
        const pair = `${words[i]} ${words[i + 1]}`;

        // English: "twenty two" -> 22
        if (NUMBERS_EN[words[i]] && NUMBERS_EN[words[i + 1]]) {
            // Only if first is a ten (20, 30...) and second is unit (1-9)
            if (NUMBERS_EN[words[i]] >= 20 && NUMBERS_EN[words[i + 1]] < 10) {
                return NUMBERS_EN[words[i]] + NUMBERS_EN[words[i + 1]];
            }
        }

        // French: "vingt deux" -> 22
        if (NUMBERS_FR[words[i]] && NUMBERS_FR[words[i + 1]]) {
            if (NUMBERS_FR[words[i]] >= 20 && NUMBERS_FR[words[i + 1]] < 20) { // French allows 20-19 sometimes (soixante-dix-neuf) but simplified here
                return NUMBERS_FR[words[i]] + NUMBERS_FR[words[i + 1]];
            }
        }

        // Arabic: "ahada ashara" (11) is already in map, but "wahid wa ishrun" (21) needs logic
        // Arabic typically says "unit and ten" (wahid wa ishrun)
        if (words[i + 1] === "wa" && i < words.length - 2) {
            const unit = words[i];
            const ten = words[i + 2];
            if (NUMBERS_AR[unit] && NUMBERS_AR[ten]) {
                return NUMBERS_AR[unit] + NUMBERS_AR[ten];
            }
        }
    }

    return null;
};
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
/// <reference types="node" />
</file>

<file path="start-api-server.bat">
@echo off
REM Start Python API Server for Soccer Analysis

echo ========================================
echo   Soccer Analysis API Server
echo ========================================
echo.

REM Check if Python is installed
python --version >nul 2>&1
if errorlevel 1 (
    echo ERROR: Python is not installed or not in PATH
    echo Please install Python 3.8 or higher
    pause
    exit /b 1
)

echo [1/3] Checking Python environment...
python --version

REM Check if virtual environment exists
if not exist "venv\" (
    echo.
    echo [2/3] Creating virtual environment...
    python -m venv venv
    if errorlevel 1 (
        echo ERROR: Failed to create virtual environment
        pause
        exit /b 1
    )
) else (
    echo [2/3] Virtual environment already exists
)

REM Activate virtual environment
echo.
echo [3/3] Activating virtual environment...
call venv\Scripts\activate.bat

REM Install dependencies
echo.
echo Installing/Updating dependencies...
pip install -r python\requirements.txt

REM Start API server
echo.
echo ========================================
echo   Starting API Server
echo ========================================
echo.
echo Server will be available at: http://localhost:5000
echo Press Ctrl+C to stop the server
echo.

cd python
python api_server.py

pause
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./pages/**/*.{ts,tsx}", "./components/**/*.{ts,tsx}", "./app/**/*.{ts,tsx}", "./src/**/*.{ts,tsx}"],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
      fontFamily: {
        sans: ["var(--font-sans)", "sans-serif"],
        mono: ["var(--font-mono)", "monospace"],
      },
    },
    extend: {
      fontFamily: {
        oswald: ["Oswald", "sans-serif"],
        inter: ["Inter", "sans-serif"],
      },
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        success: "hsl(var(--success))",
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        "glow-pulse": {
          "0%, 100%": {
            boxShadow: "0 0 20px hsl(var(--success-glow) / 0.5)",
          },
          "50%": {
            boxShadow: "0 0 30px hsl(var(--success-glow) / 0.8)",
          },
        },
        "button-flash": {
          "0%": {
            transform: "scale(1)",
            boxShadow: "0 0 0 hsl(var(--success) / 0)",
          },
          "50%": {
            transform: "scale(1.05)",
            boxShadow: "0 0 25px hsl(var(--success) / 0.8)",
          },
          "100%": {
            transform: "scale(1)",
            boxShadow: "0 0 0 hsl(var(--success) / 0)",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "glow-pulse": "glow-pulse 2s ease-in-out infinite",
        "button-flash": "button-flash 0.3s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "types": [
      "vite/client",
      "node"
    ]
  },
  "include": [
    "src"
  ]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": [
      "ES2023"
    ],
    "module": "ESNext",
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,
    "types": [
      "node"
    ]
  },
  "include": [
    "vite.config.ts"
  ]
}
</file>

<file path="vercel.json">
{
    "cleanUrls": true,
    "framework": "vite",
    "rewrites": [
        {
            "source": "/(.*)",
            "destination": "/index.html"
        }
    ]
}
</file>

<file path="verify_analytics.ts">
import fs from 'fs';
import path from 'path';
import { analyzeTactics } from './src/utils/analysisEngine';
import { LoggedEvent } from './src/hooks/useGamepad';

// Get file path from command line args
const filePath = process.argv[2];

if (!filePath) {
    console.error("‚ùå Usage: npx ts-node verify_analytics.ts <path_to_events.json>");
    console.error("Please export events from the application (Admin -> Export) and provide the file path.");
    process.exit(1);
}

try {
    const rawData = fs.readFileSync(filePath, 'utf-8');
    const events: LoggedEvent[] = JSON.parse(rawData);

    if (!Array.isArray(events)) {
        throw new Error("File must contain an array of LoggedEvent objects.");
    }

    console.log(`\nüìä Analyzing ${events.length} events from ${path.basename(filePath)}...`);
    const result = analyzeTactics(events);

    console.log("\n--- TEAM A KPIs ---");
    console.log(JSON.stringify(result.kpis.teamA, null, 2));
    console.log("\n--- TEAM A Recommendations ---");
    console.log(result.recommendations.teamA);

    console.log("\n--- TEAM B KPIs ---");
    console.log(JSON.stringify(result.kpis.teamB, null, 2));
    console.log("\n--- TEAM B Recommendations ---");
    console.log(result.recommendations.teamB);

    console.log("\n‚úÖ Verification Complete.");

} catch (error) {
    console.error(`‚ùå Error reading or parsing file: ${error instanceof Error ? error.message : error}`);
    process.exit(1);
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";

// https://vitejs.dev/config/
export default defineConfig(({ mode }: { mode: string }) => ({
  server: {
    host: "::",
    port: 8080,
    allowedHosts: [
      "33780c2005a4.ngrok-free.app",
      "8545df7e93a2c3.lhr.life",
      "192.168.100.193",
      "localhost",
      ".loca.lt"
    ],
    proxy: {
      "/api": {
        target: "http://127.0.0.1:3001",
        changeOrigin: true,
      },
      "/socket.io": {
        target: "http://127.0.0.1:3001",
        ws: true,
        changeOrigin: true,
        secure: false,
      },
      "/analysis-api": {
        target: "http://127.0.0.1:8000",
        changeOrigin: true,
        rewrite: (path: string) => path.replace(/^\/analysis-api/, ""),
      },
    },
    watch: {
      ignored: [
        "**/python_env_new/**",
        "**/.venv/**",
        "**/venv/**",
        "**/__pycache__/**",
        "**/extracted_assets/**",
        "**/recreated_assets/**",
      ],
    },
  },
  plugins: [react(), mode === "development" && componentTagger()].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
</file>

</files>
